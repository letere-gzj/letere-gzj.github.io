<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"letere-gzj.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="leetcode 2022年 秋招算法题">
<meta property="og:type" content="article">
<meta property="og:title" content="【面试】Leetcode2022秋招算法">
<meta property="og:url" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="leetcode 2022年 秋招算法题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%8E%A5%E9%9B%A8%E6%B0%B4.png">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.jpg">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.gif">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.png">
<meta property="og:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3.jpg">
<meta property="article:published_time" content="2022-08-09T12:55:25.000Z">
<meta property="article:modified_time" content="2022-08-29T07:01:52.490Z">
<meta property="article:author" content="莱特雷">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%8E%A5%E9%9B%A8%E6%B0%B4.png">

<link rel="canonical" href="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【面试】Leetcode2022秋招算法 | 个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="莱特雷">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【面试】Leetcode2022秋招算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-09 20:55:25" itemprop="dateCreated datePublished" datetime="2022-08-09T20:55:25+08:00">2022-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-29 15:01:52" itemprop="dateModified" datetime="2022-08-29T15:01:52+08:00">2022-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>leetcode 2022年 秋招算法题</p>
<a id="more"></a>

<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h3><h4 id="1-1-两数之和"><a href="#1-1-两数之和" class="headerlink" title="1.1 两数之和"></a>1.1 两数之和</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【哈希表】</span></span><br><span class="line"><span class="comment">// 优点：消耗内存，节省时间，一次循环解决</span></span><br><span class="line"><span class="comment">// 将数据存入Map中，记录num和index，寻找target-nums[i]值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; subTarget = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subTarget.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;subTarget.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        subTarget.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-三数之和"><a href="#1-2-三数之和" class="headerlink" title="1.2 三数之和"></a>1.2 三数之和</h4><ul>
<li>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>]</span><br><span class="line">输出：[[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【排序 + 双指针】</span></span><br><span class="line"><span class="comment">// 当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 排序，方便去重</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> first=<span class="number">0</span>; first&lt;nums.length-<span class="number">2</span>; first++) &#123;</span><br><span class="line">        <span class="comment">// 有序数组，first元素&gt;0，结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (nums[first] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// first去重</span></span><br><span class="line">        <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> third = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> second=first+<span class="number">1</span>; second&lt;nums.length-<span class="number">1</span>; second++) &#123;</span><br><span class="line">            <span class="comment">// second去重</span></span><br><span class="line">            <span class="keyword">if</span> (second &gt; first+<span class="number">1</span> &amp;&amp; nums[second] == nums[second-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证second 在 third 左边，并移动 third 直至和&lt;=0</span></span><br><span class="line">            <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[first]+nums[second]+nums[third] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                third --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 双指针重合时，往后的三者之和数必定&gt;0，结束second循环</span></span><br><span class="line">            <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[first]+nums[second]+nums[third] == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[first], nums[second], nums[third])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-合并两个有序数组"><a href="#1-3-合并两个有序数组" class="headerlink" title="1.3 合并两个有序数组"></a>1.3 合并两个有序数组</h4><ul>
<li>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：需要合并 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 。</span><br><span class="line">合并结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常思路为双指针，新开一个数组，双指针比较，小的放入新数组，指针后移</span></span><br><span class="line"><span class="comment">// 【逆双指针】</span></span><br><span class="line"><span class="comment">// 示例nums1后面数组为空，可以直接覆盖，不用新开数组，从后往前比较大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge2</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span> || nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">            nums1[index] = nums2[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[index] = nums1[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(nums1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-螺旋矩阵"><a href="#1-4-螺旋矩阵" class="headerlink" title="1.4 螺旋矩阵"></a>1.4 螺旋矩阵</h4><ul>
<li>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【按层模拟】</span></span><br><span class="line"><span class="comment">// 类似同心圆，从外层到里层，转一圈为一个循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> bottom = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 按层循环</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="comment">// 向右移动 →</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = left; column &lt;= right; column ++) &#123;</span><br><span class="line">            matrix[top][column] = num;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向下移动 ↓</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = top + <span class="number">1</span>; row &lt;= bottom; row ++) &#123;</span><br><span class="line">            matrix[row][right] = num;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向左移动 ←</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = right - <span class="number">1</span>; column &gt;= left; column --) &#123;</span><br><span class="line">            matrix[bottom][column] = num;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向上移动 ↑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = bottom -<span class="number">1</span>; row &gt;= top + <span class="number">1</span>; row --) &#123;</span><br><span class="line">            matrix[row][left] = num;</span><br><span class="line">            num ++;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">        top ++;</span><br><span class="line">        bottom --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2 字符串"></a>2 字符串</h3><h4 id="2-1-有效的括号"><a href="#2-1-有效的括号" class="headerlink" title="2.1 有效的括号"></a>2.1 有效的括号</h4><ul>
<li>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串 s ，判断字符串是否有效。</li>
<li>有效字符串需满足：<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ul>
</li>
</ul>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;([)]&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;&#123;[]&#125;&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【栈】</span></span><br><span class="line"><span class="comment">// （规律）当遇到第一个右括号时，栈顶必定为对应的左括号；匹配后栈顶出栈，依次循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合法性判断，奇数一定不合法</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Map存储对应关系，方便处理</span></span><br><span class="line">    Map&lt;Character, Character&gt; charMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    charMap.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    charMap.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    charMap.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 栈处理</span></span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// 匹配到右括号，判断栈顶左括号</span></span><br><span class="line">        <span class="keyword">if</span> (charMap.containsKey(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.empty() || !stack.peek().equals(charMap.get(c))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-字符串相加"><a href="#2-2-字符串相加" class="headerlink" title="2.2 字符串相加"></a>2.2 字符串相加</h4><ul>
<li>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">num1</span> = <span class="string">&quot;11&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出：<span class="string">&quot;134&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【模拟竖直相加】</span></span><br><span class="line"><span class="comment">// 从个位往前相加，进位=和/10，相加后的位数=和%10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = num2.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (m &gt;=<span class="number">0</span> || n &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            carry += num1.charAt(m) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            carry += num2.charAt(n) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.insert(<span class="number">0</span>, carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">        m --;</span><br><span class="line">        n --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-最长回文子串"><a href="#2-3-最长回文子串" class="headerlink" title="2.3 最长回文子串"></a>2.3 最长回文子串</h4><ul>
<li>给你一个字符串 s，找到 s 中最长的回文子串。</li>
</ul>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【中心拓展法】</span></span><br><span class="line"><span class="comment">// 将字符串每个下标作为中心，向左右拓展，枚举出最长的回文，记录初始结束点</span></span><br><span class="line"><span class="comment">// 回文有奇数回文，和偶数回文</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1;</span><br><span class="line">    <span class="keyword">int</span> len2;</span><br><span class="line">    <span class="keyword">int</span> maxLen;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 奇数回文串</span></span><br><span class="line">        len1 = getMaxLen(s, i, i);</span><br><span class="line">        <span class="comment">// 偶数回文串</span></span><br><span class="line">        len2 = getMaxLen(s, i, i + <span class="number">1</span>);</span><br><span class="line">        maxLen = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (maxLen &gt; end - start) &#123;</span><br><span class="line">            start = i - (maxLen-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            end = i + maxLen/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt; -<span class="number">1</span></span><br><span class="line">            &amp;&amp; right &lt; s.length()</span><br><span class="line">            &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">        left --;</span><br><span class="line">        right ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-单链表"><a href="#3-单链表" class="headerlink" title="3 单链表"></a>3 单链表</h3><h4 id="3-1-合并两个单链表"><a href="#3-1-合并两个单链表" class="headerlink" title="3.1 合并两个单链表"></a>3.1 合并两个单链表</h4><ul>
<li>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【单链表数据结构】</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ListNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;val=&quot;</span> + val +</span><br><span class="line">                <span class="string">&quot;, next=&quot;</span> + next +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【迭代循环】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode headNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode currentNode = headNode;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &gt; list2.val) &#123;</span><br><span class="line">            currentNode.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentNode.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    currentNode.next = list1 == <span class="keyword">null</span> ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> headNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-单链表反转"><a href="#3-2-单链表反转" class="headerlink" title="3.2 单链表反转"></a>3.2 单链表反转</h4><ul>
<li>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【迭代循环】</span></span><br><span class="line"><span class="comment">// 遍历下一个节点时，下一个节点.next=前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = curr.next;</span><br><span class="line">        <span class="comment">// 位置互换</span></span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-两链表相加"><a href="#3-3-两链表相加" class="headerlink" title="3.3 两链表相加"></a>3.3 两链表相加</h4><ul>
<li>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</li>
<li>请你将两个数相加，并以相同形式返回一个表示和的链表。</li>
<li>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], l2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">0</span>,<span class="number">8</span>]</span><br><span class="line">解释：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【循环迭代】</span></span><br><span class="line"><span class="comment">// 思路类似字符串相加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">	ListNode headNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">	ListNode sum = headNode;</span><br><span class="line">	<span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">			carry += l1.val;</span><br><span class="line">			l1 = l1.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">			carry += l2.val;</span><br><span class="line">			l2 = l2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		sum.next = <span class="keyword">new</span> ListNode(carry % <span class="number">10</span>);</span><br><span class="line">		sum = sum.next;</span><br><span class="line">		carry = carry / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> headNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-重排链表"><a href="#3-4-重排链表" class="headerlink" title="3.4 重排链表"></a>3.4 重排链表</h4><ul>
<li>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<ul>
<li><code>L0 → L1 → … → Ln - 1 → Ln</code></li>
</ul>
</li>
<li>请将其重新排列后变为：<ul>
<li><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></li>
</ul>
</li>
<li>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【寻找链表中点 + 链表逆序 + 合并链表】</span></span><br><span class="line"><span class="comment">// 找出中间点，分左右两部分（中间点包含在左），右边部分反转，然后交叉插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	ListNode midNode = midNode(head);</span><br><span class="line">	ListNode reverseList = reverseList(midNode.next);</span><br><span class="line">	midNode.next = <span class="keyword">null</span>;</span><br><span class="line">	mergeList(head, reverseList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表中点</span></span><br><span class="line"><span class="comment">// fast是slow的两倍移速，当fast到达末尾时，slow在中间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">midNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	ListNode fast = head;</span><br><span class="line">	ListNode slow = head;</span><br><span class="line">	<span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">		fast = fast.next.next;</span><br><span class="line">		slow = slow.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">	ListNode next;</span><br><span class="line">	ListNode current = head;</span><br><span class="line">	<span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">		next = current.next;</span><br><span class="line">		current.next = pre;</span><br><span class="line">		pre = current;</span><br><span class="line">		current = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表交叉合并</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">	ListNode l1Temp;</span><br><span class="line">	ListNode l2Temp;</span><br><span class="line">	<span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2!= <span class="keyword">null</span>) &#123;</span><br><span class="line">		l1Temp = l1.next;</span><br><span class="line">		l2Temp = l2.next;</span><br><span class="line">		<span class="comment">// 交叉合并</span></span><br><span class="line">		l1.next = l2;</span><br><span class="line">		l2.next = l1Temp;</span><br><span class="line">		<span class="comment">// 重新赋值</span></span><br><span class="line">		l1 = l1Temp;</span><br><span class="line">		l2 = l2Temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-双链表"><a href="#4-双链表" class="headerlink" title="4 双链表"></a>4 双链表</h3><h4 id="4-1-LRU算法"><a href="#4-1-LRU算法" class="headerlink" title="4.1 LRU算法"></a>4.1 LRU算法</h4><hr>
<h3 id="5-双指针"><a href="#5-双指针" class="headerlink" title="5 双指针"></a>5 双指针</h3><h4 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h4><h5 id="5-1-1-移除元素"><a href="#5-1-1-移除元素" class="headerlink" title="5.1.1 移除元素"></a>5.1.1 移除元素</h5><ul>
<li>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</li>
<li><strong>不要使用额外的数组空间</strong>，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</li>
<li><strong>元素的顺序可以改变</strong>。你不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【双指针向中间遍历】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            <span class="comment">// 左指针元素相同，左指针元素=右指针元素（判断右指针元素，写法简化了if条件），向前移动</span></span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            right --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左指针元素不同，向后移动</span></span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-1-2-有序数组的平方"><a href="#5-1-2-有序数组的平方" class="headerlink" title="5.1.2 有序数组的平方"></a>5.1.2 有序数组的平方</h5><ul>
<li>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-4</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br><span class="line">解释：平方后，数组变为 [<span class="number">16</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">100</span>]</span><br><span class="line">排序后，数组变为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【双指针向中间遍历】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 负数平方后最左边最大，正数平方后最右边最大，双指针设置在左右进行遍历</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = right;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left]*nums[left] &lt; nums[right]*nums[right]) &#123;</span><br><span class="line">            result[i] = nums[right] * nums[right];</span><br><span class="line">            right --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i] = nums[left] * nums[left];</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        i --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-1-3-长度最小的子数组"><a href="#5-1-3-长度最小的子数组" class="headerlink" title="5.1.3 长度最小的子数组"></a>5.1.3 长度最小的子数组</h5><ul>
<li>给定一个含有 n 个正整数的数组和一个正整数 target 。</li>
<li>找出该数组中满足其<strong>和≥target</strong> 的<strong>长度最小</strong>的 <strong>连续</strong>子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果<strong>不存在</strong>符合条件的子数组，<strong>返回 0</strong> 。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【滑动窗口（双指针）】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 右指针一直往右移动，移动到sum&gt;=target时，记录长度，并开始移动左指针，直到sum&lt;taget时，再移动右指针</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            minLen = Math.min(minLen, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        right ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minLen == Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-字符串"><a href="#5-2-字符串" class="headerlink" title="5.2 字符串"></a>5.2 字符串</h4><h5 id="5-2-1-反转字符串"><a href="#5-2-1-反转字符串" class="headerlink" title="5.2.1 反转字符串"></a>5.2.1 反转字符串</h5><ul>
<li>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</li>
<li>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</li>
</ul>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br><span class="line">输出：[<span class="string">&quot;o&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【双指针（中间靠拢）】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="comment">// 首尾指针元素互换，向中间移动</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        temp  = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        left ++;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-2-2-无重复字符的最长字串"><a href="#5-2-2-无重复字符的最长字串" class="headerlink" title="5.2.2 无重复字符的最长字串"></a>5.2.2 无重复字符的最长字串</h5><ul>
<li>给定一个字符串 s ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【滑动窗口（双指针）】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; chars = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// right指针右移，直至出现重复字符；移动left指针，并移除left指针对应的字符，直至不与right指针字符重复</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (chars.contains(s.charAt(right))) &#123;</span><br><span class="line">            chars.remove(s.charAt(left));</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        chars.add(s.charAt(right));</span><br><span class="line">        right ++;</span><br><span class="line">        maxLen = Math.max(maxLen, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-2-3-字符串的排列"><a href="#5-2-3-字符串的排列" class="headerlink" title="5.2.3 字符串的排列"></a>5.2.3 字符串的排列</h5><ul>
<li>给你两个字符串 s1 和 s2 ，写一个函数来判断 <strong>s2 是否包含 s1 的排列</strong>。如果是，返回 true ；否则，返回 false 。</li>
<li>换句话说，s1 的排列之一是 s2 的 子串 。</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">&quot;ab&quot;</span> <span class="built_in">s2</span> = <span class="string">&quot;eidbaooo&quot;</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="built_in">s2</span> 包含 <span class="built_in">s1</span> 的排列之一 (<span class="string">&quot;ba&quot;</span>).</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【双指针】</span></span><br><span class="line"><span class="comment">// s1的排列，可以用统计字符出现次数来判断，长度相同，字符出现相同，则时s2的排列字串之一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s1.length();</span><br><span class="line">    <span class="keyword">int</span> m = s2.length();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计s1 26字母字符次数</span></span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; m; ++right) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = s2.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cnt[x] --;</span><br><span class="line">        <span class="comment">// s2当前字符-1，若&lt;0，表示非s1中的字符，移动左指针把字符加回去</span></span><br><span class="line">        <span class="keyword">while</span> (cnt[x] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动右指针中，未出现字符&lt;0，且长度right-left=n，则命中</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-链表"><a href="#5-3-链表" class="headerlink" title="5.3 链表"></a>5.3 链表</h4><h5 id="5-3-1-环形链表"><a href="#5-3-1-环形链表" class="headerlink" title="5.3.1 环形链表"></a>5.3.1 环形链表</h5><ul>
<li>给你一个链表的头节点 head ，判断<strong>链表中是否有环</strong>。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line">(pos表示尾节点与哪个节点相连， 不作为参数进行传递 。仅仅是为了标识链表的实际情况)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【快慢指针】</span></span><br><span class="line"><span class="comment">// 慢指针移动1，快指针=2*慢指针，如果出现环形，总会出现快指针=慢指针</span></span><br><span class="line"><span class="comment">// 若无循环，快指针=null时结束</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-3-2-删除链表的倒数第N个结点"><a href="#5-3-2-删除链表的倒数第N个结点" class="headerlink" title="5.3.2 删除链表的倒数第N个结点"></a>5.3.2 删除链表的倒数第N个结点</h5><ul>
<li>给你一个链表，<strong>删除链表的倒数第 n 个结点</strong>，并且返回链表的头结点。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【双指针】</span></span><br><span class="line"><span class="comment">// 创建两指针，first和second，first比second向后移动了n格，当first到达尾节点时，second就到达了n点</span></span><br><span class="line"><span class="comment">// 因为时单链表删除，需要到n前一个进行删除，所以first和second相距n+1格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="comment">// first向后移动n格，不考虑n&gt;指针长度出现null报错</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除链表</span></span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-3-3-链表的中间结点"><a href="#5-3-3-链表的中间结点" class="headerlink" title="5.3.3 链表的中间结点"></a>5.3.3 链表的中间结点</h5><ul>
<li>给定一个头结点为 head 的非空单链表，返回<strong>链表的中间结点</strong>。</li>
<li>如果有两个中间结点，则返回第二个中间结点。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：此列表中的结点 <span class="number">4</span> (序列化形式：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">由于该列表有两个中间结点，值分别为 <span class="number">3</span> 和 <span class="number">4</span>，我们返回第二个结点。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="comment">// 快慢指针，快指针 = 慢指针 * 2，快指针到末尾时，慢指针到中间结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-3-4-环形链表Ⅱ"><a href="#5-3-4-环形链表Ⅱ" class="headerlink" title="5.3.4 环形链表Ⅱ"></a>5.3.4 环形链表Ⅱ</h5><ul>
<li>给定一个链表的头节点 head，<strong>返回链表开始入环的第一个节点</strong>。 如果链表无环，则返回null。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【双指针】</span></span><br><span class="line"><span class="comment">// 快慢指针，快指针=2*慢指针</span></span><br><span class="line"><span class="comment">// 根据公式推到，当快指针与慢指针相遇时，慢指针跑完环的距离 = 头节点到环的距离，头节点和慢指针相遇就是入环点</span></span><br><span class="line"><span class="comment">// 推导地址：https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，新指针指向头节点，与慢指针同速移动</span></span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            ListNode ptr = head;</span><br><span class="line">            <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                ptr = ptr.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 与慢指针相遇的点为入环点</span></span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6 哈希表"></a>6 哈希表</h3><h4 id="6-1-有效的字母异位词"><a href="#6-1-有效的字母异位词" class="headerlink" title="6.1 有效的字母异位词"></a>6.1 有效的字母异位词</h4><ul>
<li>给定两个字符串s和t ，编写一个函数来<strong>判断t是否是s的字母异位词</strong>。</li>
</ul>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;anagram&quot;</span>, <span class="attr">t</span> = <span class="string">&quot;nagaram&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【哈希表】</span></span><br><span class="line"><span class="comment">// 26位数组表示26字母，记录次数；遍历相减，若出现负数，就不是异位词</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录s字符串中字母次数</span></span><br><span class="line">    <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        table[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减去t中字符字母出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (table[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-2-存在重复元素"><a href="#6-2-存在重复元素" class="headerlink" title="6.2 存在重复元素"></a>6.2 存在重复元素</h4><ul>
<li>给你一个整数数组nums。如果任一值在数组中<strong>出现至少两次 ，返回true</strong> ；如果数组中每个元素<strong>互不相同，返回false</strong> 。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【Set】</span></span><br><span class="line"><span class="comment">// Set不能存储重复元素，若重复返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.add(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-3-两个数组的交集"><a href="#6-3-两个数组的交集" class="headerlink" title="6.3 两个数组的交集"></a>6.3 两个数组的交集</h4><ul>
<li>给定<strong>两个数组nums1和nums2，返回它们的交集</strong> 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line">解释：[<span class="number">4</span>,<span class="number">9</span>] 也是可通过的</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【Set】</span></span><br><span class="line"><span class="comment">// Set去重然后比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="comment">// 通过Set去重其中一个数组</span></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟另一个数组进行比较，重复加入到Set（去重）</span></span><br><span class="line">    Set&lt;Integer&gt; resultSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">            resultSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转成数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[resultSet.size()];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer num : resultSet) &#123;</span><br><span class="line">        arr[i] = num;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-4-四数相加Ⅱ"><a href="#6-4-四数相加Ⅱ" class="headerlink" title="6.4 四数相加Ⅱ"></a>6.4 四数相加Ⅱ</h4><ul>
<li>给你四个整数数组 nums1、nums2、nums3和nums4 ，数组长度都是n，请你<strong>计算有多少个元组</strong>(i, j, k, l) 能满足：<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">-2</span>,<span class="number">-1</span>], nums3 = [<span class="number">-1</span>,<span class="number">2</span>], nums4 = [<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line"><span class="number">1.</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) -&gt; nums1[<span class="number">0</span>] + nums2[<span class="number">0</span>] + nums3[<span class="number">0</span>] + nums4[<span class="number">1</span>] = <span class="number">1</span> + (<span class="number">-2</span>) + (<span class="number">-1</span>) + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2.</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) -&gt; nums1[<span class="number">1</span>] + nums2[<span class="number">1</span>] + nums3[<span class="number">0</span>] + nums4[<span class="number">0</span>] = <span class="number">2</span> + (<span class="number">-1</span>) + (<span class="number">-1</span>) + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【分组 + 哈希表】</span></span><br><span class="line"><span class="comment">// 将ABCD分为两组，AB一组，CD一组，记录AB之间所有相加的可能数字，并记录次数。同理CD也是，最后比较相加等于0的次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双for记录AB相加的数字，以及次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; countAB = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : B) &#123;</span><br><span class="line">            countAB.put(i+j, countAB.getOrDefault(i+j, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双for比较C+D中的数字的负数，是否A+B中出现；出现即相加等于0</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : C) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : D) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countAB.containsKey(-(i+j))) &#123;</span><br><span class="line">                count += countAB.get(-(i+j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-队列"><a href="#7-队列" class="headerlink" title="7 队列"></a>7 队列</h3><h4 id="7-1-用队列实现栈"><a href="#7-1-用队列实现栈" class="headerlink" title="7.1 用队列实现栈"></a>7.1 用队列实现栈</h4><ul>
<li>请你仅使用<strong>两个队列实现一个后入先出（LIFO）的栈</strong>，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MyStack&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;empty&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="keyword">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = <span class="keyword">new</span> MyStack();</span><br><span class="line">myStack.<span class="keyword">push</span>(<span class="number">1</span>);</span><br><span class="line">myStack.<span class="keyword">push</span>(<span class="number">2</span>);</span><br><span class="line">myStack.top(); <span class="comment">// 返回 2</span></span><br><span class="line">myStack.<span class="keyword">pop</span>(); <span class="comment">// 返回 2</span></span><br><span class="line">myStack.empty(); <span class="comment">// 返回 False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新元素入列到queue2，再从queue出列并入列到queue2，queue1 = queue2（最后数据都存在queue1中）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-2-前K个高频元素"><a href="#7-2-前K个高频元素" class="headerlink" title="7.2 前K个高频元素"></a>7.2 前K个高频元素</h4><ul>
<li>给你一个整数数组nums和一个整数 k ，请你返回其中<strong>出现频率前k高的元素</strong>。你可以按<strong>任意顺序</strong>返回答案。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【优先队列】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// map统计数字次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; numCount = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        numCount.put(num, numCount.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建优先队列（根据比较器自动进行排序【根据次数进行降序】），存储长度为2的数组，[0]存储数字，[1]存储出现次数</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((m, n) -&gt; n[<span class="number">1</span>] - m[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : numCount.entrySet()) &#123;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出前k个</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        result[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-滑动窗口最大值"><a href="#7-3-滑动窗口最大值" class="headerlink" title="7.3 滑动窗口最大值"></a>7.3 滑动窗口最大值</h4><ul>
<li>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</li>
<li>返回<strong>滑动窗口中的最大值</strong>。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【单调队列】</span></span><br><span class="line"><span class="comment">// 营造出单调递减队列，队首永远时最大值，只要队首的下标在窗口范围内，就是当前窗口最大值；不在则出队，下一个值为窗口最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 预处理前k条数据（后数&gt;前数，前数出队列，直至队列为empty或后数&lt;前数），保证队首的值最大【记录的是数组下标】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">0</span>] = nums[deque.peekFirst()];</span><br><span class="line">    <span class="comment">// 窗口向右移动（从k开始）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 上面逻辑同理</span></span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">        <span class="comment">// 当队首的最大不在窗口范围内，则进行移除（保证当前队首时有效最大值）</span></span><br><span class="line">        <span class="keyword">while</span> (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-栈"><a href="#8-栈" class="headerlink" title="8 栈"></a>8 栈</h3><h4 id="8-1-用栈实现队列"><a href="#8-1-用栈实现队列" class="headerlink" title="8.1 用栈实现队列"></a>8.1 用栈实现队列</h4><ul>
<li>请你仅使用<strong>两个栈实现先入先出队列</strong>。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入：</span></span><br><span class="line">[<span class="string">&quot;MyQueue&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;push&quot;</span>, <span class="string">&quot;peek&quot;</span>, <span class="string">&quot;pop&quot;</span>, <span class="string">&quot;empty&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line"><span class="string">输出：</span></span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">解释：</span></span><br><span class="line"><span class="string">MyQueue</span> <span class="string">myQueue</span> <span class="string">=</span> <span class="string">new</span> <span class="string">MyQueue();</span></span><br><span class="line"><span class="string">myQueue.push(1);</span> <span class="string">//</span> <span class="attr">queue is:</span> [<span class="number">1</span>]</span><br><span class="line"><span class="string">myQueue.push(2);</span> <span class="string">//</span> <span class="attr">queue is:</span> [<span class="number">1</span>, <span class="number">2</span>] <span class="string">(leftmost</span> <span class="string">is</span> <span class="string">front</span> <span class="string">of</span> <span class="string">the</span> <span class="string">queue)</span></span><br><span class="line"><span class="string">myQueue.peek();</span> <span class="string">//</span> <span class="string">return</span> <span class="number">1</span></span><br><span class="line"><span class="string">myQueue.pop();</span> <span class="string">//</span> <span class="string">return</span> <span class="number">1</span><span class="string">,</span> <span class="string">queue</span> <span class="string">is</span> [<span class="number">2</span>]</span><br><span class="line"><span class="string">myQueue.empty();</span> <span class="string">//</span> <span class="string">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1; <span class="comment">// 入队列用</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2; <span class="comment">// 出队列用</span></span><br><span class="line">    <span class="keyword">int</span> front; <span class="comment">// 队首</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录队首，并元素放入stack1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1.isEmpty()) &#123;</span><br><span class="line">            front = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队列时，将stack1入栈到stack2，此时stack2栈顶就是队首</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-2-逆波兰表达式求值"><a href="#8-2-逆波兰表达式求值" class="headerlink" title="8.2 . 逆波兰表达式求值"></a>8.2 . 逆波兰表达式求值</h4><ul>
<li>根据逆波兰表示法（后缀表达式），求表达式的值。</li>
<li>有效的算符包括<code>+、-、*、/</code>。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((<span class="number">2</span> + <span class="number">1</span>) * <span class="number">3</span>) = <span class="number">9</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">// 存数字</span></span><br><span class="line">    <span class="comment">// 遇到操作符，将入栈的数字出栈参与计算，将计算结果重新入栈</span></span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(token) || <span class="string">&quot;-&quot;</span>.equals(token) || <span class="string">&quot;*&quot;</span>.equals(token) || <span class="string">&quot;/&quot;</span>.equals(token)) &#123;</span><br><span class="line">            stack.push(cul(stack.pop(), stack.pop(), token));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(Integer.parseInt(token));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cul</span><span class="params">(Integer num1, Integer num2, String operate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num2 + num1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num2 - num1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num2 * num1;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num2 / num1;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-3-接雨水"><a href="#8-3-接雨水" class="headerlink" title="8.3 接雨水"></a>8.3 接雨水</h4><ul>
<li>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%8E%A5%E9%9B%A8%E6%B0%B4.png" class="">

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【单调栈】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历数据，栈记录下标（方便计算面积），当当前元素高度&gt;栈顶元素高度，可能会形成包围</span></span><br><span class="line">    <span class="comment">// 栈顶元素出栈，作为&#x27;底&#x27;，高度计算 = min(新栈顶元素高度，当前元素高度) - ‘底’</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123;</span><br><span class="line">            top = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = stack.peek();</span><br><span class="line">            width = i - left - <span class="number">1</span>;</span><br><span class="line">            result += width * (Math.min(height[i], height[left]) - height[top]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-二叉树"><a href="#9-二叉树" class="headerlink" title="9 二叉树"></a>9 二叉树</h3><h4 id="9-1-二叉树遍历"><a href="#9-1-二叉树遍历" class="headerlink" title="9.1 二叉树遍历"></a>9.1 二叉树遍历</h4><h5 id="9-1-1-二叉树中序遍历"><a href="#9-1-1-二叉树中序遍历" class="headerlink" title="9.1.1 二叉树中序遍历"></a>9.1.1 二叉树中序遍历</h5><ul>
<li>给定一个二叉树的根节点 root ，返回它的<strong>中序遍历</strong> 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【二叉树结构】</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="keyword">this</span>.val = val;</span><br><span class="line">         <span class="keyword">this</span>.left = left;</span><br><span class="line">         <span class="keyword">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inOrder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历左子树</span></span><br><span class="line">    inOrder(node.left, result);</span><br><span class="line">    result.add(node.val);</span><br><span class="line">    <span class="comment">// 遍历右子树</span></span><br><span class="line">    inOrder(node.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="9-1-2-二叉树的层序遍历"><a href="#9-1-2-二叉树的层序遍历" class="headerlink" title="9.1.2 二叉树的层序遍历"></a>9.1.2 二叉树的层序遍历</h5><ul>
<li>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" class="">
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">3</span>],[<span class="number">9</span>,<span class="number">20</span>],[<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【广度优先搜索】</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 记录每层节点数，遍历对应的节点数，list封装为一层，重新计算新的一层的个数，依次往复</span></span><br><span class="line">        <span class="keyword">int</span> levelSize = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (levelSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            levelSize --;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="9-1-3-二叉树的锯齿层序遍历"><a href="#9-1-3-二叉树的锯齿层序遍历" class="headerlink" title="9.1.3 二叉树的锯齿层序遍历"></a>9.1.3 二叉树的锯齿层序遍历</h5><ul>
<li>给你二叉树的根节点 root ，返回其节点值的<strong>锯齿形层序遍历</strong>。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" class="">

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：[[<span class="number">3</span>],[<span class="number">20</span>,<span class="number">9</span>],[<span class="number">15</span>,<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【广度优先搜索】</span></span><br><span class="line"><span class="comment">// 跟层序遍历基本一直，稍作变形</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">boolean</span> isLeftOrder = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 记录每层节点数，遍历对应的节点数，list封装为一层，重新计算新的一层的个数，一次往复</span></span><br><span class="line">        <span class="keyword">int</span> levelSize = queue.size();</span><br><span class="line">        Deque&lt;Integer&gt; level = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (levelSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">// 双向队列存储数据，奇数层从后往前存，偶数层从前往后存</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftOrder) &#123;</span><br><span class="line">                level.offerLast(node.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                level.offerFirst(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            levelSize --;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(level));</span><br><span class="line">        isLeftOrder = !isLeftOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-2-二叉树的属性"><a href="#9-2-二叉树的属性" class="headerlink" title="9.2 二叉树的属性"></a>9.2 二叉树的属性</h4><h5 id="9-2-1-二叉树的最大深度"><a href="#9-2-1-二叉树的最大深度" class="headerlink" title="9.2.1 二叉树的最大深度"></a>9.2.1 二叉树的最大深度</h5><ul>
<li>给定一个二叉树，找出其最大深度。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">给定二叉树</span> [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]<span class="string">，</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    <span class="string">/</span>  <span class="string">\</span></span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"><span class="string">返回它的最大深度</span> <span class="number">3</span> <span class="string">。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【递归】【深度优先】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="9-2-2-二叉树的直径"><a href="#9-2-2-二叉树的直径" class="headerlink" title="9.2.2 二叉树的直径"></a>9.2.2 二叉树的直径</h5><ul>
<li>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树</span><br><span class="line"></span><br><span class="line">          <span class="number">1</span></span><br><span class="line">         / \</span><br><span class="line">        <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">       / \     </span><br><span class="line">      <span class="number">4</span>   <span class="number">5</span>    </span><br><span class="line">返回 <span class="number">3</span>, 它的长度是路径 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 或者 [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【递归】【深度优先搜索】</span></span><br><span class="line"><span class="keyword">int</span> maxlength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxDepth(root);</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightHeight = maxDepth(root.right);</span><br><span class="line">    <span class="comment">// 记录最长路径（左子树深度 + 右子树深度）</span></span><br><span class="line">    maxlength = Math.max(maxlength, leftHeight + rightHeight);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="9-2-3-二叉树中的最大路径和"><a href="#9-2-3-二叉树中的最大路径和" class="headerlink" title="9.2.3 二叉树中的最大路径和"></a>9.2.3 二叉树中的最大路径和</h5><ul>
<li>给你一个二叉树的根节点 root ，返回其最大路径和 。</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.jpg" class="">
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入：root</span> <span class="string">=</span> [<span class="number">-10</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line"><span class="string">输出：42</span></span><br><span class="line"><span class="string">解释：最优路径是</span> <span class="number">15</span> <span class="string">-&gt;</span> <span class="number">20</span> <span class="string">-&gt;</span> <span class="number">7</span> <span class="string">，路径和为</span> <span class="number">15</span> <span class="string">+</span> <span class="number">20</span> <span class="string">+</span> <span class="number">7</span> <span class="string">=</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【递归】【深度优先搜索】</span></span><br><span class="line"><span class="keyword">int</span> maxSum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxSum = Integer.MIN_VALUE;</span><br><span class="line">    getMaxSum(root);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSum</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大总数 &gt; 0 才采用此子树的节点</span></span><br><span class="line">    <span class="keyword">int</span> leftPathSum = Math.max(getMaxSum(node.left), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> rightPathSum = Math.max(getMaxSum(node.right), <span class="number">0</span>);</span><br><span class="line">    maxSum = Math.max(maxSum, leftPathSum + rightPathSum + node.val);</span><br><span class="line">    <span class="keyword">return</span> node.val + Math.max(leftPathSum, rightPathSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-3-二叉树的构造"><a href="#9-3-二叉树的构造" class="headerlink" title="9.3 二叉树的构造"></a>9.3 二叉树的构造</h4><h5 id="9-3-1-从中序与后序遍历序列构造二叉树"><a href="#9-3-1-从中序与后序遍历序列构造二叉树" class="headerlink" title="9.3.1 从中序与后序遍历序列构造二叉树"></a>9.3.1 从中序与后序遍历序列构造二叉树</h5><ul>
<li>给定两个整数数组inorder和postorder ，其中<strong>inorder 是二叉树的中序遍历</strong>， <strong>postorder 是同一棵树的后序遍历</strong>，请你构造并返回这颗 二叉树 。</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" class="">

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>], postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【递归】</span></span><br><span class="line"><span class="keyword">int</span>[] postorder;</span><br><span class="line"><span class="keyword">int</span> postIdx;</span><br><span class="line">Map&lt;Integer, Integer&gt; inorderMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">    postIdx = postorder.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录inorderMap（key是元素，value是下标）</span></span><br><span class="line">    inorderMap = <span class="keyword">new</span> HashMap&lt;&gt;(inorder.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.length; i++) &#123;</span><br><span class="line">        inorderMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建树</span></span><br><span class="line">    <span class="keyword">return</span> buildTreeByInIdx(<span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过inorder下标边界构建树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeByInIdx</span><span class="params">(<span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in_left &gt; in_right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postIdx]);</span><br><span class="line">    <span class="keyword">int</span> inIdx = inorderMap.get(postorder[postIdx]);</span><br><span class="line">    <span class="comment">// 后序遍历，从后往前访问; 变成先处理右子树，再处理左子树</span></span><br><span class="line">    postIdx --;</span><br><span class="line">    root.right = buildTreeByInIdx(inIdx+<span class="number">1</span>, in_right);</span><br><span class="line">    root.left = buildTreeByInIdx(in_left, inIdx-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-贪心算法"><a href="#10-贪心算法" class="headerlink" title="10 贪心算法"></a>10 贪心算法</h3><h4 id="10-1-基础常见问题"><a href="#10-1-基础常见问题" class="headerlink" title="10.1 基础常见问题"></a>10.1 基础常见问题</h4><h5 id="10-1-1-分发饼干"><a href="#10-1-1-分发饼干" class="headerlink" title="10.1.1 分发饼干"></a>10.1.1 分发饼干</h5><ul>
<li>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多<strong>只能给一块饼干</strong>。</li>
<li>对每个孩子 i，都有一个胃口值<code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸<code>s[j]</code>。如果<code>s[j]</code>&gt;= <code>g[i]</code>，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], s = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，<span class="number">3</span>个孩子的胃口值分别是：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是<span class="number">1</span>，你只能让胃口值是<span class="number">1</span>的孩子满足。</span><br><span class="line">所以你应该输出<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【贪心算法】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(g);</span><br><span class="line">    Arrays.sort(s);</span><br><span class="line">    <span class="comment">// 因为每个孩子只有一个饼干，将大于胃口值的饼干分发下去</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;g.length &amp;&amp; j&lt;s.length; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.length &amp;&amp; g[i] &gt; s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; s.length) &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-2-区间问题"><a href="#10-2-区间问题" class="headerlink" title="10.2 区间问题"></a>10.2 区间问题</h4><h5 id="10-2-1-跳跃游戏"><a href="#10-2-1-跳跃游戏" class="headerlink" title="10.2.1 跳跃游戏"></a>10.2.1 跳跃游戏</h5><ul>
<li>给定一个非负整数数组 nums ，你最初<strong>位于数组的第一个下标</strong>。</li>
<li>数组中的每个元素代表你在该位置可以跳跃的最大长度。</li>
<li>判断你是否能够<strong>到达最后一个下标</strong>。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可以先跳 <span class="number">1</span> 步，从下标 <span class="number">0</span> 到达下标 <span class="number">1</span>, 然后再从下标 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个下标。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【贪心算法】</span></span><br><span class="line"><span class="comment">// 遍历数组，并记录当前位置最大能跳距离，如果最大能跳距离 &lt; 当前index，则return false;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxJump = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxJump &lt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxJump = Math.max(maxJump, i+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="10-2-2-跳跃游戏Ⅱ"><a href="#10-2-2-跳跃游戏Ⅱ" class="headerlink" title="10.2.2 跳跃游戏Ⅱ"></a>10.2.2 跳跃游戏Ⅱ</h5><ul>
<li>给你一个非负整数数组nums，你最初位于数组的第一个位置。</li>
<li>数组中的每个元素代表你在该位置可以跳跃的最大长度。</li>
<li>你的目标是使用<strong>最少的跳跃次数</strong>到达数组的最后一个位置。</li>
<li>假设你<strong>总是可以到达数组的最后一个位置</strong>。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 <span class="number">2</span>。</span><br><span class="line">     从下标为 <span class="number">0</span> 跳到下标为 <span class="number">1</span> 的位置，跳 <span class="number">1</span> 步，然后跳 <span class="number">3</span> 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【贪心算法】（局部最优）</span></span><br><span class="line"><span class="comment">// 在一跳的过程中，记录每个点的最远距离，选出最远距离的该点作为下一跳点，step+1</span></span><br><span class="line"><span class="comment">// 每遍历一个跳点，更新一次最远距离。当遍历到跳跃的边界时，将最远距离作为新的边界，相当于在其中选择了跳得最远的点，作为下一个跳点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxJump = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        maxJump = Math.max(maxJump, nums[i] + i);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            end = maxJump;</span><br><span class="line">            step ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="10-2-3-划分字母区间"><a href="#10-2-3-划分字母区间" class="headerlink" title="10.2.3 划分字母区间"></a>10.2.3 划分字母区间</h5><ul>
<li>字符串S由小写字母组成。我们要把这个字符串划分为尽可能多的片段，<strong>同一字母最多出现在一个片段中</strong>。返回一个表示每个字符串片段的长度的列表。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：S = <span class="string">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 <span class="string">&quot;ababcbaca&quot;</span>, <span class="string">&quot;defegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span>。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 <span class="string">&quot;ababcbacadefegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【贪心算法】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 26字母，记录每个字母组后出现位置</span></span><br><span class="line">    <span class="keyword">int</span>[] lastPos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        lastPos[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历字符串，比较遍历的每个字符串最后出现的位置end，取其中最大值</span></span><br><span class="line">    <span class="comment">// 若i == end，表示里面的所有字母都包含在此字段，切分字段</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        end = Math.max(end, lastPos[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            result.add(end-start+<span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-3-两个维度权衡问题"><a href="#10-3-两个维度权衡问题" class="headerlink" title="10.3 两个维度权衡问题"></a>10.3 两个维度权衡问题</h4><h5 id="10-3-1-根据身高重建队列"><a href="#10-3-1-根据身高重建队列" class="headerlink" title="10.3.1 根据身高重建队列"></a>10.3.1 根据身高重建队列</h5><ul>
<li>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code>表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</li>
<li>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 <code>queue[j] = [hj, kj]</code>是队列中第 j 个人的属性（<code>queue[0]</code>是排在队列前面的人）。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>]]</span><br><span class="line">解释：</span><br><span class="line">编号为 <span class="number">0</span> 的人身高为 <span class="number">5</span> ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 <span class="number">1</span> 的人身高为 <span class="number">7</span> ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 <span class="number">2</span> 的人身高为 <span class="number">5</span> ，有 <span class="number">2</span> 个身高更高或者相同的人排在他前面，即编号为 <span class="number">0</span> 和 <span class="number">1</span> 的人。</span><br><span class="line">编号为 <span class="number">3</span> 的人身高为 <span class="number">6</span> ，有 <span class="number">1</span> 个身高更高或者相同的人排在他前面，即编号为 <span class="number">1</span> 的人。</span><br><span class="line">编号为 <span class="number">4</span> 的人身高为 <span class="number">4</span> ，有 <span class="number">4</span> 个身高更高或者相同的人排在他前面，即编号为 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 的人。</span><br><span class="line">编号为 <span class="number">5</span> 的人身高为 <span class="number">7</span> ，有 <span class="number">1</span> 个身高更高或者相同的人排在他前面，即编号为 <span class="number">1</span> 的人。</span><br><span class="line">因此 [[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">    <span class="comment">// 先按身高降序，同身高按个数升序</span></span><br><span class="line">    Arrays.sort(people, (o1, o2) -&gt; o2[<span class="number">0</span>]-o1[<span class="number">0</span>]==<span class="number">0</span> ? o1[<span class="number">1</span>]-o2[<span class="number">1</span>] : o2[<span class="number">0</span>]-o1[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 按照个数进行插空</span></span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">        res.add(person[<span class="number">1</span>], person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(people);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="10-3-2-分发糖果"><a href="#10-3-2-分发糖果" class="headerlink" title="10.3.2 分发糖果"></a>10.3.2 分发糖果</h5><ul>
<li>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</li>
<li>你需要按照以下要求，给这些孩子分发糖果：<ul>
<li>每个孩子<strong>至少分配到 1 个糖果</strong>。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
</li>
<li>请你给每个孩子分发糖果，计算并返回需要准备的<strong>最少糖果数目</strong>。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 <span class="number">2</span>、<span class="number">1</span>、<span class="number">2</span> 颗糖果。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【规律得出】</span></span><br><span class="line"><span class="comment">// 自增时，糖果数 = 前糖果数 + 1 ; </span></span><br><span class="line"><span class="comment">// 相同时，糖果数 = 1 ; </span></span><br><span class="line"><span class="comment">// 递减时，糖果数 = 1，且每递减一次，前面递减序列的糖果都+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> incrSize = <span class="number">0</span>; <span class="comment">// 递增长度</span></span><br><span class="line">    <span class="keyword">int</span> decrSize = <span class="number">0</span>; <span class="comment">// 递减长度</span></span><br><span class="line">    <span class="keyword">int</span> candyCount = <span class="number">1</span>; <span class="comment">// 当前糖果数</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>; <span class="comment">// 总糖果数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;ratings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt;= ratings[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            decrSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] == ratings[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                candyCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                candyCount ++;</span><br><span class="line">            &#125;</span><br><span class="line">            incrSize = candyCount;</span><br><span class="line">            result += candyCount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrSize ++;</span><br><span class="line">            <span class="comment">// 递增大小 == 递减大小时，将递增最后一个纳入递减中</span></span><br><span class="line">            <span class="keyword">if</span> (decrSize == incrSize) &#123;</span><br><span class="line">                decrSize ++;</span><br><span class="line">            &#125;</span><br><span class="line">            result += decrSize;</span><br><span class="line">            candyCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="11-动态规划"><a href="#11-动态规划" class="headerlink" title="11 动态规划"></a>11 动态规划</h3><h4 id="11-1-基础"><a href="#11-1-基础" class="headerlink" title="11.1 基础"></a>11.1 基础</h4><h5 id="11-1-1-爬楼梯"><a href="#11-1-1-爬楼梯" class="headerlink" title="11.1.1 爬楼梯"></a>11.1.1 爬楼梯</h5><ul>
<li>假设你正在爬楼梯。需要n阶你才能到达楼顶。</li>
<li>每次你可以爬1或2个台阶。你有<strong>多少种不同的方法</strong>可以爬到楼顶呢？</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span> <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="comment">// 得出规律 f(x) = f(x-1) + f(x-2)，最终可能走一步，也可能走两步</span></span><br><span class="line"><span class="comment">// 下一步的总方法个数 = 前两个总方法个数之和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 a = f(1)，b = f(2)</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">        <span class="comment">// a，b数值更新，a相当于f(x-2)，b相当于f(x-1)</span></span><br><span class="line">        a = b;</span><br><span class="line">        b = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-1-2-杨辉三角"><a href="#11-1-2-杨辉三角" class="headerlink" title="11.1.2 杨辉三角"></a>11.1.2 杨辉三角</h5><ul>
<li>给定一个非负整数 numRows，生成「杨辉三角」的前numRows行。</li>
<li>在「杨辉三角」中，<strong>每个数是它左上方和右上方的数的和</strong>。</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.gif" class="">

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numRows = <span class="number">5</span></span><br><span class="line">输出: [[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化（第一行只有1个1）</span></span><br><span class="line">    List&lt;Integer&gt; row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    row.add(<span class="number">1</span>);</span><br><span class="line">    result.add(row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;numRows; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; preRow = result.get(i-<span class="number">1</span>);</span><br><span class="line">        row = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++) &#123;</span><br><span class="line">            <span class="comment">// 计算上一行左上方、右上方个数，超出列数设置为0</span></span><br><span class="line">            <span class="keyword">int</span> left = j==<span class="number">0</span> ? <span class="number">0</span> : preRow.get(j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> right = j==i ? <span class="number">0</span> : preRow.get(j);</span><br><span class="line">            row.add(left+right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-1-3-不同路径"><a href="#11-1-3-不同路径" class="headerlink" title="11.1.3 不同路径"></a>11.1.3 不同路径</h5><ul>
<li>一个机器人位于一个<strong>m x n</strong>网格的左上角 （起始点在下图中标记为 “Start” ）。</li>
<li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</li>
<li>问总共<strong>有多少条不同的路径</strong>？</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.png" class="">

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">// 初始化（因为只会向右和下移动，所以边界只有1种可抵达方法）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据递推公式，填充dp数组 （dp[i][j] = dp[i-1][j] + dp[i][j-1]）（跟爬台阶类似）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-2-线性问题"><a href="#11-2-线性问题" class="headerlink" title="11.2 线性问题"></a>11.2 线性问题</h4><h5 id="11-2-1-打家劫舍"><a href="#11-2-1-打家劫舍" class="headerlink" title="11.2.1 打家劫舍"></a>11.2.1 打家劫舍</h5><ul>
<li>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</li>
<li>给定一个代表每个房屋存放金额的<strong>非负整数数组</strong>，计算你<strong>不触动警报</strong>装置的情况下，一夜之内能够偷窃到的<strong>最高金额</strong>。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp数组初始化（下标：能抢劫的户数-1；数值：能抢劫户数下的最大金额）</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 根据公式填充dp数组，dp[i] = max(dp[i-2]+nums[i], dp[i-1])</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">2</span>]+nums[i], dp[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-2-打家劫舍Ⅲ"><a href="#11-2-2-打家劫舍Ⅲ" class="headerlink" title="11.2.2 打家劫舍Ⅲ"></a>11.2.2 打家劫舍Ⅲ</h5><ul>
<li>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</li>
<li>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的<strong>排列类似于一棵二叉树</strong>”。 如果两个<strong>直接相连的房子在同一天晚上被打劫 ，房屋将自动报警</strong>。</li>
<li>给定二叉树的 root 。返回 在<strong>不触动警报</strong>的情况下 ，小偷能够盗取的<strong>最高金额</strong>。</li>
</ul>
<img src="/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3.jpg" class="">

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> <span class="string">root</span> <span class="string">=</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">输出:</span> <span class="number">7</span> </span><br><span class="line"><span class="string">解释:</span> <span class="string">小偷一晚能够盗取的最高金额</span> <span class="number">3</span> <span class="string">+</span> <span class="number">3</span> <span class="string">+</span> <span class="number">1</span> <span class="string">=</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = robArr(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标(0:不偷能获取的最大金额，1：偷能获取的最大金额)</span></span><br><span class="line"><span class="comment">// 递推公式：0:不偷 = max(左偷, 左不偷) + max(右偷, 右不偷)； 1：偷 = node.val + 左不偷 + 右不偷</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] robArr(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归获取子树偷ro不偷数组</span></span><br><span class="line">    <span class="keyword">int</span>[] leftArr = robArr(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] rightArr = robArr(root.right);</span><br><span class="line">    <span class="comment">// 计算当前节点偷or不偷的最大金额</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">0</span>] = Math.max(leftArr[<span class="number">0</span>], leftArr[<span class="number">1</span>]) + Math.max(rightArr[<span class="number">0</span>], rightArr[<span class="number">1</span>]);</span><br><span class="line">    result[<span class="number">1</span>] = root.val + leftArr[<span class="number">0</span>] + rightArr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-3-买卖股票最佳时机"><a href="#11-2-3-买卖股票最佳时机" class="headerlink" title="11.2.3 买卖股票最佳时机"></a>11.2.3 买卖股票最佳时机</h5><ul>
<li>给定一个数组 prices ，它的第i个元素<code>prices[i]</code>表示一支给定股票第i天的价格。</li>
<li>你只能选择<strong>某一天</strong>买入这只股票，并选择在<strong>未来的某一个不同的日子</strong>卖出该股票。设计一个算法来计算你所能获取的最大利润。</li>
<li>返回你可以从这笔交易中获取的<strong>最大利润</strong>。如果你不能获取任何利润，返回 0 。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minPrice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 状态转移；循环比较最小购入金额，以及最大利润</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">            minPrice = prices[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxProfit = Math.max(prices[i]-minPrice, maxProfit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-4-买卖股票的最佳时机Ⅱ"><a href="#11-2-4-买卖股票的最佳时机Ⅱ" class="headerlink" title="11.2.4 买卖股票的最佳时机Ⅱ"></a>11.2.4 买卖股票的最佳时机Ⅱ</h5><ul>
<li>给你一个整数数组prices，其中<code>prices[i]</code>表示某支股票第i天的价格。</li>
<li>在<strong>每一天</strong>，你可以决定是否<strong>购买和/或出售</strong>股票。你在任何时候<strong>最多只能持有一股</strong>股票。</li>
<li>返回你能获得的<strong>最大利润</strong>。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span> - <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span> 。</span><br><span class="line">     总利润为 <span class="number">4</span> + <span class="number">3</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化（第一天数据填入），have表示手中有股表，nothave表示手中无股票，值表示利润</span></span><br><span class="line">    <span class="keyword">int</span> have = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> notHave = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 依次与昨天比较，进行状态转移</span></span><br><span class="line">    <span class="comment">// 无股票：（1）昨天也无股票，（2）昨天有股票，但卖出了，加上昨天股票价钱</span></span><br><span class="line">    <span class="comment">// 有股票：（1）昨天也有股票，（2）昨天无股票，但花钱购买了，减上昨天股票价钱</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++) &#123;</span><br><span class="line">        have = Math.max(have, notHave - prices[i]);</span><br><span class="line">        notHave = Math.max(notHave, have + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> notHave;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-5-最大子数组和"><a href="#11-2-5-最大子数组和" class="headerlink" title="11.2.5 最大子数组和"></a>11.2.5 最大子数组和</h5><ul>
<li>给你一个整数数组nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态推移 </span></span><br><span class="line">    <span class="comment">// pre = max(pre+nums[i], nums[i])</span></span><br><span class="line">    <span class="comment">// result = max(pre, result)</span></span><br><span class="line">    <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        pre = Math.max(nums[i]+pre, nums[i]);</span><br><span class="line">        result = Math.max(result, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-6-最长递增子序列"><a href="#11-2-6-最长递增子序列" class="headerlink" title="11.2.6 最长递增子序列"></a>11.2.6 最长递增子序列</h5><ul>
<li>给你一个整数数组nums，找到其中最长严格递增子序列的长度。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：最长递增子序列是 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>]，因此长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/ 【动态规划】</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp数组：index=当前数字下标；value=最长递增序列个数（即：当前数字最长递增序列个数）</span></span><br><span class="line">    <span class="comment">// 默认最长递增序列为1（即自身）</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// i 跟 i之前的数字比较大小；nums[i] &gt; nums[j]，dp[i] = max(dp[i], dp[j]+1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = Math.max(result, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-7-编辑距离"><a href="#11-2-7-编辑距离" class="headerlink" title="11.2.7 编辑距离"></a>11.2.7 编辑距离</h5><ul>
<li>给你两个单词word1和word2，请返回将word1转换成word2所使用的最少操作数。</li>
</ul>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;horse&quot;</span>, word2 = <span class="string">&quot;ros&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line"><span class="function"><span class="title">horse</span> -&gt;</span> rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rorse</span> -&gt;</span> rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="function"><span class="title">rose</span> -&gt;</span> ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n = word2.length();</span><br><span class="line">    <span class="comment">// 出现空串，操作次数 = 非空串长度</span></span><br><span class="line">    <span class="keyword">if</span> (m * n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> m + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp数组：i表示word1前i个字符，j表示word2前j个字符，dp[i][j] = word1前i个字符和word2前j个字符，互相转换的最小次数</span></span><br><span class="line">    <span class="comment">// 额外多出1个空间，表示空字符串，位于0号位</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n+<span class="number">1</span>; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递推公式：dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1], dp[i-1][j-1]+1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = dp[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> down = dp[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> left_down = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// left_down表示替换，字符一样无需替换</span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) != word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                left_down ++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = Math.min(left, Math.min(down, left_down));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-3-背包问题"><a href="#11-3-背包问题" class="headerlink" title="11.3 背包问题"></a>11.3 背包问题</h4><h5 id="11-3-1-单词拆分"><a href="#11-3-1-单词拆分" class="headerlink" title="11.3.1 单词拆分"></a>11.3.1 单词拆分</h5><ul>
<li>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</li>
<li><strong>注意</strong>：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</li>
</ul>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;leetcode&quot;</span>, <span class="attr">wordDict</span> = [<span class="string">&quot;leet&quot;</span>, <span class="string">&quot;code&quot;</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">&quot;leetcode&quot;</span> 可以由 <span class="string">&quot;leet&quot;</span> 和 <span class="string">&quot;code&quot;</span> 拼接成。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拆分字段去重</span></span><br><span class="line">    Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">    <span class="comment">// dp[j]==true（表示上个单词拆分的边界）</span></span><br><span class="line">    <span class="comment">// 若此时string.sub(j, i) == wordDict中的词，j边界到i之间又有一个拆分的词，dp[i] = true</span></span><br><span class="line">    <span class="comment">// 当dp[n] == true，表示整个字符串都能被单词拆分</span></span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化（0号位表示空串，用来设置边界）</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.length()+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-2-零钱兑换"><a href="#11-2-2-零钱兑换" class="headerlink" title="11.2.2 零钱兑换"></a>11.2.2 零钱兑换</h5><ul>
<li>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</li>
<li>计算并返回可以凑成总金额所需的<strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</li>
<li>你可以认为每种硬币的<strong>数量是无限</strong>的。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【动态规划】</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp数组，i表示金额，dp[i]表示达到i所需最小硬币数</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化：填充amount+1，用于判断数组末尾是否有硬币能组合，硬币组合不了值一定等于amount+1</span></span><br><span class="line">    Arrays.fill(dp, amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 状态转移公式：dp[i] = Math.min(dp[i], dp[i-coins[j]+1])</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;amount+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="11-2-3-完全平方数"><a href="#11-2-3-完全平方数" class="headerlink" title="11.2.3 完全平方数"></a>11.2.3 完全平方数</h5><ul>
<li>给你一个整数 n ，返回0和为n的完全平方数的最少数量</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：<span class="number">12</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp数组：i为数字，dp[i]为组成该数字所需的最小平方数和</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 默认为i，即该数全由1组成</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">// 从1到i找出最小的平方数和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            min = Math.min(min, dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-3-区间问题"><a href="#11-3-区间问题" class="headerlink" title="11.3 区间问题"></a>11.3 区间问题</h4><h5 id="11-3-1-最长回文子序列"><a href="#11-3-1-最长回文子序列" class="headerlink" title="11.3.1 最长回文子序列"></a>11.3.1 最长回文子序列</h5><ul>
<li>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<ul>
<li>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</li>
</ul>
</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;bbbab&quot;</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一个可能的最长回文子序列为 <span class="string">&quot;bbbb&quot;</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="comment">// i, j为字符i到j组成的字符串，dp[i][j]为ij字符串的最长回文序列</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 默认1，即一个字符</span></span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// i从后往前推移，j从前往后推移，保证数据存在</span></span><br><span class="line">        <span class="comment">// 假如i字符==j字符，往字符内部推移，即dp[i+1][j-1]+2</span></span><br><span class="line">        <span class="comment">// 假如i字符!=j字符，取i or j 往内推移的最大值，max(dp[i+1][j], dp[i][j-1])</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/25/%E3%80%90ElasticSearch%E3%80%91ES%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="prev" title="【ElasticSearch】ES环境搭建">
      <i class="fa fa-chevron-left"></i> 【ElasticSearch】ES环境搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/21/%E3%80%90Redis%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="next" title="【Redis】分布式锁">
      【Redis】分布式锁 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84"><span class="nav-text">1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">1.1 两数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-text">1.2 三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-text">1.3 合并两个有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-text">1.4 螺旋矩阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">2 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-text">2.1 有效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="nav-text">2.2 字符串相加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">2.3 最长回文子串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">3 单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">3.1 合并两个单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="nav-text">3.2 单链表反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E4%B8%A4%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0"><span class="nav-text">3.3 两链表相加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-text">3.4 重排链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">4 双链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-LRU%E7%AE%97%E6%B3%95"><span class="nav-text">4.1 LRU算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">5 双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E6%95%B0%E7%BB%84"><span class="nav-text">5.1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-1-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">5.1.1 移除元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-2-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="nav-text">5.1.2 有序数组的平方</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-3-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-text">5.1.3 长度最小的子数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.2 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.2.1 反转字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2"><span class="nav-text">5.2.2 无重复字符的最长字串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-text">5.2.3 字符串的排列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E9%93%BE%E8%A1%A8"><span class="nav-text">5.3 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-text">5.3.1 环形链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-2-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-text">5.3.2 删除链表的倒数第N个结点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-3-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="nav-text">5.3.3 链表的中间结点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-4-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1"><span class="nav-text">5.3.4 环形链表Ⅱ</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">6 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-text">6.1 有效的字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-text">6.2 存在重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-text">6.3 两个数组的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1"><span class="nav-text">6.4 四数相加Ⅱ</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E9%98%9F%E5%88%97"><span class="nav-text">7 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-text">7.1 用队列实现栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-text">7.2 前K个高频元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">7.3 滑动窗口最大值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%A0%88"><span class="nav-text">8 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text">8.1 用栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-text">8.2 . 逆波兰表达式求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-text">8.3 接雨水</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="nav-text">9.1 二叉树遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">9.1.1 二叉树中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">9.1.2 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-1-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">9.1.3 二叉树的锯齿层序遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">9.2 二叉树的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#9-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-text">9.2.1 二叉树的最大深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-text">9.2.2 二叉树的直径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-2-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-text">9.2.3 二叉树中的最大路径和</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-text">9.3 二叉树的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#9-3-1-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">9.3.1 从中序与后序遍历序列构造二叉树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-text">10 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">10.1 基础常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-1-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-text">10.1.1 分发饼干</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-text">10.2 区间问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#10-2-1-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-text">10.2.1 跳跃游戏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-2-2-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1"><span class="nav-text">10.2.2 跳跃游戏Ⅱ</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-2-3-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-text">10.2.3 划分字母区间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-%E4%B8%A4%E4%B8%AA%E7%BB%B4%E5%BA%A6%E6%9D%83%E8%A1%A1%E9%97%AE%E9%A2%98"><span class="nav-text">10.3 两个维度权衡问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#10-3-1-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-text">10.3.1 根据身高重建队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-3-2-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-text">10.3.2 分发糖果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">11 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-%E5%9F%BA%E7%A1%80"><span class="nav-text">11.1 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-1-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-text">11.1.1 爬楼梯</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-2-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-text">11.1.2 杨辉三角</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-3-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-text">11.1.3 不同路径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">11.2 线性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-1-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-text">11.2.1 打家劫舍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-2-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A2"><span class="nav-text">11.2.2 打家劫舍Ⅲ</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-3-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-text">11.2.3 买卖股票最佳时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-4-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1"><span class="nav-text">11.2.4 买卖股票的最佳时机Ⅱ</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-5-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-text">11.2.5 最大子数组和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-6-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">11.2.6 最长递增子序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-7-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-text">11.2.7 编辑距离</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">11.3 背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-1-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-text">11.3.1 单词拆分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-2-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-text">11.2.2 零钱兑换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-3-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-text">11.2.3 完全平方数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-text">11.3 区间问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-1-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">11.3.1 最长回文子序列</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="莱特雷"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">莱特雷</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">217</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/402971365" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;402971365" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/letere" title="gitee → https:&#x2F;&#x2F;gitee.com&#x2F;letere" rel="noopener" target="_blank"><i class="fab fa-git fa-fw"></i>gitee</a>
      </span>
  </div>



      </div>

    </div>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">莱特雷</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
