{"meta":{"title":"个人博客","subtitle":"","description":"","author":"莱特雷","url":"https://letere-gzj.github.io","root":"/"},"pages":[{"title":"目录","date":"2020-09-18T03:52:33.000Z","updated":"2020-09-18T04:04:19.020Z","comments":false,"path":"categories/index.html","permalink":"https://letere-gzj.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【Spring】SpringCache缓存框架","slug":"【Spring】SpringCache缓存框架","date":"2022-08-31T16:14:25.000Z","updated":"2022-08-31T17:14:05.098Z","comments":true,"path":"2022/09/01/【Spring】SpringCache缓存框架/","link":"","permalink":"https://letere-gzj.github.io/2022/09/01/%E3%80%90Spring%E3%80%91SpringCache%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/","excerpt":"SpringCache缓存框架简介与使用","text":"SpringCache缓存框架简介与使用 1 简介 Spring从3.1开始，定义了Cache和CacheManager接口来统一管理不同的缓存 通过注解的形式，来实现对缓存的读取，写入，删除操作，简化开发 【SpringCache文档】 注解 说明 @Cacheable 读取缓存。缓存存在，不执行方法直接返回缓存；若缓存不存在，执行方法，并将方法的返回值写入缓存 @CacheEvict 删除缓存 @CachePut 将方法的返回值写入缓存 @Caching 组合多个缓存注解操作 2 操作演示 操作演示使用的是redis作为缓存，且使用springboot来演示，非spring 2.1 环境准备 （1）依赖 1234567891011&lt;!-- spring-cache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; （2）yaml配置 123456789spring: cache: type: redis # 缓存类型：redis redis: time-to-live: 30000 # 所有redis-key过期时间（单位：毫秒） cache-null-values: true # 缓存null值（解决缓存穿透） redis: host: 127.0.0.1 port: 6379 （3）SpringBoot启动类添加@EnableCaching 2.2 @Cacheable 【SpEL表达式使用】 12345@Cacheable(value = &#123;#Category&#125;, key = &quot;#keyName&quot;, sync = #true/false)value: 缓存分类or目录key: 缓存的key名(使用SpEl表达式)sync: 是否加本地锁(虽然不是分布式锁，但也是能降低缓存击穿问题) 1234567// 【演示代码】@Cacheable(value = &quot;test&quot;, key = &quot;&#x27;msg&#x27;&quot;, sync = true)@Overridepublic String getMsg() &#123; System.out.println(&quot;log --- 调用了数据库，没命中缓存&quot;); return &quot;Hello World&quot;;&#125; 2.3 @CacheEvict | @CachePut @CacheEvict | @CachePut 两注解使用场景基本一致，用于维护缓存和数据库一致性 @CacheEvict：先更新数据库，后删除缓存 @CachePut:：先更新数据库，再更新缓存 12345@CacheEvict(value = &#123;#category&#125;, key = &quot;#keyName&quot;, allEntries = #true/false)value：缓存目录key：缓存key名allEntries：是否删除满足条件所有缓存（可以只填value值，不填具体的key值，就会将value目录下的所有缓存删除） 1234@CachePut(value = &#123;#category&#125;, key = &quot;#keyName&quot;)value：缓存目录key：缓存key名 12345678910111213141516// 【演示代码】// 移除缓存（更新删除）@CacheEvict(value = &quot;test&quot;, key = &quot;&#x27;msg&#x27;&quot;)@Overridepublic void updateMsg() &#123; // 更新数据库逻辑&#125;// ---// 更新缓存（双写模式）@CachePut(value = &quot;test&quot;, key = &quot;&#x27;msg&#x27;&quot;)@Overridepublic String updateMsg() &#123; // 更新数据库逻辑，并将更新后的数据返回&#125; 2.4 @Caching12345@Caching(cacheable = &#123;&#125;, put = &#123;&#125;, evict = &#123;&#125;)cachable：放入@Cachable注解put：放入@CachePut注解evict：放入@CacheEvict注解 123456789101112// 【演示代码】// 组合操作@Caching( evict = &#123; @CacheEvict(value = &quot;test&quot;, key = &quot;&#x27;msg1&#x27;&quot;), @CacheEvict(value = &quot;test&quot;, key = &quot;&#x27;msg2&#x27;&quot;) &#125;)@Overridepublic void updateMsg2() &#123; // 更新数据库数据&#125; 3 自定义配置类 因为缓存存入redis中，value使用了jdk序列化的形式，不便于跨平台使用，建议使用json来序列化 因此需要自定一个配置类来解决问题 123456789101112131415161718192021222324252627@EnableConfigurationProperties(CacheProperties.class) // 使yaml中配置绑定的配置类放入ioc容器中@EnableCaching@Configurationpublic class MyRedisCacheConfig &#123; @Bean public RedisCacheConfiguration getRedisCacheConfiguration(CacheProperties cacheProperties) &#123; // 修改value序列化方法，默认使用jdk序列化，改成json序列化 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); // 其余照搬源码（org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration.createConfiguration()方法） CacheProperties.Redis redisProperties = cacheProperties.getRedis(); if (redisProperties.getTimeToLive() != null) &#123; config = config.entryTtl(redisProperties.getTimeToLive()); &#125; if (redisProperties.getKeyPrefix() != null) &#123; config = config.prefixCacheNameWith(redisProperties.getKeyPrefix()); &#125; if (!redisProperties.isCacheNullValues()) &#123; config = config.disableCachingNullValues(); &#125; if (!redisProperties.isUseKeyPrefix()) &#123; config = config.disableKeyPrefix(); &#125; return config; &#125;&#125; 4 SpringCache的不足 从缓存三大问题分析 缓存穿透：配置中有spring.cache.redis.cache-null-values = true，来存储null，可以完美解决缓存穿透问题 缓存击穿：@Cacheable(sync = true)，读取缓存可以使用本地同步锁，解决方法虽不如分布式锁，但一定程度上也算是解决缓存击穿问题 缓存雪崩：无法解决，所有缓存设置的过期时间都一致，有可能存在缓存雪崩问题","categories":[{"name":"Spring","slug":"Spring","permalink":"https://letere-gzj.github.io/categories/Spring/"}],"tags":[]},{"title":"【Gradle】gradle入门","slug":"【Gradle】gradle入门","date":"2022-08-30T04:35:05.000Z","updated":"2022-08-31T10:28:47.147Z","comments":true,"path":"2022/08/30/【Gradle】gradle入门/","link":"","permalink":"https://letere-gzj.github.io/2022/08/30/%E3%80%90Gradle%E3%80%91gradle%E5%85%A5%E9%97%A8/","excerpt":"gradle基于命令的使用介绍","text":"gradle基于命令的使用介绍 1 创建Gradle项目 （1）可以使用【Spring Initializr】来辅助创建gradle目录 （2）可以基于命令来创建gradle项目gradle init 注：此构建方法目录结构稍微有点不一样 2 Gradle常用指令 指令 说明 gradle clean 清空build目录 gradle classes 编译业务代码和配置文件 gradle test 编译测试代码，生产测试报告(\\build\\reports\\tests) gradle build 构建项目 gradle build -x test 构建项目（跳过测试） 3 修改maven下载源 gradle自带的maven源地址为国外，访问速度慢。建议使用国内第三方开放的maven源 （1）事先准备maven，配置好M2_HOME环境变量 （2）在gradle目录\\init.d\\中创建一个init.gradle脚本 （3）将以下内容粘贴到脚本中，保存12345678910111213141516allprojects &#123; repositories &#123; mavenLocal() maven &#123; name &quot;Alibaba&quot; ; url &quot;https://maven.aliyun.com/repository/public&quot; &#125; maven &#123; name &quot;Bstek&quot; ; url &quot;https://nexus.bsdn.org/content/groups/public/&quot; &#125; mavenCentral() &#125; buildscript &#123; repositories &#123; maven &#123; name &quot;Alibaba&quot; ; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125; maven &#123; name &quot;Bstek&quot; ; url &#x27;https://nexus.bsdn.org/content/groups/public/&#x27; &#125; maven &#123; name &quot;M2&quot; ; url &#x27;https://plugins.gradle.org/m2/&#x27; &#125; &#125; &#125; &#125;","categories":[{"name":"Gradle","slug":"Gradle","permalink":"https://letere-gzj.github.io/categories/Gradle/"}],"tags":[]},{"title":"【Gradle】gradle介绍与安装","slug":"【Gradle】gradle介绍与安装","date":"2022-08-27T12:20:10.000Z","updated":"2022-08-27T12:34:21.209Z","comments":true,"path":"2022/08/27/【Gradle】gradle介绍与安装/","link":"","permalink":"https://letere-gzj.github.io/2022/08/27/%E3%80%90Gradle%E3%80%91gradle%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/","excerpt":"Gradle简单介绍，下载安装，以及目录结构解析","text":"Gradle简单介绍，下载安装，以及目录结构解析 1 项目构建工具区别 Ant：2000年Apache推出的纯Java编写构建工具，通过xmlbuild.xml文件管理项目 优点：使用灵活，速度快(快于gradle和maven) 缺点：Ant没有强加任何编码约定的项目目录结构,开发人员需编写繁杂XML文件构建指令,对开发人员是一个挑战 Maven：2004年Apache组织推出的再次使用xml文件pom.xml管理项目的构建工具 优点：遵循一套约定大于配置的项目目录结构，使用统一的GAV坐标进行依赖管理，侧重于包管理 缺点：项目构建过程僵化,配置文件编写不够灵活、不方便自定义组件,构建速度慢于gradle Gradle：2012年Google推出的基于Groovy语言的全新项目构建工具，集合了Ant和Maven各自的优势 优点：集Ant脚本的灵活性+Maven约定大于配置的项目目录优势，支持多种远程仓库和插件，侧重于大项目构建 缺点：学习成本高、资料少、脚本灵活、版本兼容性差等 Ant Maven Gradle 构建性能 高 低 中 仓库 开发者自己处理 maven仓库 支持多种远程仓库 依赖管理 ivy管理 GAV坐标管理 GNV坐标管理 插件支持 实现方便 实现较难 实现方便 遵循特定目录结构 不遵循 遵循 遵循 配置文件 xml文件最为繁琐 xml文件 代码脚本。便于写业务逻辑 侧重点 小型项目构建 项目包管理 大象项目构建 目前地位 使用较少 目前主流 未来可期 2 Gradle安装2.1 版本选择 （1） SpringBoot要求Gradle版位6.8以上 【springboot文档】 （2） IDEA支持版本，在IDEA目录\\plugins\\gradle\\lib下查看IDEA默认支持版本 （idea并非所有gralde版本都支持，若版本不支持，选择升级idea版本） 综合以上两种情况来选择合适的Gradle版本 2.2 下载和安装 （1） 【Gradle下载地址】 下载有binary-only和complete (checksums)两个版本 binary-only文件较小 complete (checksums)文件较大，但包含文档和源码，建议开发下载此版本 （2） 下载后解压配置环境变量（不多介绍） 还要多配置一个GRADLE_USER_HOME变量，这是Gradle仓库位置，可以与Maven仓库共用 （3） 使用命令gradle -v查看是否安装成功 3 Gradle项目目录结构","categories":[{"name":"Gradle","slug":"Gradle","permalink":"https://letere-gzj.github.io/categories/Gradle/"}],"tags":[]},{"title":"【Redis】分布式锁","slug":"【Redis】分布式锁","date":"2022-08-21T14:28:04.000Z","updated":"2022-08-24T01:52:42.463Z","comments":true,"path":"2022/08/21/【Redis】分布式锁/","link":"","permalink":"https://letere-gzj.github.io/2022/08/21/%E3%80%90Redis%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"Redis实现分布式锁","text":"Redis实现分布式锁 1 Redis实现1.1 环境123456&lt;!--依赖--&gt;&lt;!-- redis（lettuce）--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt; 12345# application.yamlspring: redis: host: 127.0.0.1 # redis地址 port: 6379 # redis端口 1.2 代码1234567891011121314151617181920212223242526272829303132@Autowiredprivate RedisTemplate redisTemplate;@RequestMapping(&quot;/test&quot;)public void test() &#123; // 循环通过setnx获取锁，获取失败，沉睡两秒 // 锁设置过期时间，避免程序停掉，未删除锁，造成死锁 String uuid = UUID.randomUUID().toString(); while (!redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 30, TimeUnit.SECONDS)) &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 获取锁成功，执行业务，业务执行完后删除锁 try &#123; System.out.println(Thread.currentThread() + &quot; -- 获取锁成功，执行业务...&quot;); Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 利用lua脚本，保证原子性删除（uuid相同才删除lock，避免业务超时lock过期，删除了新进程产生的lock） String script = &quot;if redis.call(\\&quot;get\\&quot;,KEYS[1]) == ARGV[1] then\\n&quot; + &quot; return redis.call(\\&quot;del\\&quot;,KEYS[1])\\n&quot; + &quot;else\\n&quot; + &quot; return 0\\n&quot; + &quot;end&quot;; redisTemplate.execute(new DefaultRedisScript(script, Long.class), Arrays.asList(&quot;lock&quot;), uuid); System.out.println(Thread.currentThread() + &quot; -- 释放锁&quot;); &#125;&#125; 2 Redisson实现 Redisson是redis官方用来推荐来实现分布式锁的工具，除了常规锁，redisson还实现多种功能的锁，实用性强 官方文档：https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器 1234567&lt;!-- 依赖 --&gt;&lt;!-- springboot redisson整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.17.5&lt;/version&gt;&lt;/dependency&gt; 12345678# application.yamlspring: redis: redisson: config: | # 具体参数查询org.redisson.config.SingleServerConfig类 singleServerConfig: address: &quot;redis://127.0.0.1:6379&quot; database: 0 2.1 可重入锁1234567891011121314151617public void redissonLock() &#123; // 创建锁 RLock lock = redissonClient.getLock(&quot;lock&quot;); // 获取锁（阻塞，只有获取成功才会向下执行） lock.lock(); try &#123; // 执行业务 System.out.println(Thread.currentThread() + &quot; -- 获取锁&quot;); Thread.sleep(10000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; // 释放锁 System.out.println(Thread.currentThread() + &quot; -- 释放锁&quot;); lock.unlock(); &#125;&#125; 补充： 不手动设置key过期时间，会默认设置30s，且内部有看门狗(watch dog)机制，会对业务进行自动续期 手动设置过期时间，看门狗功能不会生效，不会自动续期 支持非阻塞获取锁，方法为lock.tryLock() 2.2 读写锁 读写锁：一旦写锁获取时，禁止获取读锁。写锁释放时，读锁才能获取； 读写锁主要保证读取的数据永远是最新的； 写锁是互斥锁（获取锁后，读锁无法获取）；读锁是共享锁（读锁获取时相当于无锁，所有请求都可以同时获取锁）； 12345678910111213141516171819202122232425262728293031323334@Autowiredprivate RedissonClient redissonClient;@GetMapping(&quot;/write&quot;)public void writeLock() &#123; RLock wlock = redissonClient.getReadWriteLock(&quot;rwlock&quot;).writeLock(); // 获取写锁 wlock.lock(); try &#123; System.out.println(Thread.currentThread() + &quot; -- 获取写锁&quot;); Thread.sleep(10000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread() + &quot; -- 释放写锁&quot;); wlock.unlock(); &#125;&#125;@GetMapping(&quot;/read&quot;)public void readLock() &#123; RLock rlock = redissonClient.getReadWriteLock(&quot;rwlock&quot;).readLock(); // 获取读锁 rlock.lock(); try &#123; System.out.println(Thread.currentThread() + &quot; -- 获取读锁&quot;); Thread.sleep(5000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread() + &quot; -- 释放读锁&quot;); rlock.unlock(); &#125;&#125; 2.3 信号量 信号量：预先设置空间大小，每获取一次信号，可使用空间减少，直到信号量为0时。禁止获取空间，阻塞处理。直到有空间释放时，才能进行下一步处理。 信号量可以应用在停车场车位，限流等场景 12345678910111213141516171819202122232425@Autowiredprivate RedisTemplate redisTemplate;@Autowiredprivate RedissonClient redissonClient;@GetMapping(&quot;/acquire&quot;)public void acquire() &#123; // 设置可使用信号量 redisTemplate.opsForValue().setIfAbsent(&quot;semaphore&quot;, 3); RSemaphore semaphore = redissonClient.getSemaphore(&quot;semaphore&quot;); try &#123; // 获取信号量，阻塞获取（需要非阻塞，使用tryAcquire） semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;@GetMapping(&quot;/release&quot;)public void release() &#123; RSemaphore semaphore = redissonClient.getSemaphore(&quot;semaphore&quot;); // 释放信号量 semaphore.release();&#125;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【面试】Leetcode2022秋招算法","slug":"【面试】Leetcode2022秋招算法","date":"2022-08-09T12:55:25.000Z","updated":"2022-08-29T07:01:52.490Z","comments":true,"path":"2022/08/09/【面试】Leetcode2022秋招算法/","link":"","permalink":"https://letere-gzj.github.io/2022/08/09/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Leetcode2022%E7%A7%8B%E6%8B%9B%E7%AE%97%E6%B3%95/","excerpt":"leetcode 2022年 秋招算法题","text":"leetcode 2022年 秋招算法题 1 数组1.1 两数之和123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 12345678910111213// 【哈希表】// 优点：消耗内存，节省时间，一次循环解决// 将数据存入Map中，记录num和index，寻找target-nums[i]值public static int[] twoSum2(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; subTarget = new HashMap&lt;&gt;(); for (int i=0; i&lt;nums.length; i++) &#123; if (subTarget.containsKey(target - nums[i])) &#123; return new int[]&#123;subTarget.get(target - nums[i]), i&#125;; &#125; subTarget.put(nums[i], i); &#125; return new int[0];&#125; 1.2 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组 12输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]] 123456789101112131415161718192021222324252627282930313233343536// 【排序 + 双指针】// 当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); // 排序，方便去重 Arrays.sort(nums); for (int first=0; first&lt;nums.length-2; first++) &#123; // 有序数组，first元素&gt;0，结束循环 if (nums[first] &gt; 0) &#123; break; &#125; // first去重 if (first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) &#123; continue; &#125; int third = nums.length - 1; for (int second=first+1; second&lt;nums.length-1; second++) &#123; // second去重 if (second &gt; first+1 &amp;&amp; nums[second] == nums[second-1]) &#123; continue; &#125; // 保证second 在 third 左边，并移动 third 直至和&lt;=0 while (second &lt; third &amp;&amp; nums[first]+nums[second]+nums[third] &gt; 0) &#123; third --; &#125; // 双指针重合时，往后的三者之和数必定&gt;0，结束second循环 if (second == third) &#123; break; &#125; if (nums[first]+nums[second]+nums[third] == 0) &#123; result.add(new ArrayList&lt;&gt;(Arrays.asList(nums[first], nums[second], nums[third]))); &#125; &#125; &#125; return result;&#125; 1.3 合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 12345678910111213141516171819// 正常思路为双指针，新开一个数组，双指针比较，小的放入新数组，指针后移// 【逆双指针】// 示例nums1后面数组为空，可以直接覆盖，不用新开数组，从后往前比较大小public void merge2(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1; int j = n - 1; int index = m + n - 1; while (j &gt;= 0) &#123; if (i == -1 || nums1[i] &lt; nums2[j]) &#123; nums1[index] = nums2[j]; j--; &#125; else &#123; nums1[index] = nums1[i]; i--; &#125; index--; &#125; System.out.println(Arrays.toString(nums1));&#125; 1.4 螺旋矩阵 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 123456789101112131415161718192021222324252627282930313233343536373839// 【按层模拟】// 类似同心圆，从外层到里层，转一圈为一个循环public static int[][] generateMatrix(int n) &#123; // 初始化 int[][] matrix = new int[n][n]; int left = 0; int top = 0; int right = n - 1; int bottom = n - 1; int num = 1; // 按层循环 while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; // 向右移动 → for (int column = left; column &lt;= right; column ++) &#123; matrix[top][column] = num; num ++; &#125; // 向下移动 ↓ for (int row = top + 1; row &lt;= bottom; row ++) &#123; matrix[row][right] = num; num ++; &#125; // 向左移动 ← for (int column = right - 1; column &gt;= left; column --) &#123; matrix[bottom][column] = num; num ++; &#125; // 向上移动 ↑ for (int row = bottom -1; row &gt;= top + 1; row --) &#123; matrix[row][left] = num; num ++; &#125; left ++; right --; top ++; bottom --; &#125; return matrix;&#125; 2 字符串2.1 有效的括号 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 12345输入：s = &quot;([)]&quot;输出：false输入：s = &quot;&#123;[]&#125;&quot;输出：true 123456789101112131415161718192021222324252627// 【栈】// （规律）当遇到第一个右括号时，栈顶必定为对应的左括号；匹配后栈顶出栈，依次循环public static boolean isValid(String s) &#123; // 合法性判断，奇数一定不合法 if (s.length() % 2 != 0) &#123; return false; &#125; // Map存储对应关系，方便处理 Map&lt;Character, Character&gt; charMap = new HashMap&lt;&gt;(); charMap.put(&#x27;)&#x27;, &#x27;(&#x27;); charMap.put(&#x27;]&#x27;, &#x27;[&#x27;); charMap.put(&#x27;&#125;&#x27;, &#x27;&#123;&#x27;); // 栈处理 Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) &#123; // 匹配到右括号，判断栈顶左括号 if (charMap.containsKey(c)) &#123; if (stack.empty() || !stack.peek().equals(charMap.get(c))) &#123; return false; &#125; stack.pop(); &#125; else &#123; stack.push(c); &#125; &#125; return stack.isEmpty();&#125; 2.2 字符串相加 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。 12输入：num1 = &quot;11&quot;, num2 = &quot;123&quot;输出：&quot;134&quot; 123456789101112131415161718192021// 【模拟竖直相加】// 从个位往前相加，进位=和/10，相加后的位数=和%10public static String addStrings(String num1, String num2) &#123; int m = num1.length() - 1; int n = num2.length() - 1; int carry = 0; StringBuilder result = new StringBuilder(); while (m &gt;=0 || n &gt;= 0 || carry != 0) &#123; if (m &gt; -1) &#123; carry += num1.charAt(m) - &#x27;0&#x27;; &#125; if (n &gt; -1) &#123; carry += num2.charAt(n) - &#x27;0&#x27;; &#125; result.insert(0, carry % 10); carry /= 10; m --; n --; &#125; return result.toString();&#125; 2.3 最长回文子串 给你一个字符串 s，找到 s 中最长的回文子串。 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 123456789101112131415161718192021222324252627282930313233// 【中心拓展法】// 将字符串每个下标作为中心，向左右拓展，枚举出最长的回文，记录初始结束点// 回文有奇数回文，和偶数回文public static String longestPalindrome(String s) &#123; int len1; int len2; int maxLen; int start = 0; int end = 0; String result = &quot;&quot;; for (int i=0; i&lt;s.length(); i++) &#123; // 奇数回文串 len1 = getMaxLen(s, i, i); // 偶数回文串 len2 = getMaxLen(s, i, i + 1); maxLen = Math.max(len1, len2); if (maxLen &gt; end - start) &#123; start = i - (maxLen-1)/2; end = i + maxLen/2; &#125; &#125; return s.substring(start, end + 1);&#125;public static int getMaxLen(String s, int left, int right) &#123; while (left &gt; -1 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left --; right ++; &#125; return right - left - 1;&#125; 3 单链表3.1 合并两个单链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 12输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 123456789101112131415161718192021222324// 【单链表数据结构】public class ListNode &#123; int val; ListNode next; ListNode() &#123;&#125; ListNode(int val) &#123; this.val = val; &#125; ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; @Override public String toString() &#123; return &quot;ListNode&#123;&quot; + &quot;val=&quot; + val + &quot;, next=&quot; + next + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011121314151617// 【迭代循环】public static ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode headNode = new ListNode(-1); ListNode currentNode = headNode; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &gt; list2.val) &#123; currentNode.next = list2; list2 = list2.next; &#125; else &#123; currentNode.next = list1; list1 = list1.next; &#125; currentNode = currentNode.next; &#125; currentNode.next = list1 == null ? list2 : list1; return headNode.next;&#125; 3.2 单链表反转 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 123456789101112131415// 【迭代循环】// 遍历下一个节点时，下一个节点.next=前一个节点public static ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode next; ListNode curr = head; while (curr != null) &#123; next = curr.next; // 位置互换 curr.next = prev; prev = curr; curr = next; &#125; return prev;&#125; 3.3 两链表相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 123456789101112131415161718192021// 【循环迭代】// 思路类似字符串相加public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode headNode = new ListNode(-1); ListNode sum = headNode; int carry = 0; while (l1 != null || l2 != null || carry != 0) &#123; if (l1 != null) &#123; carry += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; carry += l2.val; l2 = l2.next; &#125; sum.next = new ListNode(carry % 10); sum = sum.next; carry = carry / 10; &#125; return headNode.next;&#125; 3.4 重排链表 给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为： L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换 12输入：head = [1,2,3,4,5]输出：[1,5,2,4,3] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 【寻找链表中点 + 链表逆序 + 合并链表】// 找出中间点，分左右两部分（中间点包含在左），右边部分反转，然后交叉插入public void reorderList(ListNode head) &#123; ListNode midNode = midNode(head); ListNode reverseList = reverseList(midNode.next); midNode.next = null; mergeList(head, reverseList);&#125;// 链表中点// fast是slow的两倍移速，当fast到达末尾时，slow在中间public ListNode midNode(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; return slow;&#125;// 链表反转public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode next; ListNode current = head; while (current != null) &#123; next = current.next; current.next = pre; pre = current; current = next; &#125; return pre;&#125;// 链表交叉合并public void mergeList(ListNode l1, ListNode l2) &#123; ListNode l1Temp; ListNode l2Temp; while (l1 != null &amp;&amp; l2!= null) &#123; l1Temp = l1.next; l2Temp = l2.next; // 交叉合并 l1.next = l2; l2.next = l1Temp; // 重新赋值 l1 = l1Temp; l2 = l2Temp; &#125;&#125; 4 双链表4.1 LRU算法 5 双指针5.1 数组5.1.1 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 12345678910111213141516// 【双指针向中间遍历】public int removeElement(int[] nums, int val) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; if (nums[left] == val) &#123; // 左指针元素相同，左指针元素=右指针元素（判断右指针元素，写法简化了if条件），向前移动 nums[left] = nums[right]; right --; &#125; else &#123; // 左指针元素不同，向后移动 left ++; &#125; &#125; return left;&#125; 5.1.2 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 12345678910111213141516171819// 【双指针向中间遍历】public static int[] sortedSquares(int[] nums) &#123; int[] result = new int[nums.length]; // 负数平方后最左边最大，正数平方后最右边最大，双指针设置在左右进行遍历 int left = 0; int right = nums.length - 1; int i = right; while (left &lt;= right) &#123; if (nums[left]*nums[left] &lt; nums[right]*nums[right]) &#123; result[i] = nums[right] * nums[right]; right --; &#125; else &#123; result[i] = nums[left] * nums[left]; left ++; &#125; i --; &#125; return result;&#125; 5.1.3 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和≥target 的长度最小的 连续子数组[numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回 0 。 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 123456789101112131415161718192021// 【滑动窗口（双指针）】public int minSubArrayLen(int target, int[] nums) &#123; int left = 0; int right = 0; int sum = 0; int minLen = Integer.MAX_VALUE; // 右指针一直往右移动，移动到sum&gt;=target时，记录长度，并开始移动左指针，直到sum&lt;taget时，再移动右指针 while (right &lt; nums.length) &#123; sum += nums[right]; while (sum &gt;= target) &#123; minLen = Math.min(minLen, right - left + 1); sum -= nums[left]; left ++; &#125; right ++; &#125; if (minLen == Integer.MAX_VALUE) &#123; return 0; &#125; return minLen;&#125; 5.2 字符串5.2.1 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 12输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 1234567891011121314// 【双指针（中间靠拢）】public void reverseString(char[] s) &#123; int left = 0; int right = s.length - 1; char temp; // 首尾指针元素互换，向中间移动 while (left &lt; right) &#123; temp = s[left]; s[left] = s[right]; s[right] = temp; left ++; right --; &#125;&#125; 5.2.2 无重复字符的最长字串 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 123456789101112131415161718// 【滑动窗口（双指针）】public static int lengthOfLongestSubstring(String s) &#123; int left = 0; int right = 0; int maxLen = 0; Set&lt;Character&gt; chars = new HashSet&lt;&gt;(); // right指针右移，直至出现重复字符；移动left指针，并移除left指针对应的字符，直至不与right指针字符重复 while (right &lt; s.length()) &#123; while (chars.contains(s.charAt(right))) &#123; chars.remove(s.charAt(left)); left ++; &#125; chars.add(s.charAt(right)); right ++; maxLen = Math.max(maxLen, right-left); &#125; return maxLen;&#125; 5.2.3 字符串的排列 给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。 换句话说，s1 的排列之一是 s2 的 子串 。 123输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出：true解释：s2 包含 s1 的排列之一 (&quot;ba&quot;). 1234567891011121314151617181920212223242526272829// 【双指针】// s1的排列，可以用统计字符出现次数来判断，长度相同，字符出现相同，则时s2的排列字串之一public static boolean checkInclusion(String s1, String s2) &#123; int n = s1.length(); int m = s2.length(); if (n &gt; m) &#123; return false; &#125; // 统计s1 26字母字符次数 int[] cnt = new int[26]; for (int i = 0; i &lt; n; ++i) &#123; cnt[s1.charAt(i) - &#x27;a&#x27;] ++; &#125; int left = 0; for (int right = 0; right &lt; m; ++right) &#123; int x = s2.charAt(right) - &#x27;a&#x27;; cnt[x] --; // s2当前字符-1，若&lt;0，表示非s1中的字符，移动左指针把字符加回去 while (cnt[x] &lt; 0) &#123; cnt[s2.charAt(left) - &#x27;a&#x27;] ++; left ++; &#125; // 移动右指针中，未出现字符&lt;0，且长度right-left=n，则命中 if (right - left + 1 == n) &#123; return true; &#125; &#125; return false;&#125; 5.3 链表5.3.1 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 1234输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。(pos表示尾节点与哪个节点相连， 不作为参数进行传递 。仅仅是为了标识链表的实际情况) 123456789101112131415161718// 【快慢指针】// 慢指针移动1，快指针=2*慢指针，如果出现环形，总会出现快指针=慢指针// 若无循环，快指针=null时结束public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) &#123; return false; &#125; ListNode slow = head; ListNode fast = head.next; while (slow != fast) &#123; if (fast == null || fast.next == null) &#123; return false; &#125; slow = slow.next; fast = fast.next.next; &#125; return true;&#125; 5.3.2 删除链表的倒数第N个结点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 12345678910111213141516171819// 【双指针】// 创建两指针，first和second，first比second向后移动了n格，当first到达尾节点时，second就到达了n点// 因为时单链表删除，需要到n前一个进行删除，所以first和second相距n+1格public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0, head); ListNode first = head; ListNode second = dummy; // first向后移动n格，不考虑n&gt;指针长度出现null报错 for (int i = 0; i &lt; n; ++i) &#123; first = first.next; &#125; while (first != null) &#123; first = first.next; second = second.next; &#125; // 删除链表 second.next = second.next.next; return dummy.next;&#125; 5.3.3 链表的中间结点 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 1234567891011// 双指针// 快慢指针，快指针 = 慢指针 * 2，快指针到末尾时，慢指针到中间结点public ListNode middleNode(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125; 5.3.4 环形链表Ⅱ 给定一个链表的头节点 head，返回链表开始入环的第一个节点。 如果链表无环，则返回null。 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 1234567891011121314151617181920212223242526// 【双指针】// 快慢指针，快指针=2*慢指针// 根据公式推到，当快指针与慢指针相遇时，慢指针跑完环的距离 = 头节点到环的距离，头节点和慢指针相遇就是入环点// 推导地址：https://leetcode.cn/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/public ListNode detectCycle(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; // 快慢指针相遇，新指针指向头节点，与慢指针同速移动 if (fast == slow) &#123; ListNode ptr = head; while (ptr != slow) &#123; ptr = ptr.next; slow = slow.next; &#125; // 与慢指针相遇的点为入环点 return ptr; &#125; &#125; return null;&#125; 6 哈希表6.1 有效的字母异位词 给定两个字符串s和t ，编写一个函数来判断t是否是s的字母异位词。 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 1234567891011121314151617181920// 【哈希表】// 26位数组表示26字母，记录次数；遍历相减，若出现负数，就不是异位词public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) &#123; return false; &#125; // 记录s字符串中字母次数 int[] table = new int[26]; for (int i = 0; i &lt; s.length(); i++) &#123; table[s.charAt(i) - &#x27;a&#x27;]++; &#125; // 减去t中字符字母出现次数 for (int i = 0; i &lt; t.length(); i++) &#123; table[t.charAt(i) - &#x27;a&#x27;]--; if (table[t.charAt(i) - &#x27;a&#x27;] &lt; 0) &#123; return false; &#125; &#125; return true;&#125; 6.2 存在重复元素 给你一个整数数组nums。如果任一值在数组中出现至少两次 ，返回true ；如果数组中每个元素互不相同，返回false 。 12输入：nums = [1,2,3,1]输出：true 1234567891011// 【Set】// Set不能存储重复元素，若重复返回falsepublic boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int x : nums) &#123; if (!set.add(x)) &#123; return true; &#125; &#125; return false;&#125; 6.3 两个数组的交集 给定两个数组nums1和nums2，返回它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 123输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 123456789101112131415161718192021222324// 【Set】// Set去重然后比较public int[] intersection(int[] nums1, int[] nums2) &#123; // 通过Set去重其中一个数组 Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums1) &#123; set.add(num); &#125; // 跟另一个数组进行比较，重复加入到Set（去重） Set&lt;Integer&gt; resultSet = new HashSet&lt;&gt;(); for (int num : nums2) &#123; if (set.contains(num)) &#123; resultSet.add(num); &#125; &#125; // 转成数组 int[] arr = new int[resultSet.size()]; int i = 0; for (Integer num : resultSet) &#123; arr[i] = num; i ++; &#125; return arr;&#125; 6.4 四数相加Ⅱ 给你四个整数数组 nums1、nums2、nums3和nums4 ，数组长度都是n，请你计算有多少个元组(i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 123456输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 123456789101112131415161718192021// 【分组 + 哈希表】// 将ABCD分为两组，AB一组，CD一组，记录AB之间所有相加的可能数字，并记录次数。同理CD也是，最后比较相加等于0的次数public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; // 双for记录AB相加的数字，以及次数 Map&lt;Integer, Integer&gt; countAB = new HashMap&lt;&gt;(); for (int i : A) &#123; for (int j : B) &#123; countAB.put(i+j, countAB.getOrDefault(i+j, 0)+1); &#125; &#125; // 双for比较C+D中的数字的负数，是否A+B中出现；出现即相加等于0 int count = 0; for (int i : C) &#123; for (int j : D) &#123; if (countAB.containsKey(-(i+j))) &#123; count += countAB.get(-(i+j)); &#125; &#125; &#125; return count;&#125; 7 队列7.1 用队列实现栈 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 12345678910111213输入：[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False 12345678910111213141516171819202122232425262728293031public class MyStack &#123; Queue&lt;Integer&gt; queue1; Queue&lt;Integer&gt; queue2; public MyStack() &#123; queue1 = new LinkedList&lt;&gt;(); queue2 = new LinkedList&lt;&gt;(); &#125; // 将新元素入列到queue2，再从queue出列并入列到queue2，queue1 = queue2（最后数据都存在queue1中） public void push(int x) &#123; queue2.offer(x); while (!queue1.isEmpty()) &#123; queue2.offer(queue1.poll()); &#125; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; public int pop() &#123; return queue1.poll(); &#125; public int top() &#123; return queue1.peek(); &#125; public boolean empty() &#123; return queue1.isEmpty(); &#125;&#125; 7.2 前K个高频元素 给你一个整数数组nums和一个整数 k ，请你返回其中出现频率前k高的元素。你可以按任意顺序返回答案。 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 12345678910111213141516171819// 【优先队列】public int[] topKFrequent(int[] nums, int k) &#123; // map统计数字次数 Map&lt;Integer, Integer&gt; numCount = new HashMap&lt;Integer, Integer&gt;(); for (int num : nums) &#123; numCount.put(num, numCount.getOrDefault(num, 0) + 1); &#125; // 创建优先队列（根据比较器自动进行排序【根据次数进行降序】），存储长度为2的数组，[0]存储数字，[1]存储出现次数 PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((m, n) -&gt; n[1] - m[1]); for (Map.Entry&lt;Integer, Integer&gt; entry : numCount.entrySet()) &#123; queue.offer(new int[]&#123;entry.getKey(), entry.getValue()&#125;); &#125; // 取出前k个 int[] result = new int[k]; for (int i = 0; i &lt; k; ++i) &#123; result[i] = queue.poll()[0]; &#125; return result;&#125; 7.3 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 1234567891011121314151617181920212223242526272829// 【单调队列】// 营造出单调递减队列，队首永远时最大值，只要队首的下标在窗口范围内，就是当前窗口最大值；不在则出队，下一个值为窗口最大值public static int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); // 预处理前k条数据（后数&gt;前数，前数出队列，直至队列为empty或后数&lt;前数），保证队首的值最大【记录的是数组下标】 for (int i = 0; i &lt; k; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); &#125; int[] ans = new int[n - k + 1]; ans[0] = nums[deque.peekFirst()]; // 窗口向右移动（从k开始） for (int i = k; i &lt; n; ++i) &#123; // 上面逻辑同理 while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); // 当队首的最大不在窗口范围内，则进行移除（保证当前队首时有效最大值） while (deque.peekFirst() &lt;= i - k) &#123; deque.pollFirst(); &#125; ans[i - k + 1] = nums[deque.peekFirst()]; &#125; return ans;&#125; 8 栈8.1 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 12345678910111213输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false 123456789101112131415161718192021222324252627282930313233343536373839public class MyQueue &#123; private Stack&lt;Integer&gt; stack1; // 入队列用 private Stack&lt;Integer&gt; stack2; // 出队列用 int front; // 队首 public MyQueue() &#123; stack1 = new Stack&lt;&gt;(); stack2 = new Stack&lt;&gt;(); &#125; // 记录队首，并元素放入stack1 public void push(int x) &#123; if (stack1.isEmpty()) &#123; front = x; &#125; stack1.push(x); &#125; // 出队列时，将stack1入栈到stack2，此时stack2栈顶就是队首 public int pop() &#123; if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125; public int peek() &#123; if (stack2.isEmpty()) &#123; return front; &#125; return stack2.peek(); &#125; public boolean empty() &#123; return stack1.isEmpty() &amp;&amp; stack2.isEmpty(); &#125;&#125; 8.2 . 逆波兰表达式求值 根据逆波兰表示法（后缀表达式），求表达式的值。 有效的算符包括+、-、*、/。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 123输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 12345678910111213141516171819202122232425262728public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 存数字 // 遇到操作符，将入栈的数字出栈参与计算，将计算结果重新入栈 for (String token : tokens) &#123; if (&quot;+&quot;.equals(token) || &quot;-&quot;.equals(token) || &quot;*&quot;.equals(token) || &quot;/&quot;.equals(token)) &#123; stack.push(cul(stack.pop(), stack.pop(), token)); &#125; else &#123; stack.push(Integer.parseInt(token)); &#125; &#125; return stack.peek();&#125;// 计算public int cul(Integer num1, Integer num2, String operate) &#123; switch (operate) &#123; case &quot;+&quot;: return num2 + num1; case &quot;-&quot;: return num2 - num1; case &quot;*&quot;: return num2 * num1; case &quot;/&quot;: return num2 / num1; default: return -1; &#125;&#125; 8.3 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 123输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 1234567891011121314151617181920212223//【单调栈】public static int trap(int[] height) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int top; int left; int width; int result = 0; // 遍历数据，栈记录下标（方便计算面积），当当前元素高度&gt;栈顶元素高度，可能会形成包围 // 栈顶元素出栈，作为&#x27;底&#x27;，高度计算 = min(新栈顶元素高度，当前元素高度) - ‘底’ for (int i=0; i&lt;height.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) &#123; top = stack.pop(); if (stack.isEmpty()) &#123; break; &#125; left = stack.peek(); width = i - left - 1; result += width * (Math.min(height[i], height[left]) - height[top]); &#125; stack.push(i); &#125; return result;&#125; 9 二叉树9.1 二叉树遍历9.1.1 二叉树中序遍历 给定一个二叉树的根节点 root ，返回它的中序遍历 。 123456789101112131415161718// 【二叉树结构】public class TreeNode &#123; public int val; public TreeNode left; public TreeNode right; TreeNode() &#123;&#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125;&#125; 12345678910111213141516public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); inOrder(root, result); return result;&#125;public void inOrder(TreeNode node, List&lt;Integer&gt; result) &#123; if (node == null) &#123; return; &#125; // 遍历左子树 inOrder(node.left, result); result.add(node.val); // 遍历右子树 inOrder(node.right, result);&#125; 9.1.2 二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。（即逐层地，从左到右访问所有节点）。 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7] 123456789101112131415161718192021222324252627// 【广度优先搜索】public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; // 记录每层节点数，遍历对应的节点数，list封装为一层，重新计算新的一层的个数，依次往复 int levelSize = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); while (levelSize &gt; 0) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; levelSize --; &#125; result.add(level); &#125; return result;&#125; 9.1.3 二叉树的锯齿层序遍历 给你二叉树的根节点 root ，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[20,9],[15,7]] 1234567891011121314151617181920212223242526272829303132333435// 【广度优先搜索】// 跟层序遍历基本一直，稍作变形public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); boolean isLeftOrder = true; while (!queue.isEmpty()) &#123; // 记录每层节点数，遍历对应的节点数，list封装为一层，重新计算新的一层的个数，一次往复 int levelSize = queue.size(); Deque&lt;Integer&gt; level = new LinkedList&lt;&gt;(); while (levelSize &gt; 0) &#123; TreeNode node = queue.poll(); // 双向队列存储数据，奇数层从后往前存，偶数层从前往后存 if (isLeftOrder) &#123; level.offerLast(node.val); &#125; else &#123; level.offerFirst(node.val); &#125; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; levelSize --; &#125; result.add(new ArrayList&lt;&gt;(level)); isLeftOrder = !isLeftOrder; &#125; return result;&#125; 9.2 二叉树的属性9.2.1 二叉树的最大深度 给定一个二叉树，找出其最大深度。 1234567给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 123456789// 【递归】【深度优先】public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); return Math.max(leftHeight, rightHeight) + 1;&#125; 9.2.2 二叉树的直径 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 12345678给定二叉树 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 123456789101112131415161718// 【递归】【深度优先搜索】int maxlength = 0;public int diameterOfBinaryTree(TreeNode root) &#123; maxDepth(root); return maxlength;&#125;public int maxDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); // 记录最长路径（左子树深度 + 右子树深度） maxlength = Math.max(maxlength, leftHeight + rightHeight); return Math.max(leftHeight, rightHeight) + 1;&#125; 9.2.3 二叉树中的最大路径和 给你一个二叉树的根节点 root ，返回其最大路径和 。 123输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 12345678910111213141516171819// 【递归】【深度优先搜索】int maxSum;public int maxPathSum(TreeNode root) &#123; maxSum = Integer.MIN_VALUE; getMaxSum(root); return maxSum;&#125;public int getMaxSum(TreeNode node) &#123; if (node == null) &#123; return 0; &#125; // 最大总数 &gt; 0 才采用此子树的节点 int leftPathSum = Math.max(getMaxSum(node.left), 0); int rightPathSum = Math.max(getMaxSum(node.right), 0); maxSum = Math.max(maxSum, leftPathSum + rightPathSum + node.val); return node.val + Math.max(leftPathSum, rightPathSum);&#125; 9.3 二叉树的构造9.3.1 从中序与后序遍历序列构造二叉树 给定两个整数数组inorder和postorder ，其中inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 12输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 123456789101112131415161718192021222324252627282930// 【递归】int[] postorder;int postIdx;Map&lt;Integer, Integer&gt; inorderMap;public TreeNode buildTree(int[] inorder, int[] postorder) &#123; this.postorder = postorder; postIdx = postorder.length - 1; // 记录inorderMap（key是元素，value是下标） inorderMap = new HashMap&lt;&gt;(inorder.length); for (int i=0; i&lt;inorder.length; i++) &#123; inorderMap.put(inorder[i], i); &#125; // 构建树 return buildTreeByInIdx(0, inorder.length-1);&#125;// 通过inorder下标边界构建树public TreeNode buildTreeByInIdx(int in_left, int in_right) &#123; if (in_left &gt; in_right) &#123; return null; &#125; TreeNode root = new TreeNode(postorder[postIdx]); int inIdx = inorderMap.get(postorder[postIdx]); // 后序遍历，从后往前访问; 变成先处理右子树，再处理左子树 postIdx --; root.right = buildTreeByInIdx(inIdx+1, in_right); root.left = buildTreeByInIdx(in_left, inIdx-1); return root;&#125; 10 贪心算法10.1 基础常见问题10.1.1 分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸s[j]。如果s[j]&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 123456输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 12345678910111213141516// 【贪心算法】public int findContentChildren(int[] g, int[] s) &#123; Arrays.sort(g); Arrays.sort(s); // 因为每个孩子只有一个饼干，将大于胃口值的饼干分发下去 int count = 0; for (int i=0, j=0; i&lt;g.length &amp;&amp; j&lt;s.length; i++, j++) &#123; while (j &lt; s.length &amp;&amp; g[i] &gt; s[j]) &#123; j++; &#125; if (j &lt; s.length) &#123; count ++; &#125; &#125; return count;&#125; 10.2 区间问题10.2.1 跳跃游戏 给定一个非负整数数组 nums ，你最初位于数组的第一个下标。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 123输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 123456789101112// 【贪心算法】// 遍历数组，并记录当前位置最大能跳距离，如果最大能跳距离 &lt; 当前index，则return false;public boolean canJump(int[] nums) &#123; int maxJump = 0; for(int i=0; i&lt;nums.length; i++) &#123; if (maxJump &lt; i) &#123; return false; &#125; maxJump = Math.max(maxJump, i+nums[i]); &#125; return true;&#125; 10.2.2 跳跃游戏Ⅱ 给你一个非负整数数组nums，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 1234输入: nums = [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 12345678910111213141516// 【贪心算法】（局部最优）// 在一跳的过程中，记录每个点的最远距离，选出最远距离的该点作为下一跳点，step+1// 每遍历一个跳点，更新一次最远距离。当遍历到跳跃的边界时，将最远距离作为新的边界，相当于在其中选择了跳得最远的点，作为下一个跳点public int jump(int[] nums) &#123; int maxJump = 0; int end = 0; int step = 0; for (int i=0; i&lt;nums.length-1; i++) &#123; maxJump = Math.max(maxJump, nums[i] + i); if (i == end) &#123; end = maxJump; step ++; &#125; &#125; return step;&#125; 10.2.3 划分字母区间 字符串S由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。 123456输入：S = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释：划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。 123456789101112131415161718192021// 【贪心算法】public List&lt;Integer&gt; partitionLabels(String s) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // 26字母，记录每个字母组后出现位置 int[] lastPos = new int[26]; for (int i=0; i&lt;s.length(); i++) &#123; lastPos[s.charAt(i)-&#x27;a&#x27;] = i; &#125; // 遍历字符串，比较遍历的每个字符串最后出现的位置end，取其中最大值 // 若i == end，表示里面的所有字母都包含在此字段，切分字段 int start = 0; int end = 0; for (int i=0; i&lt;s.length(); i++) &#123; end = Math.max(end, lastPos[s.charAt(i)-&#x27;a&#x27;]); if (i == end) &#123; result.add(end-start+1); start = end + 1; &#125; &#125; return result;&#125; 10.3 两个维度权衡问题10.3.1 根据身高重建队列 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki]表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj]是队列中第 j 个人的属性（queue[0]是排在队列前面的人）。 12345678910输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 12345678910public int[][] reconstructQueue(int[][] people) &#123; // 先按身高降序，同身高按个数升序 Arrays.sort(people, (o1, o2) -&gt; o2[0]-o1[0]==0 ? o1[1]-o2[1] : o2[0]-o1[0]); // 按照个数进行插空 List&lt;int[]&gt; res = new LinkedList&lt;&gt;(); for (int[] person : people) &#123; res.add(person[1], person); &#125; return res.toArray(people);&#125; 10.3.2 分发糖果 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。 123输入：ratings = [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 12345678910111213141516171819202122232425262728293031// 【规律得出】// 自增时，糖果数 = 前糖果数 + 1 ; // 相同时，糖果数 = 1 ; // 递减时，糖果数 = 1，且每递减一次，前面递减序列的糖果都+1public int candy(int[] ratings) &#123; int incrSize = 0; // 递增长度 int decrSize = 0; // 递减长度 int candyCount = 1; // 当前糖果数 int result = 1; // 总糖果数 for (int i=1; i&lt;ratings.length; i++) &#123; if (ratings[i] &gt;= ratings[i-1]) &#123; decrSize = 0; if (ratings[i] == ratings[i-1]) &#123; candyCount = 1; &#125; else &#123; candyCount ++; &#125; incrSize = candyCount; result += candyCount; &#125; else &#123; decrSize ++; // 递增大小 == 递减大小时，将递增最后一个纳入递减中 if (decrSize == incrSize) &#123; decrSize ++; &#125; result += decrSize; candyCount = 1; &#125; &#125; return result;&#125; 11 动态规划11.1 基础11.1.1 爬楼梯 假设你正在爬楼梯。需要n阶你才能到达楼顶。 每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？ 123456输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 12345678910111213141516171819// 【动态规划】// 得出规律 f(x) = f(x-1) + f(x-2)，最终可能走一步，也可能走两步// 下一步的总方法个数 = 前两个总方法个数之和public int climbStairs(int n) &#123; if (n &lt; 3) &#123; return n; &#125; // 初始化 a = f(1)，b = f(2) int a = 1; int b = 2; int sum = 0; for (int i=3; i&lt;=n; i++) &#123; sum = a + b; // a，b数值更新，a相当于f(x-2)，b相当于f(x-1) a = b; b = sum; &#125; return sum;&#125; 11.1.2 杨辉三角 给定一个非负整数 numRows，生成「杨辉三角」的前numRows行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 12输入: numRows = 5输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 1234567891011121314151617181920212223// 【动态规划】public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (numRows == 0) &#123; return result; &#125; // 初始化（第一行只有1个1） List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); result.add(row); for (int i=1; i&lt;numRows; i++) &#123; List&lt;Integer&gt; preRow = result.get(i-1); row = new ArrayList&lt;&gt;(); for (int j=0; j&lt;=i; j++) &#123; // 计算上一行左上方、右上方个数，超出列数设置为0 int left = j==0 ? 0 : preRow.get(j-1); int right = j==i ? 0 : preRow.get(j); row.add(left+right); &#125; result.add(row); &#125; return result;&#125; 11.1.3 不同路径 一个机器人位于一个m x n网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 12输入：m = 3, n = 7输出：28 123456789101112131415161718// 【动态规划】public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; // 初始化（因为只会向右和下移动，所以边界只有1种可抵达方法） for (int i=0; i&lt;m; i++) &#123; dp[i][0] = 1; &#125; for (int i=0; i&lt;n; i++) &#123; dp[0][i] = 1; &#125; // 根据递推公式，填充dp数组 （dp[i][j] = dp[i-1][j] + dp[i][j-1]）（跟爬台阶类似） for (int i=1; i&lt;m; i++) &#123; for (int j=1; j&lt;n; j++) &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125; 11.2 线性问题11.2.1 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 123456789101112131415161718// 【动态规划】public int rob(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (nums.length == 1) &#123; return nums[0]; &#125; // dp数组初始化（下标：能抢劫的户数-1；数值：能抢劫户数下的最大金额） int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); // 根据公式填充dp数组，dp[i] = max(dp[i-2]+nums[i], dp[i-1]) for (int i=2; i&lt;nums.length; i++) &#123; dp[i] = Math.max(dp[i-2]+nums[i], dp[i-1]); &#125; return dp[nums.length-1];&#125; 11.2.2 打家劫舍Ⅲ 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额。 123输入: root = [3,2,3,null,3,null,1]输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 123456789101112131415161718192021// 【动态规划】public int rob(TreeNode root) &#123; int[] result = robArr(root); return Math.max(result[0], result[1]);&#125;// 下标(0:不偷能获取的最大金额，1：偷能获取的最大金额)// 递推公式：0:不偷 = max(左偷, 左不偷) + max(右偷, 右不偷)； 1：偷 = node.val + 左不偷 + 右不偷private int[] robArr(TreeNode root) &#123; if (root == null) &#123; return new int[2]; &#125; // 递归获取子树偷ro不偷数组 int[] leftArr = robArr(root.left); int[] rightArr = robArr(root.right); // 计算当前节点偷or不偷的最大金额 int[] result = new int[2]; result[0] = Math.max(leftArr[0], leftArr[1]) + Math.max(rightArr[0], rightArr[1]); result[1] = root.val + leftArr[0] + rightArr[0]; return result;&#125; 11.2.3 买卖股票最佳时机 给定一个数组 prices ，它的第i个元素prices[i]表示一支给定股票第i天的价格。 你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 1234567891011121314//【动态规划】public int maxProfit(int[] prices) &#123; int minPrice = Integer.MAX_VALUE; int maxProfit = 0; // 状态转移；循环比较最小购入金额，以及最大利润 for (int i=0; i&lt;prices.length; i++) &#123; if (prices[i] &lt; minPrice) &#123; minPrice = prices[i]; &#125; else &#123; maxProfit = Math.max(prices[i]-minPrice, maxProfit); &#125; &#125; return maxProfit;&#125; 11.2.4 买卖股票的最佳时机Ⅱ 给你一个整数数组prices，其中prices[i]表示某支股票第i天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。 返回你能获得的最大利润。 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 1234567891011121314151617// 【动态规划】public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; // 初始化（第一天数据填入），have表示手中有股表，nothave表示手中无股票，值表示利润 int have = -prices[0]; int notHave = 0; // 依次与昨天比较，进行状态转移 // 无股票：（1）昨天也无股票，（2）昨天有股票，但卖出了，加上昨天股票价钱 // 有股票：（1）昨天也有股票，（2）昨天无股票，但花钱购买了，减上昨天股票价钱 for (int i=1; i&lt;prices.length; i++) &#123; have = Math.max(have, notHave - prices[i]); notHave = Math.max(notHave, have + prices[i]); &#125; return notHave;&#125; 11.2.5 最大子数组和 给你一个整数数组nums，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 12345678910111213141516// 【动态规划】public int maxSubArray(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; // 状态推移 // pre = max(pre+nums[i], nums[i]) // result = max(pre, result) int pre = nums[0]; int result = nums[0]; for (int i=1; i&lt;nums.length; i++) &#123; pre = Math.max(nums[i]+pre, nums[i]); result = Math.max(result, pre); &#125; return result;&#125; 11.2.6 最长递增子序列 给你一个整数数组nums，找到其中最长严格递增子序列的长度。 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 123456789101112131415161718192021/ 【动态规划】public int lengthOfLIS(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; // dp数组：index=当前数字下标；value=最长递增序列个数（即：当前数字最长递增序列个数） // 默认最长递增序列为1（即自身） int[] dp = new int[nums.length]; int result = 1; for (int i=0; i&lt;nums.length; i++) &#123; dp[i] = 1; // i 跟 i之前的数字比较大小；nums[i] &gt; nums[j]，dp[i] = max(dp[i], dp[j]+1) for (int j=0; j&lt;i; j++) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = Math.max(dp[i], dp[j]+1); &#125; &#125; result = Math.max(result, dp[i]); &#125; return result;&#125; 11.2.7 编辑距离 给你两个单词word1和word2，请返回将word1转换成word2所使用的最少操作数。 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;) 123456789101112131415161718192021222324252627282930313233343536// 【动态规划】public int minDistance(String word1, String word2) &#123; if (word1 == null || word2 == null) &#123; return 0; &#125; int m = word1.length(); int n = word2.length(); // 出现空串，操作次数 = 非空串长度 if (m * n == 0) &#123; return m + n; &#125; // dp数组：i表示word1前i个字符，j表示word2前j个字符，dp[i][j] = word1前i个字符和word2前j个字符，互相转换的最小次数 // 额外多出1个空间，表示空字符串，位于0号位 int[][] dp = new int[m+1][n+1]; // 初始化边界 for (int i=0; i&lt;m+1; i++) &#123; dp[i][0] = i; &#125; for (int j=0; j&lt;n+1; j++) &#123; dp[0][j] = j; &#125; // 递推公式：dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1], dp[i-1][j-1]+1) for (int i=1; i&lt;m+1; i++) &#123; for (int j=1; j&lt;n+1; j++) &#123; int left = dp[i-1][j] + 1; int down = dp[i][j-1] + 1; int left_down = dp[i-1][j-1]; // left_down表示替换，字符一样无需替换 if (word1.charAt(i-1) != word2.charAt(j-1)) &#123; left_down ++; &#125; dp[i][j] = Math.min(left, Math.min(down, left_down)); &#125; &#125; return dp[m][n];&#125; 11.3 背包问题11.3.1 单词拆分 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 1234567891011121314151617181920// 【动态规划】public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; // 拆分字段去重 Set&lt;String&gt; wordDictSet = new HashSet&lt;&gt;(wordDict); // dp[j]==true（表示上个单词拆分的边界） // 若此时string.sub(j, i) == wordDict中的词，j边界到i之间又有一个拆分的词，dp[i] = true // 当dp[n] == true，表示整个字符串都能被单词拆分 boolean[] dp = new boolean[s.length()+1]; // 初始化（0号位表示空串，用来设置边界） dp[0] = true; for (int i=1; i&lt;s.length()+1; i++) &#123; for (int j=0; j&lt;i; j++) &#123; if (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()];&#125; 11.2.2 零钱兑换 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 1234567891011121314151617// 【动态规划】public int coinChange(int[] coins, int amount) &#123; // dp数组，i表示金额，dp[i]表示达到i所需最小硬币数 int[] dp = new int[amount + 1]; // 初始化：填充amount+1，用于判断数组末尾是否有硬币能组合，硬币组合不了值一定等于amount+1 Arrays.fill(dp, amount+1); dp[0] = 0; // 状态转移公式：dp[i] = Math.min(dp[i], dp[i-coins[j]+1]) for(int i=1; i&lt;amount+1; i++) &#123; for (int coin : coins) &#123; if (coin &lt;= i) &#123; dp[i] = Math.min(dp[i], dp[i - coin] + 1); &#125; &#125; &#125; return dp[amount] &gt; amount ? -1 : dp[amount];&#125; 11.2.3 完全平方数 给你一个整数 n ，返回0和为n的完全平方数的最少数量 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 123456789101112131415// 动态规划public int numSquares(int n) &#123; // dp数组：i为数字，dp[i]为组成该数字所需的最小平方数和 int[] dp = new int[n+1]; for (int i = 1; i &lt;= n; i++) &#123; // 默认为i，即该数全由1组成 int min = i; // 从1到i找出最小的平方数和 for (int j = 1; j * j &lt;= i; j++) &#123; min = Math.min(min, dp[i-j*j]+1); &#125; dp[i] = min; &#125; return dp[n];&#125; 11.3 区间问题11.3.1 最长回文子序列 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 123456789101112131415161718192021// 动态规划public int longestPalindromeSubseq(String s) &#123; int n = s.length(); // i, j为字符i到j组成的字符串，dp[i][j]为ij字符串的最长回文序列 int[][] dp = new int[n][n]; for (int i = n - 1; i &gt;= 0; i--) &#123; // 默认1，即一个字符 dp[i][i] = 1; // i从后往前推移，j从前往后推移，保证数据存在 // 假如i字符==j字符，往字符内部推移，即dp[i+1][j-1]+2 // 假如i字符!=j字符，取i or j 往内推移的最大值，max(dp[i+1][j], dp[i][j-1]) for (int j = i + 1; j &lt; n; j++) &#123; if (s.charAt(i) == s.charAt(j)) &#123; dp[i][j] = dp[i+1][j-1] + 2; &#125; else &#123; dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[0][n - 1];&#125;","categories":[{"name":"面试","slug":"面试","permalink":"https://letere-gzj.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"【ElasticSearch】ES环境搭建","slug":"【ElasticSearch】ES环境搭建","date":"2022-04-25T02:27:09.000Z","updated":"2022-04-25T03:23:04.004Z","comments":true,"path":"2022/04/25/【ElasticSearch】ES环境搭建/","link":"","permalink":"https://letere-gzj.github.io/2022/04/25/%E3%80%90ElasticSearch%E3%80%91ES%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"ES环境搭建","text":"ES环境搭建 1 Windows搭建ES集群 集群演示为3个节点，集群名为es-cluster，节点名分别为node-9201，node-9202，node-9203，node-9201为主节点，其他为数据节点 1.1 步骤 将ES压缩包解压，复制为3份，对应3个节点 修改./config/elasticsearch.yml文件 （1）node-9201123456789101112131415161718192021# 集群名cluster.name: es-cluster# 节点名node.name: node-9201# 节点角色node.roles: [master, data]# ip地址network.host: localhost# 端口号http.port: 9201# 内部通信端口号transport.port: 9301# 跨域设置http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; （2）node-9202 大部分与node-9201一致，所以只展示不同的地方12345678node.name: node-9202node.roles: [data]http.port: 9202transport.port: 9302# 集群发现地址discovery.seed_hosts: [&quot;localhost:9201&quot;]cluster.initial_master_nodes: [&quot;node-9201&quot;] （3）node-9203 与node-9202同理 12345678node.name: node-9203node.roles: [data]http.port: 9203transport.port: 9303# 集群发现地址discovery.seed_hosts: [&quot;localhost:9201&quot;, &quot;localhost:9202&quot;]cluster.initial_master_nodes: [&quot;node-9201&quot;] 依次启动9201，9202，9203即可 查询集群状态：get http://ip:port/_cluster/health","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://letere-gzj.github.io/categories/ElasticSearch/"}],"tags":[]},{"title":"【ElasticSearch】Java整合ES","slug":"【ElasticSearch】Java整合ES","date":"2022-04-21T05:46:47.000Z","updated":"2022-04-25T02:03:18.819Z","comments":true,"path":"2022/04/21/【ElasticSearch】Java整合ES/","link":"","permalink":"https://letere-gzj.github.io/2022/04/21/%E3%80%90ElasticSearch%E3%80%91Java%E6%95%B4%E5%90%88ES/","excerpt":"Java整合ES","text":"Java整合ES 1 环境准备1.1 依赖 演示的ES版本为8.x版本，8.x版本抛弃了rest-high-level-client的依赖的使用，改用新的依赖，若ES版本为8.x之前的，查看rest-high-level-client对应的使用 123456789101112&lt;!-- es-java整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;co.elastic.clients&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-java&lt;/artifactId&gt; &lt;version&gt;8.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jackson-json处理 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.2.2&lt;/version&gt;&lt;/dependency&gt; 1.2 连接ES 因为连接ES比较常用，直接封装为工具类 1234567891011public class ESUtil &#123; // 获取ES客户端 public static ElasticsearchClient getEsClient() &#123; RestClient restClient = RestClient.builder( // 地址, 端口, 通信协议（http/https） new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;) ).build(); RestClientTransport restClientTransport = new RestClientTransport(restClient, new JacksonJsonpMapper()); return new ElasticsearchClient(restClientTransport); &#125;&#125; 2 索引使用2.1 创建索引1234567// 创建索引@Testpublic void createIndex() throws Exception&#123; ElasticsearchClient esClient = ESUtil.getEsClient(); CreateIndexResponse createIndexResponse = esClient.indices().create(c -&gt; c.index(&quot;user&quot;)); System.out.println(createIndexResponse);&#125; 2.2 查询索引123456789// 查询索引@Testpublic void getIndex() throws Exception&#123; ElasticsearchClient esClient = ESUtil.getEsClient(); GetIndexResponse getIndexResponse = esClient.indices().get(i -&gt; i.index(&quot;user&quot;)); // 获取响应数据 IndexState indexState = getIndexResponse.result().get(&quot;user&quot;); System.out.println(indexState);&#125; 2.3 删除索引1234567// 删除索引@Testpublic void deleteIndex() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); DeleteIndexResponse deleteIndexResponse = esClient.indices().delete(i -&gt; i.index(&quot;user&quot;)); System.out.println(deleteIndexResponse);&#125; 3 文档使用 创建一个User类，当作文档存储的数据 12345678910// 需要引入lombok依赖@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private Integer id; private String name; private Integer age; private String sex;&#125; 3.1 创建文档12345678// 创建文档@Testpublic void createDocument() throws Exception&#123; ElasticsearchClient esClient = ESUtil.getEsClient(); User user = new User(1001, &quot;letere&quot;, 18, &quot;男&quot;); CreateResponse createResponse = esClient.create(i -&gt; i.index(&quot;user&quot;).id(&quot;1002&quot;).document(user)); System.out.println(createResponse);&#125; 3.2 更新文档12345678// 更新文档@Testpublic void updateDocument() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); User user = new User(1001, &quot;letere&quot;, 18, &quot;女&quot;); UpdateResponse&lt;User&gt; updateResponse = esClient.update(i -&gt; i.index(&quot;user&quot;).id(&quot;1001&quot;).doc(user), User.class); System.out.println(updateResponse);&#125; 3.3 查询文档1234567// 查询文档@Testpublic void getDocument() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); GetResponse&lt;User&gt; getResponse = esClient.get(i -&gt; i.index(&quot;user&quot;).id(&quot;1001&quot;), User.class); System.out.println(getResponse.source());&#125; 3.4 删除文档1234567// 删除文档@Testpublic void deleteDocument() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); DeleteResponse deleteResponse = esClient.delete(i -&gt; i.index(&quot;user&quot;).id(&quot;1001&quot;)); System.out.println(deleteResponse);&#125; 4 文档批量处理4.1 批量创建123456789101112131415161718192021// 批量创建文档@Testpublic void batchCreateDocument() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(new User(1001, &quot;letere&quot;, 18, &quot;男&quot;)); users.add(new User(1002, &quot;glucat&quot;, 22, &quot;男&quot;)); users.add(new User(1003, &quot;咕料&quot;, 30, &quot;男&quot;)); users.add(new User(1004, &quot;C酱&quot;, 28, &quot;女&quot;)); // 转成List&lt;BulkOperation&gt; List&lt;BulkOperation&gt; bulkOperations = new ArrayList&lt;&gt;(); for (User user : users) &#123; bulkOperations.add(BulkOperation.of( b -&gt; b.create( d -&gt; d.id(user.getId().toString()).document(user) ) )); &#125; BulkResponse response = esClient.bulk(i -&gt; i.index(&quot;user&quot;).operations(bulkOperations)); System.out.println(response.items());&#125; 4.2 批量删除1234567891011121314151617// 批量删除文档@Testpublic void batchDeleteDocument() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); String[] ids = new String[]&#123;&quot;1001&quot;, &quot;1002&quot;&#125;; // 转成List&lt;BulkOperation&gt; List&lt;BulkOperation&gt; bulkOperations = new ArrayList&lt;&gt;(); for (String id : ids) &#123; bulkOperations.add(BulkOperation.of( b -&gt; b.delete( d -&gt; d.id(id) ) )); &#125; BulkResponse response = esClient.bulk(i -&gt; i.index(&quot;user&quot;).operations(bulkOperations)); System.out.println(response.items());&#125; 5 文档进阶查询5.1 全量查询1234567891011121314// 全量查询@Testpublic void queryAll() throws Exception&#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .matchAll(m -&gt; m)), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.2 条件查询123456789101112131415161718// 条件查询@Testpublic void wrapperQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q // term为完全匹配查询, match为分词匹配 // 查询的字段有中文时，field里填写&#x27;字段名.keyword&#x27;，例age.keyword .term(t -&gt; t .field(&quot;age&quot;) .value(30))), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.3 组合条件查询12345678910111213141516171819202122232425// 组合条件查询@Testpublic void boolQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .bool(b -&gt; b // must类似sql的and，should类似sql的or .must(m -&gt; m .term(t -&gt; t .field(&quot;sex.keyword&quot;) .value(&quot;男&quot;)) ) .must(m -&gt; m .match(ma -&gt; ma .field(&quot;name&quot;) .query(&quot;letere&quot;)) ))), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.4 范围查询1234567891011121314151617// 范围查询@Testpublic void rangeQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .range(r -&gt; r .field(&quot;age&quot;) .gt(JsonData.of(20)) .lt(JsonData.of(30)))), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.5 模糊查询1234567891011121314151617// 模糊查询@Testpublic void fuzzyQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .fuzzy(f -&gt; f .field(&quot;name&quot;) .value(&quot;lete&quot;) .fuzziness(&quot;2&quot;))), // 偏差字符长度，偏差长度&lt;=2的，可以查询出来 User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.6 分页查询12345678910111213141516// 分页查询@Testpublic void pageQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .matchAll(m -&gt; m)) .from(0) .size(2), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.7 排序查询123456789101112131415161718// 排序查询@Testpublic void sortQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .matchAll(m -&gt; m)) .sort(so -&gt; so .field(f -&gt; f .field(&quot;age&quot;) .order(SortOrder.Desc))), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.8 指定字段查询123456789101112131415161718// 指定字段查询@Testpublic void fieldQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .matchAll(m -&gt; m)) .source(so -&gt; so .filter(f -&gt; f .includes(&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;) .excludes(&quot;&quot;))), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.source()); &#125;&#125; 5.9 高亮查询1234567891011121314151617181920// 高亮查询@Testpublic void highLightQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .query(q -&gt; q .term(t -&gt; t .field(&quot;name.keyword&quot;) .value(&quot;咕料&quot;))) .highlight(h -&gt; h .fields(&quot;name.keyword&quot;, f -&gt; f .preTags(&quot;&lt;font color=&#x27;red&#x27;&gt;&quot;) .postTags(&quot;&lt;/font&gt;&quot;))), User.class ); for (Hit&lt;User&gt; userHit : searchResponse.hits().hits()) &#123; System.out.println(userHit.highlight()); &#125;&#125; 5.10 聚合查询1234567891011121314// 聚合查询@Testpublic void groupQuery() throws Exception &#123; ElasticsearchClient esClient = ESUtil.getEsClient(); SearchResponse&lt;User&gt; searchResponse = esClient.search( s -&gt; s.index(&quot;user&quot;) .aggregations(&quot;sexCount&quot;, a -&gt; a.terms(t -&gt; t.field(&quot;sex.keyword&quot;))), User.class ); // 根据查询的字段数据类型选择对应的terms，string选择sterms，数字选择lterms for (StringTermsBucket stringTermsBucket : searchResponse.aggregations().get(&quot;sexCount&quot;).sterms().buckets().array()) &#123; System.out.println(stringTermsBucket.key() + &quot;:&quot; + stringTermsBucket.docCount()); &#125;&#125;","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://letere-gzj.github.io/categories/ElasticSearch/"}],"tags":[]},{"title":"【ElasticSearch】ES使用","slug":"【ElasticSearch】ES使用","date":"2022-04-19T00:55:36.000Z","updated":"2022-04-19T01:02:17.662Z","comments":true,"path":"2022/04/19/【ElasticSearch】ES使用/","link":"","permalink":"https://letere-gzj.github.io/2022/04/19/%E3%80%90ElasticSearch%E3%80%91ES%E4%BD%BF%E7%94%A8/","excerpt":"ES使用","text":"ES使用 1 ES结构和索引1.1 ES结构 方便理解，可以将ES类比为数据库进行理解 Types的概念逐渐弱化，于6.x版本，一个index只允许一个type。于7.x版本之后，已将type概念删除 1.2 倒排索引 正排索引：就是我们数据库中的数据结构，通过id去关联对应的数据 倒排索引：则是通过数据的关键词，去关联对应的id 2 索引（index）使用ES演示示例，都是通过发送请求来实现，可以用postman来进行 12345678910111213141516171819# 创建索引url：http://localhost:9200/(index名)method: PUT---# 指定查询索引url: http://localhost:9200/(index名)method: GET# 查询所有索引url: http://localhost:9200/_cat/indices?vmethod: GET---# 删除指定索引url: http://localhost:9200/(index名)method: DELETE 3 文档（document）使用1234567891011121314151617181920212223242526272829303132333435363738# 创建文档url: http://localhost:9200/(index名)/_docmethod: postbody: &#123;json数据&#125;# 创建指定id文档（两种url都可以）url1: http://localhost:9200/(index名)/_doc/(id值)url2: http://localhost:9200/(index名)/_create/(id值)method: PUT/POSTbody: &#123;json数据&#125;---# 查询指定id文档url: http://localhost:9200/(index名)/_doc/(文档id)method: GET# 查询全部文档url: http://localhost:9200/(index名)/_searchmethod: GET---# 全部更新文档url: http://localhost:9200/(index名)/_doc/(文档id)method: PUTbody: &#123;json数据&#125;# 部分更新文档url: http://localhost:9200/(index名)/_update/(文档id)method: POSTbody: &#123;&quot;doc&quot;: &#123;json数据&#125;&#125;---# 删除文档url: http://localhost:9200/(index名)/_doc/(文档id)method: DELETE 4 文档进阶查询123url: http://localhost:9200/(index名)/_searchmethod: GETbody: &#123;json数据&#125; 1234567891011121314151617181920212223242526// 示例json数据&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 0, &quot;size&quot;: 2, &quot;_source&quot;: [&quot;name&quot;], &quot;sort&quot;: &#123; &quot;age&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123; &quot;name&quot;: &#123;&#125; &#125; &#125;, &quot;aggs&quot;: &#123; &quot;count&quot;： &#123; &quot;term&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125; 文档进阶查询主要在请求body上进行处理 4.1 where条件查询12345&#123; &quot;query&quot;: &#123; xxxx条件 &#125;&#125; （1）全文检索匹配条件 当查询条件为字符串时，会进行分词查询，也就是将字符串值拆分，一个个去匹配 非字符串时，就是普通的eq匹配 1234567891011&quot;match&quot;: &#123; &quot;字段名&quot;: &quot;值&quot;&#125;// 全部匹配（无需参数）&quot;match_all&quot;: &#123;&#125;// 精确匹配（不进行分词）&quot;match_phrase&quot;: &#123; &quot;字段名&quot;: &quot;值&quot;&#125; （2）and查询 类似sql的where 条件1 and 条件2 123456&quot;bool&quot;: &#123; &quot;must&quot;: [ &quot;match&quot;: &#123;&#125;, &quot;match&quot;: &#123;&#125; ]&#125; （3）or查询 类似sql的where 条件1 or 条件2 123456&quot;bool&quot;: &#123; &quot;should&quot;: &#123; &quot;match&quot;: &#123;&#125;, &quot;match&quot;: &#123;&#125; &#125;&#125; （4）过滤范围 类似sql的不等于，但不作为匹配条件，用于数据最后过滤 gt=大于，lt=小于 不支持ge，le，eq，要等于就在查询条件match拼接 123456789&quot;bool&quot;: &#123; &quot;filter&quot;: &#123; &quot;range&quot;: &#123; &quot;字段名&quot;: &#123; &quot;gt&quot;: &quot;值&quot; &#125; &#125; &#125;&#125; 4.2 分页查询 使用起来类似sql的limit 0, 112&quot;from&quot;: 起始位置（从0开始）&quot;size&quot;: 数据大小 4.3 查询指定字段 类似sql的select xx, xx1&quot;_source&quot;: [&quot;字段名1&quot;, &quot;字段名2&quot;] 4.4 排序 类似sql的order by xxx asc/desc12345&quot;sort&quot;: &#123; &quot;字段名&quot;: &#123; &quot;order&quot;: &quot;asc/desc&quot; &#125;&#125; 4.5 聚合函数 类似sql的select count(xx) from xxx group by xx 聚合函数：term类似sql的count统计个数，sum求和，avg求平均值1234567&quot;aggs&quot;: &#123; &quot;xxxx&quot;： &#123; // 变量名，可以随意起 &quot;聚合函数&quot;: &#123; &quot;field&quot;: &quot;字段名&quot; &#125; &#125;&#125; 4.6 查询结果高亮12345&quot;highlight&quot;: &#123; &quot;fields&quot;: &#123; &quot;字段名&quot;: &#123;&#125; &#125;&#125; 5 映射 映射类似于mysql中的表结构，来规定表中的数据结构 type：为字段类型，text表示支持分词查询，password不知分词查询 index：是否允许索引，即是否可以充当查询条件123456&quot;properties&quot;: &#123; &quot;字段名&quot;: &#123; &quot;type&quot;: &quot;text/password&quot;, &quot;index&quot;: true/false &#125;&#125; 12345678910# 创建映射url: http://localhost:9200/(index名)_mappingmethod: PUTbody: &#123;properties数据&#125;---# 查询映射url: http://localhost:9200/(index名)_mappingmethod: GET","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://letere-gzj.github.io/categories/ElasticSearch/"}],"tags":[]},{"title":"【ElasticSearch】ES入门","slug":"【ElasticSearch】ES入门","date":"2022-04-14T03:09:06.000Z","updated":"2022-04-14T03:11:03.628Z","comments":true,"path":"2022/04/14/【ElasticSearch】ES入门/","link":"","permalink":"https://letere-gzj.github.io/2022/04/14/%E3%80%90ElasticSearch%E3%80%91ES%E5%85%A5%E9%97%A8/","excerpt":"ES入门","text":"ES入门 1 ES简介 ES：是一个分布式、restful风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例 ELK Stack：使用Elasticsearch、Logstash、Kibana和Beats的框架组合，能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索，分析和可视化。 ES特点： 能够处理分析查询 具有良好的可伸缩行，适用于分布式 开源日志管理 监控和指标 2 ES下载和安装 下载地址：https://www.elastic.co/cn/downloads/elasticsearch 安装：（演示为windows版本）windows直接解压缩包即可 配置环境变量：环境变量名为ES_JAVA_HOME，位置为es自带的jdk，es目录/jdk 关闭ssl安全认证：es目录/config/elasticsearch.yml，将xpack.security.enabled改为false 启动和访问：双击es目录/bin/elasticsearch.bat启动，启动后访问http://localhost:9200","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://letere-gzj.github.io/categories/ElasticSearch/"}],"tags":[]},{"title":"【JavaWeb】i18n国际化","slug":"【JavaWeb】i18n国际化","date":"2022-04-12T02:04:50.000Z","updated":"2022-04-12T03:43:47.971Z","comments":true,"path":"2022/04/12/【JavaWeb】i18n国际化/","link":"","permalink":"https://letere-gzj.github.io/2022/04/12/%E3%80%90JavaWeb%E3%80%91i18n%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"i18n国际化","text":"i18n国际化 1 i18n入门 i8n：internationalization，国际化，由于名字过长，以i开头，以n结尾，中间18个字母，简称为i18n Locale 记录时区语言，例如zh_CN - 中文_中国，en_US - 英文_美国 i18n配置文件 命名规则：xxxx_语言_地区.properties 123// i18n_en_US.propertiesusername=usernamepassword=password 123// i18n_zh_CN.propertiesusername=用户名password=密码 ResourceBundle 根据不同的locale来加载不同的i18n配置文件 1234567 Locale locale = Locale.US;// locale = Locale.CHINA;// &#x27;i18n&#x27;是文件的前缀xxxx，根据自己的配置文件进行修改ResourceBundle bundle = ResourceBundle.getBundle(&quot;i18n&quot;, locale);// utf-8文件中文乱码，需要格式化System.out.println(new String(bundle.getString(&quot;username&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;));System.out.println(new String(bundle.getString(&quot;password&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;)); 2 JSP整合i18n123456789101112131415161718192021&lt;body&gt;&lt;% Locale locale; // 先根据参数获取语言信息，若参数不存在，默认获取浏览器请求的语言参数 String language = request.getParameter(&quot;language&quot;); if (&quot;en&quot;.equals(language)) &#123; locale = Locale.US; &#125; else if (&quot;zh&quot;.equals(language)) &#123; locale = Locale.CHINA; &#125; else &#123; locale = request.getLocale(); &#125; ResourceBundle i18n = ResourceBundle.getBundle(&quot;i18n&quot;, locale);%&gt;// 语言切换修改param参数&lt;a href=&quot;index.jsp?language=en&quot;&gt;English&lt;/a&gt; | &lt;a href=&quot;index.jsp?language=zh&quot;&gt;中文&lt;/a&gt;&lt;br/&gt;// 可以写一个工具类来解决utf-8格式化&lt;span&gt;&lt;%=new String(i18n.getString(&quot;username&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;)%&gt;&lt;/span&gt;&lt;span&gt;&lt;%=new String(i18n.getString(&quot;password&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;)%&gt;&lt;/span&gt;&lt;/body&gt; 3 JSTL标签整合i18n12345678&lt;body&gt; &lt;fmt:setLocale value=&quot;$&#123;param.locale&#125;&quot;/&gt; &lt;fmt:bundle basename=&quot;i18n&quot;/&gt; &lt;a href=&quot;jstlI18n.jsp?locale=en_US&quot;&gt;English&lt;/a&gt; | &lt;a href=&quot;jstlI18n.jsp?locale=zh_CN&quot;&gt;中文&lt;/a&gt; &lt;br/&gt; &lt;span&gt;&lt;fmt:message key=&quot;username&quot;/&gt;&lt;/span&gt; &lt;span&gt;&lt;fmt:message key=&quot;password&quot;/&gt;&lt;/span&gt;&lt;/body&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】AJAX","slug":"【JavaWeb】AJAX","date":"2022-04-11T12:35:03.000Z","updated":"2022-04-11T16:41:06.115Z","comments":true,"path":"2022/04/11/【JavaWeb】AJAX/","link":"","permalink":"https://letere-gzj.github.io/2022/04/11/%E3%80%90JavaWeb%E3%80%91AJAX/","excerpt":"AJAX请求","text":"AJAX请求 1 AJAX入门 AJAX：Asynchronous Javascript And Xml（异步Javascript和Xml），是浏览器通过js异步发送请求，局部更新页面的技术 原生JS发送异步请求1234567891011121314151617/** * javascript原生异步请求 */function () &#123; const request = new XMLHttpRequest(); // 参数：请求方法, 请求地址[, 是否异步(true/false)] request.open(&quot;GET&quot;, &quot;http://localhost:8080/15_ajax/ajaxTest?action=getAjax&quot;, true); // 请求监听（异步操作需要事件监听）（监听readyStatus改变） request.onreadystatechange = function () &#123; /* readyStats: 0=请求未初始化 1=服务器连接已建立 2=请求已接收 3=请求处理中 4=请求已完成 */ if (request.readyState === 4 &amp;&amp; request.status === 200) &#123; console.log(&quot;接收的响应数据为：&quot; + request.responseText); &#125; &#125; // 发送请求 request.send();&#125; 2 JQuery发送ajax2.1 $.ajax123456789101112131415161718function () &#123; $.ajax(&#123; // 请求地址 url: &quot;http://localhost:8080/15_ajax/ajaxTest&quot;, // 请求类型&#x27;GET&#x27;、&#x27;POST&#x27; type: &quot;GET&quot;, // 请求数据 data: &#123; action: &quot;getAjax&quot; &#125;, // 响应数据类型&#x27;text&#x27;、&#x27;xml&#x27;、&#x27;json&#x27; dataType: &quot;text&quot;, // 请求成功回调函数 success: function (data) &#123; console.log(&quot;接收到的数据为：&quot; + data); &#125; &#125;)&#125; 2.2 $.get和$.post $.get和$.post使用方法一样 12345678910111213function () &#123; // 参数：请求地址[, 数据, 回调方法, 响应数据类型] $.get( &quot;http://localhost:8080/15_ajax/ajaxTest&quot;, &#123; action: &quot;getAjax&quot; &#125;, function (data) &#123; console.log(&quot;ajax-get：&quot; + data) &#125;, &quot;text&quot; );&#125; 2.3 $.getJson $.getJson方法规定了get请求，响应数据类型为json 123456789101112function () &#123; // 参数：请求地址[, 数据, 回调方法] $.getJSON( &quot;http://localhost:8080/15_ajax/ajaxTest&quot;, &#123; action: &quot;getAjax&quot; &#125;, function (data) &#123; console.log(&quot;ajax-getJson：&quot; + data) &#125; );&#125; 2.4 serialize方法 serialze用于获取表单form中的数据，并格式化为key=vlaue&amp;key=value的形式 1表单jquery对象.serialze();","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】JSON","slug":"【JavaWeb】JSON","date":"2022-02-23T14:46:30.000Z","updated":"2022-04-11T12:30:05.381Z","comments":true,"path":"2022/02/23/【JavaWeb】JSON/","link":"","permalink":"https://letere-gzj.github.io/2022/02/23/%E3%80%90JavaWeb%E3%80%91JSON/","excerpt":"JSON学习","text":"JSON学习 1 JSON入门1.1 介绍 JSON（JavaScript Object Notation）：JS对象符号，是一种轻量级的书交换格式（相对比于xml）。 数据交换一般为客户端和服务端之间进行数据交换 1.2 数据格式123456789101112var json = &#123; // 单个值 &quot;key&quot;: &quot;value&quot;, // 数组 &quot;arr&quot;: [123, &quot;abc&quot;, true] // 对象 &quot;obj&quot;: &#123; &quot;key&quot;: value &#125;&#125; 特点： json是一个对象，用&#123;&#125;来包裹数据 json的数据，存储形式类似key-value形式 json的key值要用&quot;&quot;括起来 json的value值支持数字、字符串、布尔型、json对象 json数据之间用,进行隔开 1.3 数据获取 以上面的json为例12345678910// 获取单个值var key = json.key;// 获取数组var arr = json.arr;var arrValue = json.arr[0];// 获取对象var obj = json.obj;var objValue = json.obj.key; 2 JS JSON处理12345// 将json对象格式化为json字符串JSON.stringify(json对象);// 将json字符串解析为json对象JSON.parse(json字符串); json对象：用于js数据处理 json字符串：用于客户端与服务端进行数据交互 3 Java JSON处理 JSON处理的jar有很多，案例演示的是谷歌的json处理jar包 （1）依赖123456&lt;!-- 谷歌json处理 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; （2）方法12345678910111213Gson gson = new Gson();// &#x27;对象/List/Map&#x27;转json字符串gson.toJson(对象/List/Map);// json字符串转&#x27;对象&#x27;gson.fromJson(json字符串, 类.class);// json字符串转&#x27;List&#x27;gson.fromJson(json字符串, new TypeToken&lt;List&lt;类&gt;&gt;()&#123;&#125;.getType());// json字符串转&#x27;Map&#x27;gson.fromJson(json字符串, new TypeToken&lt;Map&lt;类1, 类2&gt;&gt;()&#123;&#125;.getType());","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】ThreadLocal","slug":"【JavaWeb】ThreadLocal","date":"2022-02-22T14:48:39.000Z","updated":"2022-08-31T10:26:52.875Z","comments":true,"path":"2022/02/22/【JavaWeb】ThreadLocal/","link":"","permalink":"https://letere-gzj.github.io/2022/02/22/%E3%80%90JavaWeb%E3%80%91ThreadLocal/","excerpt":"ThreadLocal学习","text":"ThreadLocal学习 1 ThreadLocal介绍 ThreadLocal类似Map集合，key-value的数据结构，但ThreadLocal根据当前线程作为key12345678/** 为当前线程关联一个数据 */public void set(T value)/** 获取当前线程关联的数据 */public T get();/** 移除当前线程关联的数据 */public void remove()； 特点 每一个ThreadLocal对象，只能为当前线程关联一个数据 ThreadLocal对象定义时，一般都是static类型 ThreadLocal中保存的数据，在线程销毁后，会由JVM自动释放 2 ThreadLocal实现事务 （1）JDBC工具类 用ThreadLocal为每个线程分配一个数据库连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class JdbcUtils &#123; private static DataSource dataSource; private static ThreadLocal&lt;Connection&gt; connes = new ThreadLocal&lt;&gt;(); // 初始化 static &#123; Properties properties = new Properties(); try &#123; properties.load(JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;)); dataSource = DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; System.out.println(&quot;log --- 数据库初始化失败！&quot;); e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return connection */ public static Connection getConnection() &#123; // 获取当前线程conn，不存在则创建 Connection conn = connes.get(); if(conn == null) &#123; try &#123; conn = dataSource.getConnection(); conn.setAutoCommit(false); // 手动提交事务 connes.set(conn); // 当前线程存储连接 &#125; catch (SQLException throwables) &#123; System.out.println(&quot;log --- 获取连接失败！&quot;); throwables.printStackTrace(); &#125; &#125; return conn; &#125; /** * 提交事务，并关闭连接 */ public static void commitAndClose() &#123; Connection conn = connes.get(); if (conn != null) &#123; try &#123; conn.commit(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; connes.remove(); &#125; &#125; &#125; /** * 回滚事务，并关闭连接 */ public static void rollbackAndClose() &#123; Connection conn = connes.get(); if (conn != null) &#123; try &#123; conn.rollback(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; finally &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; connes.remove(); &#125; &#125; &#125;&#125; （2）事务过滤器 过滤器直接放行请求，执行无异常，调用工具类的提交方法；出现异常，调用工具类的回滚方法12345678910111213141516public class TransactionFilter implements Filter&#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; try &#123; chain.doFilter(request, response); //事务提交 JdbcUtils.commitAndClose(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 事务回滚 JdbcUtils.rollbackAndClose(); throw new RuntimeException(e); &#125; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】Filter","slug":"【JavaWeb】Filter","date":"2022-02-20T13:36:16.000Z","updated":"2022-02-20T15:48:16.304Z","comments":true,"path":"2022/02/20/【JavaWeb】Filter/","link":"","permalink":"https://letere-gzj.github.io/2022/02/20/%E3%80%90JavaWeb%E3%80%91Filter/","excerpt":"Filter过滤器学习","text":"Filter过滤器学习 1 基本介绍1.1 filter介绍 Filter：翻译为过滤器，是JavaEE的规范，也就是接口 Filter作用：拦截请求，过滤响应 请求拦截场景： 权限检查 日记操作 事务管理 1.2 简单实现过滤器 （1）创建filter，实现接口Filter，重写doFilter()方法12345678910111213141516public class AdminFilter implements Filter &#123; /** 对拦截的请求进行过滤操作 */ public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 权限控制处理，例如判断session中是否有用户信息 HttpServletRequest request = (HttpServletRequest) servletRequest; Object user = request.getSession().getAttribute(&quot;user&quot;); if (user == null) &#123; // 拦截并响应 servletResponse.setContentType(&quot;text/html; charset=UTF-8&quot;); servletResponse.getWriter().write(&quot;你无权访问此资源！&quot;); return; &#125; // 放行，向下一个过滤器执行 filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; （2）web.xml配置过滤器，以及拦截路径12345678910&lt;filter&gt; &lt;filter-name&gt;adminFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.AdminFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;adminFilter&lt;/filter-name&gt; &lt;!-- * ：表示admin的子目录的所有资源（包括孙子目录）都拦截 --&gt; &lt;!-- url-pattern支持写多个 --&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 1.3 注解实现1234567891011// 单个urlpatterns@WebFilter(filterName = &quot;AdminFilter&quot;, urlPatterns = &quot;/admin/*&quot;)public class AdminFilter implements Filter &#123; // .....&#125;// 多个url-patterns@WebFilter(filterName = &quot;AdminFilter&quot;, urlPatterns = &#123;&quot;/admin/*&quot;, &quot;/letere/*&quot;&#125;)public class AdminFilter implements Filter &#123; // .....&#125; 2 路径匹配 （1）精确匹配 精确匹配访问资源的路径 /admin/nokopara.jpg：只拦截admin目录下的nokopara.jpg图片 （2）目录匹配 匹配该目录下的所有资源 /admin/*：拦截admin目录下的所有资源 （3）后缀名匹配 匹配指定后缀名的资源路径 *.jpg：拦截所有jpg后缀名的资源 注意：后缀名匹配不能以/开头 3 多个过滤器执行顺序 （1）过滤器在web.xml配置 按照web.xml配置的过滤器从上往下进行匹配，路径匹配成功，进行该过滤器的doFilter()方法 （2）过滤器在注解配置 通过过滤器名字进行字母排序执行 4 生命周期 5 FilterConfig类 FilterConfig，能获取一些filter的配置信息 FilterConfig在public void init(FilterConfig filterConfig)的方法中","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】Session","slug":"【JavaWeb】Session","date":"2022-02-17T15:40:41.000Z","updated":"2022-02-17T16:09:18.669Z","comments":true,"path":"2022/02/17/【JavaWeb】Session/","link":"","permalink":"https://letere-gzj.github.io/2022/02/17/%E3%80%90JavaWeb%E3%80%91Session/","excerpt":"Session学习","text":"Session学习 1 Session介绍 Session，翻译为会话，是用来维护一个客户端和服务器之间关联的一种技术 每个客户端都有自己的一个Session会话 在Session会话中，常用于保存用户登录后的信息 Session的信息存储在服务端 123// Session获取HttpServletRequest req;HttpSession session = req.getSession(); 2 Session常用方法1234567891011121314151617181920// 判断是否是新创建的Sessionboolean isNew();// 获取sessionIdString getId();// 在Session域设置参数void setAttribute(String key, Object value);// 从Session域中获取参数Object getAttribute(String key);// 设置Session超时时间（单位为秒）（负数永不超时）void setMaxInactiveInterval(int second);// 获取Session超时时间int getMaxInactiveInterval();// Session失效（销毁）void invalidate(); 3 Session超时 Session的超时，是指客户端两次请求的时间间隔是否超出时间 Session的默认超时为30分钟，这是由tomcat中/conf/web.xml文件中所配置 若需要修改，可以在自己项目中的web.xml做同样设置123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 4 Session技术原理 （1）客户端发送请求给服务器，服务器创建Session，并将创建好的Session放入到内存中 （2）服务器通过Cookie的形式，将SessionId返回给客户端保存 （3） 客户端下一次请求，携带上SessionId的Cookie，服务器获取到SessionId，从内存中取出对应的Session （4）客户端关闭浏览器，Cookie被清除，再想服务器发送请求，服务器获取不到SessionId，会重新创建Session保存在内存中","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】Cookie","slug":"【JavaWeb】Cookie","date":"2022-02-09T15:17:53.000Z","updated":"2022-02-10T15:23:42.658Z","comments":true,"path":"2022/02/09/【JavaWeb】Cookie/","link":"","permalink":"https://letere-gzj.github.io/2022/02/09/%E3%80%90JavaWeb%E3%80%91Cookie/","excerpt":"Cookie介绍和学习","text":"Cookie介绍和学习 1 Cookie介绍 Cookie直译为饼干 Cookie是服务器通知客户端保存键值对的一种技术 客户端有了Cookie之后，每次请求都会携带Cookie发送给服务端 每个Cookie的大小不能超过4KB 2 Cookie创建1234567891011121314/** * 创建Cookie * @param req * @param resp */protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 创建cookie Cookie cookie = new Cookie(&quot;key1&quot;, &quot;value1&quot;); // 通知客户端保存cookie resp.addCookie(cookie); // 支持添加多个cookie Cookie cookie2 = new Cookie(&quot;key2&quot;, &quot;value2&quot;); resp.addCookie(cookie2);&#125; 3 Cookie获取123456789/** 获取Cookie */protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取Cookie Cookie[] cookies = req.getCookies(); // 遍历 for (Cookie cookie : cookies) &#123; System.out.println(cookie.getName() + &quot;=&quot; + cookie.getValue()); &#125;&#125; 4 Cookie存活123456789101112131415/** 设置Cookie存活 */protected void liftCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 设置cookie存活时间（正数、单位秒） Cookie cookie1 = new Cookie(&quot;age&quot;, &quot;60&quot;); cookie1.setMaxAge(60); resp.addCookie(cookie1); // 删除cookie（0） Cookie cookie2 = new Cookie(&quot;age&quot;, &quot;0&quot;); cookie2.setMaxAge(0); resp.addCookie(cookie2); // 浏览器关闭，清除cookie（负数，默认） Cookie cookie3 = new Cookie(&quot;age&quot;, &quot;-1&quot;); cookie3.setMaxAge(-1); resp.addCookie(cookie3);&#125; 5 Cookie过滤 可以通过cookie的path属性，来过滤cookie的发送 path属性会跟请求地址进行匹配，匹配成功才将cookie添加进请求头中 例： CookieA（path=/test） CookieB（path=/test/abc） 请求路径：http://ip:port/test/a.html，此时只会将CookieA放入请求头中","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【拓展】固态硬盘","slug":"【拓展】固态硬盘","date":"2022-01-29T14:30:37.000Z","updated":"2022-01-29T14:34:38.621Z","comments":true,"path":"2022/01/29/【拓展】固态硬盘/","link":"","permalink":"https://letere-gzj.github.io/2022/01/29/%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/","excerpt":"固态硬盘介绍","text":"固态硬盘介绍 固态分类 协议 NVME：快 AHCI 总线通道 SATA PCIE：快 接口 SATA M2 PCIE M2固态 M Key接口，走PCI-E X4总线通道 （M Key只有一个缺口） B&amp;M Key接口，走PCI-E X2总线通道 （B Key有两个缺口，但可以插入只有一个缺口的固态接口上） B&amp;M Key接口，走SATA总线通道 B Key接口，走SATA总线通道 M2固态长度 2242（宽22，长42） 2260 2280 22110 固态结构 固态硬盘 主控固件 闪存颗粒 外置缓存 颗粒 （从上到下，性能从高到低） SLC颗粒 MLC颗粒 TLC颗粒 QLC颗粒 颗粒品质 原片：严格检测，品质最佳 白片：品质次一档的颗粒 黑片：偷偷流出的残次品颗粒 缓存： DRAM外置缓存：内存颗粒，起到缓冲作用，提高硬盘速度的稳定性 无外置缓存：使用SLC模拟，借用电脑内置缓存（大文件写入到一半时，可能速度大跌）","categories":[{"name":"拓展","slug":"拓展","permalink":"https://letere-gzj.github.io/categories/%E6%8B%93%E5%B1%95/"}],"tags":[]},{"title":"【工作技能】微信支付-native支付","slug":"【工作技能】微信支付-native支付","date":"2022-01-29T07:36:42.000Z","updated":"2022-02-06T06:49:03.138Z","comments":true,"path":"2022/01/29/【工作技能】微信支付-native支付/","link":"","permalink":"https://letere-gzj.github.io/2022/01/29/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD%E3%80%91%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98-native%E6%94%AF%E4%BB%98/","excerpt":"微信支付对接","text":"微信支付对接 1 参数准备 按照官方文档步骤操作：https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_7_1.shtml 最终需要的参数： appid：应用id mchid：商户id mchSerialNo：证书序列号 apiV3key：apiV3密钥 apiclient_key.pem：商户私钥文件 2 环境准备 （1）yaml文件1234567wechat: appId: 应用id mchId: 商户id mchSerialNo: 证书序列号 apiV3Key: apiV3密钥 mchPrivateKeyPath: 商户私钥文件地址路径 notifyUrl: 通知接受接口地址（按实际情况填写） （2）依赖引入1234567891011121314151617181920212223242526272829303132&lt;!-- web启动 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- yaml参数注入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- 注解生成get、set方法 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 微信支付SDK --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt; &lt;artifactId&gt;wechatpay-apache-httpclient&lt;/artifactId&gt; &lt;version&gt;0.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- json处理 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt;&lt;/dependency&gt; （3）微信支付配置（工具）类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Data@Component@ConfigurationProperties(prefix = &quot;wechat&quot;)public class WechatConfig &#123; // 应用id private String appId; // 商户id private String mchId; // 证书序列号 private String mchSerialNo; // apiV3密钥 private String apiV3Key; // 商户私钥文件路径 private String mchPrivateKeyPath; // 通知接收地址 private String notifyUrl; /** * 获取商户私钥文件 * @return 私钥 */ public PrivateKey getPrivateKey() &#123; try &#123; return PemUtil.loadPrivateKey(new FileInputStream(this.mchPrivateKeyPath)); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(&quot;私钥文件不存在&quot;, e); &#125; &#125; /** * 获取签名验证器 * @param privateKey 商户私钥 * @return */ public ScheduledUpdateCertificatesVerifier getVerifier(PrivateKey privateKey) &#123; // 私钥签名 PrivateKeySigner privateKeySigner = new PrivateKeySigner(this.mchSerialNo, privateKey); // 身份认证 WechatPay2Credentials wechatPay2Credentials = new WechatPay2Credentials(this.mchId, privateKeySigner); // 验证器 return new ScheduledUpdateCertificatesVerifier(wechatPay2Credentials, this.apiV3Key.getBytes(StandardCharsets.UTF_8)); &#125; /** * 获取http请求客户端 * @return */ public CloseableHttpClient getHttpClient() &#123; // 商户私钥 PrivateKey privateKey = this.getPrivateKey(); // 验证器 ScheduledUpdateCertificatesVerifier verifier = this.getVerifier(privateKey); WechatPay2Validator validator = new WechatPay2Validator(verifier); // httpClient return WechatPayHttpClientBuilder.create() .withMerchant(this.mchId, this.mchSerialNo, privateKey) .withValidator(validator) .build(); &#125;&#125; 3 下单（获取qrCode）123456789101112131415161718192021222324252627282930313233343536@Autowiredprivate WechatConfig wechatConfig;@GetMapping(&quot;/createOrder&quot;)public String createOrder() throws Exception&#123; String orderNo = &quot;NO&quot; + System.currentTimeMillis(); // 封装必填参数（具体看文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_1.shtml） Map&lt;String, Object&gt; paramsMap = new HashMap&lt;&gt;(); paramsMap.put(&quot;appid&quot;, wechatConfig.getAppId()); paramsMap.put(&quot;mchid&quot;, wechatConfig.getMchId()); paramsMap.put(&quot;description&quot;, &quot;下单测试&quot;); paramsMap.put(&quot;out_trade_no&quot;, orderNo); paramsMap.put(&quot;notify_url&quot;, wechatConfig.getNotifyUrl()); Map&lt;String, Object&gt; amountMap = new HashMap&lt;&gt;(); amountMap.put(&quot;total&quot;, 1); paramsMap.put(&quot;amount&quot;, amountMap); // 参数处理 String paramsJson = JSONObject.toJSONString(paramsMap); StringEntity entity = new StringEntity(paramsJson, StandardCharsets.UTF_8); entity.setContentType(&quot;application/json&quot;); // 请求封装 String uri = &quot;https://api.mch.weixin.qq.com/v3/pay/transactions/native&quot;; HttpPost httpPost = new HttpPost(uri); httpPost.setEntity(entity); httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;); // 发送请求 CloseableHttpClient httpClient = wechatConfig.getHttpClient(); CloseableHttpResponse response = httpClient.execute(httpPost); // 处理响应 int statusCode = response.getStatusLine().getStatusCode(); if (statusCode == 200) &#123; String qrCode = JSONObject.parseObject(EntityUtils.toString(response.getEntity())).getString(&quot;code_url&quot;); return orderNo + &quot;：&quot; + qrCode; &#125; return &quot;发送失败 or 无响应数据&quot;;&#125; 获取到的qrCode，可以返回给前端，让前端生成二维码 也可以后端生成二维码【http://letere.gitee.io/blog/2021/06/29/【工作技能】二维码生成 4 订单查询123456789101112131415161718192021222324@Autowiredprivate WechatConfig wechatConfig;/** * 订单查询 * @param orderNo * @return * @throws Exception */@GetMapping(&quot;/queryOrder&quot;)public String queryOrder(String orderNo) throws Exception &#123; // 封装请求（参数具体看文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_2.shtml） HttpGet httpGet = new HttpGet(&quot;https://api.mch.weixin.qq.com/v3/pay/transactions/out-trade-no/&quot; + orderNo + &quot;?mchid=&quot; + wechatConfig.getMchId()); httpGet.setHeader(&quot;Accept&quot;, &quot;application/json&quot;); // 发送请求 CloseableHttpClient httpClient = wechatConfig.getHttpClient(); CloseableHttpResponse response = httpClient.execute(httpGet); // 数据响应 int statusCode = response.getStatusLine().getStatusCode(); if (statusCode == 200) &#123; return EntityUtils.toString(response.getEntity()); &#125; return &quot;无响应数据 or 查询失败&quot;;&#125; 5 支付成功通知接收支付通知接收需要一个外网可以访问到的接口，给微信进行请求发送，如电脑没有可以访问的外网，则可以进行内网穿透来实现 5.1 内网穿透 ngrok下载：https://ngrok.com 注意 ：需要注册获取authtoken，注册建议使用github来注册 12345// 关联ngrok（token在注册登录后，可以在后台看到）ngrok authtoken &lt;token&gt;// 端口映射ngrok http &lt;端口号&gt; 5.2 通知接收代码1234567891011121314151617181920212223242526272829303132333435363738394041@Autowiredprivate WechatConfig wechatConfig;@PostMapping(&quot;/native/notify&quot;)public String nativeNotify(@RequestBody String body, HttpServletRequest request, HttpServletResponse response) &#123; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(); try &#123; // 获取请求体数据 JSONObject bodyObject = JSONObject.parseObject(body); // 参数验签 WechatPay2ValidatorForReq validator = new WechatPay2ValidatorForReq( wechatConfig.getVerifier(wechatConfig.getPrivateKeyByStr()), bodyObject.getString(&quot;id&quot;), body); if (!validator.validate(request)) &#123; throw new Exception(&quot;验签失败&quot;); &#125; // 数据解密（解密后的数据具体看文档：https://pay.weixin.qq.com/wiki/doc/apiv3_partner/apis/chapter4_4_5.shtml） JSONObject resourceObject = bodyObject.getJSONObject(&quot;resource&quot;); AesUtil aesUtil = new AesUtil(wechatConfig.getApiV3Key().getBytes()); String data = aesUtil.decryptToString( resourceObject.getString(&quot;associated_data&quot;).getBytes(), resourceObject.getString(&quot;nonce&quot;).getBytes(), resourceObject.getString(&quot;ciphertext&quot;)); // 订单逻辑处理... Map&lt;String, Object&gt; dataMap = JSONObject.parseObject(data, Map.class); System.out.println(dataMap); // 处理成功 response.setStatus(200); result.put(&quot;code&quot;, &quot;SUCCESS&quot;); result.put(&quot;message&quot;, &quot;成功&quot;); return JSONObject.toJSONString(result); &#125; catch (Exception e) &#123; e.printStackTrace(); // 处理失败 response.setStatus(500); result.put(&quot;code&quot;, &quot;FAILURE&quot;); result.put(&quot;message&quot;, &quot;失败&quot;); return JSONObject.toJSONString(result); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 改写WechatPay2Validator类，用作对request请求进行参数校验public class WechatPay2ValidatorForReq &#123; protected static final Logger log = LoggerFactory.getLogger(WechatPay2Validator.class); protected static final long RESPONSE_EXPIRED_MINUTES = 5L; protected final Verifier verifier; protected final String body; protected final String requestId; public WechatPay2ValidatorForReq(Verifier verifier, String requestId, String body) &#123; this.verifier = verifier; this.requestId = requestId; this.body = body; &#125; /** * 参数异常 * @param message * @param args * @return */ protected static IllegalArgumentException parameterError(String message, Object... args) &#123; message = String.format(message, args); return new IllegalArgumentException(&quot;parameter error: &quot; + message); &#125; /** * 签名失败异常 * @param message * @param args * @return */ protected static IllegalArgumentException verifyFail(String message, Object... args) &#123; message = String.format(message, args); return new IllegalArgumentException(&quot;signature verify fail: &quot; + message); &#125; /** * 签名验证 * @param request * @return * @throws IOException */ public final boolean validate(HttpServletRequest request) throws IOException &#123; try &#123; // 参数校验 this.validateParameters(request); // 构建验签字符串 String message = this.buildMessage(request); // 验签 String serial = request.getHeader(&quot;Wechatpay-Serial&quot;); String signature = request.getHeader(&quot;Wechatpay-Signature&quot;); if (!this.verifier.verify(serial, message.getBytes(StandardCharsets.UTF_8), signature)) &#123; throw verifyFail(&quot;serial=[%s] message=[%s] sign=[%s], request-id=[%s]&quot;, serial, message, signature, request.getHeader(&quot;Request-ID&quot;)); &#125; else &#123; return true; &#125; &#125; catch (IllegalArgumentException var5) &#123; log.warn(var5.getMessage()); return false; &#125; &#125; /** * 验证参数 * @param request */ protected final void validateParameters(HttpServletRequest request) &#123; String[] headers = new String[]&#123;&quot;Wechatpay-Serial&quot;, &quot;Wechatpay-Signature&quot;, &quot;Wechatpay-Nonce&quot;, &quot;Wechatpay-Timestamp&quot;&#125;; String value = null; for (String headerName : headers) &#123; value = request.getHeader(headerName); if (value == null) &#123; throw parameterError(&quot;empty [%s], request-id=[%s]&quot;, headerName, requestId); &#125; &#125; String timestampStr = value; try &#123; Instant responseTime = Instant.ofEpochSecond(Long.parseLong(timestampStr)); if (Duration.between(responseTime, Instant.now()).abs().toMinutes() &gt;= 5L) &#123; throw parameterError(&quot;timestamp=[%s] expires, request-id=[%s]&quot;, timestampStr, requestId); &#125; &#125; catch (NumberFormatException | DateTimeException var10) &#123; throw parameterError(&quot;invalid timestamp=[%s], request-id=[%s]&quot;, timestampStr, requestId); &#125; &#125; /** * 构建签名信息 * @param request * @return * @throws IOException */ protected final String buildMessage(HttpServletRequest request) throws IOException &#123; String timestamp = request.getHeader(&quot;Wechatpay-Timestamp&quot;); String nonce = request.getHeader(&quot;Wechatpay-Nonce&quot;); String body = this.body; return timestamp + &quot;\\n&quot; + nonce + &quot;\\n&quot; + body + &quot;\\n&quot;; &#125;&#125; 6 订单关闭123456789101112131415161718192021222324252627282930313233@Autowiredprivate WechatConfig wechatConfig;/** * 订单关闭 * @param orderNo * @return * @throws Exception */@GetMapping(&quot;/closeOrder/&#123;orderNo&#125;&quot;)public String closeOrder(@PathVariable String orderNo) throws Exception&#123; // 封装必填参数（具体看文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_4_3.shtml） Map&lt;String, Object&gt; paramsMap = new HashMap&lt;&gt;(); paramsMap.put(&quot;mchid&quot;, wechatConfig.getMchId()); // 参数处理 String paramsJson = JSONObject.toJSONString(paramsMap); StringEntity entity = new StringEntity(paramsJson, StandardCharsets.UTF_8); entity.setContentType(&quot;application/json&quot;); // 封装请求 String uri = &quot;https://api.mch.weixin.qq.com/v3/pay/transactions/out-trade-no/&quot; + orderNo + &quot;/close&quot;; HttpPost httpPost = new HttpPost(uri); httpPost.setEntity(entity); httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;); // 发送请求 CloseableHttpClient httpClient = wechatConfig.getHttpClient(); CloseableHttpResponse response = httpClient.execute(httpPost); // 响应处理 int statusCode = response.getStatusLine().getStatusCode(); if (statusCode == 200 || statusCode == 204) &#123; return &quot;订单：&quot; + orderNo + &quot;，关闭成功！&quot;; &#125; return &quot;订单：&quot; + orderNo + &quot;，关闭失败！&quot;;&#125;","categories":[{"name":"工作技能","slug":"工作技能","permalink":"https://letere-gzj.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"【JavaWeb】文件上传和下载","slug":"【JavaWeb】文件上传和下载","date":"2022-01-17T14:27:38.000Z","updated":"2022-01-18T15:17:26.618Z","comments":true,"path":"2022/01/17/【JavaWeb】文件上传和下载/","link":"","permalink":"https://letere-gzj.github.io/2022/01/17/%E3%80%90JavaWeb%E3%80%91%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/","excerpt":"文件上传和下载实现","text":"文件上传和下载实现 1 文件上传1.1 上传 页面 使用form表单提交数据，提交方法用post from表单设置提交数据类型，encType=&quot;multipart/from-data&quot; 用&lt;input type=&quot;file&quot;&gt;来上传图片1234567&lt;body&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;http://localhost:8080/10_fileUpDown/uploadServlet&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br/&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;avatar&quot; /&gt; &lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt; 服务器 创建servlet接受数据 mutipart/from-data传输的数据为byte流123456789public class UploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // multipart/form-data数据读取方式 byte[] buffer = new byte[2048000]; ServletInputStream sis = req.getInputStream(); int len = sis.read(buffer); System.out.println(new String(buffer, 0, len));&#125; 1.2 文件上传协议介绍 1.3 multipart数据处理 依赖1234567891011121314151617181920&lt;!-- 文件上传 --&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- servlet（tomcat10以下） --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; Servlet123456789101112131415161718192021222324252627public class UploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try &#123; // 判断是否multipart数据 RequestContext requestContext = new ServletRequestContext(req); if (ServletFileUpload.isMultipartContent(requestContext)) &#123; // 解析数据 ServletFileUpload servletFileUpload = new ServletFileUpload(new DiskFileItemFactory()); List&lt;FileItem&gt; fileItems = servletFileUpload.parseRequest(requestContext); // 遍历数据 for (FileItem fileItem : fileItems) &#123; if (fileItem.isFormField()) &#123; // 普通字段处理（中文注意乱码） System.out.println(fileItem.getFieldName() + &quot;=&quot; + fileItem.getString(&quot;UTF-8&quot;)); &#125; else &#123; // 文件处理 System.out.println(fileItem.getFieldName() + &quot;=&quot; + fileItem.getName()); fileItem.write(new File(&quot;D:\\\\WorkSpace\\\\workspace-idea\\\\workspace01\\\\JavaWeb\\\\10_文件上传和下载\\\\src\\\\main\\\\resources\\\\&quot; + fileItem.getName())); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.4 tomcat10处理 由于tomcat10修改了HttpServletRequest的包名，而commons-fileupload.jar没对tomcat10进行适配，需要我们手动进行修改才能使用 再将自己创建的类来构建RequestContext即可 2 文件下载 依赖1234567&lt;!-- IO工具类 --&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt; 服务器 创建Servlet处理文件下载 下载文件需要设置response的响应类型Content-Type，以及数据处理方式Content-Disposition 读取文件，将输入流的内容移动到response中的输出流1234567891011121314151617public class DownloadServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 1 获取下载文件名 req.setCharacterEncoding(&quot;UTF-8&quot;); String filename = req.getParameter(&quot;filename&quot;); // 2 response设置 // 2.1 文件的类型 resp.setContentType(req.getServletContext().getMimeType(&quot;/file/&quot; + filename)); // 2.2 数据处理方式（附件）[中文需要编码处理] resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(filename, &quot;UTF-8&quot;)); // 3 获取文件输入流，并转为输出流 // 如果文件保存在web目录下，可以通过ServletContext来获取输入流 InputStream inputStream = req.getServletContext().getResourceAsStream(&quot;/file/&quot; + filename); IOUtils.copy(inputStream, resp.getOutputStream()); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】JSTL标签库","slug":"【JavaWeb】JSTL标签库","date":"2022-01-10T15:36:25.000Z","updated":"2022-01-16T14:55:18.721Z","comments":true,"path":"2022/01/10/【JavaWeb】JSTL标签库/","link":"","permalink":"https://letere-gzj.github.io/2022/01/10/%E3%80%90JavaWeb%E3%80%91JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/","excerpt":"JSTL标签库学习记录","text":"JSTL标签库学习记录 1 介绍1.1 基础介绍 JSTL：JSP Standard Tag Library（JSP标准标签库） 主要替代JSP的代码脚本部分，使代码更加简洁 五种标签库 功能范围 URI 前缀 核心标签库（重点） http://java.sun.com/jsp/jstl/core c 格式化 http://java.sun.com/jsp/jstl/fmt fmt 函数 http://java.sun.com/jsp/jstl/functions fn 数据库（不使用） http://java.sun.com/jsp/jstl/sql sql XML（不使用） http://java.sun.com/jsp/jstl/xml x 1.2 使用 （1）引入依赖（jar）12345678910111213141516171819202122232425262728&lt;!-- tomcat10以下 --&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.taglibs/taglibs-standard-impl --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt; &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.taglibs/taglibs-standard-spec --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt; &lt;artifactId&gt;taglibs-standard-spec&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--tomcat10--&gt;&lt;!-- https://mvnrepository.com/artifact/org.glassfish.web/jakarta.servlet.jsp.jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/jakarta.servlet.jsp.jstl/jakarta.servlet.jsp.jstl-api --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; （2）JSP引入标签库 脚本：&lt;%@ taglib prefix=&quot;前缀&quot; uri=&quot;URI地址&quot; %&gt; 2 Core标签库2.1 &lt;c:set&gt; &lt;c:set&gt;：向四种域设置值 示例123456789&lt;body&gt; &lt;%-- scope：域【page, request, session, application】 var：key名 value：value值 --%&gt; &lt;c:set scope=&quot;page&quot; var=&quot;key&quot; value=&quot;value&quot;/&gt; $&#123; pageScope.key &#125;&lt;/body&gt; 2.2 &lt;c:if&gt; &lt;c:if&gt;：条件判断（无else） 示例12345678&lt;body&gt; &lt;%-- test：判断条件（EL表达式） --%&gt; &lt;c:if test=&quot;$&#123;1 == 1&#125;&quot;&gt; &lt;span&gt;if测试&lt;/span&gt; &lt;/c:if&gt;&lt;/body&gt; 2.3 &lt;c:choose&gt;&lt;c:when&gt;&lt;c:otherwise&gt; &lt;c:choose&gt;&lt;c:when&gt;&lt;c:otherwise&gt;：多路判断（类似if … else if … else） 示例1234567891011121314151617181920212223&lt;body&gt; &lt;%-- choose：多路判断开始标签 when：多路判断（类似if / else if） test：判断条件（EL表达式） otherwise：末尾判断（类似else） --%&gt; &lt;c:set scope=&quot;page&quot; var=&quot;score&quot; value=&quot;80&quot;/&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;pageScope.score &gt;= 90&#125;&quot;&gt; &lt;span&gt;优秀&lt;/span&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;pageScope.score &gt;= 80&#125;&quot;&gt; &lt;span&gt;良好&lt;/span&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;pageScope.score &gt;= 60&#125;&quot;&gt; &lt;span&gt;及格&lt;/span&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;span&gt;不及格&lt;/span&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/body&gt; 2.4 &lt;c:forEach&gt; &lt;c:forEach&gt;：用于循环遍历数据 1234567891011121314151617181920212223&lt;body&gt; &lt;%-- （1）数字遍历 begin：起始数据 end：结束数据 step：步长（默认1） var：接收参数 --%&gt; &lt;c:forEach begin=&quot;0&quot; end=&quot;10&quot; step=&quot;2&quot; var=&quot;index&quot;&gt; $&#123;index&#125; &lt;br/&gt; &lt;/c:forEach&gt; &lt;%-- （2）数组/集合遍历 items：遍历对象（数组，List，Map） --%&gt; &lt;% pageContext.setAttribute(&quot;arr&quot;, new String[]&#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;); %&gt; &lt;c:forEach items=&quot;$&#123;pageScope.arr&#125;&quot; var=&quot;item&quot;&gt; $&#123;item&#125; &lt;br/&gt; &lt;/c:forEach&gt;&lt;/body&gt; 补充：forEach标签还有一个额外参数，varStatus，里面存放遍历元素的信息 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;%-- varStatus：元素状态 --%&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;当前元素&lt;/th&gt; &lt;th&gt;当前下标&lt;/th&gt; &lt;th&gt;已遍历元素个数&lt;/th&gt; &lt;th&gt;是否第一个元素&lt;/th&gt; &lt;th&gt;是否最后一个元素&lt;/th&gt; &lt;th&gt;begin值&lt;/th&gt; &lt;th&gt;end值&lt;/th&gt; &lt;th&gt;step值&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach begin=&quot;0&quot; end=&quot;2&quot; step=&quot;1&quot; items=&quot;$&#123;pageScope.arr&#125;&quot; varStatus=&quot;status&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;status.current&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.index&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.first&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.last&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.begin&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.end&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.step&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】EL表达式","slug":"【JavaWeb】EL表达式","date":"2022-01-09T12:38:04.000Z","updated":"2022-01-10T15:09:06.512Z","comments":true,"path":"2022/01/09/【JavaWeb】EL表达式/","link":"","permalink":"https://letere-gzj.github.io/2022/01/09/%E3%80%90JavaWeb%E3%80%91EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"EL表达式说明和使用方式","text":"EL表达式说明和使用方式 1 EL表达式介绍 EL：Expression Language（表达式语言） 作用：简化并替换JSP页面的表达式脚本，用来在JSP页面输出数据 示例12345&lt;body&gt; &lt;% request.setAttribute(&quot;key&quot;, &quot;value&quot;); %&gt; JSP表达式：&lt;%= request.getAttribute(&quot;key&quot;) %&gt; &lt;br/&gt; EL表达式：$&#123;key&#125;&lt;/body&gt; 2 EL表达式作用域 EL表达式主要用来输出四大域对象中的数据 四大域对象存储相同key名的数据，优先输出范围最小的域对象的数据 123456789&lt;body&gt; &lt;% pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;); request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;); %&gt; $&#123;key&#125; &lt;%-- 输出结果为&quot;pageContext&quot; --%&gt;&lt;/body&gt; 3 常用数据结构取值 实例 123456789101112// 创建一个类， 里面包含平时常见的数据结构@Datapublic class Sample &#123; private String param; private String[] arr; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; public String getEl() &#123; return &quot;el表达式获取对象数值，只是通过get方法获取&quot;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;% Sample sample = new Sample(); sample.setParam(&quot;属性&quot;); // 数组 sample.setArr(new String[]&#123;&quot;数组1&quot;, &quot;数组2&quot;&#125;); // List集合 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;list1&quot;); list.add(&quot;list2&quot;); sample.setList(list); // Map集合 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;, &quot;map1&quot;); map.put(&quot;key2&quot;, &quot;map2&quot;); sample.setMap(map); // 放入域对象 pageContext.setAttribute(&quot;sample&quot;, sample); %&gt; Param：$&#123;sample.param&#125; &lt;br/&gt; &lt;br/&gt; Arr: $&#123;sample.arr&#125; &lt;br/&gt; Arr[0]: $&#123;sample.arr[0]&#125; &lt;br/&gt; &lt;br/&gt; List: $&#123;sample.list&#125; &lt;br/&gt; List.get(0): $&#123;sample.list[0]&#125; &lt;br/&gt; &lt;br/&gt; Map: $&#123;sample.map&#125; &lt;br/&gt; Map.get(&quot;key1&quot;): $&#123;sample.map.key1&#125; &lt;br/&gt; &lt;br/&gt; EL表达式取值原理：$&#123;sample.el&#125;&lt;/body&gt; 4 运算4.1 关系运算 关系运算符 说明 示例 结果 == 或 eq 等于 $&#123;5 == 5&#125; true 或 false != 或 ne 不等于 $&#123;5 != 5&#125; true 或 false &lt; 或 lt 小于 $&#123;5 &lt; 5&#125; true 或 false &lt;= 或 le 小于等于 $&#123;5 &lt;= 5&#125; true 或 false &gt; 或 gt 大于 $&#123;5 &gt; 5&#125; true 或 false &gt;= 或 ge 大于等于 $&#123;5 &gt;= 5&#125; true 或 false 4.2 逻辑运算 逻辑运算符 说明 示例 结果 &amp;&amp; 或 and 与运算 $&#123;5 == 5 &amp;&amp; 11 == 11&#125; true 或 false ll 或 or 或运算 $&#123;5 == 5 ll 11 == 11&#125; true 或 false ! 或 not 取反运算 $&#123;!true&#125; true 或 false 4.3 算术运算 算术运算符 说明 示例 结果 + 加法 $&#123; 1 + 1 &#125; - 减法 $&#123; 1 - 1 &#125; * 乘法 $&#123; 1 * 1 &#125; / 或 div 除法 $&#123; 1 / 1 &#125; % 或 mod 取模 $&#123; 1 % 1 &#125; 4.4 empty运算 empty运算：判断一个数据是否为空，为空则true，反之false 语法：$&#123; empty 数据 &#125; 数据为空的情况 值为null 空字符串 数组长度为0，且类型为Object list集合长度为0 map集合长度为0 4.5 三元运算 语法：$&#123; 表达式1 ? 表达式2 : 表达式3 &#125; 表达式1为true，执行表达式2，反之执行表达式3 5 11个隐含对象 EL表达式中，自定义了11个隐含对象，可以直接拿来使用 变量名 类型 作用 pageContext PageContextImpl 获取Jsp中九大内置对象 pageScope Map&lt;String, Object&gt; 获取pageContext域中的数据 requestScope Map&lt;String, Object&gt; 获取requestContext域中的数据 sessionScope Map&lt;String, Object&gt; 获取session域中的数据 applicationScope Map&lt;String, Object&gt; 获取application域中的数据 param Map&lt;String, String&gt; 获取request中的请求参数值 paramValues Map&lt;String, String[]&gt; 获取request中的请求参数值，存在多个值时使用 header Map&lt;String, String&gt; 获取request中请求头参数值 headerValues Map&lt;String, String[]&gt; 获取request中的请求参数值，存在多个值时使用 cookies Map&lt;String, Cookie&gt; 获取当前请求中的cookie信息 initParam Map&lt;String, String&gt; 获取在web.xml中&lt;context-param&gt;的参数值","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】JSP","slug":"【JavaWeb】JSP","date":"2021-11-20T04:12:14.000Z","updated":"2022-01-16T15:03:48.173Z","comments":true,"path":"2021/11/20/【JavaWeb】JSP/","link":"","permalink":"https://letere-gzj.github.io/2021/11/20/%E3%80%90JavaWeb%E3%80%91JSP/","excerpt":"JavaWeb关于JSP页面的学习","text":"JavaWeb关于JSP页面的学习 1 介绍1.1 基本介绍 JSP：java server page 作用：代替servlet程序回传html页面数据 因为servlet程序回传html页面数据是非常繁琐的事情，开发成本和维护成本极高 1.2 servlet回传页面数据12345678910111213141516171819// servletpublic class PrintHtmlServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 动态返回页面 resp.setContentType(&quot;text/html; charset=UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.write(&quot;&lt;!DOCTYPE html&gt;\\r\\n&quot;); writer.write(&quot;&lt;html lang=\\&quot;en\\&quot;&gt;\\r\\n&quot;); writer.write(&quot;&lt;head&gt;\\r\\n&quot;); writer.write(&quot; &lt;meta charset=\\&quot;UTF-8\\&quot;&gt;\\r\\n&quot;); writer.write(&quot; &lt;title&gt;Title&lt;/title&gt;\\r\\n&quot;); writer.write(&quot;&lt;/head&gt;\\r\\n&quot;); writer.write(&quot;&lt;body&gt;\\r\\n&quot;); writer.write(&quot; 这里是要动态显示在页面的数据，html是静态页面，数据是写死的\\r\\n&quot;); writer.write(&quot;&lt;/body&gt;\\r\\n&quot;); writer.write(&quot;&lt;/html&gt;\\r\\n&quot;); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;printHtmlServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.letere.jsp.servlet.PrintHtmlServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;printHtmlServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/printHtml&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 由此例子可知，用servlet动态返回页面数据，十分麻烦，因此引入JSP来返回动态数据页面 1.3 JSP本质 JSP页面本质是一个Servlet程序 （1）在我们访问jsp页面时，会自动生成一个jsp的java文件，以及其编译class文件 （2）查看源码发现index_jsp.java继承HttpJspBase，而HttpJspBase继承HttpServlet （3）简单查看index_jsp.java源码，跟上面演示的servlet程序写法类似 综上所述：JSP的本质就是一个servlet程序 2 Page指令12345678910&lt;%@ page import=&quot;java.util.*&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot; autoFlush=&quot;true&quot; buffer=&quot;8kb&quot; errorPage=&quot;/errorPage.html&quot; isErrorPage=&quot;false&quot; session=&quot;true&quot; extends=&quot;java.util.List&quot; %&gt; 属性介绍 import：跟java一样，导入包，类 contentType：jsp返回的数据类型，即源码中response.setContentType()的参数值 language：jsp翻译后的语言文件，目前只支持java autoFlush：out输出流缓冲区满后是否自动刷新，默认true buffer：缓冲区大小，默认8kb errorPage：设置页面报错后跳转错误页面位置，/即以web目录开头的相对路径 isErrorPage：当前页面是否错误页面，默认false。true源代码多出一个Execption类 session：访问页面时，是否创建HttpSession对象，默认true extends：生成的java文件默认继承的类，不建议修改 3 脚本3.1 声明脚本 语法：&lt;%! 声明的java代码 %&gt; 作用：jsp可以翻译出java定义的类属性、静态代码块，方法和内部类 123456789101112131415161718192021&lt;body&gt; &lt;%! // 声明类属性 public static String name; // 声明静态代码块 static &#123; name = &quot;你好&quot;; &#125; // 声明类方法 public void hello() &#123; System.out.println(&quot;Hello World!&quot;); &#125; // 声明内部类 public class InnerClass &#123; public String sex; &#125; %&gt;&lt;/body&gt; 声明脚本会将代码填写到jsp生成的java文件中，仅做声明，不执行 3.2 表达式脚本 语法：&lt;%=表达式%&gt; 作用：在Jsp页面上输出数据，数据可以是一个变量或对象 123456&lt;body&gt; &lt;%!public String name = &quot;456&quot;;%&gt; &lt;%= 123 %&gt; &lt;%= name %&gt;&lt;/body&gt; 表达式脚本最主要的作用还是能够输出变量 注意表达式脚本不能以;，否则翻译出的代码为out.print(xxx;);，在java是错误语法 3.3 代码脚本 语法：&lt;%可执行代码%&gt; 作用：Jsp页面刷新时，执行代码脚本中的代码 123456789&lt;body&gt; &lt;% Integer sum = 0; for(int i=0; i&lt;10; i++) &#123; sum += i; &#125; System.out.println(sum); %&gt;&lt;/body&gt; 翻译后的java代码在out.write()附近，所以当页面打印数据的时候，会调用代码脚本写的代码 一个完整的Java语句，支持多个代码脚本拼接成一个完整Java语句 4 JSP九大内置对象 依赖 1234567&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; JSP翻译成Servlet的类中，内置了9个可用的对象 request：请求 response：响应 pageContext：jsp上下文对象 session：HttpSession对象 exception：异常对象 application：ServletContext对象 config：ServletConfig对象 out：Jsp输出流对象 page：指向当前JSP的对象 5 JSP四大域对象 在JSP九个内置对象中，有4个位域对象 域对象就是像Map一样，可以存储和取出数据 PageContextImpl pageContext：范围 - 当前JSP页面内 HttpServletRequest request：范围 - 一次请求内 HttpSession session：范围 - 一次会话内（打开浏览器访问服务器 ~ 关闭浏览器 之间） ServletContext application：范围 - 整个web工程内 6 输出流6.1 JSP的out和response.getWriter 示例1123456789&lt;body&gt; &lt;% out.write(&quot;out输出1 &lt;br/&gt;&quot;); out.write(&quot;out输出2 &lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出1 &lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出2 &lt;br/&gt;&quot;); %&gt;&lt;/body&gt; 说明：原本先执行的out输出，结果在末尾输出。out和response都有各自的缓存区，jsp在向页面输出内容前，会执行out.flush()方法，把out缓存区的内容加入到response缓存区的末尾，然后通过response向浏览器输出数据 示例21234567891011&lt;body&gt; &lt;% out.write(&quot;out输出1 &lt;br/&gt;&quot;); out.flush(); // 手动将out缓存区内容加入到response缓存区 out.write(&quot;out输出2 &lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出1 &lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出2 &lt;br/&gt;&quot;); %&gt;&lt;/body&gt; 6.2 out.print()和out.write() 示例123456789101112&lt;body&gt; &lt;% out.write(&quot;这是write字符串 &lt;br/&gt;&quot;); out.print(&quot;这是print字符串 &lt;br/&gt;&quot;); %&gt; &lt;br/&gt; &lt;% out.write(1); out.write(&quot;&lt;br/&gt;&quot;); out.print(1); %&gt;&lt;/body&gt; 说明：print和write方法，在输出字符串时不会出现问题，而在输出数字时会出现乱码。是因为write方法会将int转成char然后再输出 7 JSP常用标签7.1 静态包含 将多个JSP共用的内容提取为一个单独的JSP页面，通过静态包含引入单独的JSP页面，模块化处理，减少维护成本 语法：&lt;%@include file=&quot;共用的JSP页面路径&quot;%&gt; 示例：12345678910&lt;%-- 主JSP页面 --%&gt;&lt;body&gt; 以下内容为引入的内容：&lt;br/&gt; &lt;%@include file=&quot;/include/sub/sub.jsp&quot;%&gt;&lt;/body&gt;&lt;%-- 次JSP页面 --%&gt;&lt;body&gt; 这里是被引入的内容啊！&lt;/body&gt; 7.2 动态包含 动态包含的效果和静态包含的类似，但底层实现的逻辑不一样 语法：&lt;jsp:include page=&quot;路径&quot;&gt;&lt;/jsp:include&gt; 示例12345678910111213&lt;!-- 主JSP --&gt;&lt;body&gt; 动态包含：&lt;br/&gt; &lt;jsp:include page=&quot;/include/sub/sub.jsp&quot;&gt; &lt;jsp:param name=&quot;myParam&quot; value=&quot;你好啊&quot;/&gt; &lt;/jsp:include&gt;&lt;/body&gt;&lt;!-- 次JSP --&gt;&lt;body&gt; 这里是动态包含的内容！&lt;br/&gt; 这是接受到的参数：&lt;%=request.getParameter(&quot;myParam&quot;)%&gt;&lt;/body&gt; 动态包含特点 会把包含的Jsp页面也翻译成Java代码 调用方法去获取包含页面的输出信息，而不是直接将内容复制 动态包含可以进行参数传递 7.3 请求转发 语法：&lt;jsp:forward page=&quot;转发路径&quot;&gt;&lt;/jsp:forward&gt; 示例123&lt;body&gt; &lt;jsp:forward page=&quot;/include/sub/sub.jsp&quot;/&gt;&lt;/body&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【面试】Java高频面试题（尚硅谷）","slug":"【面试】Java高频面试题（尚硅谷）","date":"2021-10-26T04:19:54.000Z","updated":"2021-10-28T09:53:48.949Z","comments":true,"path":"2021/10/26/【面试】Java高频面试题（尚硅谷）/","link":"","permalink":"https://letere-gzj.github.io/2021/10/26/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/","excerpt":"关于Java高频面试题学习","text":"关于Java高频面试题学习 1 JavaSE1.1 自增变量12345678910111213141516171819202122@Testpublic void test01() &#123; /* 考点：i++，先赋值，再自增；++i，先自增，再赋值 运算结果：i=4，j=1，k=11 */ int i=1; i = i++; // i是先赋值给i，所以i仍然是1 int j = i++; // j=1，再i自增，i=2 int k = i + ++i * i++; // k = 2 + 3 * 3 = 11，结束赋值后i++自增1 System.out.println(&quot;i=&quot; + i); System.out.println(&quot;j=&quot; + j); System.out.println(&quot;k=&quot; + k); /* 总结： 赋值=，最后计算 =右边的从左到右加载值一次压入操作数栈 按照运算符优先级计算 自增、自减操作都是直接修改变量的值，不经过操作数栈 最后的复制之前，临时结果也是存储在操作数栈中 */&#125; 1.2 单例模式 饿汉式：直接创建对象，不存在线程安全问题（3种） 1234567891011public class Singleton1 &#123; /* 要点（懒汉式）： 1、构造器私有化 2、自行创建，并用静态变量保存实例 3、向外提供实例（public 或 自定义get方法） 4、强调是单例，可以用final进行修饰 */ public static final Singleton1 INSTANCE = new Singleton1(); private Singleton1() &#123;&#125;&#125; 123456public enum Singleton2 &#123; /* 枚举类只定义一个，即为单例 */ INSTANCE;&#125; 12345678910111213141516171819public class Singleton3 &#123; /* 跟直接实例化懒汉式基本一致，但使用场景不同 使用场景： 实例化带有参数，而且参数是从配置文件动态获取时 */ public static final Singleton3 INSTANCE; static &#123; // 配置文件动态获取info（这里直接写死） String info = &quot;Hello World!&quot;; INSTANCE = new Singleton3(info); &#125; private String info; private Singleton3(String info) &#123; this.info = info; &#125;&#125; 懒汉式：延迟创建对象（3种） 1234567891011121314151617181920public class Singleton4 &#123; /* 要点： 1、私有构造器 2、私有静态变量实例 3、提供静态方法获取实例（实例为null，则创建，反之返回实例） 【多线程存在线程安全问题】 */ private static Singleton4 instance; private Singleton4() &#123;&#125; public static Singleton4 getInstance() &#123; if (instance == null) &#123; // 若此部分执行代码过长，会导致其他线程运行时，发现实例不存在，也会进入此判断 instance = new Singleton4(); &#125; return instance; &#125;&#125; 123456789101112131415161718192021public class Singleton5 &#123; /* 加入同步锁，解决线程安全 外层加多一层判断，提供性能 */ private static Singleton5 instance; private Singleton5() &#123;&#125; public static Singleton5 getInstance() &#123; if (instance == null) &#123; // 加入同步锁，保证线程安全 synchronized (Singleton5.class) &#123; if (instance == null) &#123; instance = new Singleton5(); &#125; &#125; &#125; return instance; &#125;&#125; 12345678910111213141516public class Singleton6 &#123; /* 1、内部类被加载时才会创建INSTANCE实例（内部类加载就会有此INSTANCE，不存在INSTANCE为null，重新new的情况） 2、静态内部类不会随外部类加载而进行初始化，需要单独加载和初始化 3、因为是在内部类加载和初始化时创建的，因此是线程安全的 */ private Singleton6() &#123;&#125; private static class Inner &#123; private static final Singleton6 INSTANCE = new Singleton6(); &#125; public static Singleton6 getInstance() &#123; return Inner.INSTANCE; &#125;&#125; 1.3 类初始化和实例化过程 （1）类初始化过程 main函数所在类先初始化 子类初始化需要先初始化父类 按代码顺序执行静态类变量、静态代码块 （2）类实例化过程 子类实例化需要先实例化父类 按代码顺序执行非静态变量、非静态代码块 构造器永远最后执行 （3）重写 子类重写父类方法，父类调用方法时是调用子类的重写方法 1234567891011121314151617181920212223242526272829// 父类public class Father &#123; private int i = test(); private static int j = method(); static &#123; System.out.print(&quot;(1)&quot;); &#125; Father() &#123; System.out.print(&quot;(2)&quot;); &#125; &#123; System.out.print(&quot;(3)&quot;); &#125; public int test() &#123; System.out.print(&quot;(4)&quot;); return 1; &#125; public static int method() &#123; System.out.print(&quot;(5)&quot;); return 1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 1、main所在类进行初始化 （1）先初始化Father 静态变量 j = method()，没被重写，【（5）】 静态代码块 【（1）】 （2）再初始化Son 静态变量 j = method()，【（10）】 静态代码块 【（6）】 2、&quot;Son s1 = new Son();&quot;类实例化 （1）先实例化Father 非静态变量 i = test()，方法被重写，【（9）】 非静态代码块 【（3）】 构造器 【（2）】 （2）再实例化Son 非静态变量 i = test()，【（9）】 非静态代码块 【（8）】 构造器 【（7）】 总运行结果为：（5）（1）（10）（6）（9）（3）（2）（9）（8）（7） */public class Son extends Father&#123; private int i = test(); private static int j = method(); static &#123; System.out.print(&quot;(6)&quot;); &#125; Son() &#123; System.out.print(&quot;(7)&quot;); &#125; &#123; System.out.print(&quot;(8)&quot;); &#125; @Override public int test() &#123; System.out.print(&quot;(9)&quot;); return 1; &#125; // 重载（非重写，static不能重写） public static int method() &#123; System.out.print(&quot;(10)&quot;); return 1; &#125; public static void main(String[] args) &#123; Son s = new Son(); // （5）（1）（10）（6）（9）（3）（2）（9）（8）（7） &#125;&#125; 1.4 传参机制 基本数据类型：传递值 引用数据类型：传递地址值 String和包装类：无法修改值，改变值需要新创空间，重新指向新空间 1234567891011121314151617181920212223242526272829public class ParamTest &#123; public static void main(String[] args) &#123; int i = 1; String str = &quot;hello&quot;; Integer num = 200; int[] arr = &#123;1, 2, 3, 4&#125;; MyData my = new MyData(); change(i, str, num, arr, my); System.out.println(&quot;i = &quot; + i); // i = 1 （基本数据类型） System.out.println(&quot;str = &quot; + str); // str = hello （无法修改值） System.out.println(&quot;num = &quot; + num); // num = 200 （无法修改值） System.out.println(&quot;arr = &quot; + Arrays.toString(arr)); // arr = [2, 2, 3, 4] （引用数据类型） System.out.println(&quot;my.a = &quot; + my.a); // my.a = 11 （引用数据类型） &#125; static class MyData &#123; int a = 10; &#125; public static void change(int i, String str, Integer num, int[] arr, MyData my) &#123; i += 1; str += &quot;world&quot;; num += 1; arr[0] += 1; my.a += 1; &#125;&#125; 1.5 递归和迭代 递归： 优点：大问题转化为小问题，可以减少代码量，同时代码精简，可读性好 缺点：递归调用浪费了空间，而且递归太深容易造成堆栈溢出 迭代： 优点：代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销 缺点：代码不如递归简洁，可读性差 123456789/*编程题：有n步台阶，一次只能上1步或2步，共多少种走法规律：f(n) = f(n-2) + f(n-1) ...... f(3) = 3 = f(2) + f(1) (【1 1 1】、【1 2】、【2 1】) f(2) = 2 （【1 1】、【2】） f(1) = 1 （【1】） */ 123456789101112/** * 递归 * @param n 步数 * @return int */public int step1(int n) &#123; if (n == 1 || n == 2) &#123; return n; &#125; return step1(n-1) + step1(n-2);&#125; 123456789101112131415161718192021222324/** * 循环迭代 * @param n 步数 * @return int */public int step2(int n) &#123; if (n == 1 || n == 2) &#123; return n; &#125; // 初始化前两步步数 int one = 1; int two = 2; int sum = 0; for (int i=3; i&lt;=n; i++) &#123; sum = one + two; // 重新记录前两步步数 one = two; two = sum; &#125; return sum;&#125; 1.6 局部变量和成员变量 弄清楚变量作用域即可 1234567891011121314151617181920212223242526272829public class VariableTest &#123; static int s; int i; int j; &#123; int i = 1; i++; j++; s++; &#125; public void test(int j) &#123; j++; i++; s++; &#125; public static void main(String[] args) &#123; VariableTest t1 = new VariableTest(); // t1：i=0，j=1，s=1 VariableTest t2 = new VariableTest(); // t2: i=0, j=1, s=2 t1.test(10); // t1：i=1, j=1, s=3 t1.test(20); // t1: i=2, j=1, s=4 t2.test(30); // t2: i=1, j=1, s=5 System.out.println(t1.i + &quot; &quot; + t1.j + &quot; &quot; + t1.s); // 2 1 5 System.out.println(t2.i + &quot; &quot; + t2.j + &quot; &quot; + t2.s); // 1 1 5 &#125;&#125; 2 SSM2.1 SpringBean作用域1234&lt;!-- scope属性用于指定bean的作用域 --&gt;&lt;bean id=&quot;xx&quot; class=&quot;xxx&quot; scope=&quot;singleton&quot;&gt; &lt;property name=&quot;xx&quot; value=&quot;xxx&quot;&gt;&lt;/property&gt;&lt;/bean&gt; Spring的Bean默认作用域为singleton，即单例，只会实例化一个 其他的作用域： 类别 说明 singleton 在SpringIOC容器中仅存在一个Bean实例，spring启动自动创建 prototype 每次调用getBean()都会返回一个新的实例 request 每次http请求都会创建一个新Bean，仅适用于WebApplicationContext环境 session 同一个http session共享一个Bean，不同http session使用不同的Bean，仅适用于WebApplicationContext环境 2.2 事务传播属性 事务传播行为：开启事务的A方法运行在另一个开启事务的B方法，事务运行的是A的，还是B的 123456789@Transactionalpublic void A () &#123; // ......&#125;@Transactionalpublic void B () &#123; A()；&#125; 事务传播属性通过@Transactional(propagation=Propagation.XXXX)来设置 以下事务参数都添加在A方法 参数 说明 REQUIRED（默认） 使用B方法的事务 REQUIRES_NEW 使用A方法的事务 SUPPORTS NOT_SUPPORTED MANDATORY NEVER A方法无法运行在有事务的B方法，报异常 NESTED 2.3 事务隔离级别 事务并发引出问题 问题 说明 脏读 读取到别的事务更新但未提交的数据 不可重复读 事务A读取数据后，事务B修改并提交数据，事务A重新读取数据发现不一致 幻读 事务A读取表的数据，事务B向表插入新行，事务A重新读取表行数变多了 隔离级别 可通过@Transactional(isolation=Isolation.XXXXX)来设置方法的隔离级别 参数 说明 READ_UNCOMMITTED (读未提交) 允许读取修改但未提交的数据 READ_COMMITTED （读已提交） 只能读取已提交数据（避免脏读） REPEATABLE_READ （可重复读） 对某字段进行操作时，其他事务无法操作此字段 （避免不可重复读） SERIALIZABLE （串行化） 对某个表进行操作时，其他事务无法操作此表数据（避免幻读） 2.4 POST/GET请求中文乱码 POST：配置过滤器1234567891011121314&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 参数初始化 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; GET：修改tomcat的server.xml文件（tomcat8及以上版本不用配置） 2.5 SpringMVC工作流程 2.6 Mybatis驼峰命名 （1）sql语句起别名1234select last_name lastNamefrom table （2）配置开启驼峰命名123&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; （3）创建resultMap自定义映射1234&lt;resultMap id=&quot;MyEmp&quot; type=&quot;Dao.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt;&lt;/resultMap&gt; 3 Java高级3.1 linux服务类指令 http://letere.gitee.io/blog/2021/06/28/【Linux】服务管理 3.2 git分支命令与应用 命令 3.3 redis持久化 http://letere.gitee.io/blog/2021/01/13/【Redis】Redis的持久化 3.4 mysql索引 适合建立索引情况 （1）主键自动建立唯一索引 （2）频繁查询字段应建立索引 （3）外键建立索引","categories":[{"name":"面试","slug":"面试","permalink":"https://letere-gzj.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"【JavaWeb】Servlet","slug":"【JavaWeb】Servlet","date":"2021-10-25T14:13:35.000Z","updated":"2022-01-09T07:01:51.371Z","comments":true,"path":"2021/10/25/【JavaWeb】Servlet/","link":"","permalink":"https://letere-gzj.github.io/2021/10/25/%E3%80%90JavaWeb%E3%80%91Servlet/","excerpt":"关于Servlet的学习","text":"关于Servlet的学习 1 Servlet入门1.1 Servlet介绍 Servlet是JavaEE规范之一。规范是接口 Servlet是JavaWeb三大组件之一。三大组件分别为：Servlet、Filter、Listener Servlet是运行在服务器上的一个Java小程序，它可以接受客户端发送的请求，并响应数据回客户端 1.2 实现Servlet （1）引入servlet依赖123456789101112131415&lt;!-- tomcat10以下版本 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- tomcat10 --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; （2）实现Servlet接口，实现service()方法12345678public class HelloServlet implements Servlet &#123; // 省略... @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;Hello Servlet!&quot;); &#125;&#125; （3）web.xml配置servlet和其路由路径123456789101112131415&lt;!-- 定义servlet --&gt;&lt;servlet&gt; &lt;!-- servlet别名 --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- servlet类路径 --&gt; &lt;servlet-class&gt;com.letere.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 路由与servlet的映射 --&gt;&lt;servlet-mapping&gt; &lt;!-- 配置映射的servlet名（从上面定义） --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- 访问的路由路径（http://ip:port/工程路径/hello） --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; （4）tomcat启动引入依赖 tomcat启动默认不带有jar包，需要自己设置 （5）启动测试 访问配置的servlet路由地址，查看后台打印记录 2 Servlet生命周期 Servlet构造器方法 init初始化方法 以上两种方法是在第一次访问的时候，创建servlet程序时会调用 service方法 每次访问一次地址，都会执行一次此方法 destroy方法 web工程停止运行的时候调用 3 实际开发3.1 继承HttpServlet实现Servlet （1）实际开发中，一般都是继承HttpServlet来生成Servlet （2）按照不同的请求，重写对应的doGet()、doPost() … 方法 （3）将servlet注册到web.xml中 1234567891011public class HelloServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // get请求处理 ... &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // post请求处理 ... &#125;&#125; 3.2 idea自动生成servlet 4 Servlet继承体系 5 ServletConfig类 作用 （1）获取web.xml中的Servlet程序的别名servlet-name的值 （2）获取web.xml中的初始化参数init-param （3）获取servletContext对象 Config对象获取12345678910111213public class HelloServlet2 extends HttpServlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); // init方法中使用servletConfig &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 通过getServletConfig方法获取 ServletConfig config = getServletConfig(); &#125;&#125; 演示123456789101112public class HelloServlet2 extends HttpServlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); // 1.获取servlet别名 String servletName = config.getServletName(); // 2.获取init-param参数 String test = config.getInitParameter(&quot;test&quot;); // 3.获取ServletContext对象 ServletContext context = config.getServletContext(); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.letere.servlet.HelloServlet2&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;test&lt;/param-name&gt; &lt;param-value&gt;123&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 6 ServletContext类 介绍 ServletContext是一个接口 一个Web工程只有一个ServletContext对象实例 Servlet对象是一个域对象，可以像Map一样存储kv键值对，给其他Servelt共享 作用 获取web.xml中的context-param参数 获取当前工程路径 获取工程在服务器硬盘上的绝对路径 存储、获取、删除kv值 演示12345678910111213141516public class ContextServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = getServletContext(); // 1.获取context-param参数 String common = context.getInitParameter(&quot;common&quot;); // 2.获取当前工程路径 String contextPath = context.getContextPath(); // 3.获取工程部署后在服务器磁盘的绝对路径 String realPath = context.getRealPath(&quot;/&quot;); // 4.设置、获取、删除kv值 context.setAttribute(&quot;key&quot;, &quot;value&quot;); Object value = context.getAttribute(&quot;key&quot;); context.removeAttribute(&quot;key&quot;); &#125;&#125; 123456789101112&lt;context-param&gt; &lt;param-name&gt;common&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;ContextServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.letere.servlet.ContextServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ContextServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/context&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 7 HTTP协议 介绍 指客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫做HTTP协议，HTTP协议中的数据又叫做报文 7.1 GET请求 （1）常规（请求行） （2）请求头 7.2 POST请求 （1）常规（请求行） （2）请求头 （3）请求体 7.3 常见响应码 200：请求成功 302：请求重定向 404：服务器收到请求，但找不到对应资源（url错误） 500：服务器收到请求，服务器内部出现错误（代码错误） 7.4 MIME类型 介绍 是HTTP协议中的数据类型 MIME（Multipurpose Internet Mail Extensions），多功能Internet邮件扩展服务 MINE格式：大类型/小类型 文件 后缀名 MINE类型 超文本标记语言文本 .html text/html 普通文本 .txt text/plain RTF文本 .rtf application/rtf GIF图形 .gif image/gif JPEG图形 .jpeg .jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 .mid .midi audio/midi audio/x-midi RealAudio音乐文件 .ra .ram audio/x-pn-realaudio MPEG文件 .mpg .mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar 8 HttpServletRequest类8.1 基本介绍 介绍 每有一个请求，tomcat会将请求封装到Request类中，传递给service()方法提供我们使用，可以通过HttpServletRequest获取请求信息 方法 说明 getRequestURI() 获取请求资源路径 getRequestURL() 获取完整的请求资源路径 getRemoteHost() 获取客户端ip地址 getHeader() 获取请求头 getParamter() 获取请求参数 getParamterValues() 获取请求参数（参数值为多个时使用） getMothed() 获取请求方式 getRequestDispatcher() 获取请求转发对象 注意 Post请求获取请求参数时，若参数为中文，会出现乱码；需要调用方法setCharaterEncoding(&quot;UTF-8&quot;)来进行设置request编码 8.2 请求转发 将当前请求按照要求，转发给其他服务器/servlet处理 1234567891011121314151617&lt;!-- 请求转发 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;ForwardServlet1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.letere.servlet.forward.ForwardServlet1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ForwardServlet1&lt;/servlet-name&gt; &lt;url-pattern&gt;/forward1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;ForwardServlet2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.letere.servlet.forward.ForwardServlet2&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ForwardServlet2&lt;/servlet-name&gt; &lt;url-pattern&gt;/forward2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 12345678910public class ForwardServlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 请求转发 // （1）转发到servlet req.getRequestDispatcher(&quot;/forward2&quot;).forward(req, resp); // （2）转发到资源文件【WEB-INF是不允许外部链接直接访问】 req.getRequestDispatcher(&quot;/WEB-INF/头像.jpg&quot;).forward(req, resp); &#125;&#125; 123456public class ForwardServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;这里是forwardServlet2&quot;); &#125;&#125; 9 HttpServletResponse类 用于设置返回数据给客户端 9.1 两种输出流 字节流：用于返回文件，进行下载 字符流：用户返回字符串 注意：两种流一次只能使用一个，不能同时使用 123456789public class ResponseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // （1）字节流：传入字节数组 resp.getOutputStream().write(new byte[1]); // （2）字符流：传入字符串 resp.getWriter().write(&quot;hello world!&quot;); &#125;&#125; 9.2 中文乱码 返回字符串为中文时，会出现乱码，需要进行设置 有两种解决方法，选择其中一种即可 1234567891011 public class ResponseServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // （1）服务器，浏览器分别设置“UTF-8” resp.setCharacterEncoding(&quot;UTF-8&quot;); resp.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); // （2）一步将服务器和浏览器设置为UTF-8 resp.setContentType(&quot;text/html; charset=UTF-8&quot;); resp.getWriter().write(&quot;你好啊！&quot;); &#125;&#125; 9.3 请求重定向 客户端发送请求，服务器告诉客户端此地址已转移，请访问新地址，此行为称为请求转发 重定向写法有两种，择其中一种即可 1234567891011121314151617&lt;!-- 重定向 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;RedirectServlet1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.letere.servlet.redirect.RedirectServlet1&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;RedirectServlet1&lt;/servlet-name&gt; &lt;url-pattern&gt;/redirect1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;RedirectServlet2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.letere.servlet.redirect.RedirectServlet2&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;RedirectServlet2&lt;/servlet-name&gt; &lt;url-pattern&gt;/redirect2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1234567891011public class RedirectServlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 请求重定向 // （1）状态码设置302，请求头设置location resp.setStatus(302); resp.setHeader(&quot;location&quot;, &quot;http://localhost:8080/6_Servlet/redirect2&quot;); // （2）一步到位 resp.sendRedirect(&quot;http://localhost:8080/6_Servlet/redirect2&quot;); &#125;&#125; 1234567public class RedirectServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html; charset=UTF-8&quot;); resp.getWriter().write(&quot;这是重定向后的Servlet!&quot;); &#125;&#125; 重定向特点 浏览器地址栏会发生变化 总共发送两次请求 10 Listener监听器 Listener是JavaEE规范，是接口 监听器作用是监听事务的变化，然后同回调函数执行相应的处理 12345678910111213// 1 创建一个类继承监听器（以ServletContextListener为例），实现其初始化和销毁方法public class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(&quot;web工程创建时调用&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(&quot;web工程销毁时调用&quot;); &#125;&#125; 1234&lt;!-- 在web.xml中配置监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;com.letere.listener.MyListener&lt;/listener-class&gt;&lt;/listener&gt; 11 知识补充11.1 base标签12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- base标签能够无视地址栏上的地址（最后的&#x27;/&#x27;不可省略）--&gt; &lt;base href=&quot;http://localhost:8080/6-Servlet/&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 直接以base标签为当前路径进行拼接 --&gt; &lt;a href=&quot;./头像.png&quot;&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】Tomcat","slug":"【JavaWeb】Tomcat","date":"2021-10-25T02:57:02.000Z","updated":"2021-10-25T09:34:06.211Z","comments":true,"path":"2021/10/25/【JavaWeb】Tomcat/","link":"","permalink":"https://letere-gzj.github.io/2021/10/25/%E3%80%90JavaWeb%E3%80%91Tomcat/","excerpt":"关于Tomcat的认识","text":"关于Tomcat的认识 1 web概念1.1 JavaWeb JavaWeb：指通过Java语言编写，可以通过浏览器访问的程序的总称，叫JavaWeb 请求request：指客户端给服务器发送数据 响应response：指服务器给客户端回传数据 请求和响应的关系：请求与响应是成对出现，有请求就会有响应 1.2 Web资源分类 静态资源：html、css、js、txt、mp4、jpg图片 动态资源：jsp页面、servlet程序 1.3 常用web服务器 Tomcat：由apache组织提供的一种web服务器，提供对jsp和servlet的支持，它是一种轻量级的JavaWeb容器，也是当前应用最广的JavaWeb服务器（免费） Jboss：是一个遵从JavaEE规范的、开发源代码的，纯Java的EJB服务器，支持所有的JavaEE规范（免费） GLassFish：由Oracle公司开发的一款JavaWeb服务器，是一款强健的商业服务器，达到产品级质量（应用很少） Resin：是由AUCHO公司的产品，是一个非常流行的服务器，对servlet和jsp提供了良好的支持，性能也比较优良，resin自身采用Java语言开发（收费，应用比较多） WebLogic：是Oracle公司的产品，是目前应用最广泛的Web服务器，支持JavaEE规范，而且不断的完善以适应新的开发需求，适合大型项目（收费，用的不多，适合大公司） 2 Tomcat入门2.1 下载安装 下载地址：https://tomcat.apache.org/ 安装：解压，配置环境变量CATALINA_HOME 2.2 目录介绍 2.3 使用 （1）进入tomcat目录/bin文件 （2）双击打开startup.bat，即已启动tomcat（若启动窗口乱码：解决方案 ) （2.1）启动方式也可以使用命令行运行catalina run （3）浏览器输入：http://localhost:8080 ，打开tomcat默认页面 3 Tomcat进阶3.1 修改启动端口号 打开tomcat目录/conf/server.xml文件 3.2 部署项目到tomcat 方法一：在tomcat目录/webapps目录下创建一个新的目录，将项目工程拷贝到该目录下 访问方法：http://localhost:8080/项目目录名/资源路径 方法二：在tomcat目录/conf/Catalina/localhost目录下，创建一个xml文件1234&lt;!-- docBase: 项目访问的本地路径--&gt;&lt;Context docBase=&quot;D:\\Environment\\Tomcat\\hello&quot;/&gt; 3.3 ROOT工程和index.html 若浏览器直接输入http://localhost:8080 ，后面没有接上项目名，默认是访问ROOT工程下的资源 若访问地址没有资源路径的话，会默认访问，项目的中的index.html文件 4 IDEA整合Tomcat （1）设置Tomcat服务器位置 （2）创建JavaWeb工程 首先创建一个普通的Java工程，右键新增web框架支持 （3）配置tomcat服务器启动 （4）启动测试 修改项目中的index.jsp，随便添加内容，方便确认启动成功 运行配置好的tomcat服务器（跟java程序运行一样），会自动弹出默认浏览器的页面 （5）设置热部署","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】XML","slug":"【JavaWeb】XML","date":"2021-10-24T05:31:11.000Z","updated":"2021-10-24T13:06:46.549Z","comments":true,"path":"2021/10/24/【JavaWeb】XML/","link":"","permalink":"https://letere-gzj.github.io/2021/10/24/%E3%80%90JavaWeb%E3%80%91XML/","excerpt":"关于xml的认识","text":"关于xml的认识 1 简介 xml介绍：xml是可拓展的标记性语言 xml作用 1、保存数据1234567891011&lt;!-- Student[id=1, name=&quot;张三&quot;] xml的数据保存方法 --&gt;&lt;students&gt; &lt;student&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;张三&lt;/name&gt; &lt;/student&gt; &lt;student&gt; &lt;id&gt;2&lt;/id&gt; &lt;name&gt;李四&lt;/name&gt; &lt;/student&gt;&lt;/students&gt; 2、作为项目/框架的配置文件 3、作为网络传输数据的格式（已淘汰，主流使用JSON） 2 语法 1、声明12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!-- version：版本号 encoding：编码--&gt; 2、标签命名规则 1 标签名可含有字母、数字、其他字符 2 不能以数字/标点符号开头 3 名称不能包含空格 3、根元素（没有父标签的元素）不能出现同名 4、文本区域（CDATA区） 告诉xml，里面的内容只是纯文本，不需要进行解析1&lt;![CDATA[ 输入字符，例如&#x27;&gt;&#x27;，&#x27;&lt;&#x27;，就不会进行解析，会直接显示 ]]&gt; 3 xml解析 xml为标记型文档，可以使用w3c组织制定的dom技术进行解析 3.1 dom4j解析 （1）依赖123456&lt;!-- https://mvnrepository.com/artifact/org.dom4j/dom4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; （2）准备xml文件123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!-- 解析数据 --&gt;&lt;books&gt; &lt;book id=&quot;1&quot;&gt; &lt;name&gt;java入门&lt;/name&gt; &lt;price&gt;99&lt;/price&gt; &lt;/book&gt; &lt;book id=&quot;2&quot;&gt; &lt;name&gt;javaweb&lt;/name&gt; &lt;price&gt;50&lt;/price&gt; &lt;/book&gt;&lt;/books&gt; （3）准备实体类123456789// 使用了lombok注解@Data@NoArgsConstructor@AllArgsConstructorpublic class Book &#123; private int id; private String name; private BigDecimal price;&#125; （4）运行解析案例123456789101112131415161718192021222324@Testpublic void parseTest() throws Exception&#123; // 1 创建SAXReader输入流，取出xml文件，从而生成Document对象（SAX：Simple Analysis for XML） SAXReader saxReader = new SAXReader(); Document document = saxReader.read(&quot;./src/main/resources/xml/sample.xml&quot;); // 2 获取根标签元素 Element rootElement = document.getRootElement(); // 3 查询特定子标签 List&lt;Element&gt; books = rootElement.elements(&quot;book&quot;); // 4 遍历标签，并获取里面的文本内容，封装为Book对象 for (Element book : books) &#123; // 获取标签属性值 int id = Integer.parseInt(book.attributeValue(&quot;id&quot;)); // 间接获取子标签文本 String name = book.element(&quot;name&quot;).getText(); // 直接获取子标签文本 BigDecimal price = new BigDecimal(book.elementText(&quot;price&quot;)); // 封装为Book对象并打印 System.out.println(new Book(id, name, price)); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】JQuery练习","slug":"【JavaWeb】JQuery练习","date":"2021-10-24T05:20:01.000Z","updated":"2021-10-24T05:29:14.609Z","comments":true,"path":"2021/10/24/【JavaWeb】JQuery练习/","link":"","permalink":"https://letere-gzj.github.io/2021/10/24/%E3%80%90JavaWeb%E3%80%91JQuery%E7%BB%83%E4%B9%A0/","excerpt":"jQuery学习中的小练习","text":"jQuery学习中的小练习 1 全选、全不选、反选1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 导入jQuery文件 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../jQuery/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 页面加载后执行 $(function () &#123; // 1、全选按钮单击事件 $(&quot;#checkAll&quot;).click(function () &#123; // 选项全选 $(&quot;#check&gt;input&quot;).prop(&quot;checked&quot;, true); // &quot;全选/全不选&quot;勾上 $(&quot;#AllOrAllNot&quot;).prop(&quot;checked&quot;, true); &#125;) // 2、全不选按钮单击事件 $(&quot;#checkAllNot&quot;).click(function () &#123; // 选项全不选 $(&quot;#check&gt;input&quot;).prop(&quot;checked&quot;, false); // &quot;全选/全不选&quot;不勾上 $(&quot;#AllOrAllNot&quot;).prop(&quot;checked&quot;, false); &#125;) // 3、反选按钮单击事件 $(&quot;#checkRev&quot;).click(function () &#123; // 选项遍历取反 $(&quot;#check&gt;input&quot;).each(function () &#123; this.checked = !this.checked; &#125;) // 判断反选过后是否全选/全不选 let len = $(&quot;#check&gt;input&quot;).length; let checkLen = $(&quot;#check&gt;input:checked&quot;).length; $(&quot;#AllOrAllNot&quot;).prop(&quot;checked&quot;, len === checkLen); &#125;) // 4、提交按钮单击事件 $(&quot;#post&quot;).click(function () &#123; let msg = &quot;喜欢的游戏为：&quot;; $(&quot;#check&gt;input:checked&quot;).each(function () &#123; msg = msg + &#x27;\\n&#x27; + this.value; &#125;) alert(msg); &#125;) // 5、选项勾选事件（导致全选or全不选） $(&quot;#check&gt;input&quot;).click(function () &#123; let len = $(&quot;#check&gt;input&quot;).length; let checkLen = $(&quot;#check&gt;input:checked&quot;).length; $(&quot;#AllOrAllNot&quot;).prop(&quot;checked&quot;, len === checkLen); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; 喜欢的游戏为：&lt;input type=&quot;radio&quot; id=&quot;AllOrAllNot&quot;/&gt;全选/全不选 &lt;div id=&quot;check&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;怪物猎人&quot;/&gt; 怪物猎人 &lt;input type=&quot;checkbox&quot; value=&quot;合金装备&quot;/&gt; 合金装备 &lt;input type=&quot;checkbox&quot; value=&quot;孤岛惊魂&quot;/&gt; 孤岛惊魂 &lt;input type=&quot;checkbox&quot; value=&quot;耻辱&quot;/&gt; 耻辱 &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;button&quot; id=&quot;checkAll&quot; value=&quot;全选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;checkAllNot&quot; value=&quot;全不选&quot;/&gt; &lt;input type=&quot;button&quot; id=&quot;checkRev&quot; value=&quot;反选&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;post&quot; value=&quot;提交&quot; /&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2 左移、右移1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;左移、右移&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../jQuery/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 页面加载完进行 $(function () &#123; // 1、&quot;选中右移&quot;单击事件 $(&quot;#selectRM&quot;).click(function () &#123; $(&quot;#left&gt;option:checked&quot;).appendTo(&quot;#right&quot;); &#125;); // 2、&quot;全部右移&quot;单击事件 $(&quot;#allRM&quot;).click(function () &#123; $(&quot;#left&gt;option&quot;).appendTo(&quot;#right&quot;); &#125;); // 3、&quot;选中左移&quot;单击事件 $(&quot;#selectLM&quot;).click(function () &#123; $(&quot;#right&gt;option:checked&quot;).appendTo(&quot;#left&quot;); &#125;); // 4、&quot;全部左移&quot;单击事件 $(&quot;#allLM&quot;).click(function () &#123; $(&quot;#right&gt;option&quot;).appendTo(&quot;#left&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;div style=&quot;float: left&quot;&gt; &lt;select multiple=&quot;multiple&quot; id=&quot;left&quot; style=&quot;width: 70px; height: 88px; text-align: center&quot;&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;option value=&quot;D&quot;&gt;D&lt;/option&gt; &lt;option value=&quot;E&quot;&gt;E&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;input type=&quot;button&quot; id=&quot;selectRM&quot; value=&quot;选中右移&quot;&gt; &lt;br/&gt; &lt;input type=&quot;button&quot; id=&quot;allRM&quot; value=&quot;全部右移&quot;&gt; &lt;/div&gt; &lt;div style=&quot;float: left; margin-left: 10px&quot;&gt; &lt;select multiple=&quot;multiple&quot; id=&quot;right&quot; style=&quot;width: 70px; height: 88px; text-align: center&quot;&gt; &lt;/select&gt; &lt;br/&gt; &lt;input type=&quot;button&quot; id=&quot;selectLM&quot; value=&quot;选中左移&quot;&gt; &lt;br/&gt; &lt;input type=&quot;button&quot; id=&quot;allLM&quot; value=&quot;全部左移&quot;&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】JQuery","slug":"【JavaWeb】JQuery","date":"2021-10-24T05:09:47.000Z","updated":"2021-10-24T05:18:41.308Z","comments":true,"path":"2021/10/24/【JavaWeb】JQuery/","link":"","permalink":"https://letere-gzj.github.io/2021/10/24/%E3%80%90JavaWeb%E3%80%91JQuery/","excerpt":"关于jQuery的使用进行简单介绍","text":"关于jQuery的使用进行简单介绍 1 jQuery初认识1.1 jQuery介绍 jQuery： 顾名思义，就是JavaScript和Query（查询），是辅助JavaScript开发的js类库 jQuery核心思想： write less, do more（写得更少，做得更多） jQuery好处： 免费，开源，语法设计可以使开发更加便捷 1.2 jQuery下载 Github： https://github.com/jquery/jquery/tags （需要自行转变成js文件） jQuery博客： https://blog.jquery.com/2021/03/02/jquery-3-6-0-released/ （浏览器ctrl + s保存下载） jQuery文件： 一个没有带‘min’，是标准文件，排版注释都工整，一般开发中使用。带’min’，是经过极简压缩后的文件，文件很小，适合项目部署时使用 jQuery引用：123456789&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jQuery初体验&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jQuery/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // js代码... &lt;/script&gt;&lt;/head&gt; 1.3 jQuery核心函数 $() 是jQuery的核心函数，能够完成jQuery的很多功能，根据传入的参数不同，效果也会不同 1、传入参数为函数时：表示页面加载完成之后，相当于原生js的window.onload = function()&#123;&#125;123$(function () &#123; // 页面加载完后的操作...&#125;) 2、传入参数为HTML字符串时：根据html字符串构建元素节点对象 1234$(function () &#123; // 通过js构建button元素 $(&quot;&lt;button&gt;click me&lt;/button&gt;&quot;).appendTo(&quot;body&quot;);&#125;) 3、传入参数为选择器字符串时：根据对应的选择器获取标签对象 12345678$(function () &#123; // id选择器，通过id获取标签对象 let $id = $(&quot;#id属性值&quot;); // 类选择器，通过class属性查询标签对象 let $class = $(&quot;.class属性值&quot;); // 标签名选择器，根据标签名获取标签对象 let $element = $(&quot;标签名&quot;);&#125;) 4、传入的参数为DOM对象时：会转变成jQuery对象12345$(function () &#123; // 转变成jQuery对象 let btnObj = document.getElementById(&quot;btn&quot;); let $btnObj = $(btnObj);&#125;) 1.4 Dom对象和jQuery对象 jQuery对象本质： jQuery对象是Dom对象的数组 + jQuery自带的一些功能函数123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;dom对象和jQuery对象&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;jQuery/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // dom对象 window.onload = function () &#123; let btn = document.getElementById(&quot;btn&quot;); console.log(&quot;这里是dom对象&quot;) console.log(btn) &#125; // jQuery对象 $(function () &#123; let $btn = $(&quot;#btn&quot;); console.log(&quot;这里是jQuery对象&quot;) console.log($btn); console.log($btn[0]); // jQuery对象数组0号位元素就是dom对象 &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2 jQuery选择器2.1 基础选择器 1 基本选择器 就是上面的通过id，标签，class名进行获取对象，称为基础选择器 而且可以进行组合使用，用,进行隔开1234$(function () &#123; // 组合选择器 let $group = $(&quot;#id名&quot;, &quot;标签名&quot;, &quot;.class名&quot;);&#125;) 2 层级选择器 1、在给定的祖先元素下匹配所有后代元素：$(&quot;祖父元素 后代元素&quot;) 例：查找form表达下所有input元素，$(&quot;form input&quot;) 2、在给定的父元素匹配所有子元素：$(&quot;父元素 &gt; 子元素&quot;) 3、匹配所有紧接在A元素后的B元素：$(&quot;A元素 + B元素&quot;) 4、匹配所有在A元素后，且与A元素同辈的B元素：$(&quot;A元素 ~ B元素&quot;) 2.2 过滤选择器 1 基本过滤器 获取所有同名标签的第一个元素：$(&quot;元素名:first&quot;) 获取所有同名标签的最后一个元素：$(&quot;元素名:last&quot;) 去除与给定选择器匹配的元素：$(&quot;元素名:not(筛选元素)&quot;) 匹配所有索引值为奇数的元素，从0开始计算：$(&quot;元素名:even&quot;) 匹配所有索引值为偶数的元素，从0开始计算：$(&quot;元素名:odd&quot;) 匹配给定索引值的元素：$(&quot;元素名:eq(索引值)&quot;) 匹配所有大于给定索引值的元素：$(&quot;元素名:gt(索引值)&quot;) 匹配所有小于给定索引值的元素：$(&quot;元素名:lt(索引值)&quot;) 匹配所有标题标签：$(&quot;:header&quot;) 匹配所有正在执行动画效果的元素：$(&quot;:animated&quot;) 2 内容过滤器 匹配包含给定文本的元素：$(&quot;:contains(&#39;文本内容&#39;)&quot;) 匹配空文本元素/不包含子元素的元素：$(&quot;:empty&quot;) 匹配非空文本元素/包含子元素的元素：$(&quot;:parent&quot;) 匹配含有指定子元素的父元素：$(&quot;:has(指定元素)&quot;) 3 属性过滤器 匹配含有指定属性的元素：$(&quot;元素名[属性名]&quot;) 匹配含有指定属性，且属性值等于指定值的元素：$(&quot;元素名[属性名=&#39;属性值&#39;]&quot;) 匹配不含有指定属性，或属性值不等于指定值的元素：$(&quot;元素名[属性名!=&#39;属性值&#39;]&quot;) 匹配含有指定属性，且属性值以指定值为开头的元素：$(&quot;元素名[属性名^=&#39;属性值&#39;]&quot;) 匹配含有指定属性，且属性值以指定值为结尾的元素：$(&quot;元素名[属性名$=&#39;属性值&#39;]&quot;) 匹配含有指定属性，且属性值包含指定值的元素：$(&quot;元素名[属性名*=&#39;属性值&#39;]&quot;) 上面内容可以复合使用 4 表单过滤器 匹配所有的input、textarea，select和button元素：$(&quot;:input&quot;) 匹配所有的单行文本框：$(&quot;:text&quot;) 匹配所有密码框：$(&quot;:password&quot;) 匹配所有单选按钮：$(&quot;:radio&quot;) 匹配所有复选框：$(&quot;:checkbox&quot;) 匹配所有提交按钮：$(&quot;:submit&quot;) 匹配所有重置按钮：$(&quot;:reset&quot;) 匹配所有文件域：$(&quot;:file&quot;) 匹配所有选中的元素（单选，多选）：$(&quot;:checked&quot;) 匹配选中的option元素：$(&quot;:selected&quot;) 3 jQuery方法3.1 元素筛选 元素筛选跟前面的选择器区别不大，只是书写的方法有差异12// 示例$(&quot;元素名&quot;).方法(&quot;匹配条件&quot;) eq(序号)：获取匹配指定序号的元素 first()：获取匹配的第一个元素 last()：获取匹配的最后一个元素 filter(过滤条件)：按照过滤条件获取匹配的元素 is(判断条件)：按照判断条件匹配元素，元素存在返回true has(匹配条件)：获取匹配到元素的父元素 not(匹配条件)：获取除了匹配元素外的所有元素 children(匹配条件)：获取匹配元素的子元素 find(匹配条件)：获取匹配元素的后代元素 next()：获取当前元素的紧邻的下一个同辈元素 nextAll()：获取当前元素后面所有的同辈元素 nextUntil(匹配条件)：获取当前元素到匹配元素之间的所有元素（开区间） parent()：获取当前元素的父元素 prev()：获取当前元素的紧邻的上一个同辈元素 prevAll()：获取当前元素前面所有的同辈元素 prevUntil(匹配条件)：获取匹配元素到当前元素之间的所有元素（开区间） silblings()：获取当前元素所有的同辈元素 add(匹配条件)：把匹配到的元素添加到前面额jQuery对象中 3.2 属性操作 html()：设置/获取当前元素内的所有内容（不传参数为获取，传参为设置） text()：设置/获取当前元素内的所有文本内容（不传参为获取，传参为设置） val()：设置/获取表单项（input之类）元素内的值（不传参为获取，传参为设置） attr()：设置/获取元素中的属性值（传1个参数为获取，传2个参数为设置） prop()：跟attr()方法效果一样，但设置/获取参数只能为true/false 3.3 dom对象的增删改 内部插入 A.appendTo(B)：添加A到B数组的末尾（A是B的子元素） A.prependTo(B)：添加A到B数组的开头（A是B的子元素） 外部插入 A.insertAfter(B)：添加A到B的后一位（A、B同辈） A.insertBefore(B)：添加A到B的前一位（A、B同辈） 替换 A.replaceWith(B)：B替换A A.replaceAll(B)：A替换匹配到的所有B 删除 A.remove()：删除A元素 A.empty()：清空A元素的内容 4 CSS样式操作 addClass()：添加样式 removeClass()：删除样式 toggleClass()：有就删除，没有就添加样式 offset()：获取和设置元素的坐标 5 动画操作 基本动画 show()：显示隐藏的元素 hide()：隐藏显示的元素 toggle()：是可见的元素就隐藏，反之不可见就显示 上面动画可以添加参数： 参数1 - 执行时间，毫秒为单位 参数2 - 动画回调函数，即执行动画后自动执行的函数 过渡动画 fadeIn()：淡入 fadeOut()：淡出 fadeToggle()：淡入/淡出 fadeTo(时间，透明度，(回调函数))：在指定时间内，将透明度（0-1）修改到指定值 6 jQuery事件6.1 页面加载后事件12345// 原生jswindow.onload = function () &#123;&#125;// jQuery$(function () &#123;&#125;) 触发顺序 jQuery页面加载后事件比原生js页面加载后事件先执行 触发时间 jQuery的页面加载后事件是浏览器内核解析完页面的标签，创建好dom对象之后就会执行 原生js的页面加载后事件除了要解析完页面的标签，创建好dom对象外，还要等标签显示需要的内容（例如：图片）加载完后才执行 执行次数 多个jQuery页面加载后事件，会每个事件都会执行一遍 多个原生js页面加载后事件，只会执行最后一个事件 6.2 jQuery常用事件1234567891011121314click() // 可以绑定单击事件（参数：函数），以及触发单击事件（不传参数）mouseover() // 鼠标移入事件mouseout() // 鼠标移出事件bind() // 可以给元素一次性绑定一个/多个事件// 示例：$(&quot;div&quot;).bind(&quot;click&quot;, function () &#123;&#125;); 多个事件在事件名&quot;click&quot;后面用空格隔开，继续填写unbind() // 与bind()方法相反，不绑定事件one() // 使用方法和bind一样，但是one绑定的事件只会触发一次live() // 使用方法和bind一样，只要是live匹配的元素，就算是后面动态创建的新元素，也会带有live绑定的事件 6.3 事件相关知识 1 事件冒泡 介绍：父子元素同时监听同一种事件（例如click()），若子元素触发了事件，父元素也会跟着触发事件 阻止方法：子元素函数体内使用return false可以解决 2 事件对象 介绍：事件触发时，会产生一个事件对象，内封装了触发事件信息的js对象 获取方法：只要在事件触发函数中，添加一个参数（function (event) {}），该参数就是事件对象","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【教程】Vue+Springboot项目部署","slug":"【教程】Vue-Springboot项目部署","date":"2021-10-20T11:24:08.000Z","updated":"2021-10-20T16:54:45.179Z","comments":true,"path":"2021/10/20/【教程】Vue-Springboot项目部署/","link":"","permalink":"https://letere-gzj.github.io/2021/10/20/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91Vue-Springboot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/","excerpt":"关于Vue+Springboot前后端分离的项目如何部署在服务器的教程","text":"关于Vue+Springboot前后端分离的项目如何部署在服务器的教程 1 服务器环境搭建 安装java环境 安装mysql数据库 https://blog.csdn.net/qq_38591756/article/details/82958333 安装nginx https://letere.gitee.io/blog/2021/07/19/【Nginx】Nginx入门 2 项目打包2.1 Vue项目 Vue项目在命令行（cmd）执行指令npm run build即可 打包完成后会在项目中自动生成一个dist文件 2.2 Springboot项目 方式一： 通过Maven指令mvn package即可 方式二： 通过IDEA整合的Maven打包，点开IDEA窗口最右侧的maven 无论是方式一还是方式二，打包后的文件会在项目/target目录下 打包小技巧1：跳过测试 打包时，会自动执行我们写的测试文件中的测试，非常的耗时，可以在pom.xml中设置跳过测试123456&lt;project&gt; &lt;properties&gt; &lt;!-- 打包跳过测试 --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/properties&gt;&lt;/project&gt; 打包小技巧2：配置文件外放 打包后的jar如果配置文件（application.yaml 或 application.properties）不外放，修改一次参数就要重新打包，十分麻烦 外放配置文件，只需将配置文件放在jar包同级目录，或创建config文件夹，将配置文件放在里面 3 项目部署 将所有打包好的文件上传到服务器，上传软件可以使用xftp 3.1 Vue项目部署 1 修改nginx.conf文件 路径：”/usr/local/nginx/conf”，根据安装方式不同，路径位置可能不同12345678910111213141516server &#123; listen 5000; # 项目端口号，按照实际情况进行填写 server_name localhost; location / &#123; root /opt/java-project/blog/dist; # vue项目打包的dist文件夹路径，按照实际情况进行填写 index index.html index.html; try_files $uri $uri/ /index.html; &#125; # 跨域处理，根据vue文件中的跨域操作进行填写 location /api &#123; rewrite ^.+api/?(.*)$ /$1 break; proxy_pass http://localhost:8080; &#125;&#125; 2 启动nginx 切换路径到”/usr/local/nginx/sbin”，输入指令 ./nginx，自动会在后台挂起，终端关闭也不会停止程序 通过公网ip地址:端口号即可访问vue项目 注意 若项目无法访问，查看防火墙是否开启，若开启则需要将项目端口开放，或关闭防火墙 阿里云的话，liunx中的防火墙是关闭的，但在外面套了一个阿里的防火墙，需要在那里开放端口 3.2 Springboot项目部署 修改好配置文件（数据库地址等等）后，切换目录到jar包目录中，执行指令 nohup java -jar jar包文件名 &amp; ，即可将程序在后台挂起，终端关闭不会停止程序","categories":[{"name":"教程","slug":"教程","permalink":"https://letere-gzj.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"【MySQL】常见问题解决","slug":"【MySQL】常见问题解决","date":"2021-10-19T07:38:24.000Z","updated":"2021-10-19T14:45:16.216Z","comments":true,"path":"2021/10/19/【MySQL】常见问题解决/","link":"","permalink":"https://letere-gzj.github.io/2021/10/19/%E3%80%90MySQL%E3%80%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"关于个人使用mysql中遇到的问题总结并进行处理","text":"关于个人使用mysql中遇到的问题总结并进行处理 1 密码策略 在修改密码的时候，想修改比较简单的密码修改失败，是因为mysql的密码策略原因 12# 查看密码策略SHOW VARIABLES LIKE &#x27;validate_password%&#x27;; 12# 修改策略set global 策略名=值; 2 远程连接 mysql账号默认是本地连接，远程连接需要自行开启 12345678# 创建一个新的账号（非必须）create user &#x27;账号&#x27;@&#x27;%&#x27; identified by &#x27;密码&#x27;;# 赋予账号权限grant all PRIVILEGES on *.* to &#x27;账号&#x27;@&#x27;%&#x27; with grant option;# 刷新权限flush privileges;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【RabbitMQ】集群","slug":"【RabbitMQ】集群","date":"2021-08-12T06:14:27.000Z","updated":"2021-08-12T08:55:16.045Z","comments":true,"path":"2021/08/12/【RabbitMQ】集群/","link":"","permalink":"https://letere-gzj.github.io/2021/08/12/%E3%80%90RabbitMQ%E3%80%91%E9%9B%86%E7%BE%A4/","excerpt":"关于RabbitMQ集群的实现方法","text":"关于RabbitMQ集群的实现方法 1 集群1.1 环境准备 （1）克隆虚拟机 虚拟机管理界面，右键虚拟机 -&gt; 管理 -&gt; 克隆 （2）修改机器hostname12# 修改两台机器hostname用于区分vim /etc/hostname （3）保存主机地址12345# 将另外机器的ip地址保留，方便通讯vim /ect/hosts# 格式ip地址 hostname （4）确保机器cookies文件一致12# 确定好以一台主机为准，将该机器文件复制到其他机器上scp /var/lib/rabbitmq/.erlang.cookie root@主机名:/var/lib/rabbitmq/.erlang.cookie （5）rabbitmq重启1rabbitmq-server -detached 1.2 集群 （1）加入集群1234567891011# 暂停rabbitmq_apprabbitmqctl stop_app# 重置rabbitmqctk reset# 集群加入到其他rabbitmqrabbitmqctl join_cluster rabbit@主机名# 启动rabbitmq_apprabbitmqctl start_app （2）查看集群状态1rabbitmqctl cluster_status （3）集群设置用户12345678# 创建账号rabbitmqctl add_user 用户名 密码# 设置用户角色rabbitmqctl set_user_tags 用户名 角色（administrator）# 设置用户权限rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 1.3 脱离集群 （1）解除1234567891011# 停止rabbitmq apprabbitmqctl stop_app# 重置rabbitmqctl reset# 开启rabbitmq apprabbitmqctl start_app# 解除集群（主集群机器运行）rabbitmqctl forget_cluster_node rabbit@主机名 2 镜像队列2.1 概念 镜像队列： 将主服务创建的队列，和消息备份到另一个从服务上，该从服务的队列就为镜像队列，避免主服务宕机，导致数据丢失以及服务不可用 2.2 实现方法 3 负载均衡 此为nginx的内容，故不多细说，有需去查看之前nginx文章 4 Federation4.1 概念 Federation： 翻译过来为“联合”，可以理解为同步。例：为了减少网络延迟，不同地区部署不同的rabbitmq，但需要这些不同地区的rabbitmq的数据进行同步，否则更改地区之后，数据不一致。 4.2 步骤 （1）插件开启12rabbitmq-plugins enable rabbitmq_federationrabbitmq-plugins enable rabbitmq_federation_management （2）添加同步数据上游 上游数据会同步到下游 （3）配置上游（连接） federation交换机或队列都可以（2者选其1） 5 Shovel5.1 概念 Shovel： 翻译为“铲子”。功能和federation一样，也是数据同步。只是操作步骤比federation简单明了，只需配置源和目的地，会自动将源的消息同步到目的地中 5.2 配置 （1）插件开启12rabbitmq-plugins enable rabbitmq_shovelrabbitmq-plugins enable rabbitmq_shovel_management （2）配置源与目的地","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】其他知识点","slug":"【RabbitMQ】其他知识点","date":"2021-08-12T06:01:38.000Z","updated":"2021-08-12T06:03:08.821Z","comments":true,"path":"2021/08/12/【RabbitMQ】其他知识点/","link":"","permalink":"https://letere-gzj.github.io/2021/08/12/%E3%80%90RabbitMQ%E3%80%91%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"关于RabbitMQ比较杂碎的知识点的补充","text":"关于RabbitMQ比较杂碎的知识点的补充 1 幂等性1.1 概念 例：用户购买商品，下单支付，点击支付后，钱扣了，但界面显示网络异常，用户刷新界面，重新点击付钱。此时再次扣钱，也形参两条流水线（以前单应用系统可以通过数据库事控制） 1.2 消息重复消费 消息重复消费： MQ把消息发送给消费者，在消费者发送ack应答时，网络中断了，故MQ未收到消息，该条消息重新发送到消费者，可消费者本质上是已经成功消费了消息 解决思路： 使用全局ID（唯一标识的时间戳，UUID，MQ自身的id）来进行判断，判断是否已经消费过该消息 1.3 幂等性主流解决 （1）唯一ID + 指纹码机制 指纹码为一些规则或时间戳加别的服务给到的唯一信息码，保证唯一性。利用数据库查询此id是否存在数据库中 优点：方式简单，就一个简单的拼接 缺点：在高并发的情况下，单个数据库读写性能会出现瓶颈 （2）Redis原子性 利用redis执行setnx命令，天然具有幂等性，从而不重复消费 2 优先级队列2.1 介绍 顾名思义，优先级队列中消息存在优先级，优先级高的消息，更早从MQ中发送到消费者 使用场景： 订单催付，如果下订单的是大客户，优先发送消息叫客户支付，避免客户反悔取消订单。 2.2 代码 （1）yaml123456spring: rabbitmq: host: 192.168.85.130 port: 5672 username: guest password: guest （2）配置类1234567891011121314151617181920212223242526272829303132333435363738394041@Configurationpublic class PriorityQueueConfig &#123; /** * 构建优先级交换机 * @return DirectExchange */ @Bean public DirectExchange priorityExchange() &#123; return ExchangeBuilder .directExchange(&quot;priority_exchange&quot;) .build(); &#125; /** * 构建优先级队列 * @return Queue */ @Bean public Queue priorityQueue() &#123; return QueueBuilder .nonDurable(&quot;priority_queue&quot;) .maxPriority(10) // 设置最大优先级 .build(); &#125; /** * 绑定优先级交换机和队列 * @param priorityExchange 优先级交换机 * @param priorityQueue 优先级队列 * @return Binding */ @Bean public Binding priorityBinding(@Qualifier(&quot;priorityExchange&quot;) DirectExchange priorityExchange, @Qualifier(&quot;priorityQueue&quot;) Queue priorityQueue) &#123; return BindingBuilder .bind(priorityQueue) .to(priorityExchange) .with(&quot;priority&quot;); &#125;&#125; （3）生产者1234567891011121314151617181920212223242526272829@RestControllerpublic class ProducerController &#123; @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(&quot;/sendMsg&quot;) public String sendMsg() &#123; // map存储消息，key=消息，value=优先级 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;消息-1&quot;, 5); map.put(&quot;消息-2&quot;, 7); map.put(&quot;消息-3&quot;, 0); for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; rabbitTemplate.convertAndSend( &quot;priority_exchange&quot;, &quot;priority&quot;, entry.getKey(), message -&gt; &#123; // 设置消息优先级 message.getMessageProperties().setPriority(entry.getValue()); return message; &#125;); &#125; return &quot;消息发送成功&quot;; &#125;&#125; （4）消费者12345678910111213@Slf4j@Componentpublic class Consumer &#123; /** * 监听优先级队列，并接收消息 * @param message 消息 */ @RabbitListener(queues = &quot;priority_queue&quot;) public void receivePriorityMsg(Message message) &#123; log.info(&quot;消费者 --- 接收消息：&#123;&#125;&quot;, new String(message.getBody())); &#125;&#125; 2.3 测试 先把消费者部分的代码注释掉，启动程序，调用接口http://localhost:8080/sendMsg发送信息 然后再将消费者的注释去掉，重启程序，查看消费者接收消息的顺序 3 惰性队列3.1 概念 惰性队列： 将消息存放在磁盘上，可以减少内存的消耗，但相对的会降低消息的处理速度 3.2 代码 （1）配置类123456789101112131415@Configurationpublic class LazyQueueConfig &#123; /** * 构建惰性队列 * @return Queue */ @Bean public Queue lazyQueue() &#123; return QueueBuilder .nonDurable(&quot;lazy_queue&quot;) .lazy() // 堕性队列 .build(); &#125;&#125;","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】发布确认高级","slug":"【RabbitMQ】发布确认高级","date":"2021-08-11T00:53:54.000Z","updated":"2021-08-11T12:15:19.392Z","comments":true,"path":"2021/08/11/【RabbitMQ】发布确认高级/","link":"","permalink":"https://letere-gzj.github.io/2021/08/11/%E3%80%90RabbitMQ%E3%80%91%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7/","excerpt":"此篇为发布确认的知识补充，对在springboot实现发布确认，以及发布失败如何进行消息的重新发送的介绍","text":"此篇为发布确认的知识补充，对在springboot实现发布确认，以及发布失败如何进行消息的重新发送的介绍 1 环境准备1.1 依赖123456789101112131415161718&lt;!--web启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--rabbitmq springboot启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--lombok注解--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 yaml配置123456spring: rabbitmq: host: 192.168.85.130 port: 5672 username: guest password: guest 1.3 定义交换机与队列123456789101112131415161718192021222324252627282930313233343536373839@Slf4j@Configurationpublic class ConfirmConfig &#123; /** * 创建交换机 * @return DirectExchange */ @Bean(&quot;confirmExchange&quot;) public DirectExchange confirmExchange() &#123; return new DirectExchange(&quot;confirm_exchange&quot;); &#125; /** * 创建队列 * @return Queue */ @Bean public Queue confirmQueue() &#123; return QueueBuilder .nonDurable(&quot;confirm_queue&quot;) .build(); &#125; /** * 绑定交换机和队列 * @param confirmExchange 交换机 * @param confirmQueue 队列 * @return Binding */ @Bean public Binding queueToExchange(@Qualifier(&quot;confirmExchange&quot;) DirectExchange confirmExchange, @Qualifier(&quot;confirmQueue&quot;) Queue confirmQueue) &#123; return BindingBuilder .bind(confirmQueue) .to(confirmExchange) .with(&quot;confirm&quot;); &#125;&#125; 1.4 生产者123456789101112131415@Slf4j@RestController@RequestMapping(&quot;/confirm&quot;)public class ProducerController &#123; @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(&quot;/sendMessage&quot;) public String sendMessage(String message) &#123; rabbitTemplate.convertAndSend(&quot;confirm_exchange&quot;, &quot;confirm&quot;, message); log.info(&quot;生产者 --- 发送消息为：&#123;&#125;&quot;, message); return &quot;消息发送成功！&quot;; &#125;&#125; 1.5 消费者123456789@Slf4j@Componentpublic class Consumer &#123; @RabbitListener(queues = &quot;confirm_queue&quot;) public void receiveMessage(Message message) &#123; log.info(&quot;消费者 --- 接收消息为：&#123;&#125;&quot;, new String(message.getBody())); &#125;&#125; 2 发布确认确认生产者是否成功发布消息到交换机 2.1 配置 （1）yaml配置1234spring: rabbitmq: # ...... publisher-confirm-type: correlated # 开启发布确认，消息成功发送到交换机后触发回调函数 （2）自定义发布确认函数12345678910111213141516171819202122232425262728293031@Slf4j@Componentpublic class MyConfirmCallBack implements RabbitTemplate.ConfirmCallback &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 配置确认回调函数 */ @PostConstruct public void init() &#123; rabbitTemplate.setConfirmCallback(this); &#125; /** * 发布确认回调函数 * @param data 发送消息相关信息 * @param ack ack应答 * @param cause 失败原因 */ @Override public void confirm(CorrelationData data, boolean ack, String cause) &#123; String id = data == null ? &quot;&quot; : data.getId(); if (ack) &#123; log.info(&quot;交换机 --- 消息接收成功，消息id为：&#123;&#125;&quot;, id); &#125; else &#123; log.info(&quot;交换机 --- 消息接收失败，消息id为：&#123;&#125;，失败原因为：&#123;&#125;&quot;, id, cause); &#125; &#125;&#125; （3）消息发送添加具体参数123456789101112131415161718@Slf4j@RestController@RequestMapping(&quot;/confirm&quot;)public class ProducerController &#123; // ...... @GetMapping(&quot;/sendMessage&quot;) public String sendMessage(String message) &#123; // 发布确认回调需要的信息 CorrelationData correlationData = new CorrelationData(); correlationData.setId(String.valueOf(System.currentTimeMillis())); rabbitTemplate.convertAndSend(&quot;confirm_exchange&quot;, &quot;confirm&quot;, message, correlationData); log.info(&quot;生产者 --- 发送消息为：&#123;&#125;&quot;, message); return &quot;消息发送成功！&quot;; &#125;&#125; 2.2 测试 项目启动，浏览器输入地址：http://localhost:8080/confirm/sendMessage?message=交换机消息发布确认 3 消息回退上面的发布确认能保证消息发送到交换机没有问题，但不能保证消息从交换机发送到队列没有问题，而消息回退在消息发送到队列出现问题时，会调用消息回退函数，进行处理 3.1 配置 （1）yaml配置1234spring: rabbitmq: # ...... publisher-returns: true # 开启消息回退 （2）自定义消息回退函数123456789101112131415161718192021222324@Slf4j@Componentpublic class MyReturnCallBack implements RabbitTemplate.ReturnsCallback &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 消息回退注入 */ @PostConstruct public void init() &#123; rabbitTemplate.setReturnsCallback(this); &#125; /** * 消息回退方法 * @param returnedMessage 回退信息 */ @Override public void returnedMessage(ReturnedMessage returnedMessage) &#123; log.info(&quot;被回退消息：&#123;&#125;，原因为：&#123;&#125;&quot;, new String(returnedMessage.getMessage().getBody()), returnedMessage.getReplyText()); &#125;&#125; 3.2 测试 在发送消息时，修改发送消息的routingkey，来故意让消息发送不到队列中，来检测消息回退是否触发 4 备份交换机当发送消息给队列无法接收时，除了可以设置消息回退外，还可以设置备份交换机。交换机会自动将无法接收的消息，转发到备份交换机，交给备份交换机处理。【备份交换机优先级大于消息回退】 4.1 配置 （1）配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Slf4j@Configurationpublic class ConfirmConfig &#123; // ...... /** * 创建交换机，并关联备份交换机 * @return DirectExchange */ @Bean(&quot;confirmExchange&quot;) public DirectExchange confirmExchange() &#123;// return new DirectExchange(&quot;confirm_exchange&quot;); return ExchangeBuilder .directExchange(&quot;confirm_exchange&quot;) // 交换机类型，以及交换机名 .alternate(&quot;backup_exchange&quot;) // 备份交换机名 .build(); &#125; /** * 创建备份交换机 * @return DirectExchange */ @Bean(&quot;backupExchange&quot;) public FanoutExchange backupExchange() &#123; return new FanoutExchange(&quot;backup_exchange&quot;); &#125; /** * 创建备份队列 * @return Queue */ @Bean(&quot;backupQueue&quot;) public Queue backupQueue() &#123; return QueueBuilder .nonDurable(&quot;backup_queue&quot;) .build(); &#125; /** * 绑定备份交换机和备份队列 * @param backupExchange 备份交换机 * @param backupQueue 备份队列 * @return Binding */ @Bean public Binding backupBinding(@Qualifier(&quot;backupExchange&quot;) FanoutExchange backupExchange, @Qualifier(&quot;backupQueue&quot;) Queue backupQueue) &#123; return BindingBuilder .bind(backupQueue) .to(backupExchange); &#125;&#125; （2）消费者123456789101112131415@Slf4j@Componentpublic class Consumer &#123; // ...... /** * 接收备份队列的消息 * @param message 消息 */ @RabbitListener(queues = &quot;backup_queue&quot;) public void receiveBackupMsg(Message message) &#123; log.info(&quot;消费者（备份） --- 接收消息为：&#123;&#125;&quot;, new String(message.getBody())); &#125;&#125; 4.2 测试 还是和前面的消息回退一样，故意填写错routingKey，测试交换机是否将消息转发到备份交换机","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】延迟队列","slug":"【RabbitMQ】延迟队列","date":"2021-08-09T05:26:08.000Z","updated":"2021-08-10T13:46:02.974Z","comments":true,"path":"2021/08/09/【RabbitMQ】延迟队列/","link":"","permalink":"https://letere-gzj.github.io/2021/08/09/%E3%80%90RabbitMQ%E3%80%91%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/","excerpt":"关于RabbitMQ中延迟队列的介绍和实现","text":"关于RabbitMQ中延迟队列的介绍和实现 1 延迟队列1.1 概念 延迟队列中最主要的特征体现在其延迟性上，希望队列中的元素达到指定时间后或之前进行取出和处理 通俗来说，延迟队列为存放需要在指定时间被处理元素的队列 1.2 使用场景 订单在十分钟之内未支付则自动取消 新创建的店铺，如果在十天之内未上传过商品，则自动发送消息提醒 用户注册成功后，如果三天内没有登陆，则进行短信提醒 用户发起退款，如果三天内没有得到处理，则通知相关运营人员 预定会议后，需要在预定时间前十分钟通知人员，参加会议 1.3 关系图 可以看出，延迟队列的本质就是死信队列中ttl过期，延迟的时间就是ttl的时间，从而达到延迟的效果 所以创建有两种方法：1队列设置ttl过期时间；2生产者发送消息设置消息的ttl过期时间 2 队列设置ttl2.1 代码架构 2.2 依赖引入123456789101112131415161718&lt;!--web启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--rabbitmq springboot启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--lombok注解--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 2.3 关系配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 延迟队列配置类 * @author letere * @create 2021-08-08 14:12 */@Configurationpublic class DelayQueueConfig &#123; /** * 构建普通交换机X * @return DirectExchange */ @Bean(&quot;xExchange&quot;) public DirectExchange xExchange() &#123; return new DirectExchange(&quot;X&quot;); &#125; /** * 构建死信交换机Y * @return DirectExchange */ @Bean(&quot;yExchange&quot;) public DirectExchange yExchange() &#123; return new DirectExchange(&quot;Y&quot;); &#125; /** * 构建普通队列QA * @return Queue */ @Bean(&quot;aQueue&quot;) public Queue aQueue() &#123; return QueueBuilder .nonDurable(&quot;QA&quot;) // 不持久化(队列名) .deadLetterExchange(&quot;Y&quot;) // 死信交换机 .deadLetterRoutingKey(&quot;YD&quot;) // 死信队列routingKey .ttl(10 * 1000) // 消息存活时间ttl .build(); &#125; /** * 构建死信队列QD * @return Queue */ @Bean(&quot;dQueue&quot;) public Queue dQueue() &#123; return QueueBuilder .nonDurable(&quot;QD&quot;) .build(); &#125; /** * 绑定x交换机和a队列 * @param xExchange x普通交换机 * @param aQueue a普通队列 * @return Binding */ @Bean public Binding aQueueToXExchange(@Qualifier(&quot;xExchange&quot;) DirectExchange xExchange, @Qualifier(&quot;aQueue&quot;) Queue aQueue) &#123; return BindingBuilder .bind(aQueue) // 队列 .to(xExchange) // 交换机 .with(&quot;XA&quot;); // routingKey &#125; /** * 绑定y交换机和d队列 * @param yExchange y死信交换机 * @param dQueue d死信队列 * @return Binding */ @Bean public Binding dQueueToYExchange(@Qualifier(&quot;yExchange&quot;) DirectExchange yExchange, @Qualifier(&quot;dQueue&quot;) Queue dQueue) &#123; return BindingBuilder .bind(dQueue) .to(yExchange) .with(&quot;YD&quot;); &#125;&#125; 2.4 生产者1234567891011121314151617181920/** * 生产者接口类 * @author letere * @create 2021-08-08 14:53 */@Slf4j@RestController@RequestMapping(&quot;/ttl&quot;)public class ProducerController &#123; @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(&quot;/sendMessage&quot;) public String sendMessage(String message) &#123; log.info(&quot;时间：&#123;&#125;，接收消息：&#123;&#125;&quot;, new Date(), message); rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XA&quot;, message); return &quot;消息发送成功&quot;; &#125;&#125; 2.5 消费者12345678910111213141516171819/** * 消费者 - 监听器 * @author letere * @create 2021-08-08 15:09 */@Slf4j@Componentpublic class Consumer &#123; /** * 监听队列D的消息接收（注意包的引用，全是amqp下的类） * @param message 消息 * @param channel 信道 */ @RabbitListener(queues = &quot;QD&quot;) public void receiveD(Message message, Channel channel) &#123; log.info(&quot;时间：&#123;&#125;，接收消息：&#123;&#125;&quot;, new Date(), new String(message.getBody())); &#125;&#125; 2.6 测试 浏览器输入地址http://localhost:8080/ttl/sendMessage?message=HelloWorld 3 发消息设置ttl3.1 代码架构 跟前面一致，创建多一个队列B出来，此队列B不设置ttl时间，有生产者发送消息时，设置消息的ttl时间 3.2 代码 （1）配置类： 多创建一个队列B，并与交换机绑定1234567891011121314151617181920212223242526272829303132333435363738/** * 延迟队列配置文件 * @author letere * @create 2021-08-08 14:12 */@Configurationpublic class DelayQueueConfig &#123; // ...... /** * 构建普通队列B * @return Queue */ @Bean(&quot;bQueue&quot;) public Queue bQueue() &#123; return QueueBuilder .durable(&quot;QB&quot;) .deadLetterExchange(&quot;Y&quot;) .deadLetterRoutingKey(&quot;YD&quot;) .build(); &#125; /** * 绑定x交换机和b队列 * @param xExchange x普通交换机 * @param bQueue b普通队列 * @return Binding */ @Bean public Binding bQueueToXExchange(@Qualifier(&quot;xExchange&quot;) DirectExchange xExchange, @Qualifier(&quot;bQueue&quot;) Queue bQueue) &#123; return BindingBuilder .bind(bQueue) .to(xExchange) .with(&quot;XB&quot;); &#125;&#125; （2）生产者： 新增发送消息接口12345678910111213141516171819202122232425262728/** * 生产者接口类 * @author letere * @create 2021-08-08 14:53 */@Slf4j@RestController@RequestMapping(&quot;/ttl&quot;)public class ProducerController &#123; // ...... @GetMapping(&quot;/sendMessage2&quot;) public String sendMessage2(String message, int time) &#123; log.info(&quot;时间：&#123;&#125;，接收消息：&#123;&#125;，ttl时间：&#123;&#125;秒&quot;, new Date(), message, time); rabbitTemplate.convertAndSend( &quot;X&quot;, &quot;XB&quot;, message, msg -&gt; &#123; // 设置ttl时间 msg.getMessageProperties().setExpiration(String.valueOf(time * 1000)); return msg; &#125; ); return &quot;消息发送成功！&quot;; &#125;&#125; （3）测试 单纯只发一条消息，不会出现问题，当连续发送ttl时间不同的消息，则会出现问题 （消息在排队） 实现自定义ttl的延迟队列的实现方法在下一节，此节不能解决 4 插件实现延迟4.1 插件安装 （1）下载 下载地址：https://www.rabbitmq.com/community-plugins.html （2）开启插件 移动插件到：/usr/lib/rabbitmq/lib/rabbitmq_server-3.9.1/plugins 控制台输入指令：rabbitmq-plugins enable rabbitmq_delayed_message_exchange 重启rabbitmq：systemctl restart rabbitmq-server 4.2 代码架构 延迟的实现，不再靠队列ttl死信实现，可以通过交换机自己进行延迟 4.3 代码 （1）配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 延迟队列配置文件 * @author letere * @create 2021-08-08 14:12 */@Configurationpublic class DelayQueueConfig &#123; // ...... /** * 构建延迟交换机Z * @return CustomExchange */ @Bean(&quot;zExchange&quot;) public CustomExchange zExchange() &#123; Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(); arguments.put(&quot;x-delayed-type&quot;, &quot;direct&quot;); // 设置延迟交换机本质类型为direct类型 /* 自定义交换机 参数1：交换机名 参数2：交互机类型 参数3：是否持久化 参数4：是否自动删除 参数5：其他参数 */ return new CustomExchange( &quot;Z&quot;, &quot;x-delayed-message&quot;, false, false, arguments); &#125; /** * 构建普通队列C * @return Queue */ @Bean(&quot;cQueue&quot;) public Queue cQueue() &#123; return QueueBuilder .nonDurable(&quot;QC&quot;) .build(); &#125; /** * 绑定z交换机和c队列 * @param zExchange z延迟交换机 * @param cQueue c普通队列 * @return Binding */ @Bean public Binding cQueueToZExchange(@Qualifier(&quot;zExchange&quot;) CustomExchange zExchange, @Qualifier(&quot;cQueue&quot;) Queue cQueue) &#123; return BindingBuilder .bind(cQueue) .to(zExchange) .with(&quot;ZC&quot;) .noargs(); &#125;&#125; （2）生产者12345678910111213141516171819202122232425262728/** * 生产者接口类 * @author letere * @create 2021-08-08 14:53 */@Slf4j@RestController@RequestMapping(&quot;/ttl&quot;)public class ProducerController &#123; // ...... @GetMapping(&quot;/sendMessage3&quot;) public String sendMessage3(String message, int time) &#123; log.info(&quot;时间：&#123;&#125;，接收消息：&#123;&#125;，延迟时间：&#123;&#125;秒&quot;, new Date(), message, time); rabbitTemplate.convertAndSend( &quot;Z&quot;, &quot;ZC&quot;, message, msg -&gt; &#123; // 设置延迟时间 msg.getMessageProperties().setDelay(time * 1000); return msg; &#125; ); return &quot;消息发送成功！&quot;; &#125;&#125; （3）消费者1234567891011121314151617181920/** * 消费者 - 监听器 * @author letere * @create 2021-08-08 15:09 */@Slf4j@Componentpublic class Consumer &#123; // ...... /** * 监听队列C，并接收消息 * @param message 消息 */ @RabbitListener(queues = &quot;QC&quot;) public void receiveC(Message message) &#123; log.info(&quot;时间：&#123;&#125;，接收消息：&#123;&#125;&quot;, new Date(), new String(message.getBody())); &#125;&#125; （4）测试 和之前一样，分别发送两个延迟时间不同的请求，查看消息是否处于排队状态","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】SpringBoot整合RabbitMQ","slug":"【RabbitMQ】SpringBoot整合RabbitMQ","date":"2021-08-09T04:33:16.000Z","updated":"2021-08-09T05:03:16.160Z","comments":true,"path":"2021/08/09/【RabbitMQ】SpringBoot整合RabbitMQ/","link":"","permalink":"https://letere-gzj.github.io/2021/08/09/%E3%80%90RabbitMQ%E3%80%91SpringBoot%E6%95%B4%E5%90%88RabbitMQ/","excerpt":"关于SpringBoot对RabbitMQ的简单整合","text":"关于SpringBoot对RabbitMQ的简单整合 1 整合1.1 依赖引入1234567&lt;!--rabbitmq springboot启动器--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-amqp --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt;&lt;/dependency&gt; 1.2 yaml配置1234567spring: # rabbitmq配置 rabbitmq: host: 192.168.85.130 # ip地址 port: 5672 # 端口号 username: guest # 用户名 password: guest # 密码 1.3 声明交换机和队列 在springboot中，交换机和队列的声明放在了配置类中，不再是在生产者或消费者中声明，使代码逻辑分层明显12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 交换机、队列配置类 * @author letere * @create 2021-08-08 14:12 */@Configurationpublic class RabbitMQConfig &#123; /** * 构建普通交换机X * @return DirectExchange */ @Bean(&quot;xExchange&quot;) public DirectExchange xExchange() &#123; return new DirectExchange(&quot;X&quot;); &#125; /** * 构建普通队列QA * @return Queue */ @Bean(&quot;aQueue&quot;) public Queue aQueue() &#123; return QueueBuilder .nonDurable(&quot;QA&quot;) // 不持久化(队列名) .build(); &#125; /** * 绑定x交换机和a队列 * @param xExchange x普通交换机 * @param aQueue a普通队列 * @return Binding */ @Bean public Binding aQueueToXExchange(@Qualifier(&quot;xExchange&quot;) DirectExchange xExchange, @Qualifier(&quot;aQueue&quot;) Queue aQueue) &#123; return BindingBuilder .bind(aQueue) // 队列 .to(xExchange) // 交换机 .with(&quot;XA&quot;); // routingKey &#125;&#125; 1.4 生产者发送消息 RabbitMQ提供一个模板类rabbitTemplate来封装消息的发送等操作1234567891011121314151617181920212223/** * 生产者接口类 * @author letere * @create 2021-08-08 14:53 */@RestControllerpublic class ProducerController &#123; @Autowired private RabbitTemplate rabbitTemplate; @GetMapping(&quot;/sendMessage&quot;) public String sendMessage(String message) &#123; /* 消息发送 参数1：交换机名 参数2：routingKey 参数3：发送内容 */ rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XA&quot;, message); return &quot;消息发送成功&quot;; &#125;&#125; 1.5 消费者消息接收 SpringBoot中消费者的消息接收为一个监听器，通过注解@RabbitListener来表示123456789101112131415161718/** * 消费者 - 监听器 * @author letere * @create 2021-08-08 15:09 */@Componentpublic class Consumer &#123; /** * 监听队列QA，进行消息接收（注意包的引用，全是amqp下的类） * @param message 消息 * @param channel 信道 */ @RabbitListener(queues = &quot;QA&quot;) public void receiveQA(Message message, Channel channel) &#123; System.out.println(&quot;接收到的消息为：&quot; + new String(message.getBody())); &#125;&#125; 1.6 测试 启动SpringBoot项目，浏览器输入http://localhost:8080/sendMessage?message=HelloWorld","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】死信队列","slug":"【RabbitMQ】死信队列","date":"2021-08-05T02:45:28.000Z","updated":"2021-08-06T07:18:37.240Z","comments":true,"path":"2021/08/05/【RabbitMQ】死信队列/","link":"","permalink":"https://letere-gzj.github.io/2021/08/05/%E3%80%90RabbitMQ%E3%80%91%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/","excerpt":"死信队列的介绍以及处理","text":"死信队列的介绍以及处理 1 死信队列1.1 概念 死信： 即无法被消费的信息，由于特殊原因导致队列中的消息无法被消费，此些消息无法进行后续处理，变成死信，例如消费者宕机，无人处理消息 1.2 产生原因 （1）消息存活时间（TTL：Time To Live）过期 （2）队列已满，无法将消息添加进队列中 （3）消息被拒绝（basic.reject或basic.nack）并且不再放回队列requeue=false 2 死信演示2.1 代码架构图 2.2 TTL过期 （1）生产者123456789101112131415161718192021222324/** * 生产者 - 发送两条消息到普通交换机上 * @author letere * @create 2021-08-05 11:10 */public class Provider &#123; public static void main(String[] args) throws Exception&#123; // （工具类，具体看之间文章）获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 定义消息过期时间 AMQP.BasicProperties properties = new AMQP.BasicProperties() .builder().expiration(String.valueOf(5 * 1000)).build(); // 连续发送10条消息 for (int i=0; i&lt;10; i++) &#123; channel.basicPublish(&quot;normal_exchange&quot;, &quot;456&quot;, properties, String.valueOf(i).getBytes()); &#125; System.out.println(&quot;消息发送完毕！&quot;); &#125;&#125; （2）消费者01123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 消费者01 - 负责处理普通队列的消息，并构建整个RabbitMQ的关系 * @author letere * @create 2021-08-05 11:10 */public class Consumer01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); /* 由于关系比较复杂，为了方便启动，将所有交换机和队列关系都在此定义 然后第一个启动此程序就构建好所有关系 */ Consumer01 consumer01 = new Consumer01(); consumer01.buildRelation(channel); // 接受消息 System.out.println(&quot;普通队列消费者等待接收消息...&quot;); channel.basicConsume( &quot;normal_queue&quot;, true, (consumerTag, message) -&gt; &#123; System.out.println(&quot;接收消息：&quot; + new String(message.getBody())); &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息接收中止！&quot;); &#125; ); &#125; /** * 构建交换机和队列之间关系 * @param channel 信道 */ public void buildRelation(Channel channel) throws Exception&#123; // 定义死信交换机 channel.exchangeDeclare(&quot;dead_exchange&quot;, &quot;direct&quot;); // 定义死信队列 channel.queueDeclare(&quot;dead_queue&quot;, false, false, false, null); // 交换机与队列进行关联 channel.queueBind(&quot;dead_queue&quot;, &quot;dead_exchange&quot;, &quot;123&quot;); // 定义普通交换机 channel.exchangeDeclare(&quot;normal_exchange&quot;, &quot;direct&quot;); // 定义普通队列 Map&lt;String, Object&gt; argument = new HashMap&lt;&gt;(); argument.put(&quot;x-dead-letter-exchange&quot;, &quot;dead_exchange&quot;); // 关联死信交换机（该队列出现死信后，自动发送到该交换机中） argument.put(&quot;x-dead-letter-routing-key&quot;, &quot;123&quot;); channel.queueDeclare(&quot;normal_queue&quot;, false, false, false, argument); // 交换机与队列进行关联 channel.queueBind(&quot;normal_queue&quot;, &quot;normal_exchange&quot;, &quot;456&quot;); &#125;&#125; （3）消费者021234567891011121314151617181920212223242526/** * 消费者02 - 负责处理死信队列的 * @author letere * @create 2021-08-05 11:10 */public class Consumer02 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 接收消息 System.out.println(&quot;死信队列消费者等待接收消息...&quot;); channel.basicConsume( &quot;dead_queue&quot;, true, (consumerTag, message) -&gt; &#123; System.out.println(&quot;接收消息：&quot; + new String(message.getBody())); &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息接收中止！&quot;); &#125; ); &#125;&#125; （4）测试 先启动消费者01，来构建交换机和队列之间的关系，然后关闭消费者01 然后启动消费者02，生产者 因为消费者01没有启动，队列中的消息无法处理，达到过期时间，自动将消息发送到死信交换机 2.3 超出队列最大长度 （1）生产者 连续发送10条消息1234567891011121314151617181920/** * 生产者 - 发送两条消息到普通交换机上 * @author letere * @create 2021-08-05 11:10 */public class Provider &#123; public static void main(String[] args) throws Exception&#123; // （工具类，具体看之前文章）获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 连续发送10条消息 for (int i=0; i&lt;10; i++) &#123; channel.basicPublish(&quot;normal_exchange&quot;, &quot;456&quot;, null, String.valueOf(i).getBytes()); &#125; System.out.println(&quot;消息发送完毕！&quot;); &#125;&#125; （2）消费者01 修改队列最大长度为512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 消费者01 - 负责处理普通队列的消息，并构建整个RabbitMQ的关系 * @author letere * @create 2021-08-05 11:10 */public class Consumer01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); /* 由于关系比较复杂，为了方便启动，将所有交换机和队列关系都在此定义 然后第一个启动此程序就构建好所有关系 */ Consumer01 consumer01 = new Consumer01(); consumer01.buildRelation(channel); // 接受消息 System.out.println(&quot;普通队列消费者等待接收消息...&quot;); channel.basicConsume( &quot;normal_queue&quot;, true, (consumerTag, message) -&gt; &#123; System.out.println(&quot;接收消息：&quot; + new String(message.getBody())); &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息接收中止！&quot;); &#125; ); &#125; /** * 构建交换机和队列之间关系 * @param channel 信道 */ public void buildRelation(Channel channel) throws Exception&#123; // 定义死信交换机 channel.exchangeDeclare(&quot;dead_exchange&quot;, &quot;direct&quot;); // 定义死信队列 channel.queueDeclare(&quot;dead_queue&quot;, false, false, false, null); // 交换机与队列进行关联 channel.queueBind(&quot;dead_queue&quot;, &quot;dead_exchange&quot;, &quot;123&quot;); // 定义普通交换机 channel.exchangeDeclare(&quot;normal_exchange&quot;, &quot;direct&quot;); // 定义普通队列 Map&lt;String, Object&gt; argument = new HashMap&lt;&gt;(); argument.put(&quot;x-dead-letter-exchange&quot;, &quot;dead_exchange&quot;); // 关联死信交换机（该队列出现死信后，自动发送到该交换机中） argument.put(&quot;x-dead-letter-routing-key&quot;, &quot;123&quot;); argument.put(&quot;x-max-length&quot;, 5); // 修改最大队列长度为5 channel.queueDeclare(&quot;normal_queue&quot;, false, false, false, argument); // 交换机与队列进行关联 channel.queueBind(&quot;normal_queue&quot;, &quot;normal_exchange&quot;, &quot;456&quot;); &#125;&#125; （3）消费者02 跟前面一样，不多重复 （4）测试 因为normal_queue参数发生变化，需要事前删除该队列，然后启动consumer01，再关闭consumer01，导致消息堆积 依次启动consumer02，生产者 2.4 消息被拒 （1）生产者 跟前面的没有发生变化，不多展示 （2）消费者01 将消息改为手动应答，并对消息5进行拒绝应答123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 消费者01 - 负责处理普通队列的消息，并构建整个RabbitMQ的关系 * @author letere * @create 2021-08-05 11:10 */public class Consumer01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); /* 由于关系比较复杂，为了方便启动，将所有交换机和队列关系都在此定义 然后第一个启动此程序就构建好所有关系 */ Consumer01 consumer01 = new Consumer01(); consumer01.buildRelation(channel); // 接受消息（开启手动应答） System.out.println(&quot;普通队列消费者等待接收消息...&quot;); channel.basicConsume( &quot;normal_queue&quot;, false, (consumerTag, message) -&gt; &#123; if (new String(message.getBody()).equals(&quot;5&quot;)) &#123; System.out.println(&quot;此消息：&quot; + new String(message.getBody()) + &quot;，已被拒绝，成为死信&quot;); channel.basicReject(message.getEnvelope().getDeliveryTag(), false); &#125; else &#123; System.out.println(&quot;接收消息：&quot; + new String(message.getBody())); channel.basicAck(message.getEnvelope().getDeliveryTag(), false); &#125; &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息接收中止！&quot;); &#125; ); &#125; /** * 构建交换机和队列之间关系 * @param channel 信道 */ public void buildRelation(Channel channel) throws Exception&#123; // 定义死信交换机 channel.exchangeDeclare(&quot;dead_exchange&quot;, &quot;direct&quot;); // 定义死信队列 channel.queueDeclare(&quot;dead_queue&quot;, false, false, false, null); // 交换机与队列进行关联 channel.queueBind(&quot;dead_queue&quot;, &quot;dead_exchange&quot;, &quot;123&quot;); // 定义普通交换机 channel.exchangeDeclare(&quot;normal_exchange&quot;, &quot;direct&quot;); // 定义普通队列 Map&lt;String, Object&gt; argument = new HashMap&lt;&gt;(); argument.put(&quot;x-dead-letter-exchange&quot;, &quot;dead_exchange&quot;); // 关联死信交换机（该队列出现死信后，自动发送到该交换机中） argument.put(&quot;x-dead-letter-routing-key&quot;, &quot;123&quot;); channel.queueDeclare(&quot;normal_queue&quot;, false, false, false, argument); // 交换机与队列进行关联 channel.queueBind(&quot;normal_queue&quot;, &quot;normal_exchange&quot;, &quot;456&quot;); &#125;&#125; （3）消费者02 跟前面一样，不多展示 （4）测试 因为normal_queue参数发生变化，需要事先删除，再启动consumer01 依次启动consumer02，生产者","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】交换机","slug":"【RabbitMQ】交换机","date":"2021-08-04T05:53:08.000Z","updated":"2021-08-04T12:54:05.977Z","comments":true,"path":"2021/08/04/【RabbitMQ】交换机/","link":"","permalink":"https://letere-gzj.github.io/2021/08/04/%E3%80%90RabbitMQ%E3%80%91%E4%BA%A4%E6%8D%A2%E6%9C%BA/","excerpt":"关于RabbitMQ中交换机的使用","text":"关于RabbitMQ中交换机的使用 1 交换机1.1 使用场景 当我们需要一个消息被多个消费者共享的时候，此时就需要用到交换机，一个队列中消费者之间是竞争关系，无法实现消息共享，所以需要创建多一个队列，让交换机发送消息到这些队列中，从而达到一个消息被多个消费者共享 1.2 概念 生产者发送消息并不是直接发送到队列中，而是发送到交换机中。而交换机负责将消息放入到队列中，具体放到特定队列、多个队列、或丢弃消息，用交换机具体的类型决定 交换机类型：直接（direct）、主题（topic）、标题（headers）、扇出（fanout） 1.3 交换机与队列 交换机与队列之间的关系通过routingKey进行关联，routingKey相当于队列的唯一标识，交换机通过routingKey来寻找对应的队列，并发送消息给此队列 2 fanout交换机 fanout类型交换机，功能类似广播一样，将消息发送到所有它绑定的队列中 fanout类型交换机中，队列的routingKey都为空，不需要队列有唯一标识 2.1 生产者123456789101112131415161718192021222324252627/** * 生产者 - 发送消息给交换机 * @author letere * @create 2021-08-04 14:53 */public class Provider &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); /* 定义交换机 参数1：交换机名 参数2：交换机类型 */ channel.exchangeDeclare(&quot;fanoutExchange&quot;, &quot;fanout&quot;); // 发送消息（控制台输入） Scanner scanner = new Scanner(System.in); while (true) &#123; String message = scanner.next(); channel.basicPublish(&quot;fanoutExchange&quot;, &quot;&quot;, null, message.getBytes()); &#125; &#125;&#125; 2.2 消费者 同理创建两个一样的消费者 12345678910111213141516171819202122232425262728293031323334/** * 消费者01 - 队列绑定交换机，从队列中接收消息 * @author letere * @create 2021-08-04 14:57 */public class Consumer01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 声明默认队列，并获取队列名 String queueName = channel.queueDeclare().getQueue(); /* 与交换机绑定 参数1：队列名 参数2：交换机名 参数3：routingKey */ channel.queueBind(queueName, &quot;fanoutExchange&quot;, &quot;&quot;); System.out.println(&quot;消费者01等待接受消息...&quot;); channel.basicConsume( queueName, (consumerTag, message) -&gt; &#123; System.out.println(&quot;接收消息：&quot; + new String(message.getBody())); &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息接收异常！&quot;); &#125; ); &#125;&#125; 2.3 测试 先启动生产者来创建交换机，再启动两个消费者，在生产者控制台输入要发送过的消息 3 direct交换机 direct大部分跟fanout交换机一样，只是direct交换机绑定的routingKey有对应的值，可以发送消息到特定的队列上 3.1 生产者12345678910111213141516171819202122232425262728293031/** * 生产者 - 发送消息给交换机 * @author letere * @create 2021-08-04 14:53 */public class Provider &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); /* 定义交换机 参数1：交换机名 参数2：交换机类型 */ channel.exchangeDeclare(&quot;directExchange&quot;, &quot;direct&quot;); // 发送消息（控制台输入） Scanner scanner = new Scanner(System.in); while (true) &#123; System.out.print(&quot;请输入发送信息：&quot;); String message = scanner.next(); System.out.print(&quot;请输入routingKey：&quot;); String routingKey = scanner.next(); channel.basicPublish(&quot;directExchange&quot;, routingKey, null, message.getBytes()); System.out.println(&quot;---------------------------&quot;); &#125; &#125;&#125; 3.2 消费者 同理创建两个一样的消费者 12345678910111213141516171819202122232425262728293031323334/** * 消费者01 - 队列绑定交换机，从队列中接收消息 * @author letere * @create 2021-08-04 14:57 */public class Consumer01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 声明默认队列，并获取队列名 String queueName = channel.queueDeclare().getQueue(); /* 与交换机绑定 参数1：队列名 参数2：交换机名 参数3：routingKey */ channel.queueBind(queueName, &quot;directExchange&quot;, &quot;consumer01&quot;); System.out.println(&quot;消费者01等待接受消息...&quot;); channel.basicConsume( queueName, (consumerTag, message) -&gt; &#123; System.out.println(&quot;接收消息：&quot; + new String(message.getBody())); &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息接收异常！&quot;); &#125; ); &#125;&#125; 3.3 测试 先启动生产者来创建交换机，其次再启动两个消费者，用控制台发送消息 4 topic交换机 topic交换机是fanout和direct交换机的一个升级，可以同时向两个队列发送消息，也可以向特定的队列发送消息 4.1 routingKey命名 topic交换机中，routingKey有固定规范的命名方式 （1）命名方式用xxx.xxx.xxx的格式进行命名，其中单词的长度不限制，但总长度不能超过255 （2）存在通用字符匹配，*代表任意一个单词，#代表任意零个或多个单词 4.2 生产者12345678910111213141516171819202122232425262728293031/** * 生产者 - 发送消息给交换机 * @author letere * @create 2021-08-04 20:37 */public class Provider &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); /* 定义交换机 参数1：交换机名 参数2：交换机类型 */ channel.exchangeDeclare(&quot;topicExchange&quot;, &quot;topic&quot;); // 发送消息（控制台输入） Scanner scanner = new Scanner(System.in); while (true) &#123; System.out.print(&quot;请输入发送信息：&quot;); String message = scanner.next(); System.out.print(&quot;请输入routingKey：&quot;); String routingKey = scanner.next(); channel.basicPublish(&quot;topicExchange&quot;, routingKey, null, message.getBytes()); System.out.println(&quot;---------------------------&quot;); &#125; &#125;&#125; 4.3 消费者 同理创建两个消费者 12345678910111213141516171819202122232425262728293031323334/** * 消费者01 - 队列绑定交换机，从队列中接收消息 * @author letere * @create 2021-08-04 20:38 */public class Consumer01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 声明默认队列，并获取队列名 String queueName = channel.queueDeclare().getQueue(); /* 与交换机绑定 参数1：队列名 参数2：交换机名 参数3：routingKey */ channel.queueBind(queueName, &quot;topicExchange&quot;, &quot;#.consumer01.#&quot;); System.out.println(&quot;消费者01等待消息接收...&quot;); channel.basicConsume( queueName, (consumerTag, message) -&gt; &#123; System.out.println(&quot;接收消息：&quot; + new String(message.getBody())); &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息接收失败！&quot;); &#125; ); &#125;&#125; 4.4 测试 先启动生产者创建交换机，再启动消费者，通过控制台发送消息","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】发布确认","slug":"【RabbitMQ】发布确认","date":"2021-08-03T06:36:09.000Z","updated":"2021-08-04T03:42:53.878Z","comments":true,"path":"2021/08/03/【RabbitMQ】发布确认/","link":"","permalink":"https://letere-gzj.github.io/2021/08/03/%E3%80%90RabbitMQ%E3%80%91%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4/","excerpt":"关于生产者发布消息的相关知识","text":"关于生产者发布消息的相关知识 1 发布确认1.1 概念 发布确认： 即为在消息持久化的过程中，rabbitmq接收到消息并保存完在磁盘上后，发消息通知生产者消息发送成功，否则生产者会重新发送消息，确保消息持久化不丢失数据 1.2 发布确认开启 生产者中的信道方法confirmSelect，即为开启发布确认1Confirm.SelectOk confirmSelect() throws IOException; 1.3 单个发布确认 一种同步确认发布方式，即生产者发布一条信息，就得确认一条信息，信息确认完后才往后发其他信息 优点：保证了信息持久化 缺点：发布速度特别慢 1234567891011121314151617181920212223242526/** * 单个发布确认：发一条确认一条 * @throws Exception */public void singleConfirm() throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 定义队列 channel.queueDeclare(&quot;publish_queue1&quot;, false, false, false, null); // 开启发布确认 channel.confirmSelect(); long begin = System.currentTimeMillis(); // 发1000条数据 for (int i=0; i&lt;1000; i++) &#123; channel.basicPublish(&quot;&quot;, &quot;publish_queue1&quot;, null, String.valueOf(i).getBytes()); // 确认消息（确认失败重发） if (!channel.waitForConfirms()) &#123; i--; &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;单个发布确认共耗时：&quot; + (end-begin) + &quot;毫秒！&quot;);&#125; 1234567// 运行测试时间（602ms）public static void main(String[] args) throws Exception&#123; Provider provider = new Provider(); // 单个发布确认（602ms） provider.singleConfirm();&#125; 1.4 批量发布确认 跟单个发布确认相反，批量发布确认速度快，但一旦出现异常，就不清楚哪个信息出现异常 1234567891011121314151617181920212223242526272829/** * 批量发布确认：暂定发布100条确认一次 * @throws Exception */public void multiConfirm() throws Exception &#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 定义队列 channel.queueDeclare(&quot;publish_queue2&quot;, false, false, false, null); // 开启发布确认 channel.confirmSelect(); long begin = System.currentTimeMillis(); // 发1000条数据 for (int i=0; i&lt;1000; i++) &#123; channel.basicPublish(&quot;&quot;, &quot;publish_queue2&quot;, null, String.valueOf(i).getBytes()); if (i+1 % 100 == 0) &#123; // 发布确认（确认失败重发100条数据） if (!channel.waitForConfirms()) &#123; i -= 100; &#125; &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;批量发布确认共耗时：&quot; + (end-begin) + &quot;毫秒！&quot;);&#125; 1234567// 运行测试时间（64ms）public static void main(String[] args) throws Exception&#123; Provider provider = new Provider(); // 批量发布确认（64ms） provider.multiConfirm();&#125; 1.5 异步发布确认 即发消息和确认消息这两个步骤是异步的，生产者只需要一直发消息即可，哪些消息是确认失败的会稍后通知 需要准备一个多线程用的Map，来记录kv值，方便查找未确认的消息并重新发送 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 异步发布确认 * @throws Exception */public void asyncPublic() throws Exception &#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 定义队列 channel.queueDeclare(&quot;publish_queue3&quot;, false, false, false, null); // 开启发布确认 channel.confirmSelect(); // 存储发送消息 ConcurrentHashMap&lt;Long, String&gt; map = new ConcurrentHashMap&lt;&gt;(); /* 消息监听器，监听哪些消息成功，哪些失败 参数1：发布确认成功回调函数 参数2：发布确认失败回调函数 */ channel.addConfirmListener( (deliveryTag, multiple) -&gt; &#123; // 发布成功逻辑代码 &#125;, (deliveryTag, multiple) -&gt; &#123; // 重新发送消息 channel.basicPublish(&quot;&quot;, &quot;publish_queue3&quot;, null, map.get(deliveryTag).getBytes()); &#125; ); long begin = System.currentTimeMillis(); // 发1000条数据 for (int i=0; i&lt;1000; i++) &#123; // 将发送的消息存储到map中 map.put(channel.getNextPublishSeqNo(), String.valueOf(i)); channel.basicPublish(&quot;&quot;, &quot;publish_queue3&quot;, null, String.valueOf(i).getBytes()); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;异步发布确认共耗时：&quot; + (end-begin) + &quot;毫秒！&quot;);&#125; 1234567// 运行测试时间（45ms）public static void main(String[] args) throws Exception&#123; Provider provider = new Provider(); // 异步发布确认（45ms） provider.asyncPublic();&#125;","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】工作队列","slug":"【RabbitMQ】工作队列","date":"2021-07-31T08:21:38.000Z","updated":"2021-08-03T06:17:25.889Z","comments":true,"path":"2021/07/31/【RabbitMQ】工作队列/","link":"","permalink":"https://letere-gzj.github.io/2021/07/31/%E3%80%90RabbitMQ%E3%80%91%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/","excerpt":"关于RabbitMQ中的工作队列的介绍","text":"关于RabbitMQ中的工作队列的介绍 1 消息分发1.1 介绍 当一个生产者发送大量消息的时候，只有一个工作线程（消费者）进行消息处理的话，速度慢。此时需要多个工作线程来对消息进行处理，RabbitMQ会按照轮询法则（默认）对消息分发到多个工作线程中 1.2 轮询发送 （1）工具类123456789101112131415161718192021222324252627/** * RabbitMQ工具类 * @author letere * @create 2021-07-31 16:39 */public class RabbitMQUtil &#123; /** * 获取连接 * @return Connection */ public static Connection getConnection() throws Exception&#123; // rabbitmq连接工厂 ConnectionFactory factory = new ConnectionFactory(); // ip地址 factory.setHost(&quot;192.168.85.130&quot;); // 端口号 factory.setPort(5672); // 用户名 factory.setUsername(&quot;guest&quot;); // 密码 factory.setPassword(&quot;guest&quot;); // 创建连接 return factory.newConnection(); &#125;&#125; （2）生产者123456789101112131415161718192021/** * 生产者 * @author letere * @create 2021-07-31 17:08 */public class Producer &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 生成队列 channel.queueDeclare(&quot;worker_queue&quot;, false, false, false, null); // 循环发送消息 for (int i=1; i &lt;= 10; i++) &#123; channel.basicPublish(&quot;&quot;, &quot;worker_queue&quot;, null, String.valueOf(i).getBytes()); &#125; System.out.println(&quot;消息发送完毕！&quot;); &#125;&#125; （3）工作线程（消费者） 同理创建两个1234567891011121314151617181920212223242526/** * 工作线程1 * @author letere * @create 2021-07-31 16:50 */public class Worker01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 产生信道 Channel channel = connection.createChannel(); // 消费消息 System.out.println(&quot;worker01：等待接受消息...&quot;); channel.basicConsume( &quot;worker_queue&quot;, true, ((consumerTag, message) -&gt; &#123; System.out.println(&quot;消费消息：&quot; + new String(message.getBody())); &#125;), (consumerTag -&gt; &#123; System.out.println(&quot;消息：&quot; + consumerTag + &quot;，消费取消！&quot;); &#125;) ); &#125;&#125; （4）测试 先把工作线程启动好（可能会报404错误，因为队列还没有创建，可以事先创建队列） 再启动生产者发送消息 1.3 不公平分发 不公平分发： 会根据消费者对消息的处理速度进行分发，处理速度快的消费则分布多点，处理慢的分发少点（能者多劳） 在消费者方进行设置，信道的basicQos方法，将参数改为1，意思为：不公平分发，信道信息堆积条数为1 可以改成其他数值，来定义信道堆积信息的条数，此值被称为预取值1void basicQos(int prefetchCount) throws IOException; 2 消息应答2.1 概念 当某个工作线程的工作时间过于长，一旦该工作线程发生了宕机，则此消息的处理就会发生丢失，为解决此情况，rabbitmq引入消息应答机制 消息应答：消费者在接收消息，并处理完消息之后，告诉rabbitmq消息已经处理完毕，此时rabbitmq才把队列中的消息删除，确保消息不会丢失 2.2 自动应答 特点：消息发送后立即就认为已经传送成功了，虽然提高了消息的吞吐量，但也会造成消息的丢失。此模式仅适用于消费者可以高效并以某种速率处理消息的情况下使用 2.3 手动应答 手动应答具体分为 信道(channel) 中的三个方法123456// 肯定确认：确认消息成功处理，将消息删除void basicAck(long deliveryTag, boolean multiple) throws IOException;// 否定确认：直接将消息删除，不进行确认是否完成void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;void basicReject(long deliveryTag, boolean requeue) throws IOException; multiple - 是否批量应答 true：当一个消息处理完需要应答时，若信道中还有其他消息，则顺便将这些消息都进行应答 false：只应答当前处理完的消息 2.4 消息重新入队列 如果真的出现消费者宕机导致消息未处理的情况，rabbitmq会将消息重新进入队列 2.5 代码实现 （1）生产者123456789101112131415public class Provider &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 定义队列 channel.queueDeclare(&quot;ack_queue&quot;, false, false, false, null); // 发送消息 channel.basicPublish(&quot;&quot;, &quot;ack_queue&quot;, null, &quot;ack应答1&quot;.getBytes()); channel.basicPublish(&quot;&quot;, &quot;ack_queue&quot;, null, &quot;ack应答2&quot;.getBytes()); System.out.println(&quot;消息发送完毕！&quot;); &#125;&#125; （2）消费者 创建两个消费者，一个沉睡1秒，一个沉睡30秒12345678910111213141516171819202122232425262728public class Consumer01 &#123; public static void main(String[] args) throws Exception&#123; // 获取连接 Connection connection = RabbitMQUtil.getConnection(); // 创建信道 Channel channel = connection.createChannel(); // 接受消息，并处理 channel.basicConsume( &quot;ack_queue&quot;, false, (consumerTag, message) -&gt; &#123; // 沉睡1秒 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;接收到的消息为：&quot; + new String(message.getBody())); // 手动应答 channel.basicAck(message.getEnvelope().getDeliveryTag(), false); &#125;, consumerTag -&gt; &#123; System.out.println(&quot;消息消费取消/终止！&quot;); &#125; ); &#125;&#125; （3）测试 事先将队列创建好，然后启动消费者，再发送消息 将沉睡30秒的消费者进行关闭，去另外一个消费查看，查看消息是否重发到此消费者中 3 RabbitMQ持久化3.1 概念 有时可能会出现rabbitmq出现宕机的情况，若不对rabbitmq的队列和消息进行保存，则重启rabbitmq就会造成数据的丢失。所有需要实现rabbitmq数据的持久化 3.2 队列持久化 在声明队列的方法queueDeclare中，第二个参数durable即为持久化，改为true就可持久化12Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) throws IOException; 持久化前，需要将原同名队列进行删除，否则报错 运行程序，队列持久化 3.3 消息持久化 在发布消息的方法basicPublish中，第三个参数props设置为MessageProperties.PERSISTENT_TEXT_PLAIN 1void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException; 注意： 此消息持久化不能百分百保证消息不丢失，有可能在将消息写入磁盘的一瞬间，rabbitmq宕机了，还没将消息写入磁盘，导致消息丢失。更强有力的持久化在后面的《发布确认》进行介绍","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】RabbitMQ快速开始","slug":"【RabbitMQ】RabbitMQ快速开始","date":"2021-07-31T07:37:01.000Z","updated":"2021-07-31T08:21:06.982Z","comments":true,"path":"2021/07/31/【RabbitMQ】RabbitMQ快速开始/","link":"","permalink":"https://letere-gzj.github.io/2021/07/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","excerpt":"关于rabbitmq的快速开始（Hello World）","text":"关于rabbitmq的快速开始（Hello World） 1 快速开始以Java来实现生产者 - 队列 - 消费者之间关系 1.1 生产者 （1）准备依赖1234567&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;&lt;!-- RabbitMQ Java客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.13.0&lt;/version&gt;&lt;/dependency&gt; （2）生产者构建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 消息生产者 * @author letere * @create 2021-07-31 14:55 */public class Producer &#123; public static void main(String[] args) throws Exception&#123; Producer producer = new Producer(); // 连接rabbitmq Connection connection = producer.connectRabbitMQ(); // 创建信道 Channel channel = connection.createChannel(); /* 生成队列 参数1：队列名 参数2：是否将消息持久化到磁盘（默认false） 参数3：是否值提供一个消费者进行消费 参数4：是否自动删除队列（当没有消费者进行连接的时候） 参数5：其他参数配置 */ channel.queueDeclare(&quot;my_queue&quot;, false, false, false, null); /* 发布消息 参数1：交换机名 参数2：路由key值 参数3：其他参数配置 参数4：发布消息的内容（二进制数组） */ channel.basicPublish(&quot;&quot;, &quot;my_queue&quot;, null, &quot;Hello World&quot;.getBytes()); System.out.println(&quot;消息发送完毕！&quot;); &#125; /** * 连接rabbitmq * @return Connection * @throws Exception */ private Connection connectRabbitMQ() throws Exception&#123; // rabbitmq连接工厂 ConnectionFactory factory = new ConnectionFactory(); // ip地址 factory.setHost(&quot;192.168.85.130&quot;); // 端口号 factory.setPort(5672); // 用户名 factory.setUsername(&quot;guest&quot;); // 密码 factory.setPassword(&quot;guest&quot;); // 创建连接 return factory.newConnection(); &#125;&#125; （3）运行并查看 运行程序后，进行rabbitmq-web界面进行查看 1.2 消费者 （1）消费者构建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 消息消费者 * @author letere * @create 2021-07-31 15:46 */public class Consumer &#123; public static void main(String[] args) throws Exception&#123; Consumer consumer = new Consumer(); // 连接rabbitmq Connection connection = consumer.connectRabbitMQ(); // 创建信道 Channel channel = connection.createChannel(); /* 消费消息 参数1：队列名 参数2：是否自动应答 参数3：消费消息回调函数 参数4：消费取消回调函数 */ channel.basicConsume( &quot;my_queue&quot;, true, ((consumerTag, message) -&gt; &#123; System.out.println(consumerTag); System.out.println(new String(message.getBody())); &#125;), ((consumerTag) -&gt; &#123; System.out.println(&quot;消息：&quot; + consumerTag + &quot;，消费取消/中断！&quot;); &#125;) ); &#125; /** * 连接rabbitmq * @return Connection * @throws Exception */ private Connection connectRabbitMQ() throws Exception&#123; // rabbitmq连接工厂 ConnectionFactory factory = new ConnectionFactory(); // ip地址 factory.setHost(&quot;192.168.85.130&quot;); // 端口号 factory.setPort(5672); // 用户名 factory.setUsername(&quot;guest&quot;); // 密码 factory.setPassword(&quot;guest&quot;); // 创建连接 return factory.newConnection(); &#125;&#125; （2）运行测试","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【RabbitMQ】RabbitMQ入门","slug":"【RabbitMQ】RabbitMQ入门","date":"2021-07-31T04:07:08.000Z","updated":"2021-07-31T08:21:03.486Z","comments":true,"path":"2021/07/31/【RabbitMQ】RabbitMQ入门/","link":"","permalink":"https://letere-gzj.github.io/2021/07/31/%E3%80%90RabbitMQ%E3%80%91RabbitMQ%E5%85%A5%E9%97%A8/","excerpt":"关于rabbitmq的介绍和安装","text":"关于rabbitmq的介绍和安装 1 MQ引言1.1 MQ介绍 MQ（Message Quene）：翻译为消息队列，通过典型的生产者和消费者模型。生成者不断向消息队列中生成消息，消费者不断从队列中获取信息。因为消息的生产和消费都是异步的，而且只关系消息的发送和接收，没有业务逻辑的侵入，轻松实现系统间解耦，通过利用高效可靠的消息传递机制进行平台无关的数据交流，基于数据通信来进行分布式系统的集成 1.2 MQ种类 市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自出开发RockerMQ等 1.3 不同MQ特点 1.ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线，它是一个完全支持JMS规范的消息中间件，丰富的API，多种集群架构模式让ActiveMQ在业界中称为了老牌的消息中间件，在中小型企业颇受欢迎 2.Kafka Kakfa是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于pull的模式来处理消息消费，追求高吞吐量，一来是的目的就是用于日志收集和传输，0.8版本开始支持复制，不支持事务，对消息的重复，丢失，没有严格要求，适合产生大量数据的互联网服务的数据收集服务 3.RocketMQ RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量，高可用性，适合大规模分布式系统应用的特点。RockerMQ思路起源于Kafka，但并不是Kafka的一个复制品，它对消息的可靠传输及事务性做了优化。目前在阿里集团被广泛应用于交易，充值，流计算，消息推送，日志流式处理，binglong分发等场景 4.RabbitMQ RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现，AMQP的主要特征是面向消息、队列、路由（包括点对点 和 发布/订阅去）、可靠性、安全、AMQP协议更多用在企业系统内对数据一致性，稳定性和可靠性需求很高的场景，对性能和吞吐量的要求还在其次 1.4 MQ使用场景 （1）流量消峰 在处理能力能够应付的前提下，用户下单一秒后获得反馈。但下单次数过高，正常情况下就是超出处理上限的订单禁止下单。但使用MQ后，对订单进行缓存，可以把订单分散为一段时间来处理，打破下单1s后反馈，可能10几s后再进行反馈。用户体验比无法下单要强 （2）应用解耦 当一个应用程序包含多个系统时，其中一个系统的调用，耦合调用其他系统时。一旦其他系统中出现故障，会立马造成下单异常。但如果用MQ进行缓存，可以进行等待，等故障修复后继续执行，不会产生异常，提高用户体验。 （3）异步处理 服务A调用服务B是异步操作，服务B需要很长时间执行，但服务A需要服务B什么时候执行完。不适用MQ，则需服务A定时发送请求服务B，查看是否完成。使用MQ后，服务B完成后发送消息给MQ，MQ再发送消息给服务A 2 RabbitMQ使用2.1 RabbitMQ RabbitMQ是基于AMOP协议，erlang语言开发，是部署最广泛的开源消息中间件，是最受欢迎的开源消息中间件之一 AMOP（advanced message queuing protocol），模型如下： 官网：https://www.rabbitmq.com 官网文档：https://www.rabbitmq.com/documentation.html 2.2 RabbitMQ概念 （1）生产者 产生数据发送消息的程序 （2）交换机 用户接受生成者发送的消息，并将消息推送到队列中。将消息推送到特定队列，或推送到多个队列，或将此消息丢弃，全由交换机负责 一个交换机，可以绑定多个队列 （3）队列 RabbitMQ内容中使用的一种数据结构，是一个缓冲区，用于存储消息 （4）消费者 处理消息的程序 2.3 下载和安装本次安装使用虚拟机CentOS8.3.2011 （1）下载 erlang下载地址：https://github.com/rabbitmq/erlang-rpm/releases/tag （github外网，可能打不开） RabbitMQ下载地址：https://rabbitmq.com/install-rpm.html#downloads （2）安装12345678# 安装erlangrpm -ivh erlang安装包名# 安装rabbitMQ依赖yum install socat -y# 安装rabbitMQrpm -ivh rabbitMQ安装包名 （3）报错解决 安装rabbitmq报错 命令vim /usr/lib/tmpfiles.d/rabbitmq-server.conf，将/var/run/rabbitmq改为/run/rabbitmq 启动测试1234567891011121314# 服务启动（前台显示）rabbitmq-server start# 服务启动（后台）systemctl start rabbitmq-server/sbin/service rabbitmq-server start# 服务关闭systemctl stop rabbit-server/sbin/service rabbitmq-server stop# 服务启动查看systemctl status rabbitmq-server/sbin/service rabbit-server status 2.4 rabbitmq-web管理 （1）插件安装12# web插件安装rabbitmq-plugins enable rabbitmq_management （2）登录用户权限1234567# 创建rabbitmq配置文件vim /ect/rabbitmq/rabbitmq.conf# 输入用户权限内容（开放使用）loopback_users=none# 内容输入完保存退出即可 （2）防火墙开放端口 rabbitmq的默认端口号为5672 rabbitmq的web界面默认端口号为15672123456# 添加开放端口firewall-cmd --permanent --add-port=5672/tcpfirewall-cmd --permanent --add-port=15672/tcp# 重启防火墙firewall-cmd --reload （3）查看虚拟机ip地址1ifconfig （4）连接web界面 重启rabbitmq服务 非虚拟机浏览器输入地址：ip地址:15672 默认用户名、密码都为guest","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"}],"tags":[]},{"title":"【Nginx】Nginx原理","slug":"【Nginx】Nginx原理","date":"2021-07-26T13:03:01.000Z","updated":"2021-07-26T14:06:08.082Z","comments":true,"path":"2021/07/26/【Nginx】Nginx原理/","link":"","permalink":"https://letere-gzj.github.io/2021/07/26/%E3%80%90Nginx%E3%80%91Nginx%E5%8E%9F%E7%90%86/","excerpt":"关于Nginx简单的工作原理","text":"关于Nginx简单的工作原理 1 工作原理1.1 Nginx工作架构 一个Nginx项目的启动，至少有两个进程，一个master，一个woker 当一个请求发送到nginx中，该请求先给master，然后多个worker来争抢此请求，对此请求进行反向代理 1.2 一master多worker好处 （1）利于使用nginx -s reload操作，如果执行此操作时，正好有worker在处理请求，则此woker暂时不变，其余空闲woker发生变化，无需停到nginx服务器再启动 （2）每个多个worker时独立的进程，其中worker出现问题，不影响其余worker 1.3 worker数 每个worker，能把一个CPU的性能发挥到极致。所以worker和CPU相等即可 worker数量的设置在nginx.conf文件全局块中设置1worker_process worker数; 1.4 worker连接数 一个请求会占用woker2/4个连接数 直接请求nginx中的静态资源，request和response2个连接 如果请求动态资源文件，需要与后端服务器进行交互，额外多2个连接，共4个 woker连接数配置123events &#123; worker_connections worker连接数;&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://letere-gzj.github.io/categories/Nginx/"}],"tags":[]},{"title":"【Nginx】Nginx配置","slug":"【Nginx】Nginx配置","date":"2021-07-20T02:50:40.000Z","updated":"2021-07-26T13:02:26.483Z","comments":true,"path":"2021/07/20/【Nginx】Nginx配置/","link":"","permalink":"https://letere-gzj.github.io/2021/07/20/%E3%80%90Nginx%E3%80%91Nginx%E9%85%8D%E7%BD%AE/","excerpt":"关于Nginx中各种配置的实现","text":"关于Nginx中各种配置的实现 1 配置文件 nginx配置文件的路径：”/usr/local/nginx/conf/nginx.conf” 1.1 配置文件组成部分 （1）全局块 nginx配置文件的一些全局配置 · 12work_process 1;# 并发处理值，值越大，并发处理数越大 （2）event块 主要影响nginx服务器与用户的网络连接 12worker_connections 1024;# nginx支持的最大连接数，与nginx性能关系巨大，需要按需配置 （3）http块 nginx配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块都在此配置 http块可以细分为http全局块、server块 http块存在多个Server块 （4）http全局块 （5）server块 此块与虚拟主机有密切关系，为了节省互联网服务硬件成本 server块可以细分为全局server块、location块 server块存在多个location块 （6）全局server块 12345listen 80;# nginx服务监听的端口号为80server_name localhost;# 服务名称为localhost （7）location块 配置请求转发 2 反向代理配置2.1 tomcat安装配置 （1）Tomcat下载 tomcat下载地址：https://tomcat.apache.org/download-10.cgi 下载tar.gz后缀名文件 （2）解压 1tar -zxvf 文件名 （3）启动 12# 切换目录到tomcat的bin目录下./startup.sh 2.2 配置实例1目标：访问指定ip地址，自动转发到tomcat服务中 （1）nginx请求转发配置 配置location块，来实现请求转发12345678910111213server &#123; # 端口号 listen 80; # 服务名称 server_name 192.168.85.130; # 请求转发地址 location / &#123; root html; proxy_pass http://127.0.0.1:8080/; index index.html index.htm; &#125;&#125; （2）测试效果 修改完nginx后，需要重启nginx 浏览器输入：http://服务名称:端口号/转发地址 2.3 配置实例2目标：根据访问地址的不同，转发到不同的tomcat服务器中 （1）准备多一个tomcat服务 复制tomcat文件夹 修改/conf/server.xml中的端口号 （2）准备一些静态文件，好进行两端口区分 8080端口在/webapps创建文件夹/edu 8081端口在/webapps创建文件夹/cov 在两文件夹下放入a.html，内容如下文1&lt;h1&gt;here is 8080/8081!&lt;/h1&gt; （3）nginx配置12345678910111213141516server &#123; # 端口号 listen 8001; # 服务名称 server_name 192.168.85.130; # 转发路径（正则匹配） location ~ /edu/ &#123; proxy_pass http://127.0.0.1:8080; &#125; # 转发路径2（正则匹配） location ~ /cov/ &#123; proxy_pass http://127.0.0.1:8081; &#125;&#125; （4）防火墙开放8001端口12345# 添加8001端口firewall-cmd --add-port=8001/tcp --permanent# 重载防火墙firewall-cmd --reload （5）测试效果 事先启动tomcat8080、tomcat8081、nginx三个服务 分别访问两个tomcat的静态资源a.html 2.4 补充说明12345678location [ = | ~ | ~* | ^~] uri &#123;&#125;# location路径有可选选项进行填写# =：用于不含正则表达式的uri前，要求字符串uri严格匹配# ~：用于表示uri包含正则表达式，区分大小写# ~*：用于表示uri包含正则表达式。不区分大小写# ^~：用于不含正则表达式的uri前，寻找匹配度最高的location后，立即使用此location处理请求 3 负载均衡3.1 配置步骤 （1）准备一个相同的服务 继上面的反向代理，在tomcat8081的/webapps在创建edu目录，并创建文件a.html，内容如下1&lt;h1&gt;here is 8081!&lt;/h1&gt; （2）nginx配置 在http块中进行配置1234567891011121314151617# 负载均衡的服务器（名字自定义）upstream www.balance.com &#123; server 127.0.0.1:8080; server 127.0.0.1:8081;&#125;server &#123; # 端口号 listen 8002; # 服务名 server_name 192.168.85.130; # 转发路径（路径为上面负载均衡的服务器名） location ~ /edu/ &#123; proxy_pass http://www.balance.com; &#125;&#125; （3）防火墙开放8002端口12345# 添加8001端口firewall-cmd --add-port=8002/tcp --permanent# 重载防火墙firewall-cmd --reload （4）测试效果 记得重新启动tomcat8081和nginx 输入地址后，每次刷新都会切换到不同的tomcat服务（默认轮询算法） 3.2 补充说明 Nginx分配策略123456789101112131415161718192021222324# 不做任何配置，默认使用轮询：每个请求一个接一个平均分配到不同的服务器中# 权重策略：权重越高，分配给该服务器的请求数越多upstream www.balance.com &#123; server 127.0.0.1:8080 weight=1; server 127.0.0.1:8081 weight=2;&#125;# ip_hash：根据请求ip的hash值进行服务器分配，每个访客的固定在一台服务器，解决session问题upstream www.balance.com &#123; ip_hash; server 127.0.0.1:8080; server 127.0.0.1:8081;&#125;# fair（公平）：根据后端服务器的响应时间来分配，响应时间越短的服务器优先分配请求upstream www.balance.com &#123; server 127.0.0.1:8080; server 127.0.0.1:8081; fair;&#125; 4 动静分离4.1 介绍 动静分离：即将动态资源和静态资源部署在不同的服务器中 动态资源：一般指与数据库交互得到的数据 静态资源：一般指前端文件，即html、css、js等 实现思路：通过请求的后缀名不同，来区分动态/静态资源。通过expires参数，设置浏览器缓存，减少服务器请求。如果在指定缓存日期内请求，则会直接发送304状态码，让用户从自家浏览器缓存获取资源（前提服务器最后更新时间与浏览器缓存资源的最后更新时间一致，否则还是会从服务器下载资源） 4.2 配置实例 （1）准备静态资源 准备一个图片和html文件 （2）nginx配置12345678910111213141516171819# 若出现访问403，则需要此设置user root;http &#123; server &#123; # 端口号 listen 8003; # 服务名 server_name 192.168.85.130; # 请求转发（正则过滤静态资源） location ~ .*\\.(jpg|html)$ &#123; # 资源存放路径 root /home/letere/nginx_learn/static/; # 资源缓存时间 expires 7d; &#125; &#125;&#125; （3）防火墙开放8003端口12345# 添加8003端口firewall-cmd --add-port=8002/tcp --permanent# 重载防火墙firewall-cmd --reload （4）测试效果 5 Nginx高可用集群5.1 keepalived安装 指令：yum -y install keepalived keepalived配置文件路径：/etc/keepalived 5.2 keepalived配置12345678910111213141516171819202122# 脚本配置vrrp_script 脚本名 &#123; script &quot;脚本路径&quot; # 脚本执行时间（单位：秒） interval 数字&#125;# 服务器配置vrrp_instance 服务器名 &#123; # 服务器是主服务器/备份服务器 state MASTER/BACKUP # 网卡名称（通过ifconfig查看） interface 网卡名 # 路由id，同一服务使用同一id值 virtual_router_id id值 # 优先级 priority 数字 # 对外虚拟ip地址 virtual_ipaddress &#123; id地址 &#125;&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://letere-gzj.github.io/categories/Nginx/"}],"tags":[]},{"title":"【Nginx】Nginx入门","slug":"【Nginx】Nginx入门","date":"2021-07-19T08:30:45.000Z","updated":"2021-07-23T10:03:07.838Z","comments":true,"path":"2021/07/19/【Nginx】Nginx入门/","link":"","permalink":"https://letere-gzj.github.io/2021/07/19/%E3%80%90Nginx%E3%80%91Nginx%E5%85%A5%E9%97%A8/","excerpt":"Nginx的简单入门","text":"Nginx的简单入门 1 Nginx简介1.1 Nginx介绍 自行百度，不多废话 1.2 Nginx概念 （1）正向代理 局域网的机器要能够访问到互联网（Internet）的资源，则需要通过代理服务器来访问。这种的代理服务被称为正向代理 暴露代理服务器的地址，隐藏了客户端的信息 （2）反向代理 客户端发送请求到代理服务器，代理服务器根据请求发送到对应的真实服务器，再返回客户端 只暴露了代理服务器的地址，隐藏了真实服务器的地址 （3）负载均衡 请求数量巨大的时候，通过增加多个相同功能的服务器，将请求平摊分发到这些服务器上，减少单个服务器的请求数，减轻单个服务器的压力，称为负载均衡 （4）动静分离 将本在一台服务器部署的动态、静态资源进行拆分。一台服务器部署动态资源，一台资源部署静态资源，通过Nginx进行返回 2 Nginx安装 （1）官网下载安装包 http://nginx.org/en/download.html （2）安装Nginx相关依赖1yum install gcc gcc-c++ automake pcre pcre-devel zlib zlib-devel openssl openssl-devel （3）将Nginx压缩包解压到/opt目录1tar -zxvf (压缩文件名) （4）检查 - 编译 - 安装12./configure --prefix=/usr/local/nginx --with-http_ssl_modulemake &amp;&amp; make install 3 Nginx入门使用3.1 访问Niginx （1）开启Nginx进程12345# 切换目录到nginx指令目录cd /usr/local/nginx/sbin# 执行启动脚本./nginx （2）访问Nginx，Nginx默认端口为80，即访问地址为linux机器的ip地址12# 查看Linux机器ip地址ifconfig 若访问失败，则是Linux系统未有开放80端口号 3.2 开放80端口 （1）查看防火墙开放端口1firewall-cmd --list-all （2）开放80端口，并重启防火墙12345# 开放80端口firewall-cmd --add-port=80/tcp --permanent# 重启防火墙firewall-cmd --reload 4 Nginx命令 使用Nginx命令需要将目录切换到”/usr/local/nginx/sbin”下才能使用，或者自己配置Nginx环境变量 1234567891011121314# 查看nginx版本号./nginx -v# 启动nginx./nginx# 关闭nginx./nginx -s stop# 重载nginx（配置文件修改后不重启服务器）./nginx -s reload","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://letere-gzj.github.io/categories/Nginx/"}],"tags":[]},{"title":"【Linux】shell编程综合案例","slug":"【Linux】Shell编程综合案例","date":"2021-07-19T07:19:11.000Z","updated":"2021-07-19T07:41:04.265Z","comments":true,"path":"2021/07/19/【Linux】Shell编程综合案例/","link":"","permalink":"https://letere-gzj.github.io/2021/07/19/%E3%80%90Linux%E3%80%91Shell%E7%BC%96%E7%A8%8B%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","excerpt":"关于Shell编程的综合案例","text":"关于Shell编程的综合案例 1 数据库自动备份 （1）脚本12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/bash# 备份基础路径BACKUP_BASE_DIR=/home/letere/shell_learn/sample/data/backup# 备份日期（文件夹命名）BACKUP_TIME=$(date &quot;+%Y-%m-%d&quot;)# mysql数据库相关信息HOST=localhostUSERNAME=rootPASSWORD=123456DATABASE=nacos_configecho &quot;===== 备份开始 - $(date &quot;+%H:%M:%S&quot;) ======&quot;# 备份路径BACKUP_DIR=$&#123;BACKUP_BASE_DIR&#125;/$&#123;BACKUP_TIME&#125;# 判断文件目录是否存在，不存在则创建目录if [ ! -e $&#123;BACKUP_DIR&#125; ]then mkdir -p $&#123;BACKUP_DIR&#125;fi# 登录mysql，导出数据文件为.sql，压缩到文件目录中# 根据实际情况，用for循环备份多个数据库mysqldump -u$&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; --host=$&#123;HOST&#125; $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP_DIR&#125;/$&#123;DATABASE&#125;.sql.gz# 对当前日期的文件进行压缩tar -zcvPf $&#123;BACKUP_DIR&#125;.tar.gz $&#123;BACKUP_DIR&#125;# 删除缓存文件rm -rf $&#123;BACKUP_DIR&#125;# 删除10天前的数据find $&#123;BACKUP_BASE_DIR&#125; -mtime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \\;echo &quot;===== 备份结束 - $(date &quot;+%H:%M:%S&quot;) =====&quot; （2）演示","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【拓展】前后端数据交互","slug":"【拓展】前后端数据交互","date":"2021-07-14T01:43:14.000Z","updated":"2021-07-14T01:46:17.526Z","comments":true,"path":"2021/07/14/【拓展】前后端数据交互/","link":"","permalink":"https://letere-gzj.github.io/2021/07/14/%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/","excerpt":"工作中常见的前后端交互方式","text":"工作中常见的前后端交互方式 1 前端data传参，后端param接受1.1 解决思路 需要前端将数据封装在 FormData 里，将此FormData用data传递即可 1.2 代码123456789101112131415161718// axios方法export function dataTest(testData) &#123; return request(&#123; url: &quot;/test/dataTest&quot;, method: &quot;post&quot;, data: testData &#125;)&#125;// 前端-方法调用test() &#123; let formData = new FormData(); formData.append(&quot;name&quot;, &quot;莱特雷&quot;) formData.append(&quot;age&quot;, &quot;18&quot;) dataTest(formData).then(res =&gt; &#123; console.log(res.data) &#125;)&#125; 12345// 后端-数据接受@PostMapping(&quot;dataTest&quot;)public String dataTest(String name, String age) &#123; return name + &quot; &quot; + age;&#125;","categories":[{"name":"拓展","slug":"拓展","permalink":"https://letere-gzj.github.io/categories/%E6%8B%93%E5%B1%95/"}],"tags":[]},{"title":"【Linux】shell编程","slug":"【Linux】shell编程","date":"2021-06-30T09:26:17.000Z","updated":"2021-07-19T07:20:01.175Z","comments":true,"path":"2021/06/30/【Linux】shell编程/","link":"","permalink":"https://letere-gzj.github.io/2021/06/30/%E3%80%90Linux%E3%80%91shell%E7%BC%96%E7%A8%8B/","excerpt":"Linux中利用shell来实现编程效果","text":"Linux中利用shell来实现编程效果 1 Shell1.1 介绍 Shell 是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序 1.2 快速入门 （1）创建“hello.sh”文件1vim hello.sh （2）输入脚本解析器以及脚本执行内容12#!/bin/bash #脚本解析器为bashecho &quot;hello, world!&quot; #脚本执行内容 （3）给此脚本赋予执行权限“x”1chmod 744 hello.sh （4）运行脚本1./hello.sh 2 Shell变量2.1 介绍 Shell中变量分为：系统变量 和 用户自定义变量 系统变量：$HOME，$PWD，$SHELL，$USER set指令可查看所有系统变量 自定义变量：变量=值 撤销变量：unset 变量 声明静态变量：readonly 变量（不能够unset） 2.2 定义规则 （1）变量名可以有字母，数字，下划线组成，但不能以数字开头 （2）等号两侧不能有空格 （3）变量名一般使用大写 2.3 命令返回值用于赋值123变量=`命令`变量=$(命令) 2.4 演示 3 设置环境变量3.1 介绍 linux上所有的环境变量都配置在/etc/profile中 export 变量=值来配置环境变量 配置完毕后，通过source /etc/profile，重新加载配置文件来使用 3.2 演示 （1）打开/etc/profile配置环境变量 （2）echo打印一下环境变量（先要resource加载配置文件） 4 位置参数变量4.1 介绍 在我们执行shell脚本的时候，可以在后面拼接参数，进行传参，例：./test.sh hello world shell脚本有对应的参数变量来接收这些参数 （1）$n （n为数字） 以空格来切分命令，将上面命令变成[./test.sh, hello, world]，通过$0, $1, $2来获取参数 如果个数达到10位数以上，需要用大括号括住数字$&#123;10&#125; （2）$* 获取全部参数，会将传入的参数hello world视为一个整体 （3）$@ 获取全部参数，与上面不同，会将hello和world区分为个体 （4）$# 统计传入参数的个数 4.2 演示 （1）创建test.sh （2）带参运行test.sh 5 预定义变量5.1 介绍 shell本身有定义好的变量提供用户使用 （1）$$ 获取当前进行的PID （2）$! 获取后台运行的最后一个进程的进程号 （3）$? 最后一次执行的命令的返回状态{0=正常，非0=异常} 5.2 演示 （1）创建test.sh文件 （2）运行test.sh文件 6 运算符6.1 使用方式1234567（1）$((运算表达式))（2）$[运算表达式]（3）expr 运算表达式# 注意：expr的算法表达式的运算符号间有空格# 注意：用expr时乘法*需要用转译字符，即\\*表示 6.2 演示 7 条件判断7.1 判断条件 （1）比较符1234567= 字符串比较使用的等于-lt 小于-gt 大于-eq 等于-le 小于等于-ge 大于等于 （2）文件权限判断123-r 文件路径 ：是否有读的权限-w 文件路径 ：是否有写的权限-x 文件路径 ：是否有执行的权限 （3）文件类型判断123-e 文件路径 ：文件是否存在-f 文件路径 ：文件是否是常规文件-d 文件路径 ：文件是否是目录 7.2 if判断语法 方式一1234567if [ 判断条件 ];then 代码逻辑else 代码逻辑fi# 注意：[]中的内容左右两边要有空格，[]结尾用带有; （2）方式二12345678# 方式二if [ 判断条件 ]then 代码逻辑else 代码逻辑fi# 注意：跟上面基本一致，少了个分号&#x27;;&#x27; （3）多重判断写法1234567891011# 多重判断写法if [ 判断条件 ]then 代码逻辑elif [ 判断条件 ]then 代码逻辑else 代码逻辑fi# 注意：就是用elif来拼接，用上面两种写法都可以 7.3 演示 8 分支控制8.1 case分支控制语法 case写法123456789101112case 变量 in&quot;变量值1&quot;) 逻辑代码1;;&quot;变量值2&quot;) 逻辑代码2;;...*) 默认逻辑;;esac 8.2 演示 9 循环遍历9.1 for循环语法 （1）方式一12345for 暂时变量 in 变量1 变量2 变量3 ...do 代码逻辑done# 注意：遍历时将变量1,2,3...分别赋值给暂时变量 （2）方式二12345for ((初始值; 循环控制条件; 变量变化))do 代码逻辑done# 注意：跟java语法遍历类似，只是用了两个()进行括起 9.2 for循环演示 9.3 while循环语法 while语法1234while [ 条件判断 ]do 代码逻辑done 9.4 while循环演示 10 读取控制台输入 类似java中的scanf，等待用户输入数据，然后才进行下一步操作 10.1 语法12345read (选项) (参数) 接收变量选项: -p : 读取值时的提示符 -t : 读取值时的等待时间，超过等待时间，则自动往下执行 10.2 演示 11 函数11.1 系统函数 （1）获取文件名12basename (文件路径) （后缀名）# basename会自动帮助过滤路径，只保留文件名，若连后缀名也不保留，则要填写后缀名 （2）获取文件目录路径12dirname (文件路径)# dirname与basename相反，反而会获取文件所在目录的路径 11.2 自定义函数 函数自定义语法1234function (函数名) () &#123; 代码逻辑&#125;# 注意：shell编程的函数不需要带形参","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】软件包安装","slug":"【Linux】软件包安装","date":"2021-06-29T09:37:44.000Z","updated":"2021-06-29T09:46:23.643Z","comments":true,"path":"2021/06/29/【Linux】软件包安装/","link":"","permalink":"https://letere-gzj.github.io/2021/06/29/%E3%80%90Linux%E3%80%91%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85/","excerpt":"关于Linux中软件如何进行安装介绍","text":"关于Linux中软件如何进行安装介绍 1 RPM1.1 介绍 RPM（RedHat Package Manager：红帽软件管理工具）：用于互联网下载包的打包以及安装工具，其文件具有 .rpm 的后缀名，类似于windows的.exe文件 1.2 查询指令12345rpm -q [参数] : 查询rpm -qa : 查询全部rpmrpm -qi (包名) : 查询安装包的详细信息rpm -ql (包名) : 查询安装包安装的文件与路径rpm -qf (文件路径) : 查询该文件属于哪个安装包的 参数说明： el6：适用版本6.x操作系统 x86_64：64位操作系统 i686或i386：32位系统 noarch：通用 1.3 卸载指令12rpm -e (包名) : 卸载rpm -e --nodeps (包名) : 无视包的关系依赖，进行卸载 1.4 安装指令123rpm -i (rpm包路径名) : 本地安装rpm -iv (rpm包路径名) : 显示安装信息rpm -ih (rpm包路径名) : 显示安装进度条 2 YUM2.1 介绍 YUM：基于RPM包管理，能够从网络中自动下载RPM包，并进行安装，可以 自动处理包之间的依赖关系 ，并一次性安装所有依赖的软件包 2.2 查询指令1yum list : 列出yum服务器所有的rpm包（建议用grep进行过滤） 2.3 安装指令1yum install (包名) : 安装（默认最新）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【工作技能】二维码生成","slug":"【工作技能】二维码生成","date":"2021-06-29T07:48:15.000Z","updated":"2021-06-29T08:09:44.160Z","comments":true,"path":"2021/06/29/【工作技能】二维码生成/","link":"","permalink":"https://letere-gzj.github.io/2021/06/29/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD%E3%80%91%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90/","excerpt":"关于二维码的生成与使用","text":"关于二维码的生成与使用 1 com.google.zxing依赖1.1 依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 1.2 创建工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 二维码工具类 * @author letere * @create 2021-05-18 11:30 */public class QRCodeUtil &#123; private final static String CODE = &quot;utf-8&quot;; //编码格式 private final static int WIDTH = 300; //二维码宽 private final static int HEIGHT = 300; //二维码高 private final static String FORMAT = &quot;png&quot;; //二维码图片格式 /** * 生成二维码 * @param outputStream 输出流 * @param data 数据 * @param &lt;T&gt; 泛型 * @throws Exception */ public static&lt;T&gt; void create(OutputStream outputStream, T data) throws Exception&#123; //获取二维码生成参数 Map&lt;EncodeHintType, Object&gt; hints = getEncodeHints(); //将类转成String类型 String content = String.valueOf(data); //生成二维码信息（编码） MultiFormatWriter multiFormatWriter = new MultiFormatWriter(); BitMatrix encode = multiFormatWriter.encode(content, BarcodeFormat.QR_CODE, WIDTH, HEIGHT, hints); //输出二维码 MatrixToImageWriter.writeToStream(encode, FORMAT, outputStream); &#125; /** * 获取二维码编码参数 * @return Map&lt;EncodeHintType, Object&gt; */ private static Map&lt;EncodeHintType, Object&gt; getEncodeHints() &#123; Map&lt;EncodeHintType, Object&gt; hints = new HashMap&lt;&gt;(); hints.put(EncodeHintType.CHARACTER_SET, CODE); //编码格式 hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M); //纠错等级 hints.put(EncodeHintType.MARGIN, 1); //外边距（白边） return hints; &#125; /** * 读取二维码 * @param inputStream 输入流 * @param c 返回数据类型 * @param &lt;T&gt; 泛型 * @return T * @throws Exception */ public static&lt;T&gt; T read(InputStream inputStream, Class&lt;T&gt; c) throws Exception&#123; //读取二维码图片 BufferedImage image = ImageIO.read(inputStream); BinaryBitmap binaryBitmap = new BinaryBitmap(new HybridBinarizer(new BufferedImageLuminanceSource(image))); //读取二维码中的内容（解码） Map&lt;DecodeHintType, Object&gt; hints = getDecodeHints(); MultiFormatReader formatReader = new MultiFormatReader(); Result result = formatReader.decode(binaryBitmap, hints); //类型强转为指定指定数据类型 return (T) result.getText(); &#125; /** * 获取二维码解码参数 * @return Map&lt;DecodeHintType, Object&gt; */ private static Map&lt;DecodeHintType, Object&gt; getDecodeHints() &#123; Map&lt;DecodeHintType, Object&gt; hints = new HashMap&lt;&gt;(); hints.put(DecodeHintType.CHARACTER_SET, CODE); //解码格式 return hints; &#125;&#125; 1.3 代码测试 （1）生成二维码测试123456789@Testpublic void fileTest() throws Exception&#123; String text = &quot;https://www.bilibili.com&quot;; File file = new File(&quot;./src/main/resources/qr.png&quot;); FileOutputStream fos = new FileOutputStream(file); //工具类生成二维码（输出流，二维码内容） QRCodeUtil.create(fos, text);&#125; （2）读取二维码测试123456789@Testpublic void fileTest() throws Exception&#123; File file = new File(&quot;./src/main/resources/qr.png&quot;); FileInputStream fis = new FileInputStream(file); //工具类读取二维码图片内容（图片输入流，读取后的数据类型） String data = QRCodeUtil.read(fis, String.class); System.out.println(data);&#125;","categories":[{"name":"工作技能","slug":"工作技能","permalink":"https://letere-gzj.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"【Linux】服务管理","slug":"【Linux】服务管理","date":"2021-06-28T14:32:34.000Z","updated":"2021-06-28T15:36:30.137Z","comments":true,"path":"2021/06/28/【Linux】服务管理/","link":"","permalink":"https://letere-gzj.github.io/2021/06/28/%E3%80%90Linux%E3%80%91%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/","excerpt":"Linux关于服务如何进行管理","text":"Linux关于服务如何进行管理 1 服务管理1.1 介绍 服务的本质就是进程，但是是运行在后台的，通常会监听某个端口，等待其他进程的请求，因此我们又称为守护进程 1.2 查看服务 centos7以下：文件夹下 /etc/init.d/ 下的文件名就是已启动的服务名 centos7以上：指令 systemctl list-units –type=service查看已启动服务 1.3 管理指令 （1）Centos7.0前12345service (服务名) start : 启动服务service (服务名) stop : 关闭服务service (服务名) restart : 重启服务service (服务名) reload : 重载服务service (服务名) status : 服务状态 （2）Centos7后，service替换成systemctl，但仍然能够使用service1systemctl [start | stop | restart | reload | status] (服务名) 1.4 自启动设置 Centos7以前 123chkconfig : 查看服务在各运行级别的自启动情况chkconfig (服务名) : 查看指定服务在各运行级别的启动情况chkconfig --level (级别) (服务名) on/off : 指定某个服务在指定运行级别是否自启动 Centos7以后 12systemctl list-unit-files : 查看服务自启动情况systemctl enable/disable (服务名) : 服务自启动/关闭自启动 2 端口测试2.1 介绍 window自带的一个指令 telnet 来测试某服务的端口是否处于监听状态（启动状态） 格式：telnet ip地址 端口号 2.2 开启方法 2.3 测试 测试sshd端口22 3 服务监控3.1 指令1234netstat : 监控服务（默认监控连接中的服务）netstat -a : 监控所有服务（包含监听中）netstat -n : 不解析服务名netstat -p : 显示服务的PID","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】进程管理","slug":"【Linux】进程管理","date":"2021-06-28T08:48:32.000Z","updated":"2021-06-28T15:08:38.664Z","comments":true,"path":"2021/06/28/【Linux】进程管理/","link":"","permalink":"https://letere-gzj.github.io/2021/06/28/%E3%80%90Linux%E3%80%91%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"关于Linux进程方面的管理操作","text":"关于Linux进程方面的管理操作 1 进程管理1.1 介绍 Linux中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号 每一个进程，都会有对应一个父进程，父进程可以有多个子进程 每个进程都有两种存在方式： 前台和后台 前台进程：用户可以在屏幕进行操作 后台进程：进程在运行，但无法在屏幕上看到 2 进程显示2.1 显示系统执行的进程12345psps -a : 显示所有进程信息ps -u : 以用户格式显示进程信息ps -x : 显示后台进程运行的参数ps -f : 显示父进程ID 2.2 显示进程树123pstreepstree -p 显示进程的PIDpstree -u 显示进程所属用户 3 进程终止3.1 指令12kill (进程号：PID)kill -9 (进程号：PID) : 强制终止进程 12killall (进程名，支持通配符*)killall -9 (进程名) ： 强制终止匹配的所有进程 4 进程监控4.1 指令1234top : 动态显示进程信息top -d (秒数) : 设置指定秒数更新进程信息top -i : 不显示任何闲置或僵死的进程top -p (进程PID) : 监控指定进程信息 4.2 交互指令 进入进程监控界面之后可以输入一下指令，达到想要的效果 123456P : 以CPU使用率进行排序（默认）M : 以内存的使用率进行排序N : 以PID进行排序u : 监控指定用户的进程k : 杀死指定进程q : 退出监控","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】网络配置","slug":"【Linux】网络配置","date":"2021-06-25T10:02:31.000Z","updated":"2021-06-28T07:24:29.569Z","comments":true,"path":"2021/06/25/【Linux】网络配置/","link":"","permalink":"https://letere-gzj.github.io/2021/06/25/%E3%80%90Linux%E3%80%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","excerpt":"关于Linux的网络配置相关知识","text":"关于Linux的网络配置相关知识 1 虚拟机网络1.1 介绍 （1）windows与虚拟机连通 window下有一个网卡为 “VMware Network Adapter VMnet8” ，是用于与虚拟机进行通讯 window可以用ipconfig查看ip地址，linux可以用ifconfig查看ip地址 可以看到这两个网络是同一网段 （2）windows与Internet连接 通过windows下的真实网卡，经历路由器网关，跟互联网进行交互 1.2 查看网络IP和网关 （1）linux （2）windows 2 网络配置2.1 自动获取 缺点：没有 图形化界面，则无法对网络进行修改 2.2 指定固定ip地址 修改 /etc/sysconfig/network-scripts/ 目录下的文件，不同版本文件名不同。例如Centos8的文件名为ifcfg-ens33","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】磁盘查询指令","slug":"【Linux】磁盘查询指令","date":"2021-06-25T08:27:33.000Z","updated":"2021-06-25T08:31:24.755Z","comments":true,"path":"2021/06/25/【Linux】磁盘查询指令/","link":"","permalink":"https://letere-gzj.github.io/2021/06/25/%E3%80%90Linux%E3%80%91%E7%A3%81%E7%9B%98%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/","excerpt":"关于Linux关于磁盘方面的常用指令","text":"关于Linux关于磁盘方面的常用指令 1 磁盘查询指令1.1 查询系统整体磁盘使用情况12df (disk free : 磁盘空闲)df -h ：带单位查看 1.2 查询指定目录的磁盘占用情况123456du (disk useage : 磁盘使用)du -s (目录) ：指定目录大小汇总du -h (目录) ：带单位du -a (目录) ：统计包含文件du --max-depth=1 (目录) ：子目录深度du -c (目录) ：列出明细同时，增加汇总值 2 工作实用指令2.1 查询指定目录下文件个数1ls -l (目录) | grep &quot;^-&quot; | wc -l 2.2 查看指定目录文件个数（包含子文件）1ls -lR (目录) | grep &quot;^-&quot; | wc -l 跟上面基本一致，只是添加-R来进行递归 2.3 树形结构显示文件1tree (目录)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】磁盘分区和挂载","slug":"【Linux】磁盘分区和挂载","date":"2021-06-23T15:23:56.000Z","updated":"2021-06-23T15:30:27.993Z","comments":true,"path":"2021/06/23/【Linux】磁盘分区和挂载/","link":"","permalink":"https://letere-gzj.github.io/2021/06/23/%E3%80%90Linux%E3%80%91%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%8C%82%E8%BD%BD/","excerpt":"Linux磁盘分区知识，以及挂载实现方法","text":"Linux磁盘分区知识，以及挂载实现方法 1 磁盘分区1.1 分区方式 （1）mbr分区 最多支持四个主分区 系统只能安装主分区 拓展分区要占一个主分区 MBR最大只支持2TB，但拥有最好的兼容性 （2）gpt分区 支持无线多个主分区（但操作系统可能限制） 最大支持18EB的大容量（1EB = 1024PB，1PB = 1024TB） 1.2 Window磁盘分区 步骤： 此电脑 -&gt; 右键 -&gt; 管理 -&gt; 磁盘管理 因为本人电脑为win10，采用的分区形式有所区别，所以都是主分区 2 Linux分区2.1 介绍 Linux无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构。 Linux采用一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录关联起来。 2.2 分区命名 （1）Linux的硬盘分为IDE（旧），SCSI（新）硬盘两种 （2）IDE分区命名： 盘号标识符为：hdx~ hd为设备类型，即指IDE硬盘 x为盘号【a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘】 ~为区号，即此分区为当前盘号的第几个分区【1~4主分区，5后为逻辑分区】 （3）SCSI分区命名： 基本和IDE一致，只是设备类型不同，为sd 2.3 分区查看 命令行输入指令lsblk (list block) -f，来查看分区 3 磁盘挂载3.1 挂载案例 给linux虚拟机新创一个硬盘，并挂载到/home/newdisk下 3.2 挂载步骤 （1）虚拟机添加硬盘 （2）分区 （3）格式化 （4）挂载 （5）设置可以自动挂载（重启之后会自动重新挂载）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【数据结构和算法】马踏棋盘算法","slug":"【数据结构和算法】马踏棋盘算法","date":"2021-06-19T05:50:14.000Z","updated":"2021-06-19T06:41:27.322Z","comments":true,"path":"2021/06/19/【数据结构和算法】马踏棋盘算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/19/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E7%AE%97%E6%B3%95/","excerpt":"算法之马踏棋盘算法的介绍和实现（马踏棋盘也称为骑士周游算法）","text":"算法之马踏棋盘算法的介绍和实现（马踏棋盘也称为骑士周游算法） 1 马踏棋盘算法1.1 问题 1.2 算法介绍 马踏棋盘问题（骑士周游问题）：实际上是图的深度优先搜索的应用（递归回溯） 实现思想：需要一个步骤矩阵，记录马每一步的移动的位置。需要计算马可以走的日字可移动位置集合，选其中一点进行递归（当前可移动位置，重新计算下一个可移动位置，有从其中选一个进行递归），直到马移动的步数=棋盘的大小结束递归。反之则进行递归回溯，回到上一个点，重新选另一个可移动的位置 1.3 代码实现 （1）棋盘类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 棋盘类 * @author letere * @create 2021-06-18 17:44 */public class Chessboard &#123; /** * 子类：位置类（坐标） */ private static class Location&#123; public int x; //横坐标 public int y; //纵坐标 public Location(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125;//----------------------------------------- //棋盘大小 private static int size; //是否完成（用于跳出递归） private static boolean isFinish = false; /** * 运行“马踏棋盘”算法 * @param x 行 * @param y 列 */ public static void run(int x, int y, int boardSize) &#123; //设置棋盘大小 size = boardSize; //创建步骤矩阵 int[][] stepMatrix = new int[size][size]; int step = 1; //马踏棋盘-递归 travel(stepMatrix, x, y, step); //打印结果 if (isFinish) &#123; System.out.println(&quot;步骤矩阵为：&quot;); for (int[] row : stepMatrix) &#123; for (int column : row) &#123; System.out.print(column + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; &#125; /** * &quot;马踏棋盘&quot;算法 - 递归本体 * @param stepMatrix 步骤矩阵 * @param x 行 * @param y 列 * @param step 步骤 */ private static void travel(int[][] stepMatrix, int x, int y, int step) &#123; //将当前位置步骤记录 stepMatrix[x][y] = step; //计算可移动位置 List&lt;Location&gt; moveLocations = getMoveLocations(new Location(x, y)); //遍历可移动位置 for (Location location : moveLocations) &#123; //判断该位置是否已访问，未访问则递归寻找下一个位置 if (stepMatrix[location.x][location.y] == 0) &#123; travel(stepMatrix, location.x, location.y, step+1); &#125; &#125; //递归遍历完毕后，判断是否全部完成 //未完成则进行还原（回溯） if (step &lt; size * size &amp;&amp; !isFinish) &#123; stepMatrix[x][y] = 0; &#125;else &#123; isFinish = true; &#125; &#125; /** * 计算“马”走日字的可移动位置 * @param current 当前位置 * @return List&lt;Location&gt; */ private static List&lt;Location&gt; getMoveLocations(Location current) &#123; //可移动位移数组 List&lt;Location&gt; locations = new ArrayList&lt;&gt;(); //位移量（左右1，上下2）（左右2， 上下1） int[][] displacements = new int[][]&#123;&#123;1, 2&#125;, &#123;2, 1&#125;&#125;; //方向（正负） int[] directions = new int[]&#123;-1, 1&#125;; //左1右1，上2下2；左2右2，上1下1；八种情况枚举出来，判断是否可以移动 int x; int y; for (int[] displacement : displacements) &#123; for (int xDirection : directions) &#123; for (int yDirection : directions) &#123; x = current.x + displacement[0] * xDirection; y = current.y + displacement[1] * yDirection; //移动后的位置不越界，计入可移动位置中 if ((x &gt; -1 &amp;&amp; x &lt; size) &amp;&amp; (y &gt; -1 &amp;&amp; y &lt; size)) &#123; locations.add(new Location(x, y)); &#125; &#125; &#125; &#125; return locations; &#125;&#125; （2）测试12345@Testpublic void chessboardTest() &#123; //从(0, 0)为开始长度为8*8大小的棋盘 Chessboard.run(0, 0, 8);&#125; 1.4 算法优化 由于算法中递归回溯会浪费很多时间，所以对算法的优化目标在尽量减少递归回溯的出现 可以对可移动位置进行排序，对当前可移动位置的下一个可移动位置个数按升序排序。下一个可移动位置个数少，假若当前的位置不是正确答案，可以以少量的回溯就可以换下一个位置，来求正确答案，从而减少求出正确答案时的递归回溯。（贪心算法思想：每次选最优） （1）优化代码：新增排序方法，在遍历可移动位置时先进行排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 对位置进行排序（当前位置的可移动位置数量进行升序排序 - 从小到大） * @param locations 位置集合 */private static void sort(List&lt;Location&gt; locations) &#123; //创建比较器，实现比较方法 Comparator&lt;Location&gt; comparator = new Comparator&lt;&gt;() &#123; @Override public int compare(Location o1, Location o2) &#123; return getMoveLocations(o1).size() - getMoveLocations(o2).size(); &#125; &#125;; //排序 locations.sort(comparator);&#125;/** * &quot;马踏棋盘&quot;算法 - 递归本体 * @param stepMatrix 步骤矩阵 * @param x 行 * @param y 列 * @param step 步骤 */private static void travel(int[][] stepMatrix, int x, int y, int step) &#123; //将当前位置步骤记录 stepMatrix[x][y] = step; //计算可移动位置 List&lt;Location&gt; moveLocations = getMoveLocations(new Location(x, y)); //按照下一个可移动位置个数进行升序排序 sort(moveLocations); //遍历可移动位置 for (Location location : moveLocations) &#123; //判断该位置是否已访问，未访问则递归寻找下一个位置 if (stepMatrix[location.x][location.y] == 0) &#123; travel(stepMatrix, location.x, location.y, step+1); &#125; &#125; //递归遍历完毕后，判断是否全部完成 //未完成则进行还原（回溯） if (step &lt; size * size &amp;&amp; !isFinish) &#123; stepMatrix[x][y] = 0; &#125;else &#123; isFinish = true; &#125;&#125; （2）测试1234@Testpublic void chessboardTest() &#123; Chessboard.run(0, 0, 8);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】最短路径算法","slug":"【数据结构和算法】最短路径算法","date":"2021-06-16T09:55:55.000Z","updated":"2021-06-18T10:00:39.855Z","comments":true,"path":"2021/06/16/【数据结构和算法】最短路径算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/","excerpt":"最短路径算法的介绍和代码实现","text":"最短路径算法的介绍和代码实现 1 最短路径算法1.1 问题 2 迪杰斯特拉算法2.1 介绍 迪杰斯特拉（Dijkstra）算法：是典型的最短路径算法，用于计算一个顶点到其他顶点的最短路径。它主要特点为一起始点为中心向外层次扩展（广度优先遍历思想），直到全部顶点都被遍历过 2.2 思路 （1） 创建两个数组，一个已访问顶点数组（visitedArr），用来记录哪些顶点已被访问；另一个是最短路径数组（distanceArr），记录选定顶点到各个顶点之间的最短路径，数组初始化为-1，表示顶点之间不连通，没有最短路径。 （2） 选定一个顶点作为初始顶点（第一次的初始顶点也是选定顶点），记录该顶点为已访问，若该顶点的距离数组为-1，则此顶点是选定顶线，修改为0，表示顶点到自身的距离设置为0 （3） 将初始顶点的相邻的未访问顶点记录，先计算路径：（选定节点到初始顶点距离 + 初始顶点到相邻未访问顶点距离），比较距离数组中未访问顶点的最短路径。若为-1，则是第一连通，直接距离数据赋值。不为-1，则此顶点之前已被连通，现在的是另一种连通路线，比较路径大小。比已记录的最短路径要小，则修改距离数组。 （4） 从距离数组选取路径最短，并且是未访问的顶点，作为新的初始顶点。重复（2）（3）（4）的步骤 （5） 直到所有顶点表示为已访问时，结束算法 2.3 图解 （1）以此图为例 （2）以G点作为初始顶点，开始算法 （3）以A点继续作为初始顶点，对比相邻未访问顶点的距离 （4）以上面的情况推出得到的结果为： 2.4 代码 （1）图类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 图（邻接矩阵） * @author letere * @create 2021-06-09 16:54 */public class Graph &#123; //顶点集合 private String[] vertexes; //邻接矩阵 private int[][] matrix; //边个数 private int edgeCount; //构造器 public Graph(String[] vertexes) &#123; this.vertexes = vertexes; int temp = vertexes.length; this.matrix = new int[temp][temp]; &#125; /** * 连接顶点 * @param vertex1 顶点1 * @param vertex2 顶点2 * @param weight 边权重 */ public void connect(String vertex1, String vertex2, int weight) &#123; int index1 = getVertexIndex(vertex1); int index2 = getVertexIndex(vertex2); matrix[index1][index2] = weight; matrix[index2][index1] = weight; //边个数+1 edgeCount++; &#125; /** * 获取顶点下标 * @param vertex 顶点 */ private int getVertexIndex(String vertex) &#123; for (int i=0; i&lt;vertexes.length; i++) &#123; if (vertex.equals(vertexes[i])) &#123; return i; &#125; &#125; return -1; &#125; /** * 获取顶点集合 * @return String[] */ public String[] getVertexes() &#123; return vertexes; &#125; /** * 获取邻接矩阵 * @return int[][] */ public int[][] getMatrix() &#123; return matrix; &#125; /** * 获取边个数 * @return int */ public int getEdgeCount() &#123; return edgeCount; &#125;&#125; （2）最短路径问题类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/** * 最短路径问题 - 迪杰斯特拉算法 * @author letere * @create 2021-06-15 21:31 */public class ShortestPath &#123; //顶点数组 private final String[] vertexArr; //邻接矩阵 private final int[][] matrix; //构造器 public ShortestPath(Graph graph) &#123; this.vertexArr = graph.getVertexes(); this.matrix = graph.getMatrix(); &#125; /** * 迪杰斯特拉算法 * @param vertex 初始顶点 */ public void dijkstra(String vertex) &#123; //已访问顶点数组 boolean[] visitedArr = new boolean[vertexArr.length]; //距离数组（记录初始顶点到每个顶点最短距离） int[] distanceArr = new int[vertexArr.length]; Arrays.fill(distanceArr, -1); //前驱顶点数组（记录路线） int[] preVertexArr = new int[vertexArr.length]; Arrays.fill(preVertexArr, -1); //初始顶点下标并修改距离数组 int startIndex = getVertexIndex(vertex); distanceArr[startIndex] = 0; //最短路径长度 int len; int row = startIndex; //当下一未访问最短路径顶点存在，继续循环（-1表示不存在） while (row != -1) &#123; visitedArr[row] = true; //遍历行中元素（列） for (int column=0; column&lt;matrix[row].length; column++) &#123; //是相邻顶点 if (matrix[row][column] &gt; 0) &#123; //计算叠加后的路径（选定顶点到初始顶点距离 + 初始顶点到相邻顶点的距离） len = distanceArr[row] + matrix[row][column]; //记录初始顶点到当前相邻顶点的路径 //（-1为未访问过，直接赋值，反之跟之前的路径比较是否更短，更短才重新赋值） if (distanceArr[column] == -1) &#123; distanceArr[column] = len; preVertexArr[column] = row; &#125;else if (len &lt; distanceArr[column]) &#123; distanceArr[column] = len; preVertexArr[column] = row; &#125; &#125; &#125; //获取下一个未访问最短路径的顶点 row = getNextVertex(visitedArr, distanceArr); &#125; //打印结果 print(distanceArr, preVertexArr); &#125; /** * 获取顶点下标 * @param vertex 顶点 * @return int */ private int getVertexIndex(String vertex) &#123; for (int i=0; i&lt;vertexArr.length; i++) &#123; if (vertexArr[i].equals(vertex)) &#123; return i; &#125; &#125; return -1; &#125; /** * 获取下一个路径最短的新访问顶点 * @param visitedArr 已访问顶点数组 * @param distanceArr 距离数组 * @return int */ private int getNextVertex(boolean[] visitedArr, int[] distanceArr) &#123; int min = 0; int index = -1; //遍历寻找，最短路径的顶点，作为下一个访问顶点 for (int i=0; i&lt;visitedArr.length; i++) &#123; if (distanceArr[i] &gt; 0) &#123; //属于未访问顶点 if (!visitedArr[i]) &#123; //赋初值 if (min == 0) &#123; min = distanceArr[i]; index = i; &#125; //当前路径 &lt; 暂时最短路径，覆盖暂时最短路径，并记录下标 if (distanceArr[i] &lt; min) &#123; min = distanceArr[i]; index = i; &#125; &#125; &#125; &#125; return index; &#125; /** * 打印最短路径信息 * @param distanceArr 路径数组 * @param preVertexArr 前驱顶点数组 */ private void print(int[] distanceArr, int[] preVertexArr) &#123; //选择策略 String[] strategies = new String[distanceArr.length]; String strategy; //利用前驱顶点数组寻找最短路径路线 int index; for (int i=0; i&lt;preVertexArr.length; i++) &#123; strategy = vertexArr[i]; index = i; while (preVertexArr[index] != -1) &#123; index = preVertexArr[index]; strategy += &quot; - &quot; + vertexArr[index]; &#125; strategies[i] = strategy; &#125; //打印路线和距离 System.out.println(&quot;路线 : 距离&quot;); for (int i=0; i&lt;distanceArr.length; i++) &#123; System.out.println(strategies[i] + &quot; : &quot; + distanceArr[i]); &#125; &#125;&#125; （3）代码测试1234567891011121314151617181920212223242526272829303132@Testpublic void dijkstraTest() &#123; //创建图 Graph graph = getData(); //创建最短路径问题类 ShortestPath shortestPath = new ShortestPath(graph); //调用迪杰斯特拉算法 shortestPath.dijkstra(&quot;G&quot;);&#125;/** * 获取数据（邻接矩阵） * @return Graph */public Graph getData() &#123; String[] vertexes = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;&#125;; Graph graph = new Graph(vertexes); graph.connect(&quot;A&quot;, &quot;B&quot;, 5); graph.connect(&quot;A&quot;, &quot;C&quot;, 7); graph.connect(&quot;A&quot;, &quot;G&quot;, 2); graph.connect(&quot;B&quot;, &quot;D&quot;, 9); graph.connect(&quot;B&quot;, &quot;G&quot;, 3); graph.connect(&quot;C&quot;, &quot;E&quot;, 8); graph.connect(&quot;D&quot;, &quot;F&quot;, 4); graph.connect(&quot;E&quot;, &quot;F&quot;, 5); graph.connect(&quot;E&quot;, &quot;G&quot;, 4); graph.connect(&quot;F&quot;, &quot;G&quot;, 6); return graph;&#125; 3 弗洛伊德算法3.1 介绍 弗洛伊德（Floyd）算法：也是最短路径算法之一。弗洛伊德算法中，每一个顶点都是初始顶点，求出每个顶点到其他顶点的最短路径。这也是弗洛伊德算法的特点，会求出所有顶点到其他顶点的最短路径。 3.2 思路 （1） 创建两个二维数组（矩阵），一个是距离矩阵，用来记录每个顶点之间的最短距离。一个是中间关系矩阵，记录一个顶点到另外一个顶点，是经过哪个中间点。 （2） 初始化两个矩阵，距离矩阵初始化为图的邻接矩阵，但邻接矩阵用0代表两顶点不连通，距离矩阵使用-1表示。中间关系矩阵，初始化为每一行的中间点为自己 （3） 按顺序选第一个顶点作为中间顶点，选出所有可能的情况（两层for循环，分别枚举列出起始点和终点，只要起始点到中间点 和 中间点到终点 的距离矩阵的值都不为-1，即为可以连通），并修改距离矩阵和中间关系矩阵 （4） 重复步骤3，直到所有顶点作为中间点的情况都全部列举出来 3.3 图解 （1）以此图为例 （2）创建两个矩阵（距离矩阵和中间关系矩阵），并初始化 （3）选A点作为中间顶点，列选出所有可能情况，并修改距离矩阵和中间关系矩阵 （4）按照规则得出的最终结果为： 3.4 代码 （1）图类，上面迪杰斯特拉算法中有，不多赘述 （2）弗洛伊德算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 最短路径问题 - 弗洛伊德算法 * @author letere * @create 2021-06-17 22:52 */public class ShortestPath2 &#123; //顶点数组 private final String[] vertexArr; //邻接矩阵 private final int[][] matrix; //构造器 public ShortestPath2(Graph graph) &#123; this.vertexArr = graph.getVertexes(); this.matrix = graph.getMatrix(); &#125; /** * 弗洛伊德算法 */ public void floyd() &#123; int size = vertexArr.length; //距离矩阵（记录每个点之间的最短距离） int[][] distanceMatrix = Arrays.copyOf(matrix, size); //除了自己到自己距离为0，其余用-1表示两点不连通 for (int i=0; i&lt;size; i++) &#123; for (int j=i+1; j&lt;size; j++) &#123; if (distanceMatrix[i][j] == 0) &#123; distanceMatrix[i][j] = -1; distanceMatrix[j][i] = -1; &#125; &#125; &#125; //中间关系矩阵（记录每个点之间的中间点） int[][] midRelationMatrix = new int[size][size]; //初始化每行的中间点为自己（例：[0, 0, 0], [1, 1, 1], [2, 2, 2]） for (int i=0; i&lt;size; i++) &#123; for (int j=0; j&lt;size; j++) &#123; midRelationMatrix[i][j] = i; &#125; &#125; int len; //三次for循环，第一层选中间点，第二层选起始点，第三层选终点 for (int midIndex=0; midIndex&lt;size; midIndex++) &#123; start:for (int startIndex=0; startIndex&lt;size; startIndex++) &#123; for (int endIndex=0; endIndex&lt;size; endIndex++) &#123; //如果中间点与起始点不连通，直接选出下一个起始点 if (distanceMatrix[midIndex][startIndex] == -1) &#123; continue start; &#125; //如果中间点与终点不连通，直接选出下一个终点 if (distanceMatrix[midIndex][endIndex] == -1) &#123; continue; &#125; //都连通，则计算距离（起始点到中间点距离 + 中间点到终点距离） len = distanceMatrix[midIndex][startIndex] + distanceMatrix[midIndex][endIndex]; //此路径为第一次连通 或 此连通路径更短，则更新距离矩阵和中间关系矩阵 if (distanceMatrix[startIndex][endIndex] == -1 || len &lt; distanceMatrix[startIndex][endIndex]) &#123; distanceMatrix[startIndex][endIndex] = len; midRelationMatrix[startIndex][endIndex] = midIndex; &#125; &#125; &#125; &#125; //打印结果 print(distanceMatrix, midRelationMatrix); &#125; /** * 结果打印 * @param distanceMatrix 距离矩阵 * @param midRelationMatrix 中间关系矩阵 */ private void print(int[][] distanceMatrix, int[][] midRelationMatrix) &#123; int size = distanceMatrix.length; for (int startIndex=0; startIndex&lt;size; startIndex++) &#123; System.out.println(&quot;顶点&quot; + vertexArr[startIndex] + &quot;到各顶点的路线与距离：&quot;); for (int endIndex=0; endIndex&lt;size; endIndex++) &#123; //（1）打印路线 //打印起始点 System.out.print(vertexArr[startIndex] + &quot; -&gt; &quot;); //打印中间点 int temp = startIndex; while (midRelationMatrix[temp][endIndex] != temp) &#123; temp = midRelationMatrix[temp][endIndex]; System.out.print(vertexArr[temp] + &quot; -&gt; &quot;); &#125; //打印终点 System.out.print(vertexArr[endIndex] + &quot; : &quot;); //（2）打印距离 System.out.println(distanceMatrix[startIndex][endIndex]); &#125; System.out.println(&quot;--------------------------------------&quot;); &#125; &#125;&#125; （3）测试12345678910111213141516171819202122232425262728293031@Testpublic void floydTest() &#123; Graph graph = getData(); ShortestPath2 shortestPath2 = new ShortestPath2(graph); shortestPath2.floyd();&#125;/** * 获取数据（邻接矩阵） * @return Graph */public Graph getData() &#123; String[] vertexes = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;&#125;; Graph graph = new Graph(vertexes); graph.connect(&quot;A&quot;, &quot;B&quot;, 5); graph.connect(&quot;A&quot;, &quot;C&quot;, 7); graph.connect(&quot;A&quot;, &quot;G&quot;, 2); graph.connect(&quot;B&quot;, &quot;D&quot;, 9); graph.connect(&quot;B&quot;, &quot;G&quot;, 3); graph.connect(&quot;C&quot;, &quot;E&quot;, 8); graph.connect(&quot;D&quot;, &quot;F&quot;, 4); graph.connect(&quot;E&quot;, &quot;F&quot;, 5); graph.connect(&quot;E&quot;, &quot;G&quot;, 4); graph.connect(&quot;F&quot;, &quot;G&quot;, 6); return graph;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【工作技能】word转pdf","slug":"【工作技能】word转pdf","date":"2021-06-16T08:54:55.000Z","updated":"2021-06-16T09:08:41.593Z","comments":true,"path":"2021/06/16/【工作技能】word转pdf/","link":"","permalink":"https://letere-gzj.github.io/2021/06/16/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD%E3%80%91word%E8%BD%ACpdf/","excerpt":"如何利用java实现word转pdf","text":"如何利用java实现word转pdf 1 aspose-words工具包1.1 依赖准备123456789&lt;!--收费jar，需要下载到本地，通过本地导入--&gt;&lt;dependency&gt; &lt;groupId&gt;com.aspose&lt;/groupId&gt; &lt;artifactId&gt;aspose-words&lt;/artifactId&gt; &lt;version&gt;18.6&lt;/version&gt; &lt;classifier&gt;jdk16&lt;/classifier&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/aspose-words-18.6-jdk16-crack.jar&lt;/systemPath&gt; &lt;!--jar包路径--&gt;&lt;/dependency&gt; 百度网盘：https://pan.baidu.com/s/1wBg2Ml2Obn2n-hElO24xEw 提取码：4h45 1.2 准备license.xml文件12345678910111213&lt;License&gt; &lt;Data&gt; &lt;Products&gt; &lt;Product&gt;Aspose.Total for Java&lt;/Product&gt; &lt;Product&gt;Aspose.Words for Java&lt;/Product&gt; &lt;/Products&gt; &lt;EditionType&gt;Enterprise&lt;/EditionType&gt; &lt;SubscriptionExpiry&gt;20991231&lt;/SubscriptionExpiry&gt; &lt;LicenseExpiry&gt;20991231&lt;/LicenseExpiry&gt; &lt;SerialNumber&gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&lt;/SerialNumber&gt; &lt;/Data&gt; &lt;Signature&gt;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU=&lt;/Signature&gt;&lt;/License&gt; 1.3 修改Pom文件1234567891011&lt;!--编译java时，java文件夹下能携带xml文件--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 1.4 转换工具类123456789101112131415161718192021222324252627282930313233343536373839404142/** * word工具类 - word转pdf * @author letere * @create 2021-06-16 16:36 */public class WordUtil &#123; /** * word文档转pdf * @param inputStream word输入流 * @param pdfFile 转换后的pdf文件 */ public static void wordToPdf(InputStream inputStream, File pdfFile) throws Exception&#123; if (getLicense()) &#123; OutputStream outputStream = new FileOutputStream(pdfFile); //读取输入流 Document document = new Document(inputStream); //按pdf形式写入输出流 document.save(outputStream, SaveFormat.PDF); &#125; else &#123; throw new Exception(&quot;license文件验证失败！&quot;); &#125; &#125; /** * 获取license（文件验证，通过验证，转换后pdf无水印） * @return boolean */ private static boolean getLicense() &#123; try &#123; File file = new File(&quot;./src/main/java/util/aspose_words/license.xml&quot;); InputStream is = new FileInputStream(file); License aposeLic = new License(); aposeLic.setLicense(is); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125;&#125; 1.5 代码测试1234567891011@Testpublic void asposeWordsTest() throws Exception&#123; //word文件输入流 InputStream inputStream = new FileInputStream(&quot;./src/main/resources/word/操作手册.docx&quot;); //pdf输出文件 File pdfFile = new File(&quot;./src/main/resources/pdf/操作手册.pdf&quot;); //工具类进行转换 WordUtil.wordToPdf(inputStream, pdfFile);&#125;","categories":[{"name":"工作技能","slug":"工作技能","permalink":"https://letere-gzj.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"【数据结构和算法】最小生成树算法","slug":"【数据结构和算法】最小生成树算法","date":"2021-06-11T01:42:50.000Z","updated":"2021-06-11T15:33:30.357Z","comments":true,"path":"2021/06/11/【数据结构和算法】最小生成树算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95/","excerpt":"算法之最小生成树算法，最小生成树算法分为普里姆算法以及克鲁斯卡尔算法","text":"算法之最小生成树算法，最小生成树算法分为普里姆算法以及克鲁斯卡尔算法 1 最小生成树算法1.1 介绍 最小生成树MST（Minimun Cost Spanning Tree）：给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，称为最小生成树。 特点： （1）N个顶点，一定有N-1条边 （2）含有全部顶点 （3）N-1条边都在图中【每个顶点之间可以相互到达】 最小生成树算法：主要为普里姆算法和克鲁斯卡尔算法 1.2 最小生成树问题 2 普里姆算法2.1 介绍 普里姆算法（Prim）：选择一个点作为初始起点，将此点加入为已访问数组中，找出已访问数组中所有相邻的顶点，选择其中权重最小的顶点，并加入到已访问数组中。重复上面操作，直到已访问数组的长度等于顶点的个数停止。 2.2 图解 （1）以上面修路问题的图作为例子 （2）选择A点作为初始顶点，加入到已访问顶点中，并寻找出A点最短权重的边 （3）按照上面的思路，选中A, G点中最短权重的边 （4）按照上面的思路一路下来，最终结果为： 2.3 代码 （1）图类（邻接矩阵）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 图（邻接矩阵） * @author letere * @create 2021-06-09 16:54 */public class Graph &#123; //顶点集合 private String[] vertexes; //邻接矩阵 private int[][] matrix; //边个数 private int edgeCount; //构造器 public Graph(String[] vertexes) &#123; this.vertexes = vertexes; int temp = vertexes.length; this.matrix = new int[temp][temp]; &#125; /** * 连接顶点 * @param vertex1 顶点1 * @param vertex2 顶点2 * @param weight 边权重 */ public void connect(String vertex1, String vertex2, int weight) &#123; int index1 = getVertexIndex(vertex1); int index2 = getVertexIndex(vertex2); matrix[index1][index2] = weight; matrix[index2][index1] = weight; //边个数+1 edgeCount++; &#125; /** * 获取顶点下标 * @param vertex 顶点 */ private int getVertexIndex(String vertex) &#123; for (int i=0; i&lt;vertexes.length; i++) &#123; if (vertex.equals(vertexes[i])) &#123; return i; &#125; &#125; return -1; &#125; /** * 获取顶点集合 * @return String[] */ public String[] getVertexes() &#123; return vertexes; &#125; /** * 获取邻接矩阵 * @return int[][] */ public int[][] getMatrix() &#123; return matrix; &#125; /** * 获取边个数 * @return int */ public int getEdgeCount() &#123; return edgeCount; &#125;&#125; （2）修路问题，普里姆算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @author letere * @create 2021-06-09 16:30 */public class BuildRoad &#123; //顶点集合 String[] vertexes; //邻接矩阵 int[][] matrix; //构造器 public BuildRoad(Graph graph) &#123; this.vertexes = graph.getVertexes(); this.matrix = graph.getMatrix(); &#125; /** * 普里姆算法 */ public void primAlgorithm() &#123; //已访问顶点 List&lt;Integer&gt; visitedVertexes = new ArrayList&lt;&gt;(); visitedVertexes.add(0); //连接策略（边） List&lt;String&gt; strategy = new ArrayList&lt;&gt;(); //总权重 int total = 0; //图已全部连通：边 = 顶点数-1 while (strategy.size() &lt; vertexes.length-1) &#123; int index1 = -1; int index2 = -1; int min = 100000; //初始化一个巨大值，方便寻找最小值 for (Integer row : visitedVertexes) &#123; int column = 0; for (int weight : matrix[row]) &#123; //是邻接顶点 &amp;&amp; 权重&lt;最小权重 &amp;&amp; 是未访问顶点 if (weight &gt; 0 &amp;&amp; weight &lt; min &amp;&amp; !visitedVertexes.contains(column)) &#123; //记录下标和最小值 index1 = row; index2 = column; min = weight; &#125; column ++; &#125; &#125; //记录总权重，选择策略，已访问顶点 total += min; strategy.add(&quot;&lt;&quot; + vertexes[index1] + &quot;, &quot; + vertexes[index2] + &quot;&gt; 权重：&quot; + min); visitedVertexes.add(index2); &#125; //打印数据 for (String item : strategy) &#123; System.out.println(item); &#125; System.out.println(&quot;总权重为：&quot; + total); &#125;&#125; （3）测试123456789101112131415161718192021222324252627282930@Testpublic void primTest() &#123; Graph graph = getData(); BuildRoad buildRoad = new BuildRoad(graph); buildRoad.primAlgorithm();&#125;/** * 获取数据（邻接矩阵） * @return buildRoad */public Graph getData() &#123; String[] vertexes = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;&#125;; Graph graph = new Graph(vertexes); graph.connect(&quot;A&quot;, &quot;B&quot;, 5); graph.connect(&quot;A&quot;, &quot;C&quot;, 7); graph.connect(&quot;A&quot;, &quot;G&quot;, 2); graph.connect(&quot;B&quot;, &quot;D&quot;, 9); graph.connect(&quot;B&quot;, &quot;G&quot;, 3); graph.connect(&quot;C&quot;, &quot;E&quot;, 8); graph.connect(&quot;D&quot;, &quot;F&quot;, 4); graph.connect(&quot;E&quot;, &quot;F&quot;, 5); graph.connect(&quot;E&quot;, &quot;G&quot;, 4); graph.connect(&quot;F&quot;, &quot;G&quot;, 6); return graph;&#125; 3 克鲁斯卡尔算法3.1 介绍 克鲁斯卡尔（Krukal）算法：记录该图中所有边的权重，对边进行排序，然后从小到大选择边，加入到选择策略。选择边的时候，要注意不要形成回路。形成回路，意味着节点重复访问了。 形成回路判断：弄一个终点数组，记录每一个顶点指向下一个顶点的下标，-1表示没有下一个顶点，即为终点。当尝试加入一条边时，比较边的两个顶点的终点是否一样，一样则表示路线已连通，再进行连接会形成回路 3.2 图解 （1）还是上面修路问题的图作为例子： （2）选择不形成回路的最短边&lt;A, G&gt;，终点数组修改A指向G （3）继续按照上面思路，选择&lt;B, G&gt;，终点数组修改为B指向G （4）最终的结果图为： 3.3 代码 （1）准备一个图类，在上面的prim算法有，不再重复写 （2）修路问题-克鲁斯卡尔算法类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 克鲁斯卡尔算法 * @author letere * @create 2021-06-11 17:11 */public class BuildRoad2 &#123; /** * 私有子类：边 * 实现比较接口，方便排序 */ private class Edge implements Comparable&lt;Edge&gt;&#123; int start; //边顶点1 int end; //边顶点2 int weight; //权重 public Edge(int start, int end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125; @Override public int compareTo(Edge o) &#123; return weight - o.weight; &#125; &#125;//-------------------------------------------------------------------------- //顶点数组 private final String[] vertexes; //邻接矩阵 private final int[][] matrix; //边数组 private final Edge[] edges; //构造器 public BuildRoad2(Graph graph) &#123; this.vertexes = graph.getVertexes(); this.matrix = graph.getMatrix(); edges = new Edge[graph.getEdgeCount()]; int len = vertexes.length; int temp = 0; //初始化边数组 //上倒三角遍历，可以过滤重复的边，并且边的顶点按顶点数组的大小 for (int i=0; i&lt;len; i++) &#123; for (int j=i; j&lt;len; j++) &#123; if (matrix[i][j] &gt; 0) &#123; edges[temp] = new Edge(i, j, matrix[i][j]); temp ++; &#125; &#125; &#125; &#125; /** * 克鲁斯卡尔算法 */ public void kruskal() &#123; //终点数组：记录每个顶点的下一个顶点的下标，数值为-1则表示终点（没有下一个顶点） int[] ends = new int[vertexes.length]; for (int i=0; i&lt;vertexes.length; i++) &#123; ends[i] = -1; &#125; //选择策略（边集合） List&lt;String&gt; strategy = new ArrayList&lt;&gt;(); //总权重 int total = 0; //对边按权重大小进行排序 Arrays.sort(edges); //循环寻找选择策略 while (strategy.size() &lt; vertexes.length-1) &#123; for (Edge edge : edges) &#123; //求出边的两个顶点对应的终点 int endIndex1 = getEnd(ends, edge.start); int endIndex2 = getEnd(ends, edge.end); //对比两顶点的终点是否一致（一致则形成回路） if (endIndex1 != endIndex2) &#123; //判断哪个终点大，来修改终点数组（选择谁指向谁） if (endIndex1 &lt;= endIndex2) &#123; ends[edge.start] = edge.end; strategy.add(&quot;&lt;&quot; + vertexes[edge.start] + &quot;, &quot; + vertexes[edge.end] + &quot;&gt;：&quot; + edge.weight); &#125;else &#123; ends[edge.end] = edge.start; strategy.add(&quot;&lt;&quot; + vertexes[edge.end] + &quot;, &quot; + vertexes[edge.start] + &quot;&gt;：&quot; + edge.weight); &#125; total += edge.weight; break; &#125; &#125; &#125; //打印结果 for (String edge : strategy) &#123; System.out.println(edge); &#125; System.out.println(&quot;总权重：&quot; + total); &#125; /** * 获取当前顶点的终点下标 * @param ends 终点数组 * @param index 顶点下标 * @return int */ private int getEnd(int[] ends, int index) &#123; //值 != -1，不是终点，对指向的下一个顶点进行判断，直到找出终点 while (ends[index] != -1) &#123; index = ends[index]; &#125; return index; &#125;&#125; （3）测试123456789101112131415161718192021222324252627282930@Testpublic void kruskalTest() &#123; Graph graph = getData(); BuildRoad2 buildRoad = new BuildRoad2(graph); buildRoad.kruskal();&#125;/** * 获取数据（邻接矩阵） * @return buildRoad */public Graph getData() &#123; String[] vertexes = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;&#125;; Graph graph = new Graph(vertexes); graph.connect(&quot;A&quot;, &quot;B&quot;, 5); graph.connect(&quot;A&quot;, &quot;C&quot;, 7); graph.connect(&quot;A&quot;, &quot;G&quot;, 2); graph.connect(&quot;B&quot;, &quot;D&quot;, 9); graph.connect(&quot;B&quot;, &quot;G&quot;, 3); graph.connect(&quot;C&quot;, &quot;E&quot;, 8); graph.connect(&quot;D&quot;, &quot;F&quot;, 4); graph.connect(&quot;E&quot;, &quot;F&quot;, 5); graph.connect(&quot;E&quot;, &quot;G&quot;, 4); graph.connect(&quot;F&quot;, &quot;G&quot;, 6); return graph;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】贪心算法","slug":"【数据结构和算法】贪心算法","date":"2021-06-09T07:29:21.000Z","updated":"2021-06-09T07:31:33.921Z","comments":true,"path":"2021/06/09/【数据结构和算法】贪心算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/09/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"算法之贪心算法的介绍以及案例实现","text":"算法之贪心算法的介绍以及案例实现 1 贪心算法1.1 介绍 贪心算法（贪婪算法）：是指在对问题进行求解时，在每一步选择中都采用最好/最优的选择，从而希望能够导致结果是最后或者最优的算法 贪心算法所得的结果不一定是最优的结果，但是都是相对近似最优解的结果 2 集合覆盖问题2.1 问题 2.2 思路 （1）求出需要覆盖的所有数据的集合 （2）计算每个集合未覆盖的数据个数，记录个数最多的集合，此为局部最优集合，也是贪心算法的思想，每一步挑选最优的 （3）更新需要覆盖的数据的集合，循环上述操作，直到需要覆盖的数据集合大小为0 2.3 代码 （1）集合覆盖问题类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 集合覆盖问题 * @author letere * @create 2021-06-08 17:14 */public class CoverSet&lt;T&gt; &#123; //集合 private final Map&lt;String, List&lt;T&gt;&gt; set; //构造器 public CoverSet(Map&lt;String, List&lt;T&gt;&gt; set) &#123; this.set = set; &#125; /** * 贪心算法（解决集合覆盖） */ public void greedyAlgorithm() &#123; //未覆盖集合 Set&lt;T&gt; unCoverSet = getUnCoverSet(); //选择策略 List&lt;String&gt; strategy = new ArrayList&lt;&gt;(); while (unCoverSet.size() &gt; 0) &#123; //局部最优集合名 String bestSet = &quot;&quot;; //最大未覆盖数 int max = 0; //缓存变量 int temp; for (Map.Entry&lt;String, List&lt;T&gt;&gt; entry : set.entrySet()) &#123; temp = calUnCoverCount(entry.getValue(), unCoverSet); //对比比较出最大未覆盖数，从而得出局部最优集合 if (max &lt; temp) &#123; bestSet = entry.getKey(); max = temp; &#125; &#125; //添加进选择策略 strategy.add(bestSet); //移除已覆盖数据 removeSet(unCoverSet, set.get(bestSet)); &#125; System.out.println(&quot;选择策略为：&quot; + strategy); &#125; /** * 获取未覆盖集合 * @return Set */ private Set&lt;T&gt; getUnCoverSet() &#123; //Set集合自动去重 Set&lt;T&gt; unCoverSet = new HashSet&lt;&gt;(); //遍历添加到set中 for (List&lt;T&gt; value : set.values()) &#123; unCoverSet.addAll(value); &#125; return unCoverSet; &#125; /** * 计算未覆盖个数 * @param list 集合 * @param unCoverSet 未覆盖集合 * @return int */ private int calUnCoverCount(List&lt;T&gt; list, Set&lt;T&gt; unCoverSet) &#123; int count = 0; for (T item : list) &#123; if (unCoverSet.contains(item)) &#123; count ++; &#125; &#125; return count; &#125; /** * 移除已覆盖数据 * @param unCoverSet 未覆盖集合 * @param list 集合 */ private void removeSet(Set&lt;T&gt; unCoverSet, List&lt;T&gt; list) &#123; for (T item : list) &#123; unCoverSet.remove(item); &#125; &#125;&#125; （2）测试1234567891011121314151617181920212223242526272829303132@Testpublic void coverSet() &#123; //获取集合数据 Map&lt;String, List&lt;String&gt;&gt; set = getSetData(); //创建集合覆盖问题类 CoverSet&lt;String&gt; coverSet = new CoverSet&lt;&gt;(set); coverSet.greedyAlgorithm(); //答案为：[K1, K2, K3, K5]&#125;public Map&lt;String, List&lt;String&gt;&gt; getSetData() &#123; Map&lt;String, List&lt;String&gt;&gt; set = new HashMap&lt;&gt;(); String[] temp = new String[]&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;天津&quot;&#125;; set.put(&quot;K1&quot;, Arrays.asList(temp)); temp = new String[]&#123;&quot;广州&quot;, &quot;北京&quot;, &quot;深圳&quot;&#125;; set.put(&quot;K2&quot;, Arrays.asList(temp)); temp = new String[]&#123;&quot;成都&quot;, &quot;上海&quot;, &quot;杭州&quot;&#125;; set.put(&quot;K3&quot;, Arrays.asList(temp)); temp = new String[]&#123;&quot;上海&quot;, &quot;天津&quot;&#125;; set.put(&quot;K4&quot;, Arrays.asList(temp)); temp = new String[]&#123;&quot;杭州&quot;, &quot;大连&quot;&#125;; set.put(&quot;K5&quot;, Arrays.asList(temp)); return set;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】KMP算法","slug":"【数据结构和算法】KMP算法","date":"2021-06-07T06:41:42.000Z","updated":"2021-06-07T08:09:39.549Z","comments":true,"path":"2021/06/07/【数据结构和算法】KMP算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/07/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/","excerpt":"算法之KMP算法的介绍与实现","text":"算法之KMP算法的介绍与实现 1 暴力匹配算法1.1 介绍 暴力匹配：遍历字符串，一旦发现相似的字符，就进行匹配，匹配失败则回到发现的位置，继续往后匹配，直到匹配成功或字符串遍历完毕，匹配失败 1.2 思路 整体思路比较简单，需要注意的点是，如果匹配失败，如何返回一开始匹配的位置。因为匹配字符串都是默认保持在0号位，直到匹配成功后才往后移动。所以匹配字符串的下标就是匹配移动的长度，只要将这长度减回去，就恢复到原来的长度匹配的位置。 1.3 代码 （1）暴力匹配方法123456789101112131415161718192021222324252627282930313233343536/** * 暴力匹配 * @param s1 字符串1（被匹配字符串） * @param s2 字符串2（目标字符串） * @return int */public static int violentMatch(String s1, String s2) &#123; //转成字符数组（方便遍历） char[] s1Arr = s1.toCharArray(); char[] s2Arr = s2.toCharArray(); //index1记录字符串1的索引下标 int index1 = 0; //index2记录字符串2的索引下标 int index2 = 0; while (index1 &lt; s1Arr.length &amp;&amp; index2 &lt; s2Arr.length) &#123; //字符串匹配 if (s1Arr[index1] == s2Arr[index2]) &#123; index1++; index2++; //匹配失败，恢复原来长度，并向后移一位 &#125;else &#123; index1 = index1 - index2 + 1; index2 = 0; &#125; &#125; //匹配字符到达数组长度，匹配成功，返回开始匹配位置 if (index2 == s2Arr.length) &#123; return index1 - index2; &#125; //匹配失败，返回-1 return -1;&#125; （2）测试1234567@Testpublic void KMPTest() &#123; String s1 = &quot;你不不不你好啊你秀秀秀&quot;; String s2 = &quot;你好&quot;; int i = KMP.violentMatch(s1, s2); System.out.println(i); //答案为4&#125; 2 KMP算法2.1 介绍 KMP算法：是一个解决字符串是否在文本中出现过，若出现过，则返回最早出现的位置。因为此算法由三个人联合发表，KMP这是这三人的首字母组合。与暴力匹配不同在于，匹配不同时，会考虑匹配是否出现前后缀对称的字符，来决定匹配失败后重新匹配的位置。 2.2 思路 1、KMP算法核心，就是前后缀对称数组，如下图 求出前后缀对称数组思路 （1）准备两个变量，一个为 len ，用来记录前后缀对称字符的长度以及对称比较指针；另一个变量 i 用于指向字符数组，来遍历比较。下面假设 字符数组为strArr[] ， 前后缀对称数组为next[] （2）前后对称数组的0号位，一定为0，因为一个字符不存在前后缀的情况，所以字符数组遍历从1号位开始 （3）字符比较通过 strArr[i] == str[len] 来决定 （4）匹配成功，则 len+1 ，即表示前后缀字符长度+1，也表示下一次对称比较从下一个字符进行对比，然后记录前后缀对称数组 next[i] = len （5）匹配失败，则 len = next[len-1] ，意思为当前字符不存在对称情况，如果还可能出现对称情况，只能从 当前对称字符串的子对称字符串去匹配 ，一直递归往子对称字符找，要么找到成功匹配的。要么len=0，已经没有子对称的可以寻找 （6）上面的 len = next[len-1] 是kmp算法的核心，比较难理解，推荐和此博客文章进行理解：https://blog.csdn.net/yearn520/article/details/6729426 2、利用前后缀对称数组，在遍历的匹配失败的时候合理复原遍历的位置，如下图 2.3 代码 （1）KMP匹配方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * KMP匹配 * @param str1 字符串1（被匹配字符串） * @param str2 字符串2（模式串） * @return int */public static int kmpMatch(String str1, String str2) &#123; //获取前后缀对称长度数组 int[] next = getNextArr(str2); //字符数组（方便遍历） char[] s1Arr = str1.toCharArray(); char[] s2Arr = str2.toCharArray(); //遍历字符数组下标 int index1 = 0; int index2 = 0; //遍历字符数组 while(index1 &lt; s1Arr.length &amp;&amp; index2 &lt; s2Arr.length) &#123; //匹配成功 if (s1Arr[index1] == s2Arr[index2]) &#123; index1++; index2++; &#125;else &#123; //匹配失败 if (index2 &gt; 0) &#123; index2 = next[index2-1]; &#125;else &#123; index1++; &#125; &#125; &#125; //全部匹配成功，返回开始匹配下标 if (index2 == s2Arr.length) &#123; return index1 - index2; &#125; //失败返回-1 return -1;&#125;/** * 获取前后缀对称数组 * @param str 字符串 */private static int[] getNextArr(String str) &#123; //字符数组 char[] strArr = str.toCharArray(); //前后缀对称长度数组 int[] next = new int[str.length()]; //0号位一定为0 next[0] = 0; //前后缀对称字符串长度 int len = 0; //遍历字符串，从1号位开始 for(int i=1; i&lt;str.length(); i++) &#123; //匹配成功，前后缀对称长度+1 if (strArr[i] == strArr[len]) &#123; len++; &#125;else &#123; //匹配失败，递归寻找子对称是否匹配成功 while (len &gt; 0 &amp;&amp; strArr[i] != strArr[len]) &#123; len = next[len-1]; &#125; &#125; //记录长度 next[i] = len; &#125; return next;&#125; （2）测试12345678@Testpublic void KMPTest2() &#123; String s1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;; String s2 = &quot;ABCDABD&quot;; int i = KMP.kmpMatch(s1, s2); System.out.println(i); //答案为15&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】动态规划算法","slug":"【数据结构和算法】动态规划算法","date":"2021-06-06T04:18:00.000Z","updated":"2021-06-11T01:45:36.923Z","comments":true,"path":"2021/06/06/【数据结构和算法】动态规划算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/","excerpt":"算法之动态规划算法的介绍，以及案例介绍与是实现","text":"算法之动态规划算法的介绍，以及案例介绍与是实现 1 动态规划1.1 介绍 动态规划（Dynamic Programming） 算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法和分治算法类似，核心解题思想都是一样不同点 为：适合用动态规划求解的问题，经过分解后得到的子问题往往不是互相独立的（下一个子阶段的求解是建立在上一个子阶段的基础上，进一步求解） 动态规划可以通过填表的方式来逐步推出，得到最优解 2 01背包问题2.1 题目 2.2 思路 创建两个数组，来记录商品的 重量(weight) 以及 价值(value) ；创建一个二维数组，用来记录商品之间组合的最大价值，类似 填表的方式 ；表的横坐标为表示背包容量，纵坐标为可填入背包的器材，填表方式具体如下: 图解 思路总结： （1）优先比较新增商品重量与当前背包重量，大于背包重量，价值等于上一行的价值。反之进入下一步 （2）计算商品价值：新增商品价值 + 上一行当前剩余背包容量的价值 （3）比较计算后的价值与上一行的价值，计算价值&gt;上一行价值，填入计算价值，反之填入上一行价值 2.3 代码 （1）01背包问题类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 01背包 * @author letere * @create 2021-06-06 10:59 */public class Knapsack01 &#123; //物品名称 private String[] items; //物品价值 private int[] value; //物品重量 private int[] weight; //背包容量 private int size; //最大价值表格（纵坐标：物品，横坐标：背包容量） private int[][] valueTable; //装配策略 private Map&lt;String, Integer&gt;[][] strategy; //构造器 public Knapsack01(String[] items, int[] value, int[] weight, int size) &#123; this.items = items; this.value = value; this.weight = weight; this.size = size; int row = items.length + 1; int column = size + 1; this.valueTable = new int[row][column]; this.strategy = new HashMap[row][column]; //二维数组初始化，因为最大价值表int默认为0，所以不需要 for (int i=0; i&lt;row; i++) &#123; for (int j=0; j&lt;column; j++) &#123; strategy[i][j] = new HashMap&lt;&gt;(); &#125; &#125; &#125; /** * 计算最优装配策略 */ public void calculateBest() &#123; int val; //跳过第0行，从第1行开始计算 for (int row=1; row&lt;items.length+1; row++) &#123; for (int column=0; column&lt;size+1; column++) &#123; //重量 &gt; 背包容量，等于上一行价值 //row-1才是items, value, weight数组对应的下标 if (weight[row-1] &gt; column) &#123; valueTable[row][column] = valueTable[row-1][column]; strategy[row][column].putAll(strategy[row-1][column]); &#125;else &#123; //计算价值：新增商品价值 + 上一行当前剩余背包容量价值 val = value[row-1] + valueTable[row-1][column-weight[row-1]]; //比较当前计算价值与上一行的价值 if (valueTable[row-1][column] &gt; val) &#123; valueTable[row][column] = valueTable[row-1][column]; strategy[row][column] = strategy[row-1][column]; &#125;else &#123; valueTable[row][column] = val; strategy[row][column].putAll(strategy[row-1][column-weight[row-1]]); strategy[row][column].put(items[row-1], 1); &#125; &#125; &#125; &#125; System.out.println(&quot;最大价值为：&quot; + valueTable[items.length][size]); System.out.println(&quot;装配策略为：&quot; + strategy[items.length][size]); &#125; /** * 打印价值表 */ public void printValueTable() &#123; System.out.println(&quot;最大价值表格为：&quot;); for (int[] row : valueTable) &#123; for (int column : row) &#123; System.out.print(column + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; /** * 打印装配策略表 */ public void printStrategy() &#123; System.out.println(&quot;装配策略表为：&quot;); for (Map&lt;String, Integer&gt;[] row : strategy) &#123; for (Map&lt;String, Integer&gt; column : row) &#123; System.out.print(column + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; （2）测试123456789101112131415@Testpublic void knapsack01Test() &#123; String[] items = new String[]&#123;&quot;吉他&quot;, &quot;音响&quot;, &quot;电脑&quot;&#125;; int[] value = new int[]&#123;1500, 3000, 2000&#125;; int[] weight = new int[]&#123;1, 4, 3&#125;; int size = 4; Knapsack01 knapsack01 = new Knapsack01(items, value, weight, size); knapsack01.calculateBest(); System.out.println(&quot;------------------&quot;); knapsack01.printValueTable(); System.out.println(&quot;------------------&quot;); knapsack01.printStrategy();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】分治算法","slug":"【数据结构和算法】分治算法","date":"2021-06-05T09:06:57.000Z","updated":"2021-06-05T09:26:32.480Z","comments":true,"path":"2021/06/05/【数据结构和算法】分治算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/05/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","excerpt":"算法之分治算法的介绍，以及简单应用实现","text":"算法之分治算法的介绍，以及简单应用实现 1 分治算法1.1 介绍 分治算法（Divide and conquer algorithm）：顾明思义，“分而治之”，即将一个问题，分为很多个小问题，逐个解决，从而使得问题的解决变得简单。 基本步骤：分解：将原问题分解为若干和规模较小，相互独立，与原问题形式相同的子问题解决：若子问题规模较小而容易被解决，则直接解决，否则递归地解决各个子问题合并：将各个子问题的解合并为原问题的解 应用场景：二分搜索大整数乘法棋盘覆盖归并排序快速排序线性时间选择最接近点对问题循环赛日程表汉诺塔 2 汉诺塔问题2.1 思路： （1）盘子只有一个，直接将盘子从开始柱子，移动到目标柱子 （2）盘子大于一个，将盘子分为上下两部分。将上面的部分移动到中间柱子 （移动目的地变成中间柱子），下面部分移动到目标柱子，最后将中间柱子的盘子移动到目标柱子 2.2 图解 2.3 代码实现 （1）代码12345678910111213141516171819202122232425262728293031/** * 汉诺塔问题 * @author letere * @create 2021-06-05 16:33 */public class HanoiTower &#123; /** * 移动盘子（递归） * @param num 盘子个数 * @param start 盘子开始柱子 * @param target 盘子移动的目的地柱子 * @param temp 中间柱子 */ public static void move(int num, char start, char target, char temp) &#123; //盘子只有一个，直接从开始位置，移动到目的地 if (num == 1) &#123; System.out.println(start + &quot; -&gt; &quot; + target); return; &#125; //盘子 &gt; 1，分为上下两部分，递归处理 //上面部分从start柱子移动到temp柱子 move(num-1, start, temp, target); //下面部分从start柱子移动到target柱子 move(1, start, target, temp); //最后把上面部分从temp柱子移动到target柱子 move(num-1, temp, target, start); &#125;&#125; （2）测试12345@Testpublic void hanoiTowerTest() &#123; //三个盘子，从A柱移动到C柱，中间柱子为B HanoiTower.move(3, &#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】图遍历算法","slug":"【数据结构和算法】图遍历算法","date":"2021-06-03T15:22:13.000Z","updated":"2021-06-05T06:50:56.493Z","comments":true,"path":"2021/06/03/【数据结构和算法】图遍历算法/","link":"","permalink":"https://letere-gzj.github.io/2021/06/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/","excerpt":"图的遍历算法：深度优先搜索，广度优先搜索","text":"图的遍历算法：深度优先搜索，广度优先搜索 1 深度优先遍历1.1 介绍 深度优先搜索（Depth First Search）：从初始顶点开始访问，标记为”已访问”；选择其中一个邻接顶点进行访问，设置被访问的节点为初始顶点，标记”已访问”，继续选择其中一个未访问的邻接顶点进行访问…以此类推，递归进行。直到初始节点的邻接节点没有”未访问”状态的顶点，回溯到上一个顶点，判断是否有其他未访问的顶点，进行访问。明显深度优先算法和树的遍历，获取之前学的算法基本一致，都使用到了递归回溯方法。 1.2 图解 （1）以此图为例，以点A为初始顶点 （2）初始顶点A选择未访问顶点B，作为初始顶点 （3）初始顶点B选择未访问顶点C，作为初始顶点 （4）C点不存在相邻的未访问顶点，回溯到B点，选择D点作为初始顶点 （5）D点不存在相邻的未访问顶点，回溯到B点，选择E点作为初始顶点 （6）E点存在相邻未访问顶点，回溯B点；B点也不存在，回溯到A点；A点也不存在，遍历结束 1.3 代码实现 （1）准备一个图（邻接矩阵）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class AdjacencyMatrix &#123; //顶点数组 private final Object[] vertexArr; //邻接矩阵（二维数组） private final int[][] matrix; //构造器 public AdjacencyMatrix(Object[] vertexArr) &#123; this.vertexArr = vertexArr; int len = vertexArr.length; this.matrix = new int[len][len]; &#125; /** * 连接两个顶点 * @param vertex1 顶点1 * @param vertex2 顶点2 */ public void connect(Object vertex1, Object vertex2) &#123; int index1 = getIndex(vertex1); int index2 = getIndex(vertex2); //无向图（对称） matrix[index1][index2] = 1; matrix[index2][index1] = 1; &#125; /** * 获取顶点所在下标 * @param vertex 顶点 * @return int(下标) */ private int getIndex(Object vertex) &#123; for (int i=0; i&lt;vertexArr.length; i++) &#123; if (vertexArr[i].equals(vertex)) &#123; return i; &#125; &#125; throw new RuntimeException(&quot;顶点不存在，连接失败！&quot;); &#125; /** * 打印邻接矩阵 */ public void print() &#123; System.out.println(&quot;邻接矩阵为：&quot;); for(int[] row : matrix) &#123; for (int item : row) &#123; System.out.print(item + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125; （2）深度优先搜索方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 深度优先搜索 */public void depthFirstSearch() &#123; //访问标记数组（记录已访问顶点） boolean[] visitedArr = new boolean[vertexArr.length]; //深度优先搜索 - 递归 （从0号点开始） dfsRecursion(visitedArr, 0);&#125;/** * 深度优先搜索 - 递归本体 * @param visitedArr 访问标记数组 * @param row 初始顶点（邻接矩阵.行/列 == 顶点） */private void dfsRecursion(boolean[] visitedArr, int row) &#123; //标记初始顶点为&quot;已访问&quot; visitedArr[row] = true; //获取下一个未访问顶点 int nextRow = getNextUnVisited(visitedArr, row); //循环递归深度优先搜索，直至无下一个未访问顶点 while (nextRow &gt;= 0) &#123; //打印初始顶点 —&gt; 下一个未访问顶点 System.out.println(vertexArr[row] + &quot; -&gt; &quot; + vertexArr[nextRow]); //递归深度优先搜索下一个未访问顶点 dfsRecursion(visitedArr, nextRow); //递归回溯，重新寻找下一个未访问顶点 nextRow = getNextUnVisited(visitedArr, row); &#125;&#125;/** * 获取下一个未访问顶点 * @param visitedArr 访问标记数组 * @param row 初始顶点（邻接矩阵.行/列 == 顶点） * @return int */private int getNextUnVisited(boolean[] visitedArr, int row) &#123; //遍历寻找邻接顶点（邻接矩阵为1） for(int column=0; column&lt;vertexArr.length; column++) &#123; if (matrix[row][column] &gt; 0) &#123; //判断该顶点是否标记为“已访问” if (!visitedArr[column]) &#123; return column; &#125; &#125; &#125; //找不到，返回-1 return -1;&#125; （3）测试12345678910111213141516@Testpublic void dfsTest() &#123; //创建邻接矩阵 String[] vertexArr = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;; AdjacencyMatrix adjacencyMatrix = new AdjacencyMatrix(vertexArr); //连接顶点 adjacencyMatrix.connect(&quot;A&quot;, &quot;B&quot;); adjacencyMatrix.connect(&quot;A&quot;, &quot;C&quot;); adjacencyMatrix.connect(&quot;B&quot;, &quot;C&quot;); adjacencyMatrix.connect(&quot;B&quot;, &quot;D&quot;); adjacencyMatrix.connect(&quot;B&quot;, &quot;E&quot;); //深度优先搜索 adjacencyMatrix.depthFirstSearch();&#125; 2 广度优先遍历2.1 介绍 广度优先搜索（Broad First Search）：将一个初始顶点加入到队列中，然后将该初始顶点的所有邻接顶点都加入到队列中，直到无邻接顶点，此时初始顶点出列。新的初始顶点变为队列的队首，重复上面的操作，以此类推，直到队列为空，搜索结束。 若按邻接矩阵来理解，就相当于一行一行的寻找全部未访问的邻接顶点 2.2 图解 （1）以此图为例，A作为初始顶点 （2）将A点所有邻接顶点加入队列，标记为已访问，并A点出队列 （3）将B点所有邻接顶点接入队列，标记为已访问，并B点出队列 （4）C，D，E点都没有邻接顶点，依次出队列，队列为空，搜索结束 2.3 代码实现 （1）准备图（邻接矩阵），可看上面的深度优先遍历 （2）广度优先搜索方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 广度优先搜索 */public void BoardFirstSearch() &#123; //标记已访问数组 boolean[] visitedArr = new boolean[vertexArr.length]; //用linkedList来代替队列，并添加初始顶点0，标记为已访问 List&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(0); visitedArr[0] = true; //广度优先搜索 - 循环 bfsCirculation(queue, visitedArr);&#125;/** * 广度优先搜索 - 循环本体 * @param queue 队列 * @param visitedArr 标记已访问数据 */private void bfsCirculation(List&lt;Integer&gt; queue, boolean[] visitedArr) &#123; //队首 Integer head; //下一个未访问邻接顶点 int nextRow; //队列为空，结束循环 while (queue.size() &gt; 0) &#123; head = queue.get(0); nextRow = getNextUnVisited(visitedArr, head); //队首没有未访问顶点时，结束循环 while (nextRow &gt; 0) &#123; System.out.println(vertexArr[head] + &quot; -&gt; &quot; + vertexArr[nextRow]); //标记为已访问 visitedArr[nextRow] = true; //入列 queue.add(nextRow); //继续通过队首寻找下一个未访问顶点 nextRow = getNextUnVisited(visitedArr, head); &#125; //出列 queue.remove(0); &#125;&#125;/** * 获取下一个未访问顶点 * @param visitedArr 访问标记数组 * @param row 初始顶点（邻接矩阵.行/列 == 顶点） * @return int */private int getNextUnVisited(boolean[] visitedArr, int row) &#123; //遍历寻找邻接顶点（邻接矩阵为1） for(int column=0; column&lt;vertexArr.length; column++) &#123; if (matrix[row][column] &gt; 0) &#123; //判断该顶点是否标记为“已访问” if (!visitedArr[column]) &#123; return column; &#125; &#125; &#125; //找不到，返回-1 return -1;&#125; （3）测试12345678910111213141516@Testpublic void bfsTest() &#123; //创建邻接矩阵 String[] vertexArr = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;; AdjacencyMatrix adjacencyMatrix = new AdjacencyMatrix(vertexArr); //连接顶点 adjacencyMatrix.connect(&quot;A&quot;, &quot;B&quot;); adjacencyMatrix.connect(&quot;A&quot;, &quot;C&quot;); adjacencyMatrix.connect(&quot;B&quot;, &quot;C&quot;); adjacencyMatrix.connect(&quot;B&quot;, &quot;D&quot;); adjacencyMatrix.connect(&quot;B&quot;, &quot;E&quot;); //广度优先搜索 adjacencyMatrix.BoardFirstSearch();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】图","slug":"【数据结构和算法】图","date":"2021-05-31T15:27:18.000Z","updated":"2021-06-01T01:42:49.174Z","comments":true,"path":"2021/05/31/【数据结构和算法】图/","link":"","permalink":"https://letere-gzj.github.io/2021/05/31/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%9B%BE/","excerpt":"数据结构之图的介绍和实现","text":"数据结构之图的介绍和实现 1 图1.1 使用场景 线性表：只有一个前驱节点和一个后继节点（1 : 1）树：有一个前驱节点和多个后继节点（1 : 多） 一旦问题需要多 : 多的时候，以上的数据结构都不太适用所以诞生出了新的数据结构 - 图 1.2 介绍 图是一种数据结构，其中节点可以具有0个或者多个相邻元素。两个节点之间的连接称为边。节点也可以称为顶点 1.3 概念 （1）顶点【vertex】：图中的节点 （2）边【edge】：两节点之间的线 （3）路径：节点A到节点B，所经过的节点路线，例：A-&gt;C-&gt;D-&gt;B （4）无向图：两节点之间连接没有指向，即：节点AB互邻，可以A-&gt;B，也可以B-&gt;A （5）有向图：概念与无向图相反 （6）带权图：图的边带有一定的权值（数值） 1.4 编程表示方式 邻接矩阵（二维数组）：矩阵中0表示不相邻，1表示相邻。行和列都表示节点自己，所以行列的交汇点为两个节点的关系。 邻接表（数组+链表）：数组表示节点，链表表示与该节点相邻的节点编号 2 图的代码实现2.1 邻接矩阵 （1）代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 图表示方式 - 邻接矩阵 * @author letere * @create 2021-05-31 17:23 */public class AdjacencyMatrix &#123; //顶点数组 private final Object[] vertexArr; //邻接矩阵（二维数组） private final int[][] matrix; //构造器 public AdjacencyMatrix(Object[] vertexArr) &#123; this.vertexArr = vertexArr; int len = vertexArr.length; this.matrix = new int[len][len]; &#125; /** * 连接两个顶点 * @param vertex1 顶点1 * @param vertex2 顶点2 */ public void connect(Object vertex1, Object vertex2) &#123; int index1 = getIndex(vertex1); int index2 = getIndex(vertex2); //无向图（对称） matrix[index1][index2] = 1; matrix[index2][index1] = 1; &#125; /** * 获取顶点所在下标 * @param vertex 顶点 * @return int(下标) */ private int getIndex(Object vertex) &#123; for (int i=0; i&lt;vertexArr.length; i++) &#123; if (vertexArr[i].equals(vertex)) &#123; return i; &#125; &#125; throw new RuntimeException(&quot;顶点不存在，连接失败！&quot;); &#125; /** * 打印邻接矩阵 */ public void print() &#123; System.out.println(&quot;邻接矩阵为：&quot;); for(int[] row : matrix) &#123; for (int item : row) &#123; System.out.print(item + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125; （2）测试123456789101112131415@Testpublic void adjacencyMatrixTest() &#123; //创建邻接矩阵 String[] vertexArr = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;; AdjacencyMatrix adjacencyMatrix = new AdjacencyMatrix(vertexArr); //连接顶点 adjacencyMatrix.connect(&quot;A&quot;, &quot;B&quot;); adjacencyMatrix.connect(&quot;A&quot;, &quot;C&quot;); adjacencyMatrix.connect(&quot;C&quot;, &quot;E&quot;); adjacencyMatrix.connect(&quot;B&quot;, &quot;D&quot;); //打印邻接矩阵 adjacencyMatrix.print();&#125; 2.2 邻接表 （1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 图表示方法 - 邻接表 * @author letere * @create 2021-05-31 22:04 */public class AdjacencyTable &#123; /** * 邻接表子类 - 单链表 */ private static class LinkedList &#123; /** * 单链表子类 - 节点 */ private static class Node &#123; Object data; Node next; public Node(Object data) &#123; this.data = data; &#125; @Override public String toString() &#123; return &quot;Node&#123;data=&quot; + data + &#x27;&#125;&#x27;; &#125; &#125; //头节点 private Node head; /** * 添加节点 * @param data 数据 */ public void add(Object data) &#123; Node node = new Node(data); if (head == null) &#123; head = node; return; &#125; Node temp = head; while (temp.next != null) &#123; temp = temp.next; &#125; temp.next = node; &#125; /** * 打印单链表 */ public void print() &#123; if (head == null) &#123; System.out.println(&quot;null&quot;); return; &#125; Node temp = head; while (temp.next != null) &#123; System.out.print(temp + &quot; -&gt; &quot;); temp = temp.next; &#125; System.out.println(temp); &#125; &#125; //顶点数组 private final Object[] vertexArr; //邻接表（数组+链表） private final LinkedList[] linkedLists; //构造器 public AdjacencyTable(Object[] vertexArr) &#123; this.vertexArr = vertexArr; linkedLists = new LinkedList[vertexArr.length]; for (int i=0; i&lt;linkedLists.length; i++) &#123; linkedLists[i] = new LinkedList(); &#125; &#125; /** * 连接两个顶点 * @param vertex1 顶点1 * @param vertex2 顶点2 */ public void connect(Object vertex1, Object vertex2) &#123; int index1 = getIndex(vertex1); int index2 = getIndex(vertex2); //无向图（互相添加） linkedLists[index1].add(vertex2); linkedLists[index2].add(vertex1); &#125; /** * 获取顶点数组下标 * @param vertex 顶点 * @return int(下标) */ private int getIndex(Object vertex) &#123; for (int i=0; i&lt;vertexArr.length; i++) &#123; if (vertexArr[i].equals(vertex)) &#123; return i; &#125; &#125; throw new RuntimeException(&quot;顶点不存在，连接失败！&quot;); &#125; /** * 打印邻接表 */ public void print() &#123; for (int i=0; i&lt;vertexArr.length; i++) &#123; System.out.print(vertexArr[i] + &quot;：&quot;); linkedLists[i].print(); &#125; &#125;&#125; （2）测试123456789101112131415@Testpublic void adjacencyTableTest() &#123; //构建邻接表 String[] vertexArr = new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;; AdjacencyTable adjacencyTable = new AdjacencyTable(vertexArr); //连接顶点 adjacencyTable.connect(&quot;A&quot;, &quot;B&quot;); adjacencyTable.connect(&quot;A&quot;, &quot;C&quot;); adjacencyTable.connect(&quot;C&quot;, &quot;E&quot;); adjacencyTable.connect(&quot;B&quot;, &quot;D&quot;); //打印邻接表 adjacencyTable.print();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】多叉树","slug":"【数据结构和算法】多叉树","date":"2021-05-22T08:47:49.000Z","updated":"2021-05-22T09:44:39.481Z","comments":true,"path":"2021/05/22/【数据结构和算法】多叉树/","link":"","permalink":"https://letere-gzj.github.io/2021/05/22/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%A4%9A%E5%8F%89%E6%A0%91/","excerpt":"数据结构之多叉树的介绍，由于多叉树涉及的代码比较复杂，此章并没有多叉树的代码实现","text":"数据结构之多叉树的介绍，由于多叉树涉及的代码比较复杂，此章并没有多叉树的代码实现 1 多叉树1.1 场景引入 二叉树缺陷： 当二叉树的节点非常巨大的时候，二叉树相应的层数也很高。进而影响二叉树的构建速度，也影响二叉树的操作速度。因此为了解决数据量庞大的二叉树，引出多叉树的概念 1.2 多叉树介绍 多叉树(Multiway Tree)： 允许一个节点有更多的子节点，从而在庞大数据中来降低树的高度。2-3树和2-3-4树就是典型的多叉树。 2 2-3树2.1 2-3树介绍 2-3树： 2-3树是最简单的B树结构。其中的2、3指的是二节点（一个节点拥有两个子节点），三节点（一个节点拥有是三个节点） 特点：（1）2-3树的所有叶子节点都在同一层（只要B树都满足这个条件）（2）二节点要么没有子节点，要么有两个子节点（不能只有一个）（3）三节点与二节点同理，要么没有子节点，要么有三个子节点（4）2-3树是由二节点和三节点构成的树 2.3 构建思路 2-3树的创建讲究拆分和组合拆分： 即一个节点存储的数据已满，则需要将该节点的数据拆分，形参新的节点，按照排序树的规则组成满二叉树组合： 即一个节点进行拆分后，一般都会导致树的结构不符合满二叉树（根节点拆分不会导致），需要向上将数据进行组合，形参满二叉树 下面以数据 【37, 42, 12, 18, 6, 5, 11】 ，来展示一个2-3树插入数据所遇到的的情况 3 B树3.1 介绍 B树（B-Tree） ：B为Balanced，平衡。由于翻译的原因，可能会将B-Tree翻译成B-树，这是错误翻译。会让人以为B树和B-树是两种不同的树特点：（1）数据存放在树的每个节点中（2）其搜索性能类似在书中进行了一次二分查找 B+树：B+树是B树的一个变体特点:（1）数据只存放在叶子节点中，非叶子结点存放的是索引值（2）叶子节点存放的数据是一个有序的链表 B*树：B+树的一个变体，在B+树的非根节点和非叶子结点再增加指向兄弟的指针特点:（1）非根节点和非叶子结点拥有新的指针指向兄弟节点","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】平衡二叉树","slug":"【数据结构和算法】平衡二叉树","date":"2021-05-20T07:32:03.000Z","updated":"2021-05-21T01:34:29.091Z","comments":true,"path":"2021/05/20/【数据结构和算法】平衡二叉树/","link":"","permalink":"https://letere-gzj.github.io/2021/05/20/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"关于数据结构中平衡二叉树的介绍和代码实现","text":"关于数据结构中平衡二叉树的介绍和代码实现 1 平衡二叉树1.1 二叉排序树缺陷 当我们将数组[1, 2, 3, 4, 5, 6, 7]转变成二叉排序树。会出现树变成链表的形式，虽然插入/删除速度改变不大，但搜索查询的速度大大降低了。因此，提出了平衡二叉树的概念（AVL树） 1.2 平衡二叉树介绍 平衡二叉树： 也称为平衡二叉搜索树（Self-balancing binary search tree），又被称为AVL，可以保证查询效率较高 特点： 树的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是有个平衡二叉树 应用： 平衡二叉树的常用实现方法有：红黑树、AVL算法、替罪羊树、Treap、伸展树等 2 单旋转2.1 单旋转介绍 单旋转： 分为左旋转和右旋转。当左子树比右子树的高度要低，且高度差&gt;1，就使用左旋转将树转变成平衡二叉树，反之右旋转。 左旋转的目的是将根节点的右子节点作为新的根节点，右旋转则以左子节点作为新的根节点 下面以数组[4, 3, 6, 5, 7 ,8]为例，使用单旋转（左旋转）将树转变成平衡二叉树 （1）创建二叉排序树 （2）创建一个跟根节点一样的节点 该节点的左子节点指向根节点的左子节点，其右子节点指向根节点的右子节点的左子节点 （3）根节点的值更改为其右子节点的值 （4）根节点右子节点指向右子节点的右子节点，根节点左子节点指向新创建的节点 （5）整理后树的形状 2.2 代码 （1）简单创建二叉排序树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class AVLTree &#123; /** * 子类 - 节点 */ private class Node implements Comparable&lt;Node&gt;&#123; public int value; public Node left; public Node right; public Node(int value) &#123; this(value, null, null); &#125; public Node(int value, Node left, Node right) &#123; this.value = value; this.left = left; this.right = right; &#125; @Override public int compareTo(Node o) &#123; return value - o.value; &#125; @Override public String toString() &#123; return &quot;Node&#123;value = &quot; + value + &quot;&#125;&quot;; &#125; &#125;// ----------------------------------------------------------------------- //根节点 private Node root; /** * 添加数据 * @param value 值 */ public void add(Integer value) &#123; Node node = new Node(value); if (root == null) &#123; root = node; return; &#125; //循环寻找合适位置添加数据 Node temp = root; while (true) &#123; if (temp.value &lt; node.value) &#123; //向右寻找位置 if (temp.right != null) &#123; temp = temp.right; &#125;else &#123; temp.right = node; break; &#125; &#125; else &#123; //向左寻找位置 if (temp.left != null) &#123; temp = temp.left; &#125;else &#123; temp.left = node; break; &#125; &#125; &#125; &#125; /** * 中序遍历 */ public void infixPrint() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); return; &#125; infixRecursion(root); &#125; /** * 中序遍历 - 递归本体 * @param node 节点 */ private void infixRecursion(Node node) &#123; if (node.left != null) &#123; infixRecursion(node.left); &#125; System.out.println(node); if (node.right != null) &#123; infixRecursion(node.right); &#125; &#125;&#125; （2）计算树高度方法1234567891011121314151617181920212223242526272829303132/** * 获取当前节点树的高度（递归） * @param node 节点 * @return int */public int getTreeHeight(Node node) &#123; //如果节点为null，不能存在树，为0 if (node == null) &#123; return 0; &#125; //获取该节点左子树高度 int leftHeight; if (node.left == null) &#123; leftHeight = 0; &#125; else &#123; //递归求左子树高度 leftHeight = getTreeHeight(node.left); &#125; //获取该节点右子树高度 int rightHeight; if (node.right == null) &#123; rightHeight = 0; &#125; else &#123; //递归求右子树高度 rightHeight = getTreeHeight(node.right); &#125; //返回左右子树中的最大值+1（算上该节点，所以+1）作为树的整体高度 return Math.max(leftHeight, rightHeight) + 1;&#125; （3）左、右旋转方法12345678910111213141516171819202122232425262728293031323334/** * 对当前节点进行左旋转 * @param node 节点 */private void leftRotate(Node node) &#123; //（1）创建一个与根节点一样的新节点 Node temp = new Node(node.value); //（2）新节点左子节点指向根节点左子节点 temp.left = node.left; //（3）新节点的右子节点指向根节点右子节点的左子节点 temp.right = node.right.left; //（4）根节点的值 = 根节点右子节点的值 node.value = node.right.value; //（5）根节点的左子节点指向新建的节点 node.left = temp; //（6）根节点的右子节点指向右子节点的右子节点 node.right = node.right.right;&#125;/** * 对当前节点进行右旋转 * @param node 节点 */private void rightRotate(Node node) &#123; //跟左旋转大致相似，只有左右方向区别，就不再多写注释 Node temp = new Node(node.value); temp.right = node.right; temp.left = node.left.right; node.value = node.left.value; node.right = temp; node.left = node.left.left;&#125; （4）递归平衡 二叉树方法123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 平衡二叉树 */public void balanceTree() &#123; balanceTreeRecursion(root);&#125;/** * 平衡二叉树 - 递归本体 * @param node 节点 */public void balanceTreeRecursion(Node node) &#123; //从下往上平衡，优先平衡子节点 if (node.left != null) &#123; balanceTreeRecursion(node.left); &#125; if (node.right != null) &#123; balanceTreeRecursion(node.right); &#125; balance(node);&#125;/** * 平衡本体方法 * @param node 节点 */private void balance(Node node) &#123; int leftHeight = getTreeHeight(node.left); int rightHeight = getTreeHeight(node.right); //两棵树高度差值 &gt; 1，对树使用单旋转 if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123; //左子树小，使用左旋转 if (leftHeight &lt; rightHeight) &#123; leftRotate(node); &#125; //右子树小，使用右旋转 if (leftHeight &gt; rightHeight) &#123; rightRotate(node); &#125; &#125;&#125; 3 双旋转3.1 双旋转介绍 单旋转问题：在某些特定的情况下，一个节点不是平衡二叉树，但其子树都是属于平衡二叉树，此时对节点进行单旋转，但旋转过后仍然不是平衡二叉树，此时提出双旋转 双旋转：顾名思义，就是旋转两次的意思。例上图要对根节点使用右旋转，则需要判断一下左子树。左子树满足：左子树的左子树的高度 &lt; 左子树的右子树高度，则满足双旋转条件。在对根节点进行右旋转前，先对根节点的左子树进行左旋转，来降低树的高度。同理使用左旋转前，先判断右子树是否满足条件 3.2 代码 双旋转就是在原来平衡节点方法上，多做一层判断，来对比子节点的左右子树高度，进而判断是否要使用双旋转 更新平衡节点方法1234567891011121314151617181920212223242526272829303132333435/** * 平衡节点方法 * @param node 节点 */private void balance(Node node) &#123; int leftHeight = getTreeHeight(node.left); int rightHeight = getTreeHeight(node.right); //两棵树高度差值 &gt; 1，对树使用单旋转 int childLeftHeight; //子节点左右子树高度 int childRightHeight; if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123; //左子树小，使用左旋转 if (leftHeight &lt; rightHeight) &#123; childLeftHeight = getTreeHeight(node.right.left); childRightHeight = getTreeHeight(node.right.right); //判断是否要双旋转 if (childLeftHeight &gt; childRightHeight) &#123; rightRotate(node.right); &#125; leftRotate(node); &#125; //右子树小，使用右旋转 if (leftHeight &gt; rightHeight) &#123; childLeftHeight = getTreeHeight(node.left.left); childRightHeight = getTreeHeight(node.left.right); //判断是否要双旋转 if (childLeftHeight &lt; childRightHeight) &#123; leftRotate(node.left); &#125; rightRotate(node); &#125; &#125;&#125; 4 总代码 （1）完整平衡二叉树代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236public class AVLTree &#123; /** * 子类 - 节点 */ private class Node implements Comparable&lt;Node&gt;&#123; public int value; public Node left; public Node right; public Node(int value) &#123; this(value, null, null); &#125; public Node(int value, Node left, Node right) &#123; this.value = value; this.left = left; this.right = right; &#125; @Override public int compareTo(Node o) &#123; return value - o.value; &#125; @Override public String toString() &#123; return &quot;Node&#123;value = &quot; + value + &quot;&#125;&quot;; &#125; &#125;// ----------------------------------------------------------------------- //根节点 private Node root; /** * 添加数据 * @param value 值 */ public void add(Integer value) &#123; Node node = new Node(value); if (root == null) &#123; root = node; return; &#125; //循环寻找合适位置添加数据 Node temp = root; while (true) &#123; if (temp.value &lt; node.value) &#123; //向右寻找位置 if (temp.right != null) &#123; temp = temp.right; &#125;else &#123; temp.right = node; break; &#125; &#125; else &#123; //向左寻找位置 if (temp.left != null) &#123; temp = temp.left; &#125;else &#123; temp.left = node; break; &#125; &#125; &#125; //每添加一个数据，就平衡一次二叉树 balanceTree(); &#125; /** * 获取当前节点树的高度（递归） * @param node 节点 * @return int */ public int getTreeHeight(Node node) &#123; //如果节点为null，不存在树，为0 if (node == null) &#123; return 0; &#125; //获取该节点左子树高度 int leftHeight; if (node.left == null) &#123; leftHeight = 0; &#125; else &#123; //递归求左子树高度 leftHeight = getTreeHeight(node.left); &#125; //获取该节点右子树高度 int rightHeight; if (node.right == null) &#123; rightHeight = 0; &#125; else &#123; //递归求右子树高度 rightHeight = getTreeHeight(node.right); &#125; //返回左右子树中的最大值+1（算上该节点，所以+1）作为树的整体高度 return Math.max(leftHeight, rightHeight) + 1; &#125; /** * 平衡二叉树 */ public void balanceTree() &#123; balanceTreeRecursion(root); &#125; /** * 平衡二叉树 - 递归本体 * @param node 节点 */ public void balanceTreeRecursion(Node node) &#123; //从下往上平衡，优先平衡子节点 if (node.left != null) &#123; balanceTreeRecursion(node.left); &#125; if (node.right != null) &#123; balanceTreeRecursion(node.right); &#125; balance(node); &#125; /** * 平衡节点方法 * @param node 节点 */ private void balance(Node node) &#123; int leftHeight = getTreeHeight(node.left); int rightHeight = getTreeHeight(node.right); //两棵树高度差值 &gt; 1，对树使用单旋转 int childLeftHeight; int childRightHeight; if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123; //左子树小，使用左旋转 if (leftHeight &lt; rightHeight) &#123; childLeftHeight = getTreeHeight(node.right.left); childRightHeight = getTreeHeight(node.right.right); //判断是否要双旋转 if (childLeftHeight &gt; childRightHeight) &#123; rightRotate(node.right); &#125; leftRotate(node); &#125; //右子树小，使用右旋转 if (leftHeight &gt; rightHeight) &#123; childLeftHeight = getTreeHeight(node.left.left); childRightHeight = getTreeHeight(node.left.right); //判断是否要双旋转 if (childLeftHeight &lt; childRightHeight) &#123; leftRotate(node.left); &#125; rightRotate(node); &#125; &#125; &#125; /** * 对当前节点进行左旋转 * @param node 节点 */ private void leftRotate(Node node) &#123; //（1）创建一个与根节点一样的新节点 Node temp = new Node(node.value); //（2）新节点左子节点指向根节点左子节点 temp.left = node.left; //（3）新节点的右子节点指向根节点右子节点的左子节点 temp.right = node.right.left; //（4）根节点的值 = 根节点右子节点的值 node.value = node.right.value; //（5）根节点的左子节点指向新建的节点 node.left = temp; //（6）根节点的右子节点指向右子节点的右子节点 node.right = node.right.right; &#125; /** * 对当前节点进行右旋转 * @param node 节点 */ private void rightRotate(Node node) &#123; //跟左旋转大致相似，只有左右方向区别，就不再多写注释 Node temp = new Node(node.value); temp.right = node.right; temp.left = node.left.right; node.value = node.left.value; node.right = temp; node.left = node.left.left; &#125; /** *中序遍历 */ public void infixPrint() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); return; &#125; infixRecursion(root); &#125; /** * 中序遍历 - 递归本体 * @param node 节点 */ private void infixRecursion(Node node) &#123; if (node.left != null) &#123; infixRecursion(node.left); &#125; System.out.println(node); if (node.right != null) &#123; infixRecursion(node.right); &#125; &#125;&#125; （2）测试代码123456789101112131415161718@Testpublic void avlTreeTest() &#123; //创建平衡二叉树 AVLTree avlTree = new AVLTree(); //循环遍历添加数据 int[] arr = new int[]&#123;1, 2, 3, 4, 5 ,6&#125;; for (int i : arr) &#123; avlTree.add(i); &#125; //中序遍历查看是否按顺序 avlTree.infixPrint(); System.out.println(&quot;/------------------------------------/&quot;); //为了明显效果，再写了个前序遍历，查看树结构是否真发生变化（代码没有前序，自己按需自行添加） avlTree.prePrint();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【工作技能】PDF处理-FreeMarker&xhtmlrenderer","slug":"【工作技能】PDF处理-FreeMarker-xhtmlrenderer","date":"2021-05-19T06:24:06.000Z","updated":"2021-05-19T06:32:44.841Z","comments":true,"path":"2021/05/19/【工作技能】PDF处理-FreeMarker-xhtmlrenderer/","link":"","permalink":"https://letere-gzj.github.io/2021/05/19/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD%E3%80%91PDF%E5%A4%84%E7%90%86-FreeMarker-xhtmlrenderer/","excerpt":"关于使用freemarker和xhtmlrenderer来实现动态生成pdf","text":"关于使用freemarker和xhtmlrenderer来实现动态生成pdf 1 PDF处理1.1 数据准备 将生产的PDF所需数据封装为Map集合中 例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MetaData &#123; //类 public static class Person &#123; public String name; public String sex; public Person(String name, String sex) &#123; this.name = name; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; &#125; /** * 获取数据 * @return Map&lt;String, Object&gt; */ public static Map&lt;String, Object&gt; getData() &#123; Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;single&quot;, &quot;普通数据&quot;); data.put(&quot;person&quot;, new Person(&quot;莱特雷&quot;, &quot;男&quot;)); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;Hello&quot;); list.add(&quot;World&quot;); list.add(&quot;!&quot;); data.put(&quot;lists&quot;, list); return data; &#125;&#125; 1.2 模板准备 （1）创建html文件，编写pdf模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;!--注意：在meta这里补充一个&#x27;/&#x27;，默认生成没有--&gt; &lt;title&gt;pdf模板测试&lt;/title&gt; &lt;style&gt; @page &#123; /* 页面大小：示例中设置为A4纸的大小 */ size: 210mm 297mm; margin: 15mm 15mm 15mm 15mm; &#125; body &#123; width: 178mm; font-family: SimSun; /* 设置字体（宋体） */ font-size: 18px; &#125; table &#123; width: 100%; border-collapse: collapse; &#125; thead th &#123; border: 1px solid #000; padding: 5px 5px; &#125; tr td &#123; border: 1px solid #000; padding: 5px 5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;PDF模板测试&lt;/h2&gt; &lt;p&gt; 这里是Map中key的数据： &lt;span&gt;$&#123;single&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; Map中对象数据： &lt;span&gt;$&#123;person.name&#125;&lt;/span&gt; , &lt;span&gt;$&#123;person.sex&#125;&lt;/span&gt; &lt;/p&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;数据&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;#list lists as item&gt; &lt;!-- 被遍历的数据需要用此进行封装, lists为map中的key，item为遍历的元素&#x27; --&gt; &lt;tr&gt; &lt;td&gt;$&#123;item_index + 1&#125;&lt;/td&gt; &lt;!--需要获取遍历数据的下标，可以通过xxx_index来获取--&gt; &lt;td&gt;$&#123;item&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; （2）模板准备好，就修改后缀名为ftl 1.3 工具类准备 （1）依赖导入12345678910111213&lt;!-- freemarker --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 将HTML文件转化为PDF文件 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt; &lt;artifactId&gt;flying-saucer-pdf&lt;/artifactId&gt; &lt;version&gt;9.1.20&lt;/version&gt;&lt;/dependency&gt; （2）准备字体文件 （3）工具类代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * FreeMarker - Pdf工具类 * @author letere * @create 2021-05-14 15:28 */public class PdfUtil &#123; //编码格式 private static final String ENCODING = &quot;UTF-8&quot;; //ftl模板位置 private static final String TEMPLATE_PATH = &quot;/ftl/templates/pdf&quot;; //字体（宋体）文件路径 private static final String FONT = &quot;/ftl/font/simsun.ttc&quot;; //FreeMarker配置 private static final Configuration CFG = new Configuration(Configuration.VERSION_2_3_22); static &#123; //设置模板所在文件夹 CFG.setClassForTemplateLoading(PdfUtil.class, TEMPLATE_PATH); // setEncoding这个方法一定要设置国家及其编码，不然在ftl中的中文在生成html后会变成乱码 CFG.setEncoding(Locale.getDefault(), ENCODING); // 设置异常处理器,这样的话就可以$&#123;a.b.c.d&#125;即使没有属性也不会出错 CFG.setTemplateExceptionHandler(TemplateExceptionHandler.IGNORE_HANDLER); &#125; /** * 创建PDF文件 * @param data 数据 * @param templateFileName 模板名 * @param outputStream 输出流 */ public static void create(Map&lt;String, Object&gt; data, String templateFileName, OutputStream outputStream) throws Exception&#123; //将数据写进模板，得到模板字符串 String templateStr = writeTemplate(data, templateFileName, outputStream); //渲染字符串形成pdf renderPDF(templateStr, outputStream); &#125; /** * 将数据动态写进pdf模板 * @param data 数据 * @param templateFileName 模板名 * @param outputStream 输出流 * @return String */ private static String writeTemplate(Map&lt;String, Object&gt; data, String templateFileName, OutputStream outputStream) throws Exception&#123; //获取ftl模板 Template template = CFG.getTemplate(templateFileName, ENCODING); //将数据写入到ftl模板中 StringWriter writer = new StringWriter(); template.process(data, writer); writer.flush(); //返回写入后的模板字符串 return writer.toString(); &#125; /** * 渲染pdf模板形成PDF * @param templateStr 模板字符串 * @param outputStream 输出流 */ private static void renderPDF(String templateStr, OutputStream outputStream) throws Exception&#123; //防止依赖冲突，导致找不到TransformerFactory，设置TransformerFactory位置 System.setProperty(&quot;javax.xml.transform.TransformerFactory&quot;, &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl&quot;); ITextRenderer renderer = new ITextRenderer(); //设置字体样式 renderer.getFontResolver().addFont(FONT, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); //渲染模板字符串 renderer.setDocumentFromString(templateStr); renderer.layout(); //生成pdf renderer.createPDF(outputStream, false); renderer.finishPDF(); outputStream.flush(); &#125;&#125; 1.4 测试 （1）测试代码123456789101112 @Testpublic void pdfUtilTest() throws Exception&#123; //获取输出流 String fileName = &quot;./src/main/resources/template/test.pdf&quot;; OutputStream outputStream = new FileOutputStream(fileName); //获取数据 Map&lt;String, Object&gt; data = MetaData.getData(); //创建PDF PdfUtil.create(data, &quot;pdfTemplate.ftl&quot;, outputStream);&#125; （2）测试效果","categories":[{"name":"工作技能","slug":"工作技能","permalink":"https://letere-gzj.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"【工作技能】Word处理-FreeMarker","slug":"【工作技能】Word处理-FreeMarker","date":"2021-05-18T09:03:39.000Z","updated":"2021-05-18T09:07:01.080Z","comments":true,"path":"2021/05/18/【工作技能】Word处理-FreeMarker/","link":"","permalink":"https://letere-gzj.github.io/2021/05/18/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD%E3%80%91Word%E5%A4%84%E7%90%86-FreeMarker/","excerpt":"关于通过Java来生成word文档的代码实现，使用的技术为FreeMarker","text":"关于通过Java来生成word文档的代码实现，使用的技术为FreeMarker 1 动态生成Word1.1 数据准备 准备需要的数据，封装为一个Map集合 例：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MetaData &#123; //类 public static class Person &#123; public String name; public int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; /** * 获取数据 * @return Map&lt;String, Object&gt; */ public static Map&lt;String, Object&gt; getData() &#123; Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;single&quot;, &quot;歪比巴卜&quot;); data.put(&quot;class&quot;, new Person(&quot;莱特雷&quot;, 18)); List&lt;String&gt; arr = new ArrayList&lt;&gt;(); arr.add(&quot;hello&quot;); arr.add(&quot;world&quot;); arr.add(&quot;!&quot;); data.put(&quot;arr&quot;, arr); return data; &#125;&#125; 1.2 根据数据创建模板 （1）创建word模板，用$&#123;数据名(key)&#125;，来动态获取数据 （2）另存为xml格式 1.3 修改xml （1）格式化xml 导出的xml都挤在一起，十分的难看，可以对xml进行格式化（本人使用VS Code来对xml进行格式化） （2）修改xml word文档转xml会将我们的$&#123;xxxx&#125;数据进行拆分，需要我们自己合并回去 （3）特殊处理List集合数据 （4）修改后缀名为ftl xml文件修改完毕后，将后缀名修改为ftl文件即可 1.4 创建Word工具类 （1）依赖导入123456&lt;!-- FreeMarker --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt; （2）word工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WordUtil &#123; //编码格式 private static final String ENCODING = &quot;UTF-8&quot;; //模板路径（按自己实际情况填写） private static final String TEMPLATE = &quot;/ftl/templates/word&quot;; //模板配置 private static final Configuration CFG = new Configuration(Configuration.VERSION_2_3_22); //初始化 static &#123; //设置模板所在文件夹 CFG.setClassForTemplateLoading(WordUtil.class, TEMPLATE); // setEncoding这个方法一定要设置国家及其编码，不然在ftl中的中文在生成html后会变成乱码 CFG.setEncoding(Locale.getDefault(), ENCODING); // 设置异常处理器,这样的话就可以$&#123;a.b.c.d&#125;即使没有属性也不会出错 CFG.setTemplateExceptionHandler(TemplateExceptionHandler.IGNORE_HANDLER); &#125; /** * 根据数据及模板生成word文件写入输出流 * @param data Map的数据结果集 * @param templateFileName ftl模版文件名 * @param outputStream 生成文件名称(可带路径) */ public static void create(Map&lt;String, Object&gt; data, String templateFileName, OutputStream outputStream) throws Exception &#123; //获取自定义ftl模板 Template template = CFG.getTemplate(templateFileName, ENCODING); //封装输出流 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream); //动态生成word，写入输出流 template.process(data, outputStreamWriter); &#125; /** * 设置response为下载word文件格式 * @param response 响应 * @param fileName 文件名 */// public static void setWordResponse(HttpServletResponse response, String fileName) throws Exception&#123;// //设置response格式// response.setCharacterEncoding(ENCODING);// response.setContentType(&quot;application/msword&quot;);// fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;); // 防止中文乱码// response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.doc&quot;);// &#125;&#125; （3）测试123456789101112131415@Testpublic void wordTest() throws Exception&#123; //模板名 String ftlName = &quot;wordTemplate.ftl&quot;; //导出word路径 String outputFile = &quot;./src/main/resources/my.doc&quot;; //数据 Map&lt;String, Object&gt; data = MetaData.getData(); //输出流 OutputStream outputStream = new FileOutputStream(outputFile); //调用工具类生成word文档 WordUtil.create(data, ftlName, outputStream);&#125;","categories":[{"name":"工作技能","slug":"工作技能","permalink":"https://letere-gzj.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"【数据结构和算法】二叉排序树","slug":"【数据结构和算法】二叉排序树","date":"2021-05-16T08:18:19.000Z","updated":"2021-05-18T02:10:34.551Z","comments":true,"path":"2021/05/16/【数据结构和算法】二叉排序树/","link":"","permalink":"https://letere-gzj.github.io/2021/05/16/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","excerpt":"数据结构之二叉排序树的介绍和代码实现","text":"数据结构之二叉排序树的介绍和代码实现 1 二叉排序树1.1 介绍 二叉排序树： BST（Binary Sort(Search) Tree），对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大，若拥有相同值，则随意放左子节点或右子节点 因为二叉排序树的特点，我们使用中序遍历，得出来的结果就是一个有序序列 1.2 代码 （1）二叉排序树 - 新增与遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class BinarySortTree &#123; //子类 --- 节点 private class Node &#123; public int value; public Node left; public Node right; public Node(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;Node&#123;value = &quot; + value + &#x27;&#125;&#x27;; &#125; &#125;//---------------------------------------------------- //根节点 private Node root; /** * 新增数据 * @param value 值 */ public void add(int value) &#123; Node node = new Node(value); if (root == null) &#123; root = node; return; &#125; //递归新增数据 addRecursion(root, node); &#125; /** * 新增数据 - 递归本体 * @param node 节点 * @param newNode 新节点 */ private void addRecursion(Node node, Node newNode) &#123; //当前值 &lt; 新增值 if (node.value &lt; newNode.value) &#123; //判断右子节点是否为null，null直接插入，否则向右递归找 if (node.right == null) &#123; node.right = newNode; &#125;else &#123; addRecursion(node.right, newNode); &#125; //当前值 &gt;= 新增值 &#125;else &#123; //判断左子节点是否为null，null直接插入，否则向左递归找 if (node.left == null) &#123; node.left = newNode; &#125;else &#123; addRecursion(node.left, newNode); &#125; &#125; &#125; /** * 中序遍历 */ public void infixPrint() &#123; if (root == null) &#123; System.out.println(&quot;树为空!&quot;); return; &#125; infixRecursion(root); &#125; /** * 中序遍历 - 递归本体 * @param node 节点 */ private void infixRecursion(Node node) &#123; if (node.left != null) &#123; infixRecursion(node.left); &#125; System.out.println(node); if (node.right != null) &#123; infixRecursion(node.right); &#125; &#125;&#125; （2）测试1234567891011121314@Testpublic void binarySortTreeTest() &#123; //创建二叉排序树 BinarySortTree binarySortTree = new BinarySortTree(); //遍历新增数据 int[] arr = new int[]&#123;7, 3, 10, 12, 5, 1, 9&#125;; for(int i : arr) &#123; binarySortTree.add(i); &#125; //中序遍历 binarySortTree.infixPrint();&#125; 2 二叉排序树-删除2.1 介绍 二叉排序树的删除情况要分为三种情况：（1）删除的是叶子节点（2）删除的是父节点，该父节点只有一个子节点（3）删除的是父节点，该父节点有两个子节点 2.2 删除基本思路 （1）删除叶子节点找到该叶子节点的父节点，将其父节点的左/右子节点赋值为null （2）删除只有一个子节点的节点找到该删除节点的父节点，将其父节点的对应的删除子节点 = 该删除节点的唯一子节点 （3）删除拥有两个子节点的节点找删除的节点的左子树中最大的值 / 右子树中最小的值，记录最小/最大值，再对该最小/最大值节点进行删除，将要删除的节点的值修改为记录的最小/大值 2.3 根节点特殊处理 上面的思路中删除叶子节点，以及删除只有一个子节点的节点都利用了目标节点的父节点，如果目标节点为根节点，那其父节点为null，会出现空指针异常，需要特殊处理 （1）删除的根节点为叶子节点当删除的根节点为叶子节点，即整棵树只有根节点，直接将根节点设置为null即可 （2）删除的根节点为只有一个子节点的节点当删除的根节点为只有一个子节点的节点，直接将根节点设置为该唯一的子节点 2.4 代码 （1）代码实现【在之前写的树基础上，新增以下方法】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 删除节点 * @param value 删除值 */public void delete(int value) &#123; //获取目标节点 和 其父节点 Map&lt;String, Node&gt; data = search(value); Node parent = data.get(&quot;parent&quot;); Node target = data.get(&quot;target&quot;); //（1）目标节点是叶子节点 if (target.left == null &amp;&amp; target.right == null) &#123; //叶子节点为根节点 if (parent == null) &#123; root = null; return; &#125; //通过父节点设置子节点为null if (parent.left == target) &#123; parent.left = null; &#125;else &#123; parent.right = null; &#125; //（2）目标节点拥有两个子节点 &#125;else if (target.left != null &amp;&amp; target.right != null) &#123; //删除右子树最小值节点，并获取返回值 int smallest = delRightSmallest(target.right); target.value = smallest; //（3）目标节点只有一个子节点 &#125;else &#123; //获取目标节点子节点 Node temp; if(target.left != null) &#123; //目标节点为根节点 if (parent == null) &#123; root = target.left; return; &#125; temp = target.left; &#125;else &#123; //目标节点为根节点 if (parent == null) &#123; root = target.right; return; &#125; temp = target.right; &#125; //父节点指向目标节点的子节点 if (parent.left == target) &#123; parent.left = temp; &#125;else &#123; parent.right = temp; &#125; &#125;&#125;/** * 查找目标节点和其父节点 * @param value 目标节点值 * @return Node */public Map&lt;String, Node&gt; search(int value) &#123; if (root == null) &#123; throw new RuntimeException(&quot;树为空！&quot;); &#125; //目标节点为root，父节点为null if (root.value == value) &#123; Map&lt;String, Node&gt; data = new HashMap&lt;&gt;(); data.put(&quot;parent&quot;, null); data.put(&quot;target&quot;, root); return data; &#125; //递归寻找目标节点和其父节点 return searchRecursion(value, root);&#125;/** * 查找目标节点和其父节点 - 递归本体 * @param value 目标节点值 * @param node 节点 * @return Map&lt;String, Node&gt; */private Map&lt;String, Node&gt; searchRecursion(int value, Node node) &#123; Node temp; //目标值 &gt; 节点值 （向右子节点找） if (node.value &lt; value) &#123; temp = node.right; //目标值 &lt; 节点值 （向左子节点找） &#125;else &#123; temp = node.left; &#125; //左/右子节点为null，删除节点不存在，抛出异常 if (temp == null) &#123; throw new RuntimeException(&quot;该删除值不存在！&quot;); &#125;else &#123; //判断左/右子节点是否删除节点，是直接返回当前节点和目标节点（Map封装），否则递归寻找 if (temp.value == value) &#123; Map&lt;String, Node&gt; data = new HashMap&lt;&gt;(); data.put(&quot;parent&quot;, node); data.put(&quot;target&quot;, temp); return data; &#125;else &#123; return searchRecursion(value, temp); &#125; &#125;&#125;/** * 删除右子树最小节点，并返回最小值 * @param node 右子树根节点 * @return int */private int delRightSmallest(Node node) &#123; Node temp = node; //循环向左寻找最小值 while (temp.left != null) &#123; temp = temp.left; &#125; //调用写好的删除节点方法 delete(temp.value); return temp.value;&#125; （2）测试1234567891011121314151617181920@Testpublic void binarySortTreeTest() &#123; //创建二叉排序树 BinarySortTree binarySortTree = new BinarySortTree(); //遍历插入数据 int[] arr = new int[]&#123;7, 3, 10, 12, 5, 1, 9&#125;; for(int i : arr) &#123; binarySortTree.add(i); &#125; //随意删除节点 binarySortTree.delete(7); binarySortTree.delete(3); binarySortTree.delete(12); binarySortTree.delete(9); //中序遍历 binarySortTree.infixPrint();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】赫夫曼编码","slug":"【数据结构和算法】赫夫曼编码","date":"2021-05-12T15:33:19.000Z","updated":"2021-05-16T07:11:01.407Z","comments":true,"path":"2021/05/12/【数据结构和算法】赫夫曼编码/","link":"","permalink":"https://letere-gzj.github.io/2021/05/12/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/","excerpt":"赫夫曼树延伸的赫夫曼编码的实现，以及压缩与解压的应用","text":"赫夫曼树延伸的赫夫曼编码的实现，以及压缩与解压的应用 1 赫夫曼编码1.1 介绍 赫夫曼编码（Huffman Coding），又称哈夫曼编码、霍夫曼编码，是一种编码方式，属于一种程序算法 赫夫曼编码是赫夫曼树在电讯通信中的经典应用之一 赫夫曼编码广泛地应用于数据文件压缩，其**压缩率通常在20%~90%**之间 赫夫曼编码是可变字长编码（VLC） 的一种。Hufffman与1952年提出一种变法方法，称之为最佳编码 1.2 其他编码介绍 （1）定长编码：一个文本，例hello world，二进制编码是固定的（通过Ascii码，再转成2进制） （2）可变长编码：统计一个文本的中字符出现的次数，例hello world，l:3 o:2 h:1 e:1 r:1 d:1 :1，按照赫夫曼树的思想（次数越大，越靠前），进行自定义二进制编码：l:0, o:1, h:10, e:11, r:100, d:101, :110来进行压缩，减少二进制编码占的空间 （3）前缀编码：每个字符的编码都只能有一个，不能重复，具有唯一性。例：二进制字符101001，有可能1或10或101是一个字符，出现匹配多义性，就不属于前缀编码 1.3 实现原理 （1）以字符hello world字符为例 （2）跟可变长编码一样，统计各字符出现的次数l:3 o:2 h:1 e:1 r:1 d:1 :1 （3）以次数作为权重，以字符作为数据，来构建一个赫夫曼树 （4）以左岔路为0，右岔路为1，对赫夫曼树进行编码，进而获得每个字符对应二进制编码（前缀编码） 注意 ：当一个赫夫曼树中出现多个权值相同的节点，根据排序算法的不同，有可能导致赫夫曼树的形状不同，进而导致赫夫曼编码不同，但是因为满足最小wpl，所以最终二进制编码的长度还是一样，不会发生改变 1.4 代码实现 前提 ： 赫夫曼编码涉及赫夫曼树的知识，没有了解的，可以翻之前的文章进行了解，涉及赫夫曼树的代码不再过多注释解释 （1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class HuffmanTree &#123; //子类 --- 节点 private class Node implements Comparable&lt;Node&gt;&#123; public int weight; public Character c; public Node left; public Node right; public Node(int weight, Character c) &#123; this.weight = weight; this.c = c; &#125; public Node(int weight, Character c, Node left, Node right) &#123; this(weight, c); this.left = left; this.right = right; &#125; @Override public int compareTo(Node o) &#123; return weight - o.weight; &#125; @Override public String toString() &#123; return &quot;Node[weight = &quot; + weight + &quot;, char = &quot; + c + &#x27;]&#x27;; &#125; &#125;//-------------------------------------------------------------------------------------- private Node root; //根节点 public HuffmanTree(char[] arr) &#123; createTree(arr); &#125; /** * 创建赫夫曼树 * @param arr 字符数组 */ private void createTree(char[] arr) &#123; List&lt;Node&gt; nodes = toNodeList(arr); while (nodes.size() &gt; 1) &#123; Collections.sort(nodes); Node left = nodes.remove(0); Node right = nodes.remove(0); Node parent = new Node(left.weight + right.weight, null, left, right); nodes.add(parent); &#125; root = nodes.get(0); &#125; /** * 将char数组转成List&lt;Node&gt; * @param arr 字符数组 * @return List&lt;Node&gt; */ private List&lt;Node&gt; toNodeList(char[] arr) &#123; Map&lt;Character, Integer&gt; counts = new HashMap&lt;&gt;(); //字符统计集合（key为字符，value为个数） //统计字符集合 Integer count; for (char c : arr) &#123; //向Map查询该字符（不存在为null，存在则返回其Integer值） count = counts.get(c); if (count == null) &#123; counts.put(c, 1); &#125;else &#123; counts.put(c, count+1); &#125; &#125; //读取Map，并封装为List&lt;Node&gt;集合 List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (Map.Entry&lt;Character, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getValue(), entry.getKey())); &#125; return nodes; &#125; /** * 获取哈夫曼编码 * @return Map&lt;Character, String&gt; */ public Map&lt;Character, String&gt; getHuffmanCode() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); return null; &#125; Map&lt;Character, String&gt; huffmanCodes = new HashMap&lt;&gt;(); //赫夫曼编码集合 StringBuilder route = new StringBuilder(); //路径记录 //递归获取赫夫曼编码，并记录在Map结合中 getCode(huffmanCodes, root, route, &quot;&quot;); return huffmanCodes; &#125; /** * 递归获取赫夫曼编码 * @param huffmanCodes 赫夫曼编码结合 * @param node 节点 * @param route 路径 * @param direction 方向（0为左，1为右） */ private void getCode(Map&lt;Character, String&gt; huffmanCodes, Node node, StringBuilder route, String direction) &#123; StringBuilder newRoute = new StringBuilder(route); //创建新StringBuilder，避免影响传入的数据（避免影响回溯） newRoute.append(direction); //拼接路径 if(node != null) &#123; //判断是否叶子节点 if (node.c == null) &#123; //向左递归 if (node.left != null) &#123; getCode(huffmanCodes, node.left, newRoute, &quot;0&quot;); &#125; //向右递归 if (node.right != null) &#123; getCode(huffmanCodes, node.right, newRoute, &quot;1&quot;); &#125; &#125;else &#123; //是叶子节点，则记录该字节，以及路径(编码) huffmanCodes.put(node.c, newRoute.toString()); &#125; &#125; &#125;&#125; （2）测试12345678910@Testpublic void huffmanTreeTest() &#123; //获取赫夫曼树 char[] chars = &quot;hello world&quot;.toCharArray(); HuffmanTree huffmanTree = new HuffmanTree(chars); //获取赫夫曼编码表 Map&lt;Character, String&gt; huffmanCode = huffmanTree.getHuffmanCode(); System.out.println(huffmanCode);&#125; 2 字符串压缩与解压2.1 补码&amp;反码&amp;原码 反码 = 补码 - 1 原码 = 反码 除了符号位（第一个数，0为正，1为负），其余都取反 2.2 介绍 赫夫曼编码，对原数据的编码就行改变，实现对数据进行压缩。压缩后的数据查询赫夫曼编码表，对数据进行解压，还原数据 2.3 代码实现 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class HuffmanCode &#123; private char[] chars; //原字符串的字符数组 private Map&lt;Character, String&gt; huffmanCodeTable; //赫夫曼编码表 private int lastLen; //数组最后的bit长度 //构造器（处理字符串，并生赫夫曼编码表） public HuffmanCode(String str) &#123; this.chars = str.toCharArray(); huffmanCodeTable = new HuffmanTree(this.chars).getHuffmanCode(); &#125; /** * 压缩字符串（编码） * @return char[] */ public char[] strZip() &#123; //将字符数组转成对应赫夫曼编码的二进制bit形式字符串 StringBuilder code = new StringBuilder(); for (char c : chars) &#123; code.append(huffmanCodeTable.get(c)); &#125; //将bit形式字符串转成char数组（8位 = 1字节 = 1 char） //计算字节数组长度 int len; if (code.length() % 8 == 0) &#123; len = code.length() / 8; //是8的倍数，长度=除数 &#125;else &#123; len = code.length() / 8 + 1; //非8的倍数，长度=除数+1(除法会向下取整) &#125; char[] huffmanCodeChars = new char[len]; //将字符串转字节数组 int index = 0; while (index &lt; len) &#123; //计算截取位置（8位长度） int start = index * 8; int end = start + 8; //判断截取长度是否超出，超出则截取剩余的 String subCode; if (end &gt; code.length()) &#123; subCode = code.substring(start); &#125;else &#123; subCode = code.substring(start, end); &#125; //将2进制bit转成10进制int，强转为char huffmanCodeChars[index] = (char) Integer.parseInt(subCode, 2); //记录最后一个元素的长度，方便解压 if(index == len-1) &#123; lastLen = subCode.length(); &#125; //index自增 index ++; &#125; return huffmanCodeChars; &#125; /** * 解压数据（解码） * @param huffmanCodeChars 压缩后字符数组 * @return String */ public String strUnzip(char[] huffmanCodeChars) &#123; //将赫夫曼字符数组转成2进制bit字符串 String bitStr = charsToBitString(huffmanCodeChars); //反转赫夫曼编码表（bit为key，char为value） Map&lt;String, Character&gt; alterHuffmanCode = new HashMap&lt;&gt;(); for (Map.Entry&lt;Character, String&gt; entry : huffmanCodeTable.entrySet()) &#123; alterHuffmanCode.put(entry.getValue(), entry.getKey()); &#125; int index = 0; //下标 StringBuilder metaStr = new StringBuilder(); //原字符串 String tempStr = &quot;&quot;; //中间变量 //遍历字符串 while (index &lt; bitStr.length()) &#123; tempStr += bitStr.charAt(index); //匹配反转赫夫曼编码表 if (alterHuffmanCode.get(tempStr) != null) &#123; metaStr.append(alterHuffmanCode.get(tempStr)); //将识别的字符加入原字符串 tempStr = &quot;&quot;; //清空中间变量 &#125; //index自增 index ++; &#125; return metaStr.toString(); &#125; /** * 将char数组转为bit类型字符串 * @param huffmanCodeChars char数组 * @return String */ private String charsToBitString(char[] huffmanCodeChars) &#123; int n = huffmanCodeChars.length; //数组长度 int index = 0; //数组下标 int temp; //中间变量，存储字符 StringBuilder bitStr = new StringBuilder(); //二进制bit字符串 //遍历数组 for (char c : huffmanCodeChars) &#123; temp = c; //对数据进行补位 //256的二进制为1 0000 0000，如果当前字符的二进制为正数，前面的0会被省略，需要进行补位 temp |= 256; //判断是否最后一位，最后一位的长度不一定是8位数 String tempStr = Integer.toBinaryString(temp); if (index == n-1) &#123; bitStr.append(tempStr.substring(tempStr.length() - lastLen)); //最后一位截取指定长度 &#125;else &#123; bitStr.append(tempStr.substring(tempStr.length() - 8)); //其余截取后八位 &#125; &#125; return bitStr.toString(); &#125;&#125; （2）测试12345678910111213@Testpublic void huffmanCodingTest() &#123; String str = &quot;hello world&quot;; //原数据 HuffmanCode huffmanCode = new HuffmanCode(str); //压缩数据 char[] chars = huffmanCode.strZip(); System.out.println(chars); //解压数据 String s = huffmanCode.strUnzip(chars); System.out.println(s);&#125; 3 文件压缩与解压3.1 介绍 文件的压缩与解压与字符串的压缩与解压差别不大，因为文件一般都是读取为byte[]，所以我们创建赫夫曼树，以及创建赫夫曼编码表时，都是用byte[]数组存储，其他差别不大 3.2 代码 （1）赫夫曼树(byte数组)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class HuffmanByteTree &#123; //子类 --- 节点 private class Node implements Comparable&lt;Node&gt;&#123; public int weight; public Byte b; public Node left; public Node right; public Node(int weight, Byte b) &#123; this.weight = weight; this.b = b; &#125; public Node(int weight, Byte b, Node left, Node right) &#123; this(weight, b); this.left = left; this.right = right; &#125; @Override public int compareTo(Node o) &#123; return weight - o.weight; &#125; @Override public String toString() &#123; return &quot;Node[weight = &quot; + weight + &quot;, byte = &quot; + b + &#x27;]&#x27;; &#125; &#125;//-------------------------------------------------------------------------------------- private Node root; //根节点 public HuffmanByteTree(byte[] arr) &#123; createTree(arr); &#125; /** * 创建赫夫曼树 * @param arr 字符数组 */ private void createTree(byte[] arr) &#123; List&lt;Node&gt; nodes = toNodeList(arr); while (nodes.size() &gt; 1) &#123; Collections.sort(nodes); Node left = nodes.remove(0); Node right = nodes.remove(0); Node parent = new Node(left.weight + right.weight, null, left, right); nodes.add(parent); &#125; root = nodes.get(0); &#125; /** * 将byte数组转成List&lt;Node&gt; * @param arr 字符数组 * @return List&lt;Node&gt; */ private List&lt;Node&gt; toNodeList(byte[] arr) &#123; Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); //字符统计集合（key为字符，value为个数） //统计字符集合 Integer count; for (byte b : arr) &#123; //向Map查询该字符（不存在为null，存在则返回其Integer值） count = counts.get(b); if (count == null) &#123; counts.put(b, 1); &#125;else &#123; counts.put(b, count+1); &#125; &#125; //读取Map，并封装为List&lt;Node&gt;集合 List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getValue(), entry.getKey())); &#125; return nodes; &#125; /** * 获取哈夫曼编码 * @return Map&lt;Byte, String&gt; */ public Map&lt;Byte, String&gt; getHuffmanCode() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); return null; &#125; Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;(); //赫夫曼编码集合 StringBuilder route = new StringBuilder(); //路径记录 //递归获取赫夫曼编码，并记录在Map结合中 getCode(huffmanCodes, root, route, &quot;&quot;); return huffmanCodes; &#125; /** * 递归获取赫夫曼编码 * @param huffmanCodes 赫夫曼编码结合 * @param node 节点 * @param route 路径 * @param direction 方向（0为左，1为右） */ private void getCode(Map&lt;Byte, String&gt; huffmanCodes, Node node, StringBuilder route, String direction) &#123; StringBuilder newRoute = new StringBuilder(route); //创建新StringBuilder，避免影响传入的数据（避免影响回溯） newRoute.append(direction); //拼接路径 if(node != null) &#123; //判断是否叶子节点 if (node.b == null) &#123; //向左递归 if (node.left != null) &#123; getCode(huffmanCodes, node.left, newRoute, &quot;0&quot;); &#125; //向右递归 if (node.right != null) &#123; getCode(huffmanCodes, node.right, newRoute, &quot;1&quot;); &#125; &#125;else &#123; //是叶子节点，则记录该字节，以及路径(编码) huffmanCodes.put(node.b, newRoute.toString()); &#125; &#125; &#125;&#125; （2）赫夫曼编码压缩与解压123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202public class HuffmanByteCode &#123; private byte[] metaByte; //原byte数组 private Map&lt;Byte, String&gt; huffmanCodeTable; //赫夫曼编码表 private int lastLen; //数组最后二进制bit长度 //构造器 public HuffmanByteCode(String srcFile) &#123; //读取文件 metaByte = inputFile(srcFile); //获取赫夫曼编码表 HuffmanByteTree huffmanByteTree = new HuffmanByteTree(metaByte); huffmanCodeTable = huffmanByteTree.getHuffmanCode(); &#125; /** * 压缩文件 * @param dstFile 压缩文件路径 */ public void fileZip(String dstFile) &#123; //将byte数组转成bit字符串 StringBuilder bitStr = new StringBuilder(); for (byte b : metaByte) &#123; bitStr.append(huffmanCodeTable.get(b)); &#125; //重新截取bit字符，转成byte数组 //1.计算byte数组长度 int len = 0; if (bitStr.length() % 8 == 0) &#123; len = bitStr.length() / 8; &#125;else &#123; len = bitStr.length() / 8 + 1; &#125; //2.截取bit字符串转成byte数组 byte[] huffmanCodeByte = new byte[len]; int index = 0; //下标 String tempStr = &quot;&quot;; //中间变量 while(index &lt; len) &#123; int start = index * 8; int end = start + 8; if (end &gt; bitStr.length()) &#123; tempStr = bitStr.substring(start); &#125;else &#123; tempStr = bitStr.substring(start, end); &#125; huffmanCodeByte[index] = (byte) Integer.parseInt(tempStr, 2); //记录末尾bit长度 if (index == len-1) &#123; lastLen = tempStr.length(); &#125; //index自增 index ++; &#125; //输出文件 outputFile(dstFile, huffmanCodeByte); float zipRate = ((float) metaByte.length - (float) len) / (float) metaByte.length * 100; System.out.println(&quot;压缩成功！&quot;); System.out.println(&quot;压缩率为：&quot; + zipRate + &#x27;%&#x27;); &#125; /** * 解压文件 * @param zipFile 压缩文件路径 * @param unzipFile 解压文件路径 */ public void fileUnzip(String zipFile, String unzipFile) &#123; //读取数据 byte[] zipByte = inputFile(zipFile); //将byte数组转成bit类型字符串 String bitStr = bytesToString(zipByte); //反转码表 Map&lt;String, Byte&gt; alterCodeTable = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodeTable.entrySet()) &#123; alterCodeTable.put(entry.getValue(), entry.getKey()); &#125; //根据反转码表获取原byte数组 List&lt;Byte&gt; unzipByte = new ArrayList&lt;&gt;(); String tempStr = &quot;&quot;; int index = 0; while (index &lt; bitStr.length()) &#123; tempStr += bitStr.charAt(index); if (alterCodeTable.get(tempStr) != null) &#123; unzipByte.add(alterCodeTable.get(tempStr)); tempStr = &quot;&quot;; &#125; //index自增 index ++; &#125; //将List&lt;Byte&gt;转byte[] byte[] fileByte = new byte[unzipByte.size()]; index = 0; for (Byte b : unzipByte) &#123; fileByte[index] = b; index ++; &#125; //输出文件 outputFile(unzipFile, fileByte); &#125; /** * byte数组转bit字符串 * @param bytes byte数组 * @return String */ private String bytesToString(byte[] bytes) &#123; StringBuilder bitStr = new StringBuilder(); String tempStr; int temp; int index = 0; //下标 for (byte b : bytes) &#123; temp = b; //补位 temp |= 256; //截取 tempStr = Integer.toBinaryString(temp); if (index == bytes.length-1) &#123; bitStr.append(tempStr.substring(tempStr.length() - lastLen)); &#125;else &#123; bitStr.append(tempStr.substring(tempStr.length() - 8)); &#125; &#125; return bitStr.toString(); &#125; /** * 读取文件 * @param srcFile 文件路径 * @return byte[] */ private byte[] inputFile(String srcFile) &#123; FileInputStream fis = null; byte[] fileByte = new byte[0]; try &#123; //创建输入流，并读取 fis = new FileInputStream(srcFile); fileByte = new byte[fis.available()]; fis.read(fileByte); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流 if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return fileByte; &#125; /** * 输出文件 * @param dstFile 文件路径 * @param fileByte 数据 */ private void outputFile(String dstFile, byte[] fileByte)&#123; FileOutputStream fos = null; try &#123; //创建流并写入数据 fos = new FileOutputStream(dstFile); fos.write(fileByte); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭流 if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; （3）测试：对上面的图片进行压缩与解压123456789101112@Testpublic void huffmanCodeByteTest() &#123; String srcFile = &quot;./src/赫夫曼编码/压缩文件/公主连接-黑猫.jpg&quot;; String dstFile = &quot;./src/赫夫曼编码/压缩文件/公主连接-黑猫.zip&quot;; String unzipFile = &quot;./src/赫夫曼编码/压缩文件/公主连接-黑猫2.jpg&quot;; HuffmanByteCode huffmanByteCode = new HuffmanByteCode(srcFile); //压缩 huffmanByteCode.fileZip(dstFile); //解压 huffmanByteCode.fileUnzip(dstFile, unzipFile);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】赫夫曼树","slug":"【数据结构和算法】赫夫曼树","date":"2021-05-07T14:08:59.000Z","updated":"2021-05-07T15:32:27.409Z","comments":true,"path":"2021/05/07/【数据结构和算法】赫夫曼树/","link":"","permalink":"https://letere-gzj.github.io/2021/05/07/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/","excerpt":"树形结构之赫夫曼树的介绍和代码实现","text":"树形结构之赫夫曼树的介绍和代码实现 1 赫夫曼树1.1 介绍 赫夫曼树（Huffman Tree）：当给树中的每个叶子节点一定的权值，来表示路径的长度。若通知这些节点的组合，形成的树的带权路径长度（wpl：weighted path length）达到最小值，此二叉树称为最优二叉树，也称为赫夫曼树（哈夫曼树，霍夫曼树） 特点：权值较大的节点一般离根节点比较近 其他概念： （1）路径：从一个节点到其子节点/孙子节点的道路。即经过哪些节点 （2）路径长度：路径跨越的层数-1 （3）节点的权：给节点赋一定值大小 （4）带权路径长度：从根节点到该节点之间的*路径长度 * 节点的权* （5）树的带权路径长度：所有节点的带权路径长度之和 1.2 思路 （1）对数组进行升序排序（从小到大） （2）取出根节点权值前两个小的树（或节点），组成一个新二叉树 （3）新二叉树的根节点值为其两个子节点权值之和 （4）根节点值加入数组，重新排序，继续循环上面步骤 举例：将数组[1, 3, 6, 7, 8, 13, 29]组成赫夫曼树 1.3 代码 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class HuffmanTree &#123; //子类 --- 树节点 //为了让节点之间能够进行比较排序，实现Comparable接口 private class Node implements Comparable&lt;Node&gt; &#123; public int weight; //权值 public Node left; //左子节点 public Node right; //右子节点 public Node(int weight) &#123; this(weight, null, null); &#125; public Node(int weight, Node left, Node right) &#123; this.weight = weight; this.left = left; this.right = right; &#125; @Override public String toString() &#123; return &quot;Node&#123;weight：&quot; + weight + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Node o) &#123; //当前数&gt;比较数o，返回正数 //当前数&lt;比较数o，返回负数 //当前数=比较数o，返回0 return weight - o.weight; &#125; &#125;//--------------------------------------------------------------------- private Node root; //根节点 //构建对象，自动调用创建赫夫曼树 public HuffmanTree(int[] arr) &#123; createTree(arr); &#125; /** * 创建赫夫曼树 * @param arr 数组 */ private void createTree(int[] arr) &#123; //因为频繁进行插、删操作，选择链表来存储 List&lt;Node&gt; nodes = new LinkedList&lt;&gt;(); //遍历数组，创建Node并加入链表 for (int weight : arr) &#123; nodes.add(new Node(weight)); &#125; while (nodes.size() &gt; 1) &#123; //node集合排序 Collections.sort(nodes); //取出前两个节点（自动从链表中删除） Node left = nodes.remove(0); Node right = nodes.remove(0); //构建新树，新树根节点权值 = 左右子节点权值之和 Node parent = new Node(left.weight + right.weight, left, right); //将新树加入链表集合 nodes.add(parent); &#125; //将创建好的赫夫曼树根节点赋值 root = nodes.get(0); &#125; /** * 前序遍历 */ public void prePrint() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); return; &#125; prePrintRecursion(root); &#125; /** * 前序遍历 --- 递归本体 * @param node 节点 */ private void prePrintRecursion(Node node) &#123; System.out.println(node); if (node.left != null) &#123; prePrintRecursion(node.left); &#125; if (node.right != null) &#123; prePrintRecursion(node.right); &#125; &#125;&#125; （2）测试1234567891011@Testpublic void huffmanTreeTest() &#123; //创建数组并打乱顺序 int[] arr = new int[]&#123;1, 6, 3, 7, 13, 8, 29&#125;; //创建赫夫曼树 HuffmanTree huffmanTree = new HuffmanTree(arr); //前序遍历查看 huffmanTree.prePrint();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】线索二叉树","slug":"【数据结构和算法】线索二叉树","date":"2021-05-05T15:41:32.000Z","updated":"2021-05-05T15:46:56.513Z","comments":true,"path":"2021/05/05/【数据结构和算法】线索二叉树/","link":"","permalink":"https://letere-gzj.github.io/2021/05/05/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"树结构之线索二叉树的介绍和代码实现","text":"树结构之线索二叉树的介绍和代码实现 1 线索二叉树1.1 介绍 由于二叉树的叶子结点的指针没有任何指向，只能空着，就提出了线索化二叉树的概念 n个节点的二叉树中含有n+1【2*n - (n-1) == n+1】：有n个节点，就有2*n个指针域，除了根节点外，每一个节点都会被一个指针引用，即（n-1）个，所以才2*n-(n-1)空指针域个空指针域 线索二叉树（Threaded BinaryTree）：利用二叉树中空指针域，用来指定该节点在某种遍历次序下的前驱和后继节点的指针。根据线索性质的不同，线索二叉树可以分为前序线索二叉树，中序线索二叉树，后续线索二叉树 一个节点的前一个节点，称为前驱节点。反之称为后继节点 1.2 图解 上面的二叉树中序遍历结果为：4 -&gt; 2 -&gt; 5 -&gt; 1 -&gt; 6 -&gt; 3 通过遍历结果，来对多余的空指针进行指向，左指针用于指向前驱节点，右指针用于指向后继节点 产生问题：一个节点的左右指针有可能是指向左右节点，也有可能是指向前驱/后继节点。所以节点需要额外的属性来标志该左右指针是指向什么内容 1.3 代码 （1）代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class ThreadBinaryTree &#123; //子类 --- 树节点 private class Node &#123; public int weight; //权重 public Object data; //数据 public Node left; //左子节点 public Node right; //右子节点 //额外的属性来表示节点类型，0是指向左右子树，1是指向前驱后继节点（默认0） public int leftType; //左子节点类型 public int rightType; //右子节点类型 public Node(int weight, Object data) &#123; this.weight = weight; this.data = data; &#125; @Override public String toString() &#123; return &quot;Node&#123;&quot; + weight + &quot;: &quot; + data + &#x27;&#125;&#x27;; &#125; &#125;//--------------------------------------------------------------------------- private Node root; //根节点 private Node preNode; //前驱节点 public ThreadBinaryTree() &#123; //因为没有具体的规则，二叉树通过手动创建 root = new Node(1, &quot;A&quot;); root.left = new Node(2, &quot;B&quot;); root.right = new Node(3, &quot;C&quot;); root.left.left = new Node(4, &quot;D&quot;); root.left.right = new Node(5, &quot;E&quot;); root.right.left = new Node(6, &quot;F&quot;); &#125; /** * 中序线索化树 */ public void midThreadedTree() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); &#125; //递归中序线索化节点 midThread(root); //清除前驱节点记录 preNode = null; &#125; /** * 中序线索化节点 -- 递归本体 * @param node 树节点 */ public void midThread(Node node) &#123; //递归中序线索化左子树 if (node.left != null) &#123; midThread(node.left); &#125; //线索化节点 //处理左节点 if (node.left == null) &#123; node.left = preNode; //左子节点指向前驱节点 node.leftType = 1; //修改结点内向为前驱节点 &#125; //处理右节点 //因为当前节点是无法获取后继节点，所以在遍历到新节点时，通过前驱节点的右空子节点来指定新节点，来实现指向后继节点 if (preNode != null &amp;&amp; preNode.right == null) &#123; preNode.right = node; preNode.rightType = 1; &#125; //处理完毕，将当前节点作为下一个节点的前驱节点 preNode = node; //递归中序线索化右子树 if (node.right != null) &#123; midThread(node.right); &#125; &#125; //测试是否线索化成功 public void test() &#123; //调用叶子节点的左右子节点是否有数据 //本应该是空指针域，变成有数据则线索化成功 //测试数据是：5号节点，前驱节点为2号节点，后继节点为1号节点 System.out.println(&quot;前驱节点为：&quot; + root.left.right.left); System.out.println(&quot;后继节点为：&quot; + root.left.right.right); &#125;&#125; （2）测试12345678@Testpublic void threadBinaryTreeTest() &#123; ThreadBinaryTree threadBinaryTree = new ThreadBinaryTree(); threadBinaryTree.midThreadedTree(); //中序线索化树 //因为Node为私有类，写一个方法来查看Node内容 threadBinaryTree.test();&#125; 1.4 遍历线索二叉树 因为二叉树的结构发生了变化，所以原来遍历二叉树的方法不再生效，会变成死递归 但因为二叉树的结构发生变化，原本利用递归来实现的回溯，可以通过后继节点来实现，变成线性遍历，提高了遍历的效率 （1）代码实现1234567891011121314151617181920212223242526272829/** * 中序遍历 */public void midPrint() &#123; //每个线索化二叉树会有其特定的规律，所以需要根据实际情况调整规律 //以下是中序线索二叉树的遍历规律 if (root == null) &#123; System.out.println(&quot;树为空！&quot;); &#125; Node node = root; while (node != null) &#123; //优先寻找左节点为叶子节点的数，特征为节点类型为1 while (node.leftType != 1) &#123; node = node.left; &#125; System.out.println(node); //通过后继节点，回溯到父节点，直至父节点存在右子树 while (node.rightType == 1) &#123; node = node.right; System.out.println(node); &#125; //切换节点到父节点的右子树，进行下一轮遍历 node = node.right; &#125;&#125; （2）测试1234567public void threadBinaryTreeTest() &#123; ThreadBinaryTree threadBinaryTree = new ThreadBinaryTree(); threadBinaryTree.midThreadedTree(); //中序线索化树 //中序遍历 threadBinaryTree.midPrint();&#125;","categories":[],"tags":[]},{"title":"【数据结构和算法】顺序存储二叉树","slug":"【数据结构和算法】顺序存储二叉树","date":"2021-05-05T13:14:45.000Z","updated":"2021-05-05T13:16:43.396Z","comments":true,"path":"2021/05/05/【数据结构和算法】顺序存储二叉树/","link":"","permalink":"https://letere-gzj.github.io/2021/05/05/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"顺序存储二叉树的介绍和代码实现","text":"顺序存储二叉树的介绍和代码实现 1 顺序存储二叉树1.1 介绍 顺序存储二叉树：从数据存储方式来看，数组存储方式和树的存储方式可以相互转换。即顺序存储二叉树本质上是一个数组，但可以将这数组抽象成为二叉树。 1.2 特点 （1）顺序存储二叉树只会考虑完全二叉树 （2）第n个元素是左子节点，满足2 * n + 1 （3）第n个元素是右子节点，满足2 * n + 2 （4）第n个元素是父节点，满足(n - 1) / 2 （5）n为二叉树中元素的编号（数组编号）（从0开始编号） 可以归纳总结为：上层和下层之间是两倍数的关系 1.3 代码 代码只是简单显示了前序遍历，中后序同理，只是打印的位置不一样而已 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ArrayBinaryTree &#123; Object[] arr; //底层存储数组（顺序存储二叉树本质是一个数组） int n; //数组长度 public ArrayBinaryTree(Object[] arr) &#123; this.arr = arr; this.n = arr.length; &#125; /** * 前序遍历 */ public void prePrint() &#123; if (arr == null || n == 0) &#123; System.out.println(&quot;树为空！&quot;); &#125; System.out.println(&quot;前序遍历为：&quot;); //数组下标0为根节点 prePrintRecursion(0); &#125; /** * 前序遍历 --- 递归本体 * @param index 数组下标 */ private void prePrintRecursion(int index) &#123; //打印当前index数据（父节点数据） System.out.print(arr[index] + &quot; &quot;); //左子树递归前序遍历 int temp = index * 2 + 1; //计算左子节点下标 if (temp &lt; n) &#123; //下标不越界就递归 prePrintRecursion(temp); &#125; //右子树递归前序遍历 temp = index * 2 + 2; //计算右子节点下标 if (temp &lt; n) &#123; prePrintRecursion(temp); &#125; &#125;&#125; （2）测试123456789@Testpublic void arrayBinaryTreeTest() &#123; //创建数组 Integer[] arr = new Integer[]&#123;1, 2, 3, 4, 5, 6, 7&#125;; //通过数组创建顺序存储二叉树 ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr); //调用前序遍历 arrayBinaryTree.prePrint();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】树&二叉树","slug":"【数据结构和算法】树-二叉树","date":"2021-05-05T09:48:42.000Z","updated":"2021-05-05T10:04:35.112Z","comments":true,"path":"2021/05/05/【数据结构和算法】树-二叉树/","link":"","permalink":"https://letere-gzj.github.io/2021/05/05/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"数据结构：数的介绍和基本实现代码","text":"数据结构：数的介绍和基本实现代码 1 树1.1 存储方式比较 （1）数组 优点：通过下标方式访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度 缺点：如果要检索某个具体的值，或者插入值会进行整体移动，效率低 （2）链表 优点：在一定程度上对数组进行优化，对插入、删除操作进行优化，只需修改结点间的指向即可，无需整体移动 缺点：链表进行检索，效率很低 （3）树 能提高数据存储、读取效率，比如利用二叉排序树，既可以保证数据的检索数据，同时也能保证数据的插入和删除的速度 1.2 树的常用术语 （1）节点：一个对象，用来存储数据，跟链表类似 （2）根节点：一树最顶部的节点 （3）父/子节点：节点A的下一个节点指向节点B，A就是B的父节点，B是A的子节点 （4）叶子节点：没有子节点的节点，即树的最底部节点 （5）节点的权：理解为节点数据的大小（大小可根据一定条件/公式计算） （6）路径：从根节点到指定节点的路线（即：经过了哪些节点） （7）子树：一个树里包含另一个树，被包含的树称为子树 （8）树的高度：树的层数（行数） （9）森林：多棵子树构成为森林 2 二叉树2.1 介绍 二叉树：顾名思义，二叉树即一个节点只有两个子节点（左节点和右节点）的树，为二叉树 满二叉树：如果二叉树的所有叶子节点都在最后一层，即节点数为2^n-1（n = 层数）的树为满二叉树 完全二叉树：二叉树所有叶子节点在最后一层或两层，且这两层之间的节点是连续的，没有断开，称为完全二叉树 2.2 前中后序遍历 （1）前序遍历：先输出父节点，再遍历左子树，然后右子树（子树也有自己对应的父节点，所以会一直遍历左边，然后才到右边） 上图：A -&gt; B -&gt; D -&gt; H -&gt; E -&gt; C -&gt; F -&gt; G （2）中序遍历：先遍历左子树，再输出父节点，然后再遍历右子树 上图：H -&gt; D -&gt; B -&gt; E -&gt; A -&gt; F -&gt; C -&gt; G （3）后序遍历：先遍历左子树，再遍历右子树，最后输出父节点 上图：H -&gt; D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A 2.3 遍历代码实现 （1）代码实现（递归）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class BinaryTree &#123; //子类：节点 private class Node &#123; public int rate; //权重 public Object data; //数据 public Node left; //左子节点 public Node right; //右子节点 public Node(int rate, Object data) &#123; this.rate = rate; this.data = data; &#125; @Override public String toString() &#123; return &quot;Node&#123;&quot; + rate + &quot;: &quot; + data + &#x27;&#125;&#x27;; &#125; &#125;//----------------------------------------------------- private Node root; //根节点 public BinaryTree() &#123; //因为最基础的二叉树没有任何规则，所以不适合自动创建，需要我们手动创建二叉树 root = new Node(1, &quot;hello&quot;); root.left = new Node(2, &quot;world&quot;); root.right = new Node(3, &quot;!&quot;); root.left.left = new Node(4, &quot;2333&quot;); &#125; /** * 前序遍历 */ public void preOrder() &#123; if (root == null) &#123; System.out.println(&quot;树为空!&quot;); return; &#125; //从根节点开始递归前序遍历 System.out.println(&quot;前序遍历为：&quot;); preOrderRecursion(root); &#125; /** * 前序遍历 -- 递归 * @param node 节点 */ private void preOrderRecursion(Node node) &#123; //打印父节点 System.out.println(node); //左子树进行前序遍历 if (node.left != null) &#123; preOrderRecursion(node.left); &#125; //右子树进行前序遍历 if (node.right != null) &#123; preOrderRecursion(node.right); &#125; &#125; /** * 中序遍历 */ public void midOrder() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); return; &#125; //从根节点开始递归中序遍历 System.out.println(&quot;中序遍历为：&quot;); midOrderRecursion(root); &#125; /** * 中序遍历 -- 递归 * @param node 节点 */ private void midOrderRecursion(Node node) &#123; //左子树进行中序遍历 if (node.left != null) &#123; midOrderRecursion(node.left); &#125; //打印父节点 System.out.println(node); //右子树进行中序遍历 if (node.right != null) &#123; midOrderRecursion(node.right); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; if (root == null) &#123; System.out.println(&quot;树为空！&quot;); return; &#125; //从根节点开始后序遍历 System.out.println(&quot;后序遍历为：&quot;); postOrderRecursion(root); &#125; /** * 后序遍历 -- 递归 * @param node 节点 */ private void postOrderRecursion(Node node) &#123; //左子树递归后序遍历 if (node.left != null) &#123; postOrderRecursion(node.left); &#125; //右子树递归后续遍历 if (node.right != null) &#123; postOrderRecursion(node.right); &#125; //打印父节点 System.out.println(node); &#125;&#125; （2）测试12345678@Testpublic void binaryTreeTest() &#123; BinaryTree binaryTree = new BinaryTree(); binaryTree.preOrder(); binaryTree.midOrder(); binaryTree.postOrder();&#125; 2.3 前中后序查找 跟前中后序遍历思路一样，就不详细细说，只不过多了个跟数据进行对比的操作，数据一样就返回，不一样就继续遍历 由于前中后的基本一样，就是比较数据的位置不一样，就只写一个前序查找例子就算了 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 通过权重前序查找数据 * @param rate 权重 */public void preSearch(int rate) &#123; if (root == null) &#123; System.out.println(&quot;树为空&quot;); &#125; //递归前序查找数据 Node node = preSearchRecursion(rate, root); if (node == null) &#123; System.out.println(&quot;查找失败！数据不存在！&quot;); &#125;else &#123; System.out.println(&quot;查找成功！数据为：&quot; + node); &#125;&#125;/** * 前序查找 -- 递归 * @param rate 权重 * @param node 节点 * @return Node */private Node preSearchRecursion(int rate, Node node) &#123; Node temp; //比较父节点是否相等 if (node.rate == rate) &#123; return node; &#125; //向左子树递归查找 if (node.left != null) &#123; temp = preSearchRecursion(rate, node.left); if (temp != null) &#123; return temp; &#125; &#125; //向右子树递归查找 if (node.right != null) &#123; temp = preSearchRecursion(rate, node.right); if (temp != null) &#123; return temp; &#125; &#125; //都查找不到，返回null return null;&#125; （2）测试123456@Testpublic void binaryTreeTest() &#123; BinaryTree binaryTree = new BinaryTree(); binaryTree.preSearch(4);&#125; 2.4 删除 删除规则 （1）删除的是叶子节点，直接删除该节点 （2）删除的是非叶子节点，则删除该的子树（或取其中一个子节点来代替头结点） （1）代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 通过权重删除数据 * @param rate 权重 */public void delete(int rate) &#123; //判断根节点是否为空 if (root == null) &#123; System.out.println(&quot;树为空，无数据删除！&quot;); return; &#125; //判断根节点是否是删除数据 if (root.rate == rate) &#123; root = null; System.out.println(&quot;删除成功！&quot;); return; &#125; //以上条件都不满足，则进行递归删除 boolean isDelete = deleteRecursion(rate, root); if (isDelete) &#123; System.out.println(&quot;删除成功！&quot;); &#125;else &#123; System.out.println(&quot;删除失败！找不到数据！&quot;); &#125;&#125;/** * 删除节点 -- 递归 * @param rate 权重 * @param node 节点 * @return boolean */private boolean deleteRecursion(int rate, Node node) &#123; boolean isDelete; //记录是否删除 //判断左子节点是否是删除数据 if (node.left != null &amp;&amp; node.left.rate == rate) &#123; node.left = null; return true; &#125; //判断右子节点是否是删除数据 if (node.right != null &amp;&amp; node.right.rate == rate) &#123; node.right = null; return true; &#125; //都不是删除数据，进行递归删除 //向左子树递归删除 if (node.left != null) &#123; isDelete = deleteRecursion(rate, node.left); //已删除则退出递归 if (isDelete) &#123; return true; &#125; &#125; //向右子树递归删除 if (node.right != null) &#123; isDelete = deleteRecursion(rate, node.right); //已删除则退出递归 if (isDelete) &#123; return true; &#125; &#125; //如果都没有退出递归，则删除失败 return false;&#125; （2）测试123456789101112@Testpublic void binaryTreeTest() &#123; BinaryTree binaryTree = new BinaryTree(); binaryTree.preOrder(); System.out.println(); binaryTree.delete(4); System.out.println(); binaryTree.preOrder();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】哈希表","slug":"【数据结构和算法】哈希表","date":"2021-05-04T15:33:24.000Z","updated":"2021-05-04T15:39:45.054Z","comments":true,"path":"2021/05/04/【数据结构和算法】哈希表/","link":"","permalink":"https://letere-gzj.github.io/2021/05/04/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"数据结构之哈希表的介绍和代码实现","text":"数据结构之哈希表的介绍和代码实现 1 哈希表1.1 介绍 哈希表（Hash Table）：也称为散列表，是根据key-value而直接进行访问的数据结构。通过key值快速映射到表中的一个位置来访问记录，以加快查找的速度。用来映射函数叫做散列函数，存放记录的数组叫做散列表 1.2 应用场景 1.3 实现思路 Hash表的实现思路和HashMap的底层相似 通过数组 + 链表的形式来实现 数组来存放链表，在添加一个数据的时候，通过散列函数对key进行一定的计算，确定数据的分区，然后在该分区以链表的形式添加数据 1.4 代码 下面的代码只是简单的实现HashTable的添加数据 和 查找数据功能，还有很多细节没有写。例如重复的key名如何处理，修改数据，和删除数据等功能没有实现 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public class HashTable &#123; //子类 -- 链表结点 private class Node &#123; String key; //关键词 Object value; //数据 Node next; //下一个节点 public Node(String key, Object value) &#123; this.key = key; this.value = value; &#125; @Override public String toString() &#123; return &#x27;&#123;&#x27; + key + &#x27;:&#x27; + value + &#x27;&#125;&#x27;; &#125; &#125;//--------------------------------------------------------------------- //子类 -- 单链表 private class LinkedList&#123; Node headNode; //头结点 /** * 添加数据（尾插法） * @param key 关键词 * @param data 数据 */ public void add(String key, Object data) &#123; Node node = new Node(key, data); //头结点没有数据，直接赋值给头结点 if (headNode == null) &#123; headNode = node; return; &#125; Node temp = headNode; while (temp.next != null) &#123; temp = temp.next; &#125; temp.next = node; &#125; /** * 通过关键词获取数据 * @param key 关键词 * @return Object */ public Object get(String key) &#123; //头结点为null，链表没数据 if (headNode == null) &#123; System.out.println(&quot;该数据不存在!&quot;); return null; &#125; //遍历链表，寻找与key相同的数据 Node temp = headNode; while (temp != null) &#123; if (temp.key.equals(key)) &#123; return temp.value; &#125; temp = temp.next; &#125; //循环退出，即找不到相同的key System.out.println(&quot;该数据不存在!&quot;); return null; &#125; /** * 打印链表 */ public void print() &#123; if (headNode == null) &#123; return; &#125; Node temp = headNode; while (temp != null) &#123; System.out.print(temp + &quot; &quot;); temp = temp.next; &#125; &#125; &#125;//--------------------------------------------------------------------- private int size; //数组长度 private LinkedList[] linkedList; //链表数组 public HashTable() &#123; this(5); //默认数组长度为5 &#125; public HashTable(int size) &#123; this.size = size; linkedList = new LinkedList[size]; &#125; /** * 添加数据 * @param key 关键词 * @param data 数据 */ public void add(String key, Object data) &#123; //通过散列函数分配数组index int index = hashFun(key); //链表为空，就先创建一个链表 if (linkedList[index] == null) &#123; linkedList[index] = new LinkedList(); &#125; linkedList[index].add(key, data); &#125; /** * 通过关键词获取数据 * @param key 关键词 * @return Object */ public Object get(String key) &#123; //通过散列函数分配数组index int index = hashFun(key); //链表为空，一定不存在数据 if (linkedList[index] == null) &#123; System.out.println(&quot;数据不存在！&quot;); return null; &#125; return linkedList[index].get(key); &#125; /** * 打印数据 */ public void print() &#123; //遍历数组打印链表 for (LinkedList list : linkedList) &#123; if (list != null) &#123; list.print(); &#125; &#125; System.out.println(); &#125; /** * 散列函数 * @param key 关键词 * @return int */ private int hashFun(String key) &#123; //每个类会有一个与之对应的hashCode int code = key.hashCode(); //取模，是最简单的散列函数 return code % size; &#125;&#125; （2）测试1234567891011121314@Testpublic void hashTableTest() &#123; //创建哈希表，并添加数据 HashTable hashTable = new HashTable(); hashTable.add(&quot;id&quot;, 1); hashTable.add(&quot;name&quot;, &quot;C酱&quot;); hashTable.add(&quot;age&quot;, 18); hashTable.add(&quot;sex&quot;, &quot;女&quot;); hashTable.print(); //通过关键词获取数据 Object sex = hashTable.get(&quot;sex&quot;); System.out.println(sex);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】查找算法","slug":"【数据结构和算法】查找算法","date":"2021-05-04T03:41:35.000Z","updated":"2021-06-05T07:59:29.374Z","comments":true,"path":"2021/05/04/【数据结构和算法】查找算法/","link":"","permalink":"https://letere-gzj.github.io/2021/05/04/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","excerpt":"查找算法的介绍和代码实现","text":"查找算法的介绍和代码实现 1 线性查找1.1 介绍 线性查找（Linear Search）：也称为顺序查找，顾明思义，就是按顺序遍历序列，找到对应匹配的数据，返回该数据所在的下标 1.2 代码 由于线性查找过于简单，就不多做思想说明 （1）代码实现1234567891011121314151617181920212223242526272829303132333435363738public class LinearSearch &#123; /** * 线性查找 - 查找一个 * @param arr 查找数组 * @param key 查找值 * @return int */ public static int findOne(int[] arr, int key) &#123; //遍历数组，比较数据 for(int i=0; i&lt;arr.length; i++) &#123; if (arr[i] == key) &#123; return i; &#125; &#125; //没有找到返回-1 return -1; &#125; /** * 线性查找 - 查找全部 * @param arr 查找数组 * @param key 查找值 * @return List&lt;Integer&gt; */ public static List&lt;Integer&gt; findAll(int[] arr, int key) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); //遍历数组，比较数据 for(int i=0; i&lt;arr.length; i++) &#123; if (arr[i] == key) &#123; temp.add(i); &#125; &#125; return temp; &#125;&#125; （2）测试123456789101112@Testpublic void linearSearchTest() &#123; int[] arr = new int[]&#123;1, -2, 5, 11, 190, 11, -45, -2&#125;; //查找一个 int index = LinearSearch.findOne(arr, 11); System.out.println(&quot;数字11的下标为：&quot; + index); //查找全部 List&lt;Integer&gt; indexList = LinearSearch.findAll(arr, 11); System.out.println(&quot;数字11的下标分别为：&quot; + indexList.toString());&#125; 2 二分查找2.1 介绍 二分查找（Binary Search）：即将一个有序的数组分为左右两部分，将查找值和中间值比较，根据大小来选取左右哪一部分在进行下一次查找，来缩小查找的范围 算法思路：通过mid = (left + right) / 2 或 mid = left + 1/2 (right - left)取出中间下标，对数组分为左右两部分，通过中见下标取出对应中间值。通过查找值key与中间值比较，大于中间值，就选取右边的部分[mid+1, right]进行递归查找，反之对左边[left, mid-1]进行递归查找。递归退出条件：（1）查到对应的值arr[mid] == key；（2）找不到对应的值，即超出边界left &gt; rigth 2.2 代码 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BinarySearch &#123; /** * 二分查找 - 升序数组 - 查找一个 * @param arr 查找数组 * @param key 查找值 * @return int */ public static int findOneByAsc(int[] arr, int key) &#123; //因为是有序数组，超出边界值一定不存在，直接退出 if (key &lt; arr[0] || key &gt; arr[arr.length-1]) &#123; return -1; &#125; return findOneRecursion(arr, 0, arr.length-1, key); &#125; /** * 查找一个 - 递归查找 * @param arr 查找数组 * @param left 左边界下标 * @param right 右边界下标 * @param key 查找值 * @return int */ private static int findOneRecursion(int[] arr, int left, int right, int key) &#123; //超出边界，找不到相应的值 if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; //中间下标 //值相等，找到下标 if (arr[mid] == key) &#123; return mid; &#125; //值 &gt; key，向左边部分递归查找 else if (arr[mid] &gt; key) &#123; return findOneRecursion(arr, left, mid - 1, key); &#125; //值 &lt; key，向右边部分递归查找 else &#123; return findOneRecursion(arr, mid + 1, right, key); &#125; &#125;&#125; （2）测试12345678@Testpublic void binarySearch() &#123; int[] arr = new int[]&#123;1, 4, 7, 11, 11, 34, 111&#125;; //查找一个 int index = BinarySearch.findOneByAsc(arr, 11); System.out.println(&quot;数字11的下标为：&quot; + index);&#125; 2.3 非递归写法 （1）代码 12345678910111213141516171819202122232425262728293031323334353637/** * 二分查找算法 - 非递归 * @author letere * @create 2021-06-05 15:31 */public class BinarySearch2 &#123; /** * 二分查找 - 升序序列 - 查找一个 * @param arr 升序序列 * @param key 查找值 * @return int */ public static int findOneByAsc(int[] arr, int key) &#123; int left = 0; int right = arr.length-1; int mid; while (left &lt;= right) &#123; mid = (right + left) / 2; //中间值匹配，返回下标 if (arr[mid] == key) &#123; return mid; &#125; //中间值 &lt; 查找值，向右查找，反之向左查找 if (arr[mid] &lt; key) &#123; left = mid + 1; &#125;else &#123; right = mid - 1; &#125; &#125; return -1; &#125;&#125; （2）测试 12345678@Testpublic void binarySearch() &#123; int[] arr = new int[]&#123;1, 4, 7, 11, 11, 34, 111&#125;; //查找一个 int index = BinarySearch2.findOneByAsc(arr, 11); System.out.println(&quot;数字11的下标为：&quot; + index);&#125; 2.4 功能完善 如果我们需要查找所有的下标值，我么可以对上面的代码进行改进：在找到对应的下标后，先不着急返回，而是遍历该下标左右两边的值。因为是一个有序数组，相同值就会在其左右两边附近。如果值等于查找值，也将其加入返回值中。最后再统一返回 （1）代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 二分查找 -升序数组 - 查找全部 * @param arr 查找数组 * @param key 查找值 * @return List&lt;String&gt; */public static List&lt;Integer&gt; findAllByAsc(int[] arr, int key) &#123; //因为是有序数组，超出边界值一定不存在，直接退出 if(key &lt; arr[0] || key &gt; arr[arr.length-1]) &#123; return new ArrayList&lt;&gt;(); &#125; return findAllRecursion(arr, 0, arr.length-1, key);&#125;/** * 查找全部 - 递归查找 * @param arr 查找数组 * @param left 左边界下标 * @param right 右边界下包 * @param key 查找值 * @return List&lt;String&gt; */private static List&lt;Integer&gt; findAllRecursion(int[] arr, int left, int right, int key) &#123; //超出边界，查找失败 if (left &gt; right) &#123; return new ArrayList&lt;&gt;(); &#125; int mid = (left + right) / 2; //值相等，找到下标 if(arr[mid] == key) &#123; List&lt;Integer&gt; indexList = new ArrayList&lt;&gt;(); //下标集合 indexList.add(mid); //向左找同样值的下标 int temp = mid -1; //暂时变量，记录下标 while (temp &gt;= 0 &amp;&amp; arr[temp] == key) &#123; indexList.add(temp); temp --; &#125; //向右找同样值的下标 temp = mid + 1; while (temp &lt; arr.length &amp;&amp; arr[temp] == key) &#123; indexList.add(temp); temp ++; &#125; return indexList; &#125; //值 &gt; key，向左边部分递归寻找 else if(arr[mid] &gt; key) &#123; return findAllRecursion(arr, left, mid-1, key); &#125; //值 &lt; key，向右边部分递归寻找 else &#123; return findAllRecursion(arr, mid+1, right, key); &#125;&#125; （2）测试12345678@Testpublic void binarySearch() &#123; int[] arr = new int[]&#123;1, 4, 7, 11, 11, 34, 111&#125;; //查找全部 List&lt;Integer&gt; indexList = BinarySearch.findAllByAsc(arr, 11); System.out.println(&quot;数组11的下标分别为：&quot; + indexList.toString());&#125; 3 插值查找3.1 介绍 插值查找（Interpolation Search）：是二分查找的拓展查找。每次分左右两个数组，不再是中间的下标。而是一个自适应的下标，根据数组和查找值变化。插值算法在一些分布比较均匀，以及等差序列的时候，算法效率很高。 算法思想：整体和二分查找一样。唯一区别就是数组的分界下标不再是中间值，而是left + (key - arr[left]) / (arr[right] - arr[left]) * (right - left)，其中的(key - arr[left]) / (arr[right] - arr[left])是计算该查找值在整个数组中的占比，来大概估算其对应的下标。二分查找这里的值直接为1/2。 3.2 代码 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class InterpolationSearch &#123; /** * 插值查找 - 升序数组 - 查找一个 * @param arr 查找数组 * @param key 查找值 * @return int */ public static int findOneByAsc(int[] arr, int key) &#123; //因为是有序数组，如果查找值超出边界，肯定查找不到 if (key &lt; arr[0] || key &gt; arr[arr.length-1]) &#123; return -1; &#125; return findOneRecursion(arr, 0, arr.length-1, key); &#125; /** * 查找一个 - 递归查找 * @param arr 查找数组 * @param left 左边界下标 * @param right 右边界下标 * @param key 查找值 * @return int */ private static int findOneRecursion(int[] arr, int left, int right, int key) &#123; //超出边界，查找不到 if(left &gt; right) &#123; return -1; &#125; //计算查找值在该数组的占比下标 int rate = left + (key - arr[left]) / (arr[right] - arr[left]) * (right - left); //找到相应值，返回下标，退出递归 if (arr[rate] == key) &#123; return rate; &#125; //值 &gt; key，向左边部分递归查找 else if (arr[rate] &gt; key) &#123; return findOneRecursion(arr, left, rate-1, key); &#125; //值 &lt; key，向右边部分递归查找 else &#123; return findOneRecursion(arr, rate+1, right, key); &#125; &#125;&#125; （2）测试12345678@Testpublic void interpolationSearchTest() &#123; int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; //查找一个 int index = InterpolationSearch.findOneByAsc(arr, 1); System.out.println(&quot;数字1的下标为：&quot; + index);&#125; 4 斐波那契查找4.1 介绍 黄金分割点：一条线段分割为两部分，这两部分之间比值约等于0.618，就称为该切割点为黄金切割点 斐波那契数列：{1, 1, 2, 3, 5, 8, 13, 21, 34, 55….}，即后面数字时前两个数字之和，可以返现相邻两个数的比例，无限接近黄金分割值0.618，例：34 / 55 斐波那契查找（Fibonacci Search）：又称为黄金分割法，利用斐波那契数列接近黄金分割值的特点，对一个数组，求出其长度。找出最接近的斐波那契数列值（数组长度不够就扩容），该值的前两个值，就是对数组分割后左右两边的长度。 4.2 思路详解 （1）找分割点原理 按照斐波那契数列的特点：F[k] = F[k-1] + F[k-2]，后面的数 = 前两个数之和 可以推导出F[k]-1 = F[k-1]-1 + F[k-2]-1 + 1 按照上面公式可以理解为：对于长度为F[k]-1的数组，可以切割成左边长度为F[k-1]-1和右边长度为F[k-2]-1长度的数组，多出来的1就是中间的黄金分割点 也因此可以得到黄金分割点 = low + F[k-1]-1 （2）递归/循环查找数据原理 跟二分法一样，比较查找值与黄金分割点值，判断该数据的左右位置 如果查找值在左边，修改右边界index = 分割点index - 1，并修改记录的数组长度，因为原长度为F[k]-1，变成了F[k-1]-1，所以我们只需要修改k值，k=k-1即可 查找值在右边跟左边大致同理，修改左边界index = 分割点index + 1，和 k=k-2 递归 / 循环重新计算分割值黄金分割点即可 4.3 代码 （1）代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class FibonacciSearch &#123; /** * 获取斐波那契数组 * @return int[] */ private static int[] getFibArray() &#123; int n = 20; //默认数组长度20，按需修改 int[] fibArray = new int[n]; //填写斐波那契数列数据 fibArray[0] = 1; fibArray[1] = 1; for(int i=2; i&lt;n; i++) &#123; fibArray[i] = fibArray[i-1] + fibArray[i-2]; &#125; return fibArray; &#125; /** * 斐波那契查找 - 升序数组 - 查找一个（循环） * @param arr 查找数组 * @param key 查找值 * @return int */ public static int findOneByAsc(int[] arr, int key) &#123; int n = arr.length; //数组长度 int left = 0; //左边界下标 int right = n - 1; //右边界下标 int goldenIndex = 0; //黄金分割点 int fibIndex = 0; //斐波那契数列下标 //获取斐波那契数列 int[] fibArray = getFibArray(); //确定fibIndex值，F(k)-1大于/等于数组长度 while (n &gt; fibArray[fibIndex] - 1) &#123; fibIndex ++; &#125; //对原数组进行扩容，使其传长度等于fibArray[fibIndex]-1 int[] temp = Arrays.copyOf(arr, fibArray[fibIndex]-1); //对多出的0数据填补为末尾的数据 for (int i=right; i&lt;temp.length; i++) &#123; temp[i] = arr[right]; &#125; while (left &lt;= right) &#123; //计算黄金分割点 goldenIndex = left + fibArray[fibIndex-1] - 1; //值 &lt; 分割点值，数据在分割点的左边 if (key &lt; temp[goldenIndex]) &#123; right = goldenIndex - 1; //修改右边界 fibIndex --; //斐波那契值往前移1位：F[k] = F[k-1] + F[k-2]，左边部分的长度 = F[k-1] &#125; //值 &gt; 分割点值，数据在分割点的右边 if (key &gt; temp[goldenIndex]) &#123; left = goldenIndex + 1; //修改左边界 fibIndex -= 2; //F[k] = F[k-1] + F[k-2]，右边部分长度 = F[k-2] &#125; //值 = 分割点值，找到数据 if (key == temp[goldenIndex]) &#123; //判断分割点值是否在扩容位置，在就返回原数组末尾下标 if (goldenIndex &gt; n-1) &#123; return n-1; &#125; return goldenIndex; &#125; &#125; return -1; &#125;&#125; （2）测试1234567@Testpublic void fibonacciSearch() &#123; int[] arr = new int[]&#123;1, 4, 7, 11, 15, 34, 111&#125;; int index = FibonacciSearch.findOneByAsc(arr, 11); System.out.println(&quot;数字11的下标为：&quot; + index);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】排序算法","slug":"【数据结构和算法】排序算法","date":"2021-04-30T03:50:48.000Z","updated":"2022-08-21T08:05:35.509Z","comments":true,"path":"2021/04/30/【数据结构和算法】排序算法/","link":"","permalink":"https://letere-gzj.github.io/2021/04/30/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"排序算法，是算法基础入门，下面介绍八种的排序算法的实现","text":"排序算法，是算法基础入门，下面介绍八种的排序算法的实现 1 排序算法1.1 介绍 排序，也称为排序算法（Sort Algorithm），排序一组数据，依指定的顺序进行排序的过程 排序分类： （1）内部排序：将需要处理的所有数据都加载到内部存储器中进行排序 （2）外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序 2 冒泡排序2.1 介绍 冒泡排序（Bubble Sorting） 的基本思想为：通过遍历比较序列，依次比较当前index，和index+1是否逆序，逆序则交换两者位置，最后变成最小 / 最大的放在末尾位置，后续遍历依次放倒数第二，倒数第三…等位置，以此类推，遍历结束则为有序序列。就仿佛水底下的气泡逐渐上升 时间复杂度：O(n^2) 算法优化：如果一趟遍历下没有进行过任何交互，证明序列为有序，就直接停止循环遍历。可以设置一个变量来记录一次遍历中是出现交换 2.2 图解算法 2.3 代码 （1）基础代码12345678910111213141516171819202122232425public class BubbleSort &#123; /** * 升序排序 * @param arr 排序序列 */ public static void asc(int[] arr)&#123; int n = arr.length; //数组长度 int temp; //中间变量 //遍历次数为：长度-1 次 for(int i=0; i&lt;n-1; i++) &#123; //比较次数为：n-当前遍历次数（因为i从0开始，要额外-1，即n-(i+1)） for (int j=0; j&lt;n-i-1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //利用中间变量交换位置 temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125; （2）测试12345678910@Testpublic void bubbleSortTest() &#123; //创建数组，并调用方法排序 int[] arr = new int[]&#123;2, 1, 5, -2&#125;; BubbleSort.asc(arr); for (int item : arr) &#123; System.out.printf(&quot;%d &quot;, item); &#125;&#125; 2.4 优化代码 在上面基础代码上添加一个变量记录是否发生交换，未发生交换，序列为有序，方法退出 12345678910111213141516171819202122232425262728/** * 升序排序 * @param arr 排序序列 */public static void asc(int[] arr)&#123; int n = arr.length; int temp; boolean isSwitch; //记录是否交换 for(int i=0; i&lt;n-1; i++) &#123; isSwitch = false; //默认设置为false for (int j=0; j&lt;n-i-1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; //记录已发生交换 isSwitch = true; &#125; &#125; //未发生交换，序列为有序，直接结束方法 if (!isSwitch) &#123; return; &#125; &#125;&#125; 3 选择排序3.1 介绍 选择排序（select sorting）：属于内部排序法，从欲排序的数据中，按照指定的规则选择出来摸一个元素，在依规定交换位置后大大排序的目的 算法思路：遍历数据，选出最小 / 最大的数据，将其交换防止数组开启；后续的遍历类型，选出最小 / 最大 放在后一位 与冒泡区别：判断的次数几乎一样，但数据之间的交换次数变少，速度比冒泡快 算法优化：如果当前起始位置刚好就是最小值，则无需交换，添加一个if判断来处理 3.2 图解算法 3.3 代码 （1）代码实现12345678910111213141516171819202122232425262728293031323334public class SelectSort &#123; /** * 选择排序 - 升序 * @param arr 排序序列 */ public static void asc(int[] arr) &#123; int n = arr.length; //数组大小 int temp; //中间变量：存储最小值 int index; //记录最小值的下标 //遍历次数：n-1次 for(int i=0; i&lt;n-1; i++) &#123; //遍历数据，起始位置为当前遍历次数-1（即 i） //默认将起始位置(i)数据作为最小值 temp = arr[i]; index = i; //因为i默认为最小值，无需跟自己比，j从i+1开始比较 for(int j=i+1; j&lt;n; j++) &#123; //发现更小的值，则记录其值和下标 if (arr[j] &lt; temp) &#123; temp = arr[j]; index = j; &#125; &#125; //找完最小值，利用中间变量交换数据 arr[index] = arr[i]; arr[i] = temp; &#125; &#125;&#125; （2）测试12345678@Testpublic void selectSortTest() &#123; //创建数据并排序 int[] arr = new int[]&#123;2, 1, 5, -2&#125;; SelectSort.asc(arr); System.out.println(Arrays.toString(arr));&#125; 3.4 代码优化 添加一个判断，如果当前起始位置就是最小值，则无需进行交换 123456789101112131415161718192021222324252627/** * 选择排序 - 升序 * @param arr 排序序列 */public static void asc(int[] arr) &#123; int n = arr.length; int temp; int index; for(int i=0; i&lt;n-1; i++) &#123; temp = arr[i]; index = i; for(int j=i+1; j&lt;n; j++) &#123; if (arr[j] &lt; temp) &#123; temp = arr[j]; index = j; &#125; &#125; //如果起始位置 == 最小值，无需进行交换 if(i != index) &#123; arr[index] = arr[i]; arr[i] = temp; &#125; &#125;&#125; 4 插入排序4.1 介绍 插入排序（insert sorting）：属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，已达到排序目的 算法思路：把n个待排序的元素分为有序表和无序表，每次遍历从无序表中，取出一个元素，跟有序表中的数据进行比较，找到合适的位置，进行插入 插入方法：待插入数据跟前一个数据比较大小，大小顺序不对，则前一个数据进行后移，再跟前前一个数据比较，直到大小顺序合适 或 已经没有前一个数据 跟冒泡比较：看起来和冒泡相似，一个将数据往后移，一个将数据往前移；但是插入排序只是将数据后移，并没有交换两者之间的数据，操作步骤对比冒泡是少了一步，算法速度更快 4.2 算法图解 4.3 代码 （1）代码实现12345678910111213141516171819202122public class InsertSort &#123; /** * 插入排序 - 升序 * @param arr 序列 */ public static void asc(int[] nums) &#123; // i表示当前要插入的数据 for (int i=1; i&lt;nums.length; i++) &#123; int idx = i; int temp = nums[i]; // i开始，从后往前比较，插入数小于前数，则前数后移 while (idx &gt; 0 &amp;&amp; temp &lt; nums[idx-1]) &#123; nums[idx] = nums[idx-1]; idx --; &#125; // idx发生变化，数据发生后移，则插入数据 if (idx != i) &#123; nums[idx] = temp; &#125; &#125; &#125;&#125; （2）测试12345678@Testpublic void insertSortTest() &#123; //创建数据并排序 int[] arr = new int[]&#123;2, 1, 5, -2&#125;; InsertSort.asc(arr); System.out.println(Arrays.toString(arr));&#125; 5 希尔排序5.1 介绍 希尔排序（shell sorting）：该算法由希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后一个更高效的版本，也称为缩小增量排序 算法思想：对序列按指定步长进行分组，对每个组执行一次排序算法。然后不断缩小分组，最后合成一个组，执行排序算法，形成有序序列 优点：将数据缩小进行排序，速度快之余，并将避免很小的数在最后，需要一步一步往前挪的情况，算法运行的时间比其他算法相对于稳定 5.2 算法图解 5.3 希尔排序-交换法（不推荐） 代码实现：1234567891011121314151617181920212223242526/** * 希尔排序-交换法（冒泡排序）-升序 * @param arr 待排序队列 */public static void ascBySwitch(int[] arr) &#123; int n = arr.length; //数组长度 int temp; //中间变量（用于交换） int step = n/2; //步长 //因为步长为1时，再计算步长1/2=0，会退出循环 //前两个循环用于分组 while(step &gt; 0) &#123; for (int i=step; i&lt;n; i++) &#123; //类似冒泡排序，只不过是从后往前按照指定步长比较（效率慢） for (int j=i-step; j&gt;=0; j-=step) &#123; if (arr[j] &gt; arr[j+step]) &#123; temp = arr[j]; arr[j] = arr[j+step]; arr[j+step] = temp; &#125; &#125; &#125; //修改步长 step = step / 2; &#125;&#125; 5.4 希尔排序-移位法（推荐） 代码实现123456789101112131415161718192021222324252627282930313233/** * 希尔排序-移位法（插入排序）-升序 * @param arr 待排序队列 */public static void ascByMove(int[] arr) &#123; int n = arr.length; //队列长度 int step = n/2; //步长 int temp; //记录待插入数据 int index; //记录待插入数据的下标 //前两个循环用于分组 while (step &gt; 0) &#123; for (int i=step; i&lt;n; i++) &#123; //记录待插入数据 temp = arr[i]; index = i; while(index-step&gt;=0 &amp;&amp; temp&lt;arr[index-step]) &#123; //数据后移 arr[index] = arr[index - step]; index -= step; &#125; //数据位置发生移动，才插入数据 if (index != i) &#123; arr[index] = temp; &#125; &#125; //修改步长 step /= 2; &#125;&#125; 6 快速排序6.1 介绍 快速排序（QuickSort）：是对冒泡排序的一种改进 算法思想：选定一个数据作为边界，通过一趟排序将要排序的数据分为两部分，一边小于选定的数据，另一边大于选定的数据。然后对此两组数据，按照上面方法再进行分组。一直递归执行，直到分组的数据小于等于1个时，才退出递归 优点：利用空间来换取时间的典型案例，利用递归来排序，速度快。但因为使用了递归，当数据量庞大的时候，会出现栈溢出的情况（递归本身是使用了栈） 6.2 图解 6.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738public void quickSort(int[] nums) &#123; sortByRec(nums, 0, nums.length-1);&#125;private void sortByRec(int[] nums, int left_idx, int right_idx) &#123; if (right_idx - left_idx &lt; 1) &#123; return; &#125; // 创建左右指针，并找出中间节点 int left = left_idx; int right = right_idx; int midVal = nums[(left+right)/2]; while (true) &#123; // 左右值相同时，避免指针不移动 if (nums[left] == nums[right] &amp;&amp; nums[left] == midVal) &#123; if (left != right) &#123; left ++; &#125; else &#123; break; &#125; &#125; // 左指针找出大于中间点的值 while (nums[left] &lt; midVal) &#123; left++; &#125; // 右指针找出小于中间点的值 while (nums[right] &gt; midVal) &#123; right--; &#125; // 左右指针数据交换 int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; &#125; // 递归 sortByRec(nums, left_idx, left-1); sortByRec(nums, right+1, right_idx);&#125; 7 归并排序7.1 介绍 归并排序（Merge Sort）：利用归并的思想实现的排序算法，采用经典的分治策略（分：将问题分成一个小的问题然后递归求解；治：将分的阶段得到的答案结合在一起） 算法思路：将数组的数组递归细分，分到只为1时。再对两个数组按大小顺序加入到一个缓存数组temp，再将缓存数组temp的数据改写进原数组数据 优点：和快速排序一样，引入了递归，牺牲空间来换取时间 7.2 图解 7.3 代码 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MergeSort &#123; /** * 归并排序 - 升序 * @param arr 待排序数组 */ public static void asc(int[] arr) &#123; divideConquer(arr, 0, arr.length-1); &#125; /** * &#x27;分 + 治&#x27; ： 将数组递归分割，并按顺序合并 * @param arr 待排序原数组 * @param left 左边界下标 * @param right 右边界下标 */ private static void divideConquer(int[] arr, int left, int right) &#123; int mid = (left + right) / 2; //当左右边界不重合，可以继续分 if (left &lt; right) &#123; //对左右两边继续进行分 divideConquer(arr, left, mid); divideConquer(arr, mid+1, right); //分完再进行&#x27;治&#x27; conquer(arr, left, mid, right); &#125; &#125; /** * &#x27;治&#x27;：将两数组比较按顺序加入暂时变量，并改写原数组 * @param arr 待排序序列 * @param left 左边界下标 * @param mid 中间下标（用于将一个数组分割为两个数组） * @param right 右边界下标 */ private static void conquer(int[] arr, int left, int mid, int right) &#123; int lIndex = left; //左边数组头下标 int rIndex = mid + 1; //右边数组头下标 int[] temp = new int[right - left + 1]; //暂时变量 int tIndex = 0; //temp数组下标 //只要下标没有移动到尾部，一直比较两数组大小 while(lIndex &lt;= mid &amp;&amp; rIndex &lt;= right) &#123; //比较两个数组的头下标的大小，谁小谁加入temp if (arr[lIndex] &lt; arr[rIndex]) &#123; temp[tIndex] = arr[lIndex]; tIndex ++; lIndex ++; &#125;else &#123; temp[tIndex] = arr[rIndex]; tIndex ++; rIndex ++; &#125; &#125; //将剩余数据加入到temp数组 //左边数组有剩 while (lIndex &lt;= mid) &#123; temp[tIndex] = arr[lIndex]; tIndex ++; lIndex ++; &#125; //右边数组有剩 while (rIndex &lt;= right) &#123; temp[tIndex] = arr[rIndex]; tIndex ++; rIndex ++; &#125; //改写arr数组数据 tIndex = 0; for (int i=left; i &lt;= right; i++) &#123; arr[i] = temp[tIndex]; tIndex ++; &#125; &#125;&#125; （2）测试代码12345678@Testpublic void mergeSortTest() &#123; int[] arr = new int[]&#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; MergeSort.asc(arr); System.out.println(Arrays.toString(arr));&#125; 8 基数排序8.1 介绍 基数排序（Radix Sort）：属于“分配式排序（Distribution Sort）”，又称为“桶子排序（bucket Sort）”。顾名思义，它通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的效果 基数排序是属于稳定性的排序，基数排序是效率高的稳定性排序法 基数排序是桶排序的拓展 实现方法，将整数按位数切割成不同的数字，然后按每个位数分别比较 算法思路：创建10个桶（负数19个），分别代表0, 1, 2, 3, 4, 5, 6, 7, 8, 9，对数组数据求个位数，将数据放入对应个位数的桶中，遍历完毕后按照顺序取出桶中数据放回数组中。下次就取十位数，下下次取百位数，以此类推，直到达到数据中最大位数为止 8.2 图解 8.3 代码 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class RadixSort &#123; /** * 基数排序 - 升序 * @param arr 待排序序列 */ public static void asc(int[] arr) &#123; int n = arr.length; //数组长度 int index; //数组下标 int[][] buckets = new int[19][n]; //定义桶（算上负数19个桶） int[] count = new int[19]; //记录桶中数据个数 int digit = 1; //位数倍数：个位数1，十位数10，百位数100，以次类推 int temp; //暂时变量 //遍历数组求出最大位数 int max = 0; for (int data : arr) &#123; //将数据取绝对值，转为字符串，求长度可得位数 int length = String.valueOf(Math.abs(data)).length(); if (length &gt; max) &#123; max = length; &#125; &#125; int times = 0; //记录循环次数 while (times &lt; max) &#123; //遍历数组存放数据 for (int data : arr) &#123; temp = data / digit % 10; //求位数 buckets[temp + 9][count[temp + 9]] = data; // +9为了跳过负数的9个桶，-9+9=0就放在0号位桶 count[temp + 9] ++; //桶中数据个数 + 1 &#125; //取出桶中数据放入原数组 index = 0; for (int i=0; i&lt;buckets.length; i++) &#123; //桶中数据不为0，取出数据覆盖原数组 if (count[i] &gt; 0) &#123; for (int j=0; j&lt;count[i]; j++) &#123; arr[index] = buckets[i][j]; index ++; &#125; count[i] = 0; //数据个数清0 &#125; &#125; digit *= 10; //修改位数倍数 times ++; //次数+1 &#125; &#125;&#125; （2）测试12345678@Testpublic void radixSortTest() &#123; int[] arr = new int[]&#123;132, 125, 43, -51, -72, -115&#125;; RadixSort.asc(arr); System.out.println(Arrays.toString(arr));&#125; 9 堆排序9.1 介绍 前提：堆排序的使用时需要数据结构-树的基础知识建议学完树形结构再来学习堆排序 堆：是具有一定性质的完全二叉树。 （1）每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆 （2）每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆 堆排序：利用堆来设计的一种排序算法，堆排序是一种选择排序（逐步选择最大/最小值进行处理）。最坏、最好、平均时间复杂度为O(nlogn)，属于不稳定排序。升序使用大顶堆，降序使用小顶堆 9.2 思路 （1）将待排序的序列构建成一个大顶堆（顺序存储二叉树） 形成大顶堆规则： 1、父节点跟子节点比较时从最后的父节点开始比较，逐步往前移 2、如果父节点与子节点发生交换后，判断交换后的子节点是否是父节点，如果是父节点，还要继续跟其子节点进行判断（因为会出现从顶部换一个很小的数给其子节点，而该子节点也是一个父节点，导致父节点&lt;子节点） （2）形成大顶堆后，顶部的根节点就是一个数组的最大值，将其与末尾元素进行交换，此时最大值已经确定了 （3）对剩余的n-1个树重复上面操作（构建大顶堆，交换最大值） 9.3 代码 （1）代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class HeapSort &#123; /** * 堆排序 - 升序 * @param arr 待排序数组 */ public static void asc(int[] arr) &#123; int arrLength = arr.length; //数组长度 int temp; //中间变量 //当数组比较个数 &lt;= 1结束循环 while (arrLength &gt; 1) &#123; //从最后一个父节点往前遍历（最后一个父节点为 n/2-1，前面的节点都是父节点） for(int i = arrLength/2-1; i &gt;= 0; i --) &#123; //实现父节点 &gt; 子节点 toLargeTop(arr, i, arrLength); &#125; //形成大顶堆后，根节点和数组末尾交换数据 temp = arr[arrLength-1]; arr[arrLength-1] = arr[0]; arr[0] = temp; //数组长度减一，排除最后已确定的数据 arrLength--; &#125; &#125; /** * 从上到下实现 父节点 &gt; 子节点 * @param arr 待排序数组 * @param parentIndex 父节点下标 * @param arrLength 数组长度 */ public static void toLargeTop(int[] arr, int parentIndex, int arrLength) &#123; int temp; //记录父节点大小 int childIndex = parentIndex * 2 + 1; //计算左子节点下标 while (childIndex &lt; arrLength) &#123; temp = arr[parentIndex]; //存在右子节点 且 右子节点&gt;左子节点 if (childIndex + 1 &lt; arrLength &amp;&amp; arr[childIndex] &lt; arr[childIndex + 1]) &#123; childIndex++; &#125; //比较子节点与父节点大小 if (arr[childIndex] &gt; arr[parentIndex]) &#123; arr[parentIndex] = arr[childIndex]; arr[childIndex] = temp; parentIndex = childIndex; //发生交换，父节点下标往下移，比较后面的子节点是否也要发生变化 &#125;else &#123; //没发生交换就退出循环 break; &#125; //重新计算子节点下标 childIndex = parentIndex * 2 + 1; &#125; &#125;&#125; （2）测试1234567@Testpublic void heapSortTest() &#123; int[] arr = new int[]&#123;1, 3, 20 ,11, 5&#125;; HeapSort.asc(arr); System.out.println(Arrays.toString(arr));&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】时间复杂度","slug":"【数据结构和算法】时间复杂度","date":"2021-04-30T02:43:33.000Z","updated":"2021-04-30T02:45:27.639Z","comments":true,"path":"2021/04/30/【数据结构和算法】时间复杂度/","link":"","permalink":"https://letere-gzj.github.io/2021/04/30/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"算法必须讨论的问题：时间复杂度，简单介绍时间复杂度以及其计算方法","text":"算法必须讨论的问题：时间复杂度，简单介绍时间复杂度以及其计算方法 1 算法时间复杂度1.1 介绍 时间复杂度：一个算法花费的时间与算法中语句的执行次数成正比，那个算法中语句执行次数多，它花费的时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为**T(n)**，n为方法调用次数 1.2 时间频度举例 计算：0~100的数字之和 123456789101112131415161718@Testpublic void test() &#123; //方法一 int count = 0; for (int i=0; i&lt;=100; i++) &#123; count += i; &#125; System.out.println(count); //时间频度：T(n) = n + 1 --- 方法执行了n+1 （100+1，额外1次是最后判断&gt;100跳出循环） //方法二： int start = 1; int end = 100; int total = (start + end) * end / 2; System.out.println(total); //时间频度为：T(n) = 1 --- 永远只执行1次&#125; 1.3 时间频度规则 （1）在次数项复杂度比较时，可会忽略常数项 例：2n+10 和 2n 差距不大，可以视为一样 （2）在幂次项复杂度比较时，可以忽略低次数项 例：n^3 + 3n 和 n^3 差距不大，可以视为一样 （3）在幂次项复杂度比较时，可以忽略系数 例：2n^3 和 n^3 差距不大，可以视为一样 1.4 时间复杂度 （1）一般情况下，算法中的基础操作语句的重复执行次数为用 T(n) 表示，若有某个辅助函数f(n)**，当n取余无穷大时，T(n) / f(n) 无限趋于0，称f(n)是T(n)的同量级函数。记左T(n) = O(f(n))**，O(f(n))为渐进时间复杂度，简称时间复杂度 （2）T(n)的不同，时间复杂度可能相同，也就是之前所讲的时间频度忽略规则。 例：T(n)=n^2+7n+6 和 T(n)=3n^3+2n+2 的时间复杂度都为O(n^2) （3）时间复杂度计算：f(n) = 时间频度的忽略规则，得出O(f(n)) 1.5 常见时间复杂度 时间复杂度从小到大，上图按从上到大排序 （1）常数阶 无论代码执行多少行，只要是没有循环等复杂结构，代码的时间复杂度都为O(1) （2）对数阶12345int i = 0;int n = 100;while(i &lt; n) &#123; i = i * 2;&#125; 在while循环里，每次都将i乘以2，乘完后，i举例n就越来越近，这种情况执行的次数就为log2(n)其他依次类推 （3）线性阶1234int n = 100;for (int i=0; i&lt;n; i++) &#123; System.out.println(&quot;hello&quot;);&#125; 代码在for循环执行，for循环多大，n就多大，用O(n)来表示 （4）线性对数阶1234567int n = 100;for (int m=0; m&lt;n; m++) &#123; int i = 0; while(i &lt; n) &#123; i = i * 2; &#125;&#125; 在对数阶的情况下，套一个for循环包围，变成线性对数阶 （5）平方阶 / 立方阶 / k次立方阶123456int n = 100;for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; System.out.println(&quot;hello&quot;); &#125;&#125; 平方阶就是多层for循环套用 1.6 其他时间复杂度 （1）平均时间复杂度 指所有可能的驶入实例均以等概率出现的情况下，该算法的运行时间 （2）最坏时间复杂度 时间复杂度最大的，称为最坏时间复杂度，一般讨论时间复杂度都围绕最坏时间复杂度讨论 （3）空间复杂度 即算法运行时消耗的空间大小，一般不做讨论，很多时候都是用空间来换时间","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】递归","slug":"【数据结构和算法】递归","date":"2021-04-29T09:30:19.000Z","updated":"2021-04-29T14:14:15.909Z","comments":true,"path":"2021/04/29/【数据结构和算法】递归/","link":"","permalink":"https://letere-gzj.github.io/2021/04/29/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E9%80%92%E5%BD%92/","excerpt":"简单介绍递归，并实现一些递归常见问题","text":"简单介绍递归，并实现一些递归常见问题 1 递归1.1 递归介绍 递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁 1.2 递归图解介绍 （1）简单递归代码123456789101112@Testpublic void recursionTest() &#123; test(3);&#125;public void test(int i) &#123; if(i &gt; 1) &#123; test(i-1); //自己调用自己 &#125; System.out.println(i);&#125; （2）实现步骤图解 1.3 递归应用场景 （1）8皇后问题 （2）汉诺塔 （3）阶乘问题 （4）迷宫问题 （5）球和篮子问题 （1）快速排序算法 （2）归并排序算啊 （3）二分查找 （4）分治算法 用栈解决的问题，可以用递归解决，代码相对简洁 1.4 递归规则 （1）执行一个方法时，就创建一个新的受抱回的独立空间（栈空间） （2）方法的局部变量是独立的，不会相互影响 （3）如果方法中使用的是引用类型变量，就会共享该应用类型的数据库 （4）递归必须向退出递归的条件逼近，否则就是无限递归 （5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 2 应用：迷宫问题2.1 问题 2.2 代码 （1）代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class Maze &#123; private int[][] maze; //迷宫 public Maze() &#123; //创建对象时，自动创建迷宫 createMaze(); &#125; /** * 创建迷宫（数组形式） * 1表示墙壁，0表示可移动空间 */ private void createMaze() &#123; maze = new int[8][7]; //上下创建围墙（设置为1） for(int i=0; i&lt;7; i++) &#123; maze[0][i] = 1; maze[7][i] = 1; &#125; //左右创建围墙（设置为1） for(int i=0; i&lt;8; i++) &#123; maze[i][0] = 1; maze[i][6] = 1; &#125; //中间墙壁（设置为1） maze[3][1] = 1; maze[3][2] = 1; &#125; /** * 查看迷宫 */ public void viewMaze() &#123; System.out.println(&quot;当前迷宫为：&quot;); for(int[] row : maze) &#123; for (int item : row) &#123; System.out.printf(&quot;%d\\t&quot;, item); &#125; System.out.println(); &#125; System.out.println(); &#125; /** * 判断是否能走 * @param i x * @param j y */ public boolean findWay(int i, int j) &#123; //假设[6, 5]为终点，到达终点，跳出递归 if (maze[6][5] == 2) &#123; System.out.println(&quot;**** 成功找到终点！ *****&quot;); viewMaze(); //查看迷宫 return true; &#125; //判断坐标是否可以行走 if(maze[i][j] == 0) &#123; //可以走，先将当前位置设置已走（2） maze[i][j] = 2; //再尝试向下走 if (findWay(i+1, j)) &#123; //接收到true返回值（找到终点），才跳出递归，下面类似 return true; &#125; //向下走不通，尝试向右走 if (findWay(i, j+1)) &#123; return true; &#125; //向下，向右走不通，尝试向上走 if (findWay(i-1, j)) &#123; return true; &#125; //向下，向右，向上走不通，尝试向左走 if (findWay(i, j-1)) &#123; return true; &#125; //若都走不通，设置为3，禁止向这格方法行走 maze[i][j] = 3; return false; &#125;else &#123; //不能走，返回false return false; &#125; &#125;&#125; （2）测试123456789@Testpublic void mazeTest() &#123; //创建迷宫，并查看迷宫 Maze maze = new Maze(); maze.viewMaze(); //从[1, 1]找路 maze.findWay(1, 1);&#125; 3 应用：八皇后问题3.1 问题 3.2 代码 （1）思路 从第一行第一个开始遍历，成功放了一个就往下一行继续从0号位遍历，直到不冲突，就继续遍历下一行 可以用八个for循环来解决，但是代码会十分的难看，且不易看懂 而用递归的形式，代码变得分成简洁 （2）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Queen8 &#123; int max = 8; //皇后数量，默认为8 int count = 1; //统计方法种数 int[] locations; //八皇后位置，以一维数组表示位置，index代表&#x27;行数&#x27;，index对应的数据代表&#x27;列数&#x27; public Queen8() &#123; locations = new int[max]; &#125; /** * 计算八皇后问题 * @param row 行号 */ public void getLocation(int row) &#123; //行号 === 行长度，位置计算完毕，打印并退出递归 if (row == max) &#123; print(); return; &#125; //遍历位置 for (int location=0; location&lt;max; location++) &#123; locations[row] = location; //判断位置是否冲突 if(!isConflict(row)) &#123; //没有冲突，递归下一行 getLocation(row+1); &#125; &#125; &#125; /** * 判断是否冲突 * @param row 行号 * @return boolean */ public boolean isConflict(int row) &#123; //循环遍历每行 for(int i=0; i&lt;row; i++) &#123; //当处于同一列，或同一条斜线（斜率为1，也理解为等腰直角三角形） if (locations[i] == locations[row] || row-i == Math.abs(locations[row] - locations[i])) &#123; return true; &#125; &#125; return false; &#125; /** * 打印结果 */ private void print() &#123; if (count &lt; 10) &#123; System.out.printf(&quot;第0%d种：&quot;, count); &#125;else &#123; System.out.printf(&quot;第%d种：&quot;, count); &#125; count++; for (int location : locations) &#123; System.out.printf(&quot;%d\\t&quot;, location); &#125; System.out.println(); &#125;&#125; （3）测试12345@Testpublic void queen8Test() &#123; Queen8 queen8 = new Queen8(); queen8.getLocation(0);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】栈","slug":"【数据结构和算法】栈","date":"2021-04-27T01:18:54.000Z","updated":"2021-04-29T01:15:52.912Z","comments":true,"path":"2021/04/27/【数据结构和算法】栈/","link":"","permalink":"https://letere-gzj.github.io/2021/04/27/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%A0%88/","excerpt":"数据结构中栈的使用","text":"数据结构中栈的使用 1 栈1.1 应用场景 计算器实现： 将一个数学算术字符串，例1+2*3+4/5，计算出来其正确结果来 底层的实现运用到了栈数据结构 其他场景： （1）子程序的调用：在跳往子程序前，会先将下一个指令的地址存储在栈中，直到子程序执行完后再讲地址取出，以回到原来的程序中 （2）处理递归调用：和子程序的调用类似，只是处理存储下一个指令的地址外，也将参数、区域变量等数据存入栈中 （3）表达式的转换（中缀表达式转后缀表达式）与求值 （4）二叉树的遍历 （5）图形的深度优先搜索法 1.2 介绍 栈的英文为Stack 栈是一个先进后出（FILO：First In Last Out）的有序列表 栈是限制线性表汇元素的插入与删除，只能在线性表的同一段进行的特殊线性表。允许添加与删除的一端，为栈顶（top），固定的另一端为栈底（Bottom） 1.3 代码实现 （1）思路 栈底为bottom，永远为0；栈顶为top，是当前数据的index + 1； 入栈：stack[top] = data； top++;，栈顶赋值，然后再移动栈顶 出栈：top--; data = stack[top];，栈顶先减一，移动到最新数据的index，在取出数据 满栈：top == size，栈顶等于栈的大小 空栈：top == bottom，栈顶 等于 栈底 （2）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ArrayStack &#123; private int size; //栈的大小 private int top; //栈顶（最新数据index + 1） private int bottom; //栈底（永远为0） private int[] stack; //栈 public ArrayStack(int size) &#123; this.size = size; stack = new int[size]; top = 0; bottom = 0; &#125; /** * 入栈 * @param data 数据 */ public void push(int data) &#123; //判断是否满栈 if(size == top) &#123; System.out.println(&quot;栈已满，无法添加数据&quot;); &#125;else &#123; stack[top++] = data; //先赋值，再top+1 &#125; &#125; /** * 出栈 * @return int */ public int pop() &#123; //判断是否空栈 if(top == bottom) &#123; System.out.println(&quot;栈为空，没有数据可取！&quot;); return 0; //暂时以0为取值失败 &#125; return stack[--top]; //先top-1，在返回数据 &#125; /** * 打印栈 */ public void print() &#123; if(top == bottom) &#123; System.out.println(&quot;栈为空！&quot;); &#125; int temp = top; System.out.println(&quot;数组栈为：&quot;); while (temp != bottom) &#123; temp--; System.out.println(stack[temp]); &#125; &#125;&#125; （3）测试12345678910111213@Testpublic void arrayStackTest() &#123; //1. 创建栈并入栈 ArrayStack stack = new ArrayStack(3); stack.push(1); stack.push(2); stack.push(3); stack.print(); //2. 出栈 stack.pop(); stack.print();&#125; 1.4 拓展：链表实现栈 由于链表的长度没有限制，可以无限添加，所以链表栈没有满栈的概念 （1）代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class LinkedListStack &#123; //节点类 private class Node &#123; public int data; public Node next; public Node(int data) &#123; this.data = data; &#125; @Override public String toString() &#123; return &quot;Node&#123; data = &quot; + data + &quot; &#125;&quot;; &#125; &#125; private Node headNode; //头节点 public LinkedListStack() &#123; headNode = new Node(0); &#125; /** * 入栈（头插法） * @param data 数据 */ public void push(int data) &#123; Node node = new Node(data); node.next = headNode.next; headNode.next = node; &#125; /** * 出栈（返回并删除第一个节点） */ public int pop() &#123; if(isEmpty()) &#123; System.out.println(&quot;error：栈为空，没有数据可取！&quot;); return 0; //暂时以0作为错误返回 &#125; Node temp = headNode.next; headNode.next = headNode.next.next; return temp.data; &#125; /** * 打印链表栈 */ public void print() &#123; if(isEmpty()) &#123; System.out.println(&quot;链表为空！&quot;); return; &#125; System.out.println(&quot;链表栈为：&quot;); Node temp = headNode.next; while (temp != null) &#123; System.out.println(temp); temp = temp.next; &#125; &#125; /** * 判断是否空栈 * @return boolean */ public boolean isEmpty() &#123; return headNode.next == null; &#125;&#125; （2）测试12345678910111213@Testpublic void linkedListStackTest() &#123; //1. 创建栈并入栈 LinkedListStack stack = new LinkedListStack(); stack.push(1); stack.push(2); stack.push(3); stack.print(); //2. 出栈 stack.pop(); stack.print();&#125; 2 计算器实现2.1 基础版（存在bug） （1）思路 创建两个栈，一个栈用来存数字，一个栈用来存字符 将字符串转为字符数组，然后遍历字符串 遍历到数字就加入数字栈 遍历到操作符，需要进行分析； 操作符栈为空，直接添加； 操作符优先级大于栈顶操作符的优先级，直接添加； 操作符优先级小于栈顶操作符的优先级，取出操作符栈顶数据，以及数字栈的两个数据，进行计算，将计算结果push回数字栈，然后才push要新增的操作符 遍历完毕后，取操作符进行计算，直到操作符栈为空，则数字栈的结果为最终结果 （2）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class Calculator &#123; private LinkedListStack numStack; //数字栈（自定义链表栈） private LinkedListStack operateStack; //操作符号栈（自定义链表栈） public Calculator() &#123; numStack = new LinkedListStack(); numStack.push(0); //防止表达式负数开头 operateStack = new LinkedListStack(); &#125; /** * 计算表达式并打印结果 * @param express 表达式 */ public void calculateExpress(String express) &#123; //字符串转字符数组 char[] chars = express.toCharArray(); //遍历字符数组进行入栈 for(char c : chars) &#123; //判断数字or操作符 if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; int i = Integer.parseInt(String.valueOf(c)); //字符数字为ascii值，需要转换整型 numStack.push(i); &#125;else &#123; pushOperateStack(c); &#125; &#125; //入栈完毕进行计算出栈 while (!operateStack.isEmpty()) &#123; char operate = (char) operateStack.pop(); int num1 = numStack.pop(); int num2 = numStack.pop(); int data = calculate(num1, num2, operate); numStack.push(data); &#125; //操作符栈为空，直接返回数字栈数据 System.out.printf(&quot;表达式的结果为：%d&quot;, numStack.pop()); &#125; /** * 往操作符栈进行入栈 * @param c 字符 */ private void pushOperateStack(char c) &#123; if (operateStack.isEmpty()) &#123; //栈为空，直接入栈 operateStack.push(c); &#125;else &#123; //栈非空，判断栈顶符号，与传入符号的优先级 char operate = (char) operateStack.pop(); if (getPriority(c) &gt; getPriority(operate)) &#123; // 优先级 &gt; 栈顶的操作符，入栈 operateStack.push(operate); operateStack.push(c); &#125;else &#123; // 优先级 &lt; 栈顶操作符， 计算栈顶，再入栈 int num1 = numStack.pop(); int num2 = numStack.pop(); int data = calculate(num1, num2, operate); numStack.push(data); operateStack.push(c); &#125; &#125; &#125; /** * 获取操作符的优先级 * @param c 操作符 * @return int */ public int getPriority(char c) &#123; switch (c) &#123; // + 和 - 优先级为 1 case &#x27;+&#x27;: case &#x27;-&#x27;: return 1; // * 和 / 优先级为 2 case &#x27;*&#x27;: case &#x27;/&#x27;: return 2; default: throw new RuntimeException(&quot;error：非法操作符！&quot;); &#125; &#125; /** * 数字计算 * @param num1 数字1 * @param num2 数字2 * @param operate 操作符 * @return int */ private int calculate(int num1, int num2, char operate) &#123; int data = 0; switch (operate) &#123; case &#x27;+&#x27;: data = num1 + num2; break; case &#x27;-&#x27;: data = num2 - num1; break; case &#x27;*&#x27;: data = num1 * num2; break; case &#x27;/&#x27;: if (num1 == 0) &#123; throw new RuntimeException(&quot;error：0不能作为分母！&quot;); &#125; data = num2 / num1; //暂时&#x27;/&#x27;以整型接受 &#125; return data; &#125;&#125; （3）测试12345@Testpublic void calculatorTest() &#123; Calculator calculator = new Calculator(); calculator.calculateExpress(&quot;3+2*6-2&quot;);&#125; （4）存在bug 只能计算个位数的数字，否则计算出错 负数计算存在一定的问题，例：-2*5-5，按道理是计算出-15，但是上述算法无法识别负号之间是相加的，直接变成10-5，然后再0-5，算出-5 2.2 改进版 （1）思路 多位数问题，可以定义一个中间变量，读取的是数字，就存在中间变量中，不立马入栈。直到读取到操作符时，再进行入数字栈。还有最后一个数字后面没有操作符，所以读取字符数组后，还要将中间变量进行入栈 减法问题：可以将减法改变为加法，加负数的形式 （2）bug解决1234567891011121314151617181920212223242526272829303132333435363738// //遍历字符数组进行入栈// for(char c : chars) &#123;// //判断数字or操作符// if(c &gt; &#x27;0&#x27; &amp;&amp; c &lt; &#x27;9&#x27;) &#123;// int i = Integer.parseInt(String.valueOf(c)); //字符数字为ascii值，需要转换整型// numStack.push(i);// &#125;else &#123;// pushOperateStack(c);// &#125;// &#125; //改进版 String temp = &quot;&quot;; for(char c : chars) &#123; //判断数字or操作符 if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; //在temp中存储字符，不立刻入栈，解决多位数问题 temp += c; &#125;else &#123; //入数字栈并清空temp if(temp != &quot;&quot;) &#123; numStack.push(Integer.parseInt(temp)); temp = &quot;&quot;; &#125; //如果是减法，转变成加法 +负数的形式 if (c == &#x27;-&#x27;) &#123; temp += &#x27;-&#x27;; c = &#x27;+&#x27;; &#125; pushOperateStack(c); &#125; &#125; //表达式最后的数字需要从temp中入数字栈 numStack.push(Integer.parseInt(temp)); 3 前中后缀表达式3.1 前缀表达式 3+4x5-6的前缀表达式为：- + x 4 5 3 6 操作符在前面，数字在后面 优先级高的操作符在后面，对应操作符参与运算的数字放前面 计算机扫描前序表达式为：从右到左， 例：所以数字依次进栈为[4 5 3 6]，读取到操作符x，就取数字栈前两个数字，4x5=20，将20放入数字栈[20 3 6]；依次类推，计算得出结果 3.2 中缀表达式 3+4x5-6的中缀表达式就是我们平时熟悉的表达式 3 + 4 x 5 - 6 我们前面的计算器的演示就是使用中缀表达式来完成 对于人来说很容易理解，但对于计算机来说不好理解，一般都是转变成后缀表达式进行计算 3.3 后缀表达式（逆波兰表达式） 3+4x5-6的后缀表达式为：3 4 5 x + 6 - 参与运算的两个数字放前面，操作符放后面 所以一步步得出4x5 = 4 5 x，3+4x5 = 3 4 5 x +，3+4*5-6 = 3 4 5 * + 6 - 计算机扫描后缀表达式为：从左到右，遇到数字就入栈，遇到操作符就计算数字栈前两个数字，再将计算的结果入栈 例：数字入栈[5 4 3]，遇到操作符x，去数字栈两数字计算5x4=20，再结果放回栈[20 3]，依次类推，计算出最终结果 3.4 中缀转后缀表达式 （1）创建两个栈，一个栈S1主要存数字（也会存运算符），另一个栈S2存运算符 （2）从左到右遍历中缀表达式 （3）读取到数字，则压入数字栈 （4）读取到非数字时，进行判断： 运算符栈S2为空，直接入栈 入栈运算符 &gt; 栈顶运算符，直接入栈 入栈运算符 &lt; 栈顶运算符，取出栈顶运算符并入栈到数字栈S1，在将运算符入栈S2 (，遇到左括号直接入栈 )，遇到右括号，将运算符号出栈S2，并入栈到数字栈S1，直到出栈的数据为(为止 （5）所有数据遍历完毕后，判断符号栈S2是否有数据，有就出栈并入栈到数字栈S1，直到空栈为止 4 逆波兰计算器 我们用中缀转后缀的形式，创建一个后缀表达式的计算器 （1）实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public class PolandCalculator &#123; /** * 中缀表达式转后缀表达式 * @param infixExpression 中缀表达式 * @return String */ public List&lt;String&gt; InfixToSuffix(String infixExpression) &#123; List&lt;String&gt; numStack = new ArrayList&lt;&gt;(); //数字栈（因为全程无需出栈，所以已一个集合来存储更方便） Stack&lt;Character&gt; operateStack = new Stack&lt;&gt;(); char[] chars = infixExpression.toCharArray(); if(chars[0] == &#x27;-&#x27;) &#123; //如果是负数开头，添加一个0入数字栈 numStack.add(String.valueOf(0)); &#125; //遍历 int count = 0; //记录第一个数字表示 String temp = &quot;&quot;; for (char c : chars) &#123; if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; temp += c; //中间变量解决多位数 &#125;else &#123; if(temp.length() != 0) &#123; //数字入栈 numStack.add(temp); temp = &quot;&quot;; &#125; //符号入栈 operatePush(operateStack, numStack, c); &#125; &#125; numStack.add(temp); //将最后的数字入栈 //操作符号栈非空，入栈到数字栈 while (!operateStack.empty()) &#123; numStack.add(String.valueOf(operateStack.pop())); &#125; return numStack; &#125; /** * 非数字符号入栈 * @param operateStack 运算符号栈 * @param numStack 数字栈（集合形式） * @param c 符号 */ public void operatePush(Stack&lt;Character&gt; operateStack, List&lt;String&gt; numStack, char c) &#123; String data; //栈为空 或 栈顶为&#x27;(&#x27; 或 入栈符号为&#x27;(&#x27; 直接入栈即可 if (operateStack.empty() || operateStack.peek() == &#x27;(&#x27; || c == &#x27;(&#x27;) &#123; operateStack.push(c); return; &#125; //入栈的为&#x27;)&#x27;，遍历出栈，并将出栈数据压入符号栈，直到出现&#x27;(&#x27;为止 if (c == &#x27;)&#x27;) &#123; while (operateStack.peek() != &#x27;(&#x27;) &#123; numStack.add(String.valueOf(operateStack.pop())); &#125; operateStack.pop(); //最后也要将&#x27;(&#x27;出栈 return; &#125; //非括号符号，比较优先级 if (getPriority(c) &gt; getPriority(operateStack.peek())) &#123; ; //入栈符号 &gt; 栈顶符号，直接入栈 operateStack.push(c); return; &#125;else &#123; //入栈符号 &lt;= 栈顶符号，出栈并压入数字栈 //栈不为空 并 入栈符号 &lt;= 栈顶符号 持续出栈 while (!operateStack.empty() &amp;&amp; getPriority(c) &lt;= getPriority(operateStack.peek())) &#123; numStack.add(String.valueOf(operateStack.pop())); &#125; operateStack.push(c); return; &#125; &#125; /** * 获取操作符优先级 * @param c 操作符 * @return int */ public int getPriority(char c) &#123; switch (c) &#123; // + 和 - 优先级为 1 case &#x27;+&#x27;: case &#x27;-&#x27;: return 1; // * 和 / 优先级为 2 case &#x27;*&#x27;: case &#x27;/&#x27;: return 2; default: throw new RuntimeException(&quot;error：非法操作符！&quot;); &#125; &#125; /** * 计算后缀表达式 * @param suffixExpression 后缀表达式 * @return Integer */ public Integer calSuffixExpression(List&lt;String&gt; suffixExpression) &#123; Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;(); //遍历元素 for (String item : suffixExpression) &#123; //正则表达式匹配数字 if (item.matches(&quot;\\\\d+&quot;)) &#123; //数字，入栈 numStack.push(Integer.valueOf(item)); &#125;else &#123; //非数字，计算结果，再入栈 Integer num1 = numStack.pop(); Integer num2 = numStack.pop(); //计算 Integer result = calculate(num1, num2, item); numStack.push(result); &#125; &#125; return numStack.pop(); &#125; /** * 数字计算 * @param num1 参数1 * @param num2 参数2 * @param operate 运算符 * @return Integer */ public Integer calculate(Integer num1, Integer num2, String operate) &#123; Integer result = null; //判断操作符，并进行相应计算 switch (operate) &#123; case &quot;+&quot;: result = num1 + num2; break; case &quot;-&quot;: result = num2 - num1; break; case &quot;*&quot;: result = num1 * num2; break; case &quot;/&quot;: result = num2 / num1; //暂时不考虑浮点型 break; default: throw new RuntimeException(&quot;error：非法操作符！&quot;); &#125; return result; &#125;&#125; （2）测试123456789101112131415@Testpublic void PolandCalculatorTest() &#123; //计算公式（中缀表达式） String ids = &quot;-(7-4)-5&quot;; //结果为-8 PolandCalculator polandCalculator = new PolandCalculator(); //中缀转后缀 List&lt;String&gt; strings = polandCalculator.InfixToSuffix(ids); System.out.println(strings); //计算后缀表达式 Integer integer = polandCalculator.calSuffixExpression(strings); System.out.println(integer);&#125; 此计算器大部分功能都能实现了，但还是有一些bug，例如：小数不能解决，括号内第一个数为负数会计算出错 此bug解决就不展开说了，中缀转后缀的思想学到了就足够了，有机会可以自行解决","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】环形链表","slug":"【数据结构和算法】环形链表","date":"2021-04-25T09:17:58.000Z","updated":"2021-04-25T09:24:59.251Z","comments":true,"path":"2021/04/25/【数据结构和算法】环形链表/","link":"","permalink":"https://letere-gzj.github.io/2021/04/25/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"关于链表的新三中形式，环形链表的介绍和代码实现","text":"关于链表的新三中形式，环形链表的介绍和代码实现 1 环形链表1.1 约瑟夫问题 约瑟夫（Josephu）问题： 设置编号为1，2，3…n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人开始报数，数到m个那个人出列，以此类推，直到所有人都出列，产生一个出队编号序列 解决问题：使用环形链表解决 1.2 单向环形链表 1.3 单向环形链表思路 （1）添加数据 创建两个变量，firstNode（第一个节点），curNode（当前最新节点） 第一次添加node时，firstNode指向该node，curnode也指向该node，node自身next指向自己形成环状 后续添加node时，curNode.next == node，node.next == firstNode，形成环状，并将curNode == node （2）遍历数据 创建临时node指向firstNode，依次next遍历数据，直到emp.next = first结束循环 1.4 单向环形代码实现 （1）代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SingleCircularLinkedList &#123; //单向节点类 private class Node &#123; public Object data; public Node next; public Node(Object data) &#123; this.data = data; &#125; @Override public String toString() &#123; return &quot;Node&#123; data = &quot; + data + &quot; &#125;&quot;; &#125; &#125; private Node firstNode; //第一个节点 private Node curNode; //最新一个节点 /** * 添加数据 * @param data 数据 */ public void add(Object data) &#123; Node node = new Node(data); //第一个数据firstNode 和 curNode需要特殊处理 if(firstNode == null) &#123; firstNode = node; &#125; if(curNode != null) &#123; curNode.next = node; &#125; node.next = firstNode; curNode = node; &#125; /** * 打印单向环形列表 */ public void print() &#123; Node temp = firstNode; if (temp == null) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; System.out.println(&quot;单向环形链表为：&quot;); do &#123; System.out.println(temp); temp = temp.next; &#125;while(temp != firstNode); &#125;&#125; （2）测试123456789@Testpublic void SingleCircularLinkedListTest() &#123; //1. 创建单向环形链表 SingleCircularLinkedList linkedList = new SingleCircularLinkedList(); linkedList.add(1); linkedList.add(2); linkedList.add(3); linkedList.print();&#125; 1.5 约瑟夫问题解决 （1）思路 （1）数数，即将firstNode 和 CurNode进行移动，移动m-1次，此时firstNode的位置为出队列位置 （2）出队列：接将节点删除，直接firstNode向后移（firstNode = firstNode.next），并curNode断开出列节点的指向（curNode.next = first） （2）代码实现123456789101112131415161718192021222324252627282930/** * 打印约瑟夫问题队列 * @param start 开始位置 * @param num 间隔 */public void josephuQueue(int start, int num) &#123; //移动位置 int count = 1; while(count != start) &#123; firstNode = firstNode.next; curNode = curNode.next; count ++; &#125; System.out.println(&quot;约瑟夫问题队列为：&quot;); while (curNode != firstNode) &#123; count = 1; //循环报数 while(count != num) &#123; firstNode = firstNode.next; curNode = curNode.next; count ++; &#125; //出列（删除节点并打印） System.out.println(firstNode); firstNode = firstNode.next; curNode.next = firstNode; &#125; System.out.println(firstNode);&#125; （3）测试1234567891011121314@Testpublic void SingleCircularLinkedListTest() &#123; //1. 创建单向环形链表 SingleCircularLinkedList linkedList = new SingleCircularLinkedList(); linkedList.add(1); linkedList.add(2); linkedList.add(3); linkedList.add(4); linkedList.add(5); linkedList.print(); //2. josephu问题 linkedList.josephuQueue(1, 2);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】双向链表","slug":"【数据结构和算法】双向链表","date":"2021-04-24T08:25:12.000Z","updated":"2021-04-24T08:29:22.754Z","comments":true,"path":"2021/04/24/【数据结构和算法】双向链表/","link":"","permalink":"https://letere-gzj.github.io/2021/04/24/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"关于双向链表的介绍以及代码实现","text":"关于双向链表的介绍以及代码实现 1 双向链表1.1 介绍 单向链表的对比： 单向链表查找的方向只能是一个方向，而双向链表可以向前或向后查找 单向链表不能自我删除，需要靠辅助接点，而双向链表则可以自我删除 1.2 思路 （1）新增节点 （2）删除节点 1.3 代码实现 双向链表的创建和单向链表的基本一致，只是部分对数据的修改方法要多写几步有所不同 （1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176public class DoubleLinkedList &#123; //双向链表节点类 private class DoubleNode &#123; public DoubleNode pre; //前一个节点 public Object data; //数据 public DoubleNode next; //后一个节点 public DoubleNode(Object data) &#123; this.data = data; &#125; @Override public String toString() &#123; return &quot;DoubleNode&#123; data = &quot; + data + &quot; &#125;&quot;; &#125; &#125; private DoubleNode headNode; //头结点 public DoubleLinkedList() &#123; this.headNode = new DoubleNode(null); &#125; /** * 添加数据（尾插） * @param data 数据 */ public void add(Object data) &#123; DoubleNode temp = headNode; while(temp.next != null) &#123; temp = temp.next; &#125; //尾插 DoubleNode newNode = new DoubleNode(data); temp.next = newNode; newNode.pre = temp; &#125; /** * 插入数据（节点间插） * @param data 数据 * @param index 下标 */ public void addByIndex(Object data, int index) &#123; DoubleNode temp = headNode.next; //检验数据合法性 if (index &lt; 0 || index &gt; getSize()) &#123; System.out.println(&quot;error：Index越界，请重新去确认index大小！&quot;); return; &#125; //index等于链表长度，直接尾插 if(index == getSize()) &#123; add(data); return; &#125; int count = 0; while (count != index) &#123; temp = temp.next; count ++; &#125; //节点间插 DoubleNode newNode = new DoubleNode(data); temp.pre.next = newNode; newNode.pre = temp.pre; newNode.next = temp; temp.pre = newNode; &#125; /** * 修改数据 * @param data 数据 * @param index 下标 */ public void updateByIndex(Object data, int index) &#123; DoubleNode temp = headNode.next; if(temp == null) &#123; System.out.println(&quot;链表为空！&quot;); return; &#125; //数据合法性校验 if(index &lt; 0 || index &gt; getSize()-1) &#123; System.out.println(&quot;error：Index数据不合法，请重新确认index的大小！&quot;); return; &#125; int count = 0; while (count != index) &#123; count ++; temp = temp.next; &#125; //修改数据 temp.data = data; &#125; /** * 删除数据 * @param index 下标 */ public void deleteByIndex(int index) &#123; DoubleNode temp = headNode.next; //空链表判断 if(temp == null) &#123; System.out.println(&quot;error：链表为空！&quot;); return; &#125; //数据合法校验 if(index &lt; 0 || index &gt; getSize()-1) &#123; System.out.println(&quot;error：index数据不合法，请重新确认Index的大小！&quot;); return; &#125; int count = 0; while(count != index) &#123; count ++; temp = temp.next; &#125; //删除数据（注意删除最后一个数据引发空指针） temp.pre.next = temp.next; if(temp.next != null) &#123; temp.next.pre = temp.pre; &#125; &#125; /** * 打印双向链表 */ public void print() &#123; DoubleNode temp = headNode.next; if(temp == null) &#123; System.out.println(&quot;链表为空！&quot;); return; &#125; System.out.println(&quot;双向链表为：&quot;); int count = 0; while(temp != null) &#123; System.out.print(count + &quot; - &quot;); System.out.println(temp); temp = temp.next; count ++; &#125; &#125; /** * 获取双向链表大小 * @return int */ public int getSize() &#123; DoubleNode temp = headNode.next; if(temp.next == null) &#123; return 0; &#125; int count = 0; while(temp != null) &#123; count ++; temp = temp.next; &#125; return count; &#125;&#125; （2）测试1234567891011121314151617181920@Testpublic void doubleLinkedListTest() &#123; //1.创建双向链表并插入数据 DoubleLinkedList linkedList = new DoubleLinkedList(); linkedList.add(&quot;hello&quot;); linkedList.add(&quot;world&quot;); linkedList.print(); //2. 节点间插入数据 linkedList.addByIndex(&quot;-&quot;, 1); linkedList.print(); //3. 修改数据 linkedList.updateByIndex(&quot;!~!&quot;, 1); linkedList.print(); //4. 删除数据 linkedList.deleteByIndex(1); linkedList.print();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】单链表","slug":"【数据结构和算法】单链表","date":"2021-04-23T10:14:02.000Z","updated":"2021-04-24T04:13:11.236Z","comments":true,"path":"2021/04/23/【数据结构和算法】单链表/","link":"","permalink":"https://letere-gzj.github.io/2021/04/23/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"关于数据结构中链表的介绍和代码实现","text":"关于数据结构中链表的介绍和代码实现 1 单链表1.1 介绍 （1）链表是以节点的方式来存储 （2）每个节点包含data域，next域 （3）链表各个节点之间未必是连续的 （4）链表分带头节点的链表和没有头结点的链表，根据实际的需求来确定 1.2 思路 （1）链表新增数据 尾插法：循环遍历链表，找到结点.next == null的节点，即尾节点，在尾节点插入数据 在链表节点之间插入：找到要插入位置的前一个节点，将前一节点.next指向插入数据，将插入数据.next指向原来位置的节点 （2）删除链表的数据 找到要删除位置的前一个节点，将前一个节点.next == 删除结点.next ，Java的垃圾回收机制，会自动收回没有被指向的节点 1.3 代码实现 以下例子是手写的一个单链表类，提供增，删，改的操作 （1）创建单链表类和子类节点类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class SingleLinkedList &#123; //创建子类Node节点 private class Node &#123; public String data; //数据 public Node next; //下一个节点 public Node(String data) &#123; this.data = data; &#125; @Override public String toString() &#123; return &quot;Node&#123; data = &quot; + data + &quot; &#125;&quot;; &#125; &#125; private Node headNode; //头结点 //构造对象时，自动创建头结点 public SingleLinkedList() &#123; headNode = new Node(&quot;&quot;); &#125; /** * 链表添加数据（尾插法） * @param data 数据 */ public void addData(String data) &#123; //设置中间变量，避免修改头结点 Node temp = headNode; //循环遍历找到尾结点（next==null） while(temp.next != null) &#123; temp = temp.next; &#125; //尾结点的next插入新增结点 temp.next = new Node(data); &#125; /** * 在指定下标插入链表数据 * @param data 数据 * @param index 下标 */ public void addDataByIndex(String data, int index) &#123; Node temp = headNode.next; if(temp == null &amp;&amp; index != 0) &#123; System.out.println(&quot;error：链表为空，index只能从0号位置插入数据！&quot;); return; &#125; if(index &gt; getSize()) &#123; System.out.println(&quot;error：index越界，请重新确认index的大小！&quot;); return; &#125; if(index != 0) &#123; //循环遍历，找到指定Index前一个Node int count = 0; while(count != index-1) &#123; temp = temp.next; count ++; &#125; &#125;else &#123; temp = headNode; &#125; //插入Node，修改链表的指向（node的next结点继承前一个节点temp的next，temp的next指向node） Node node = new Node(data); node.next = temp.next; temp.next = node; &#125; /** * 通过index更新链表结点 * @param data 数据 * @param index 下标 */ public void updateDataByIndex(String data, int index) &#123; Node temp = headNode.next; if(temp == null) &#123; System.out.println(&quot;error：链表为空，没有数据可改！&quot;); return; &#125; if(index &gt; getSize()-1) &#123; System.out.printf(&quot;error：index越界，链表的长度为%d，请重新确认index大小！\\n&quot;, getSize()); return; &#125; //找出结点，并修改数据 int count = 0; while (count != index) &#123; temp = temp.next; count ++; &#125; temp.data = data; &#125; /** * 通过index删除结点 * @param index 下标 */ public void deleteDataByIndex(int index) &#123; Node temp = headNode.next; if(temp == null) &#123; System.out.println(&quot;error：链表为空，没有数据可删！&quot;); return; &#125; if(index &gt; getSize()-1) &#123; System.out.printf(&quot;error：index越界，链表的长度为%d，请重新确认index大小！\\n&quot;, getSize()); return; &#125; int count = 0; if(index == 0) &#123; temp = headNode; &#125;else &#123; while(count != index-1) &#123; temp = temp.next; count ++; &#125; &#125; //修改结点指向，删除结点 temp.next = temp.next.next; &#125; /** * 打印单链表 */ public void printLinkedList() &#123; Node temp = headNode.next; if(temp == null) &#123; System.out.println(&quot;链表为空！&quot;); return; &#125; System.out.println(&quot;单链表为：&quot;); int count = 0; while(temp != null) &#123; System.out.print(count + &quot; - &quot;); System.out.println(temp); count ++; temp = temp.next; &#125; &#125; /** * 获取链表的大小（不算头结点） * @return int */ public int getSize() &#123; Node temp = headNode.next; if(temp == null) &#123; return 0; &#125; int count = 0; while(temp != null) &#123; count ++; temp = temp.next; &#125; return count; &#125;&#125; （2）测试1234567891011121314151617181920@Testpublic void SingleLinkedListTest() &#123; //1、创建单链表并添加数据 SingleLinkedList linkedList = new SingleLinkedList(); linkedList.addData(&quot;hello&quot;); linkedList.addData(&quot;world&quot;); linkedList.printLinkedList(); //2、插入测试（节点间插入） linkedList.addDataByIndex(&quot; - &quot;, 1); linkedList.printLinkedList(); //3、修改测试 linkedList.updateDataByIndex(&quot;Java&quot;, 2); linkedList.printLinkedList(); //4、删除测试 linkedList.deleteDataByIndex(1); linkedList.printLinkedList();&#125; 2 面试题2.1 查找单链表中倒数第k个节点 思路：找出所有有效节点的个数，减去k，得到节点的下标，通过该下标获取节点即可 （1）代码实现123456789101112131415161718192021222324252627282930/** * 逆序获取数据（取出倒数数据） * @param index 下标 */public void getDataByReverseIndex(int index) &#123; Node temp = headNode.next; //空链表判断 if(temp == null) &#123; System.out.println(&quot;链表为空，没有数据可取！&quot;); return; &#125; //获取链表长度（方法在前面写好，就直接拿来用） int size = getSize(); //数据合法检验 if(index &lt; 1 || index &gt; size) &#123; System.out.println(&quot;数据不合法，请重新确认index的大小！&quot;); return; &#125; //遍历找出相同下标节点 int count = 0; while(count != size - index) &#123; temp = temp.next; count ++; &#125; System.out.println(temp);&#125; （2）测试1234567891011@Testpublic void SingleLinkedListTest() &#123; //1、创建单链表并添加数据 SingleLinkedList linkedList = new SingleLinkedList(); linkedList.addData(&quot;hello&quot;); linkedList.addData(&quot;world&quot;); linkedList.printLinkedList(); //2.取倒数第1个节点测试 linkedList.getDataByReverseIndex(1);&#125; 2.2 单链表反转 思路： 自己创建一个新的头结点reverseHead 遍历原来的链表，每遍历一个节点，就在reverseHead的链表中插入数据（头插法），即从第一个位置插入数据，操作方法和节点间插入数据一致 遍历完毕后，就将原来链表的头结点.next == reverseHead.next来修改链表指向 （1）代码实现12345678910111213141516171819202122232425262728293031323334/** * 反转单链表 */public void reverseLinkedList() &#123; //创建反转头结点 Node reverseHead = new Node(&quot;&quot;); Node temp = headNode.next; //判断空链表 if(temp == null) &#123; System.out.println(&quot;链表为空，没有数据可以反转！&quot;); return; &#125; //链表节点是否只有一个（一个不需反转） if (temp.next.next == null) &#123; return; &#125; //遍历原来节点，并插入（头插法） while(temp != null) &#123; //将节点取出，并后移（避免原链表断链） Node reverseTemp = temp; temp = temp.next; //头插法（节点间插入） reverseTemp.next = reverseHead.next; reverseHead.next = reverseTemp; &#125; //修改头结点的next headNode.next = reverseHead.next;&#125; （2）测试123456789101112@Testpublic void SingleLinkedListTest() &#123; //1、创建单链表并添加数据 SingleLinkedList linkedList = new SingleLinkedList(); linkedList.addData(&quot;hello&quot;); linkedList.addData(&quot;world&quot;); linkedList.printLinkedList(); //2. 链表反转 linkedList.reverseLinkedList(); linkedList.printLinkedList();&#125; 2.3 逆序打印 思路 第一种：可以向链表逆序，再进行打印，再逆序回来，变回原表（不推荐） 第二种：可以使用递归来实现，递归跳出条件为节点为空 第三种：使用栈来实现，栈的效果就是先进后出（后面详细讲，暂时使用API来实现栈） （1）递归实现12345678910111213141516171819202122232425262728293031323334353637/** * 通过递归逆序打印 */public void reversePrintByRecursion() &#123; Node temp = headNode.next; if(temp == null) &#123; System.out.println(&quot;链表为空！&quot;); return; &#125; //递归 System.out.println(&quot;逆序链表为：&quot;); int count = 0; recursion(temp, count);&#125;/** * 逆序递归主要实体 * @param temp 结点 * @param count 下标 * @return int */private int recursion(Node temp, int count) &#123; //递归跳出条件 if(temp == null) &#123; return count; &#125; //递归 count = recursion(temp.next, count); //打印 System.out.print(count + &quot; - &quot;); System.out.println(temp); return ++count;&#125; （2）递归测试1234567891011@Testpublic void SingleLinkedListTest() &#123; //1、创建单链表并添加数据 SingleLinkedList linkedList = new SingleLinkedList(); linkedList.addData(&quot;hello&quot;); linkedList.addData(&quot;world&quot;); linkedList.printLinkedList(); //2. 逆序打印 linkedList.reversePrintByRecursion();&#125; （3）栈实现12345678910111213141516171819202122232425262728293031/** * 用栈实现逆序打印 */public void reversePrintByStack() &#123; Node temp = headNode.next; //判断空链表 if (temp == null) &#123; System.out.println(&quot;链表为空！&quot;); return; &#125; //引入java.util.Stack来用栈（官方包） Stack&lt;Node&gt; nodeStack = new Stack&lt;&gt;(); //入栈 while (temp != null) &#123; nodeStack.add(temp); temp = temp.next; &#125; //出栈打印 System.out.println(&quot;逆序单链表为：&quot;); int count = 0; while (nodeStack.size() &gt; 0) &#123; System.out.print(count + &quot; - &quot;); Node popNode = nodeStack.pop(); System.out.println(popNode); count ++; &#125;&#125; （4）栈测试1234567891011@Testpublic void SingleLinkedListTest() &#123; //1、创建单链表并添加数据 SingleLinkedList linkedList = new SingleLinkedList(); linkedList.addData(&quot;hello&quot;); linkedList.addData(&quot;world&quot;); linkedList.printLinkedList(); //2. 逆序打印 linkedList.reversePrintByStack();&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】队列","slug":"【数据结构和算法】队列","date":"2021-04-23T02:32:21.000Z","updated":"2021-04-23T07:00:09.849Z","comments":true,"path":"2021/04/23/【数据结构和算法】队列/","link":"","permalink":"https://letere-gzj.github.io/2021/04/23/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E9%98%9F%E5%88%97/","excerpt":"数据结构之队列的介绍和代码实现","text":"数据结构之队列的介绍和代码实现 1 队列1.1 介绍 队列是一个有序列表，可以用数组或是链表来实现 遵循先入先出的原则，即：先存入队列的数据，要先取出；后存入队列的数据，要后取出。 1.2 思路 队列添加数据：rear队尾往后移，+1 队列取出数据：font队头往后移，+1 队列为空：font == rear 队列已满：rear == 数组大小 1.3 简单代码实现 （1）创建队列类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class NormalQueue &#123; private int size; //队列长度 private int font; //队头 private int rear; //队尾 private int[] queue; //队列 public NormalQueue(int size) &#123; this.size = size; queue = new int[size]; font = -1; rear = -1; &#125; /** * 向队列添加数据 * @param data 数据 */ public void addData(int data) &#123; if(rear == size-1) &#123; System.out.println(&quot;队列已满，不能添加数据！&quot;); &#125;else &#123; rear ++; queue[rear] = data; &#125; &#125; /** * 从获取队列数据 * @return int */ public int getData() &#123; if(font == rear) &#123; System.out.println(&quot;队列为空，没有数据可取！&quot;); return 0; &#125;else &#123; font ++; return queue[font]; &#125; &#125; /** * 打印队列 */ public void printQueue() &#123; if(font != rear) &#123; System.out.println(&quot;当前队列为：&quot;); for(int i = font + 1; i&lt;= rear; i++) &#123; System.out.println(queue[i]); &#125; &#125;else &#123; System.out.println(&quot;队列为空！&quot;); &#125; &#125;&#125; （2）测试 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; //简单队列测试 //1、创建队列 NormalQueue normalQueue = new NormalQueue(3); //2、测试打印空队列 System.out.println(&quot;----测试打印空队列----&quot;); normalQueue.printQueue(); //3、添满队列 normalQueue.addData(1); normalQueue.addData(2); normalQueue.addData(3); System.out.println(&quot;----打印满队列数据----&quot;); normalQueue.printQueue(); //4、测试队列已满添加数据 System.out.println(&quot;----测试队列已满添加数据----&quot;); normalQueue.addData(4); //5、测试取出数据后队列变化 System.out.println(&quot;----取出数据后的队列----&quot;); normalQueue.getData(); normalQueue.printQueue(); //6、取出数据后再次添加数据 System.out.println(&quot;--取出数据后再次添加数据--&quot;); normalQueue.addData(4);&#125; 1.4 个人环形队列代码实现 此环形队列的实现为个人思路，非官方标准答案 我们可以新增一个变量来记录空数据的个数，如果个数为0，就表示数据已满，不能插入；个数不为0，则可以插入 （1）创建环形队列类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class CircularQueue &#123; private int size; //队列大小 private int emptyCount; //空数据个数 private int font; //队头 private int rear; //队尾 private int[] queue; //队列 public CircularQueue(int size) &#123; this.size = size; emptyCount = size; font = -1; rear = -1; queue = new int[size]; &#125; /** * 向队列添加数据 * @param data 数据 */ public void addData(int data) &#123; if(emptyCount == 0) &#123; System.out.println(&quot;队列已满，不能添加数据！&quot;); &#125;else &#123; //判断队尾是否移动到数组尾部，是就将其设置回数组头部 if(rear == size-1) &#123; rear = 0; &#125;else &#123; rear ++; &#125; emptyCount --; //空数据-1 queue[rear] = data; &#125; &#125; /** * 从队列中获取数据 * @return int */ public int getData() &#123; if(emptyCount == size) &#123; System.out.println(&quot;队列为空，没有数据可取！&quot;); return 0; &#125;else &#123; //判断队头是否移动到数组尾部，是就将其设置回数组头部 if(font == size-1) &#123; font = 0; &#125;else &#123; font ++; &#125; emptyCount ++; //空数据+1 return queue[font]; &#125; &#125; /** * 打印队列 */ public void printQueue() &#123; //判断是否为空 if(emptyCount != size) &#123; //比较队头和队尾的值 if(font &lt; rear) &#123; //队头&lt;队尾，队列在(队头，队尾]之间 System.out.println(&quot;当前队列为：&quot;); for (int i=font+1; i&lt;=rear; i++) &#123; System.out.println(queue[i]); &#125; &#125;else&#123; //队头&gt;=队尾，队列在(队头, size) 和 [0, rear]之间 System.out.println(&quot;当前队列为：&quot;); for(int i=font+1; i&lt;size; i++) &#123; System.out.println(queue[i]); &#125; for (int i=0; i&lt;=rear; i++) &#123; System.out.println(queue[i]); &#125; &#125; &#125;else &#123; System.out.println(&quot;队列为空！&quot;); &#125; &#125;&#125; （2）测试1234567891011121314public static void main(String[] args) &#123; //环形队列测试（重点测试取出数据后，再添加数据） //1、创建环形队列并添满数据 CircularQueue circularQueue = new CircularQueue(3); circularQueue.addData(1); circularQueue.addData(2); circularQueue.addData(3); circularQueue.printQueue(); //2、取出数据再添加 circularQueue.getData(); circularQueue.addData(4); circularQueue.printQueue();&#125; 1.5 标准环形队列代码实现 （1）思路 取模（取余数），我们希望队头/队尾到达数组底部的时候通过取数组大小的余数返回数组开头 将队头指向该为第一个数据的下标，将队尾指向最后一个数据的下标+1 但取模会出现一个问题，即0 % 任何数都为0，所以我们取余数时要 + 1，来避开0，所以整体大小+1 队列中数据个数：(rear + size - font) % size 队列满条件：(rear + size - font ) % size == size，可以简化为(rear + 1) % size == font 队列为空条件：font == rear （2）实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class CircularQueue &#123; private int size; //队列长度（比输入个数多1长度作为预留空间） private int font; //队首（第一个元素index） private int rear; //队尾（最后一个元素index+1） private int[] queue; //队列（创建时多创一个空间作预留） public CircularQueue(int size) &#123; this.size = size + 1; font = 0; rear = 0; queue = new int[size + 1]; &#125; /** * 向队列添加数据 * @param data 数据 */ public void addData(int data) &#123; if((rear+1)%size == font) &#123; System.out.println(&quot;队列已满，无法添加数据！&quot;); &#125;else &#123; queue[rear] = data; rear = (rear+1) % size; &#125; &#125; /** * 从队列中取出数据 * @return int */ public int getData() &#123; if((font == rear)) &#123; System.out.println(&quot;队列为空，没有数据可取！&quot;); return 0; &#125;else &#123; int data = queue[font]; font = (font + 1) % size; return data; &#125; &#125; /** * 打印队列 */ public void printQueue() &#123; if(font == rear) &#123; System.out.println(&quot;队列为空！&quot;); &#125;else &#123; System.out.println(&quot;当前队列为：&quot;); for(int i=font; i &lt; font + (rear + size - font) % size; i++) &#123; System.out.println(queue[i % size]); &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】稀疏数组","slug":"【数据结构和算法】稀疏数组","date":"2021-04-22T14:57:48.000Z","updated":"2021-04-23T10:08:18.688Z","comments":true,"path":"2021/04/22/【数据结构和算法】稀疏数组/","link":"","permalink":"https://letere-gzj.github.io/2021/04/22/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/","excerpt":"稀疏数组的介绍和代码实现","text":"稀疏数组的介绍和代码实现 1 稀疏数组（SparseArray）1.1 应用场景引入 问题发现： 保存的二维数组有很多值是0，是没有意义的数据 有效利用二维数组有用数据，减少无用数据，就可以使用稀疏数组 1.2 介绍 当一个数组大部分元素为0，或者是同一个值的时候，可以使用稀疏数组来保存该数组 处理方法： 记录数组一共几行几列，有多少不同的值 把具有不同值的元素的行和列记录在一个小规模的数组中，从而缩小程序的规模 1.3 代码实现 （1）实现思路 二维数组转稀疏数组 1、遍历二维数组，获取有效数据总数sum 2、创建大小为[sum][3]的二维数组，作为稀疏数组 3、将有效的数据存入到稀疏数组中 系数数组转二维数组 1、读取稀疏数组第一行，创建二维数组 2、读取后几行数据的位置和值，存入到二维数组中 （2）二维数组转稀疏数组12345678910111213141516171819202122232425262728293031323334public static int[][] arrayToSparseArray(int [][] array) &#123; //1. 遍历二维数组，获取不同值的大小 int sum = 0; int row = array.length; int column = array[0].length; for(int i=0; i&lt;row; i++) &#123; for(int j=0; j&lt;column; j++) &#123; if(array[i][j] != 0) &#123; sum ++; &#125; &#125; &#125; //2. 创建二维数组[sum+1][3]作为稀疏数组 int[][] sparseArray = new int[sum+1][3]; sparseArray[0][0] = row; sparseArray[0][1] = column; sparseArray[0][2] = sum; //3. 再次遍历存储数据 int count = 1; for(int i=0; i&lt;row; i++) &#123; for(int j=0; j&lt;column; j++) &#123; if(array[i][j] != 0) &#123; sparseArray[count][0] = i; sparseArray[count][1] = j; sparseArray[count][2] = array[i][j]; count++; &#125; &#125; &#125; return sparseArray;&#125; （3）稀疏数组转二维数组1234567891011121314151617181920/** * 稀疏数组 转 二维数组 * @param sparseArray 稀疏数组 * @return int[][] */public int[][] sparseArrayToArray(int[][] sparseArray) &#123; //1. 读取稀疏数组第0行数据，创建二维数组 int row = sparseArray[0][0]; int column = sparseArray[0][1]; int[][] array = new int[row][column]; //2. 读取稀疏数组剩余行，向二维数组插入数据 for(int i=1; i&lt;array.length; i++) &#123; row = sparseArray[i][0]; column =sparseArray[i][1]; array[row][column] = sparseArray[i][2]; &#125; return array;&#125; （4）测试12345678910111213141516171819202122232425262728/** * 打印二维数组 * @param array 二维数组 */public static void printArray(int[][] array) &#123; for (int[] row : array) &#123; for (int data : row) &#123; System.out.printf(&quot;%d\\t&quot;, data); &#125; System.out.println(); &#125;&#125;//测试public static void main(String[] args) &#123; int[][] array = new int[10][12]; array[1][2] = 2; array[2][3] = 4; int[][] sparseArray = arrayToSparseArray(array); System.out.println(&quot;二维数组：&quot;); printArray(array); System.out.println(&quot;稀疏数组：&quot;); printArray(sparseArray);&#125; 1.4 拓展 （1）将稀疏数组存放在磁盘123456789101112131415161718192021222324252627282930313233343536/** * 将稀疏数组写入磁盘 * @param sparseArray 稀疏数组 */public static void sparseArrayWrite(int[][] sparseArray, String fileName) &#123; //1. 创建文件写入流 FileWriter fw = null; try &#123; fw = new FileWriter(fileName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //2. 将稀疏数组转为String String stringData = &quot;&quot;; for(int[] row : sparseArray) &#123; for(int data : row) &#123; stringData += data + &quot; &quot;; &#125; stringData += &quot;\\n&quot;; &#125; //3. 写入磁盘 try &#123; fw.write(stringData); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //4. 关闭流 try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; （2）从磁盘中读取稀疏数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 读取稀疏数组 * @param fileName 文件名（含路径） * @return int[][] */public static int[][] sparseArrayRead(String fileName) &#123; //1. 创建文件读取流 File file = new File(fileName); FileReader fr = null; try &#123; fr = new FileReader(file); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; //2. 读取文件获取数据 char[] chars = new char[(int)file.length()]; try &#123; fr.read(chars); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String stringData = String.valueOf(chars); //3. 创建稀疏数组 String[] rows = stringData.split(&quot;\\n&quot;); int[][] sparseArray = new int[rows.length][3]; //4. 插入数据 int count = 0; for(String row : rows) &#123; String[] data = row.split(&quot; &quot;); sparseArray[count][0] = Integer.parseInt(data[0]); sparseArray[count][1] = Integer.parseInt(data[1]); sparseArray[count][2] = Integer.parseInt(data[2]); count++; &#125; //5.关闭流 try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sparseArray;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【数据结构和算法】数据结构入门","slug":"【数据结构和算法】数据结构入门","date":"2021-04-22T14:55:57.000Z","updated":"2021-04-22T14:57:16.528Z","comments":true,"path":"2021/04/22/【数据结构和算法】数据结构入门/","link":"","permalink":"https://letere-gzj.github.io/2021/04/22/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/","excerpt":"数据结构和算法简单介绍","text":"数据结构和算法简单介绍 1 数据结构与算法1.1 关系 （1）数据结构是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更加漂亮，更有效率的代码 （2）程序 = 数据结构 + 算法 （3）数据结构是算法的基础，换言之，想要学好算法，需要把数据结构学到位 1.2 数据结构分类 （1）线性结构： 包括：数组，队列，链表和，栈 特点为数据元素之间存在一对一的线性关系 线性结构又分为两种不同的存储结构，顺序结构和链式存储结构 顺序结构：存储的线性表为顺序表，存储的元素时连续的 链式存储结构：存储的线性表为链表，存储元素不一定连续，元素节点中存放数据元素以及相邻元素的地址信息 （2）非线性结构 包括：二维数组，多维数组，广义表，树结构，图结构","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【MybatisPlus】逻辑删除&自动填充&IDEA插件","slug":"【MybatisPlus】逻辑删除-自动填充-IDEA插件","date":"2021-04-21T14:52:52.000Z","updated":"2021-04-21T14:55:34.819Z","comments":true,"path":"2021/04/21/【MybatisPlus】逻辑删除-自动填充-IDEA插件/","link":"","permalink":"https://letere-gzj.github.io/2021/04/21/%E3%80%90MybatisPlus%E3%80%91%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-IDEA%E6%8F%92%E4%BB%B6/","excerpt":"逻辑删除，自动填充，IDEA插件整合笔记","text":"逻辑删除，自动填充，IDEA插件整合笔记 1 逻辑删除1 介绍 所谓逻辑删除，即不是真正在数据库中对数据进行删除，而是通过一个字段控制该数据的状态，来表示是否已删除 MybatisPlus的逻辑删除操作，实际是替换sql，将所有delete相关的sql，更改为update，来修改删除状态 将所有的select后面都拼接一个where deleteflag = 未删除状态，来查询未删除的数据 2 逻辑删除开启 （1）修改数据库表，添加表示删除状态的字段12alter table useradd column delete_flag int default 0 （2）实体类添加相应属性1234567891011@Datapublic class User &#123; @TableId(type = IdType.AUTO) private Integer id; private String name; private Integer age; private String email; @TableLogic //mybatis-plus3.3.0以上可以省略 private int deleteFlag;&#125; （3）配置yaml开启逻辑删除123456mybatis-plus: global-config: db-config: logic-delete-field: deleteFlag #逻辑删除实体类属性名 logic-delete-value: 1 #删除状态值 logic-not-delete-value: 0 #未删除状态值 （4）测试123456789101112131415@SpringBootTestpublic class SpringMPTest &#123; @Autowired private UserMapper userMapper; @Test public void logicDeleteTest() &#123; //删除测试 userMapper.deleteById(1); //查询测试 userMapper.selectList(null); &#125;&#125; 2 自动填充2.1 介绍 有时候，我们希望我们的sql的某些字段不用传参，也能自动补充参数，执行插入或更新操作 而MybatisPlus提供了自动填充功能，为了我们定义的字段，自动补充参数 我们也可以在创建表字段的时候设置默认值来达到此效果 2.2 使用 （1）新增数据库表字段1234567# 添加时间字段alter table useradd column create_time datetimealter table useradd column update_time datetime （2）实体新增相应属性123456789101112131415161718@Datapublic class User &#123; @TableId(type = IdType.AUTO) private Integer id; private String name; private Integer age; private String email; @TableLogic private int deleteFlag; //添加fill属性，有DEFAULT（不处理），INSERT（新增时填充），UPDATE（更新时填充），INSERT_UPDATE（新增和更新时填充） @TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT) private Date createTime; @TableField(value = &quot;update_time&quot;, fill = FieldFill.UPDATE) private Date updateTime;&#125; （3）创建自动填充处理器123456789101112131415161718192021222324@Componentpublic class AutoFillHandler implements MetaObjectHandler &#123; //插入填充 @Override public void insertFill(MetaObject metaObject) &#123; //三种方法都可以，选择其中一种 //方法一：[metaObject, 实体类属性名, Java类型，填充数值] this.strictInsertFill(metaObject, &quot;createTime&quot;, Date.class, new Date()); //方式二：[metaObject，实体类属性名, 函数:带返回值（可用lamda），Java类型] this.strictInsertFill(metaObject, &quot;createTime&quot;, () -&gt; &#123;return new Date();&#125;, Date.class); //方法三：[metaObject, 实体类属性名，填充数值] this.fillStrategy(metaObject, &quot;createTime&quot;, new Date()); &#125; //更新填充 @Override public void updateFill(MetaObject metaObject) &#123; //update与insert同理 this.strictUpdateFill(metaObject, &quot;updateTime&quot;, Date.class, new Date()); &#125;&#125; （4）测试12345678910111213141516@Testpublic void autoFillTest() &#123; //新增测试 User user = new User(); user.setName(&quot;asaki&quot;); user.setAge(18); user.setEmail(&quot;asaki@qq.com&quot;); userMapper.insert(user); //更新测试 User user1 = new User(); user1.setName(&quot;C酱&quot;); user1.setId(1); userMapper.updateById(user1);&#125; 3 IDEA插件3.1 介绍 MybatisPlus为IDEA专门提供一个便利的插件MybatisX 通过MyabtisX，我们可以通过Mapper接口，直接跳转到对应的SQL的xml文件中，十分方便 3.2 插件安装 File –&gt; Settings –&gt; Plugins ，搜索MybatisX，安装后重启IDEA 3.3 插件效果","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【MybatisPlus】自定义SQL注入器","slug":"【MybatisPlus】自定义SQL注入器","date":"2021-04-20T15:17:53.000Z","updated":"2021-04-20T15:20:53.146Z","comments":true,"path":"2021/04/20/【MybatisPlus】自定义SQL注入器/","link":"","permalink":"https://letere-gzj.github.io/2021/04/20/%E3%80%90MybatisPlus%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89SQL%E6%B3%A8%E5%85%A5%E5%99%A8/","excerpt":"关于MybatisPlus自定义SQL注入器的使用","text":"关于MybatisPlus自定义SQL注入器的使用 1 自定义SQL注入器1.1 介绍 在Mybatis的时候，通过xml来进行配置的SQL语句 在MybatisPlus，通过拓展SQL注入器，来自定义SQL，在加载mybatis环境时就注入 根据MybatisPlus的AutoSqlInjector可以自定义各种你想要的sql，注入到全局中，相当于自定义MybatisPlus自动注入的方法 MybatisPlus3.摒弃AutoSqlInjector 1.2 SQL注入使用 基于MybatisPlus3.x实现 （1）在Mapper接口中自定义一个方法12345@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123; //自定义 删除全部 方法 public void deleteAll();&#125; （2）创建方法类，继承与AbstractMehtod123456789101112//类名与自定义方法一致public class DeleteAll extends AbstractMethod &#123; @Override public MappedStatement injectMappedStatement(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo) &#123; String sql = &quot;delete from &quot; + tableInfo.getTableName(); String method = &quot;deleteAll&quot;; SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass); return this.addDeleteMappedStatement(mapperClass, method, sqlSource); //添加对应的MappedStatement &#125;&#125; （3）创建注入器类，继承于DefaultSqlInjector，将方法类添加到注入器中123456789101112@Componentpublic class MySQLInjector extends DefaultSqlInjector &#123; @Override public List&lt;AbstractMethod&gt; getMethodList(Class&lt;?&gt; mapperClass) &#123; List&lt;AbstractMethod&gt; methodList = super.getMethodList(mapperClass);//调用父类的getMethodList获取methodList methodList.add(new DeleteAll());//将自定义的方法传入 return methodList; &#125;&#125; （4）测试123456789101112@SpringBootTestpublic class SpringMPTest &#123; @Autowired private UserMapper userMapper; @Test public void injectorTest() &#123; userMapper.deleteAll(); &#125;&#125;","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【MybatisPlus】插件","slug":"【MybatisPlus】插件","date":"2021-04-18T14:05:44.000Z","updated":"2021-04-18T14:07:02.966Z","comments":true,"path":"2021/04/18/【MybatisPlus】插件/","link":"","permalink":"https://letere-gzj.github.io/2021/04/18/%E3%80%90MybatisPlus%E3%80%91%E6%8F%92%E4%BB%B6/","excerpt":"关于MybatisPlus插件的使用","text":"关于MybatisPlus插件的使用 1 插件1.1 Mybatis插件机制简介 （1）插件机制 Mybatis通过插件（Intercepter）可以做到拦截四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）相关方法的执行，根据需要，完成相关数据的动态改变 （2）插件原理 四大对象的每个对象在创建时，都会执行interceptorChain.pluginAll()，经过每个插件对象的plugin()方法，目的是未当前的四大对象创建代理。代理对象就可以拦截到四大对象相关方法的执行，因为要执行四大对象的方法需要经过代理 1.2 分页插件 用于提供数据分页功能 com.baomidou.mybatisplus.extension.plugins.inner.PaginationInterceptor （1）插件注册123456789101112@Configurationpublic class MybatisPlusConfig &#123; //插件注册 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor(); mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); //注册分页插件 return mpInterceptor; &#125;&#125; （2）分页测试1234567@Testpublic void paginationTest() &#123; User user = new User(); Page&lt;User&gt; userPage = user.selectPage(new Page&lt;User&gt;(1, 2), null); List&lt;User&gt; records = userPage.getRecords(); //SQL：SELECT id,name,age,email FROM user LIMIT ? records.forEach(System.out::println);&#125; 1.3 执行分析（阻止攻击）插件 分析 delete 和 update语句，防止恶意进行delete update全包操作，建议开发环境中使用 com.baomidou.mybatisplus.extension.plugins.SqlExplainInterceptor （已过时） com.baomidou.mybatisplus.extension.plugins.inner.BlockAttackInnerInterceptor （新版对应插件） （1）插件注册12345678//插件注册@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor(); mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); //注册分页插件 mpInterceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); //注册阻止恶意攻击插件 return mpInterceptor;&#125; （2）插件测试123456@Testpublic void blockAttackTest() &#123; User user = new User(); user.delete(null); //全表删除&#125;//执行后自动报异常 1.4 性能分析插件 性能分析拦截器，用于输出每条SQL语句及其执行时间 com.baomidou.mybatisplus.extension.plugins.PerformanceInterception （新版已删除） 1.5 乐观锁插件 当更新一条记录的时候，希望这条记录没有被其他人更新 原理是更新数据时，添加一个version进去，执行更新时version + 1，执行后判断版本是否发生改变，改变就更新失败 com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor （1）插件注册123456789//插件注册@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor(); mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); //注册分页插件 mpInterceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); //注册阻止恶意攻击插件 mpInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); //注册乐观锁插件 return mpInterceptor;&#125; （2）实体类添加version属性12345678910@Datapublic class User extends Model&lt;User&gt; &#123; @TableId(type = IdType.AUTO) private Integer id; private String name; private Integer age; private String email; @Version private Integer version;&#125; （3）表结构新增version字段12alter table useradd column version int default 1; （4）插件测试123456789@Testpublic void optimisticTest() &#123; User user = new User(); user.setId(13); user.setName(&quot;YJJ&quot;); user.setVersion(1); //使用乐观锁必须要带version属性 user.updateById();&#125;","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【MybatisPlus】代码生成器","slug":"【MybatisPlus】代码生成器","date":"2021-04-18T09:54:10.000Z","updated":"2021-04-21T14:58:30.292Z","comments":true,"path":"2021/04/18/【MybatisPlus】代码生成器/","link":"","permalink":"https://letere-gzj.github.io/2021/04/18/%E3%80%90MybatisPlus%E3%80%91%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"MybatisPlus的代码生成器配置与使用","text":"MybatisPlus的代码生成器配置与使用 1 代码生成器1.1 生成器比较 Mybatis： 代码生成器基于xml文件进行生成 生成器可以生成：实体类，Mapper接口、Mapper映射文件 Mybatis-Plus 代码生成器基于java代码来实现 生成器可以生成：实体类，Mapper接口、Mapper映射文件、Service层、Controller层 1.3 依赖引入12345678910111213&lt;!-- MybatisPlus代码生成器 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 代码生成模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt; 1.3 生成器编写 （1）全局配置 12345678910//1. 全局配置（com.baomidou.mybatisplus.generator.config.GlobalConfig）GlobalConfig globalConfig = new GlobalConfig();globalConfig.setActiveRecord(true) //实体类开启AR模式 .setAuthor(&quot;letere&quot;) //作者信息 .setOutputDir(System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/java/&quot;) //文件生成路径 .setFileOverride(true) //文件覆盖 .setIdType(IdType.AUTO) //主键类型 .setServiceName(&quot;%sService&quot;) //设置Service名字，默认开头会多出一个I字母 .setBaseResultMap(true) //生成基本的结果返回集 .setBaseColumnList(true); //生成字段列表 （2）数据源配置 SpringBoot项目还要在applicaiton.yaml中配置数据源才可以 1234567//2. 数据源配置DataSourceConfig dataSourceConfig = new DataSourceConfig();dataSourceConfig.setDbType(DbType.MYSQL) //数据库类型 .setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;) .setUsername(&quot;root&quot;) .setPassword(&quot;123&quot;) .setUrl(&quot;jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8&quot;); （3）策略配置 123456//3. 策略配置StrategyConfig strategyConfig = new StrategyConfig();strategyConfig.setCapitalMode(true) //全局大写命名 .setEntityLombokModel(true) //Lombok实体类 .setNaming(NamingStrategy.underline_to_camel) //驼峰命名 .setInclude(&quot;user&quot;); //数据库表名（多个表，传数组） （4）包名配置 12345678//4. 包名配置PackageConfig packageConfig = new PackageConfig();packageConfig.setParent(&quot;com.letere.mp&quot;) //父包位置 .setMapper(&quot;mapper&quot;) //Mapper文件包名 .setXml(&quot;mapper&quot;) //xml文件包名 .setService(&quot;service&quot;) //service文件包名 .setController(&quot;controller&quot;) //controller文件包名 .setEntity(&quot;bean&quot;); //entity文件包名 （5）整合配置与执行 12345678910//5. 整合配置AutoGenerator autoGenerator = new AutoGenerator();autoGenerator.setGlobalConfig(globalConfig) .setDataSource(dataSourceConfig) .setStrategy(strategyConfig) .setPackageInfo(packageConfig);//6. 代码生成autoGenerator.execute(); 1.4 生成效果 1.5 Service说明","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【MybatisPlus】ActiveRecord使用","slug":"【MybatisPlus】ActiveRecord使用","date":"2021-04-18T08:01:55.000Z","updated":"2021-04-19T04:58:25.384Z","comments":true,"path":"2021/04/18/【MybatisPlus】ActiveRecord使用/","link":"","permalink":"https://letere-gzj.github.io/2021/04/18/%E3%80%90MybatisPlus%E3%80%91ActiveRecord%E4%BD%BF%E7%94%A8/","excerpt":"ActiveRecord是MybatisPlus的一个语法糖，使得CRUD使用更加方便","text":"ActiveRecord是MybatisPlus的一个语法糖，使得CRUD使用更加方便 1 ActiveRecord1.1 介绍 Active Record，是一种领域模型模式，特点是一个模型类对应关系型数据库中的一个表，而模型类的一个实例对应表中的一行记录 ActiveRecord一直广受动态语言（PHP、Ruby）的喜爱，而Java作为准静态语言，对于ActiveRecord往往只能感叹器优雅，所有MP也在AR道路上进行了一定的探索 1.2 开启AR 步骤很简单，只需要JavaBean继承com.baomidou.mybatisplus.extension.activerecord.Model即可 12345678@Datapublic class User extends Model&lt;User&gt; &#123; @TableId(type = IdType.AUTO) private Integer id; private String name; private Integer age; private String email;&#125; 1.3 操作演示 由于JavaBean继承与Model，而Model里面有对数据库操作的基本方法，所以对数据库操作时用JavaBean自己来实现 1234567891011//插入@Testpublic void insertTest() &#123; User user = new User(); user.setName(&quot;asaki&quot;); user.setAge(18); user.setEmail(&quot;asaki@email.com&quot;); //自己进行插入操作 user.insert(); //SQL：INSERT INTO user ( name, age, email ) VALUES ( ?, ?, ? )&#125; 1234567891011//更新@Testpublic void updateTest() &#123; User user = new User(); user.setName(&quot;ASAKI&quot;); user.setAge(22); user.setEmail(&quot;asaki@qq.com&quot;); //自己进行修改操作 user.update(new UpdateWrapper&lt;User&gt;().eq(&quot;id&quot;, 12));&#125; 1234567891011121314151617//查询@Testpublic void selectTest() &#123; User user = new User(); //通过主键查询 User user1 = user.selectById(1); //SQL：SELECT id,name,age,email FROM user WHERE id=? System.out.println(user1); //查询全部 List&lt;User&gt; users = user.selectAll(); //SQL：SELECT id,name,age,email FROM user users.forEach(System.out::println); //条件构造器查询 List&lt;User&gt; users2 = user.selectList(new QueryWrapper&lt;User&gt;().eq(&quot;age&quot;, 18)); //SQL：SELECT id,name,age,email FROM user WHERE (age = ?) users2.forEach(System.out::println);&#125; 1234567891011//删除@Testpublic void deleteTest() &#123; User user = new User(); //通过主键id删除 user.deleteById(12); // SQL：DELETE FROM user WHERE id=? //通过条件构造器删除 user.delete(new QueryWrapper&lt;User&gt;().eq(&quot;id&quot;, 12)); //SQL：DELETE FROM user WHERE (id = ?)&#125; 1.4 总结 AR模式提供了一种更加便捷的方式实现CRUD操作，其本质还是调用的Mybatis对应的方法，类似于语法糖 到此，我们简单领略了Mybatis-Plus的美丽与高效率，值得注意的一点是：我们提供了强大的代码生成器，可以快速生成各类代码，真正做到了即开即用","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【MybatisPlus】条件构造器","slug":"【MybatisPlus】条件构造器","date":"2021-04-18T06:47:24.000Z","updated":"2021-04-18T06:49:49.021Z","comments":true,"path":"2021/04/18/【MybatisPlus】条件构造器/","link":"","permalink":"https://letere-gzj.github.io/2021/04/18/%E3%80%90MybatisPlus%E3%80%91%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"MybatisPlus的特点，条件构造器使用，帮助拼接sql","text":"MybatisPlus的特点，条件构造器使用，帮助拼接sql 1 条件构造器1.1 介绍 Mybatis-Plus通过AbstractWrapper的继承类QueryWrapper和UpdateWrapper（旧版本：EntityWrapper）让用户自由的构建查询条件，简单便捷，没有额外的负担能够有效提高开发效率 条件构造器主要用户处理sql拼接，排序，实体参数查询等 1.2 条件 官网：https://mp.baomidou.com/guide/wrapper.html#abstractwrapper 条件方法 说明 使用例子 eq(column, value) sql中的 = eq(&quot;id&quot;, 1) = id = 1 alleq(params) sql中的 = ，map集合一次性等于 allEq(&#123;id:1,name:&quot;老王&quot;,age:null&#125;) = id = 1 and name = &#39;老王&#39; and age is null ne(column, vlaue) sql中的不等于 &lt;&gt; ne(&quot;name&quot;, &quot;老王&quot;) = name &lt;&gt; &#39;老王&#39; gt(column, vlaue) sql中的 &gt; gt(&quot;age&quot;, 18) = age &gt; 18 ge(column, value) sql中的 &gt;= ge(&quot;age&quot;, 18) = age &gt;= 18 lt(column, value) sql中的 &lt; lt(&quot;age&quot;, 18) = age &lt; 18 le(column, value) sql中的 &lt;= lt(&quot;age&quot;, 18) = age &lt;= 18 between(column, value1, value2) sql中的 between … and … between(&quot;age&quot;, 18, 30) = age between 18 and 30 notBetween(column, value1, value2) sql中的 not between … and .. notBetween(&quot;age&quot;, 18, 30) = age not between 18 and 30 like(column, value) sql中的like %..% like(&quot;name&quot;, &quot;王&quot;) = name like &#39;%王%&#39; notLike(column, value) sql中的 not like %…% notLike(&quot;name&quot;, &quot;王&quot;) = name not like &#39;%王%&#39; … 还有很多，以后整理 1.3 使用演示123456789101112131415161718192021@Testpublic void wrapperTest() &#123; //查询 QueryWrapper&lt;User&gt; qw = new QueryWrapper&lt;User&gt;().eq(&quot;name&quot;, &quot;Tom&quot;); List&lt;User&gt; users = userMapper.selectList(qw); // SQL：SELECT id,name,age,email FROM user WHERE (name = ?) users.forEach(System.out::println); //更新 User user = new User(); user.setName(&quot;C酱&quot;); user.setAge(18); UpdateWrapper&lt;User&gt; uw = new UpdateWrapper&lt;User&gt;().eq(&quot;id&quot;, 1); userMapper.update(user, uw); // SQL：UPDATE user SET name=?, age=? WHERE (id = ?) //删除 QueryWrapper&lt;User&gt; qw2 = new QueryWrapper&lt;&gt;(); qw2.eq(&quot;id&quot;, 5); userMapper.delete(qw2); // SQL：DELETE FROM user WHERE (id = ?)&#125;","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【MyBatisPlus】通用CRUD","slug":"【MyBatisPlus】通用CURD","date":"2021-04-18T03:31:23.000Z","updated":"2021-04-18T14:10:16.517Z","comments":true,"path":"2021/04/18/【MyBatisPlus】通用CURD/","link":"","permalink":"https://letere-gzj.github.io/2021/04/18/%E3%80%90MyBatisPlus%E3%80%91%E9%80%9A%E7%94%A8CURD/","excerpt":"关于Mybatis的通用CRUD操作","text":"关于Mybatis的通用CRUD操作 1 CRUD1.1 与Mybatis区别 Mybatis Mybatis操作数据库，要创建一个Mapper接口，并创建对应的CURD方法 创建完接口，还要创建对应Mapper.xml文件，在里面的文件填写相应的SQL语句 MybatisPlus 只需创建一个Mapper接口，此Mapper接口继承与BaseMapper接口，就能够实现对数据库进行CURD操作，无需写SQL，但是复杂的业务还是需要手写SQL来实现 1.2 BaseMapper BaseMapper内部已经创建好了许多通用的CURD方法，所以在我们创建的Mapper接口继承BaseMapper接口后，无需创建接口方法，就可以进行CURD 12345678910111213141516171819202122232425262728293031323334353637//BaseMapper源码public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123; int insert(T entity); int deleteById(Serializable id); int deleteByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap); int delete(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); int deleteBatchIds(@Param(&quot;coll&quot;) Collection&lt;? extends Serializable&gt; idList); int updateById(@Param(&quot;et&quot;) T entity); int update(@Param(&quot;et&quot;) T entity, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; updateWrapper); T selectById(Serializable id); List&lt;T&gt; selectBatchIds(@Param(&quot;coll&quot;) Collection&lt;? extends Serializable&gt; idList); List&lt;T&gt; selectByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap); T selectOne(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); Integer selectCount(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); List&lt;T&gt; selectList(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); List&lt;Object&gt; selectObjs(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); &lt;E extends IPage&lt;T&gt;&gt; E selectPage(E page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper); &lt;E extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; E selectMapsPage(E page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);&#125; 1.3 字段注解 具体查看：https://mp.baomidou.com/guide/annotation.html （1）表名注解 @TableName(value = 表名) 表名：如果数据库表名与类名不一致，需要设置此类型，否则会找不到对应的数据库表 （2）主键注解 @TableId(value = 主键字段名, type = 主键类型) 主键字段名：如果Bean属性id和主键字段名一直，可以不设置 主键类型： IdType.ASSIGN_ID，默认，若我们主键为null，会自动为我们生成主键id并插入 IdType.AUTO，数据库ID自增，数据库表使用id自增建议使用此类型 （3）字段注解 @TableField(value = 字段名, exist = true/false) 字段名：数据库对应字段名，如果一致，可以不用设置 exist：是否为数据库存在字段，默认true，若想要对数据库操作忽略此字段，可以设置为false 1.4 全局配置策略 配置类：com.baomidou.mybatisplus.core.MybatisConfiguration 12345678910111213141516public MybatisConfiguration() &#123; this.mybatisMapperRegistry = new MybatisMapperRegistry(this); this.caches = new MybatisConfiguration.StrictMap(&quot;Caches collection&quot;); this.resultMaps = new MybatisConfiguration.StrictMap(&quot;Result Maps collection&quot;); this.parameterMaps = new MybatisConfiguration.StrictMap(&quot;Parameter Maps collection&quot;); this.keyGenerators = new MybatisConfiguration.StrictMap(&quot;Key Generators collection&quot;); this.sqlFragments = new MybatisConfiguration.StrictMap(&quot;XML fragments parsed from previous mappers&quot;); this.mappedStatements = (new MybatisConfiguration.StrictMap(&quot;Mapped Statements collection&quot;)).conflictMessageProducer((savedValue, targetValue) -&gt; &#123; return &quot;. please check &quot; + savedValue.getResource() + &quot; and &quot; + targetValue.getResource(); &#125;); this.useGeneratedShortKey = true; this.useDeprecatedExecutor = true; this.mapUnderscoreToCamelCase = true; //开启驼峰命令 this.languageRegistry.setDefaultDriverClass(MybatisXMLLanguageDriver.class);&#125; 2 插入操作2.1 基本使用12345678910111213//对应BaseMapper接口方法int insert(T entity)//使用测试@Testpublic void insertTest() &#123; User user = new User(); user.setName(&quot;C酱&quot;); user.setAge(18); user.setEmail(&quot;CC@qq.com&quot;); userMapper.insert(user);&#125; 2.2 细节 （1）获取当前数据id值 对于主键自增的数据，想要实现数据插入后，顺便获取会该数据的主键值 MybatisPlus自动封装好方法，插入成功后，自动将主键值，set回java数据中 123456789101112@Testpublic void insertTest() &#123; //通用插入 User user = new User(); user.setName(&quot;asaki&quot;); user.setAge(18); user.setEmail(&quot;1231231@qq.com&quot;); userMapper.insert(user); //获取主键值（插入成功后，id值自动被设置） Integer id = user.getId(); System.out.println(id);&#125; （2）动态SQL MybatisPlus的插入方法使用的动态SQL，如果插入值为空的话，会自动忽略该字段，不进行sql语句的插入 3 更新操作3.1 基本使用123456789101112131415//BaseMapper接口对应方法int updateById(@Param(&quot;et&quot;) T entity);//使用@Testpublic void updateTest() &#123; User user = new User(); user.setId(9); user.setName(&quot;玛利亚&quot;); user.setAge(18); user.setEmail(&quot;myl@qq.com&quot;); //修改 userMapper.updateById(user);&#125; 3.2 细节 （1）动态SQL update方法和insert方法一样，都是有动态SQL，插入值为null自动忽略该字段 4 查询操作4.1 基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546//BaseMapper接口对应方法T selectById(Serializable id);T selectOne(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);List&lt;T&gt; selectBatchIds(@Param(&quot;coll&quot;) Collection&lt;? extends Serializable&gt; idList);List&lt;T&gt; selectByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap);&lt;E extends IPage&lt;T&gt;&gt; E selectPage(E page, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; queryWrapper);//使用@Testpublic void selectTest() &#123; //1、通过主键id查询 User user = userMapper.selectById(1); //SQL：SELECT id,name,age,email FROM user WHERE id=? System.out.println(user); //2、多个字段条件查询（注意查询结果只能有一个，否则报错） User user1 = new User(); user1.setId(6); user1.setName(&quot;C酱&quot;); User user2 = userMapper.selectOne(new QueryWrapper&lt;&gt;(user1)); //SQL：SELECT id,name,age,email FROM user WHERE id=? AND name=? System.out.println(user2); //3、通过多个主键id查询多条数据 List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(1); ids.add(2); List&lt;User&gt; users = userMapper.selectBatchIds(ids); //SQL：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? ) users.forEach(System.out::println); //4、多字段条件查询（支持返回多个） Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); columnMap.put(&quot;name&quot;, &quot;C酱&quot;); columnMap.put(&quot;age&quot;, 18); List&lt;User&gt; users1 = userMapper.selectByMap(columnMap); //SQL：SELECT id,name,age,email FROM user WHERE name = ? AND age = ? users1.forEach(System.out::println); //5、分页查询（暂无效果，需要与分页插件使用才有效果） Page&lt;User&gt; page = new Page&lt;&gt;(1, 2); Page&lt;User&gt; userIPage = userMapper.selectPage(page, null); //SQL：SELECT id,name,age,email FROM user List&lt;User&gt; records = userIPage.getRecords(); records.forEach(System.out::println);&#125; 5 删除操作5.1 基本使用1234567891011121314151617181920212223242526//BaseMapper接口对应的方法int deleteById(Serializable id);int deleteByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap);int deleteBatchIds(@Param(&quot;coll&quot;) Collection&lt;? extends Serializable&gt; idList);//使用@Testpublic void deleteTest() &#123; //1、根据主键id进行删除 userMapper.deleteById(9); //SQL：DELETE FROM user WHERE id=? //2、多字段条件删除 Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); columnMap.put(&quot;name&quot;, &quot;C酱&quot;); columnMap.put(&quot;age&quot;, 18); userMapper.deleteByMap(columnMap); //SQL：DELETE FROM user WHERE name = ? AND age = ? //3、根据主键id批量删除 List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(8); ids.add(10); userMapper.deleteBatchIds(ids); //SQL：DELETE FROM user WHERE id IN ( ? , ? )&#125; 6 MP启动注入SQL6.1 问题提出 一个Mapper接口继承了BaseMapper之后，可以使用对应BaseMapper的方法。方法有了，但是对应的SQL语句并没有发现。这是因为MybatisPlus启动后会自动注入SQL 6.2 MybatisPlus原理 以后再学：https://www.bilibili.com/video/BV1Ds411E76Y?p=31&amp;spm_id_from=pageDriver","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【MybatisPlus】MybatisPlus入门","slug":"【MybatisPlus】MybatisPlus入门","date":"2021-04-17T13:57:53.000Z","updated":"2021-04-17T14:23:33.256Z","comments":true,"path":"2021/04/17/【MybatisPlus】MybatisPlus入门/","link":"","permalink":"https://letere-gzj.github.io/2021/04/17/%E3%80%90MybatisPlus%E3%80%91MybatisPlus%E5%85%A5%E9%97%A8/","excerpt":"MybatisPlus的简单入门","text":"MybatisPlus的简单入门 1 Mybatis入门1.1 介绍 Mybatis-Plus是一个Mybatis的增强工具包，只作增强不做改变，为简化开发工作、提高生产效率而生 官方文档：https://mp.baomidou.com/guide/ 代码地址 gtihub：https://github.com/baomidou/mybatis-plus gitee：https://gitee.com/baomidou/mybatis-plus 1.2 MybatisPlus整合 项目使用的是springBoot整合MybatisPlus （1）数据库表与JavaBean 1234567891011121314151617# 创建user表CREATE TABLE `user` ( `id` bigint NOT NULL COMMENT &#x27;主键ID&#x27;, `name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;, `age` int DEFAULT NULL COMMENT &#x27;年龄&#x27;, `email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 插入数据INSERT INTO user (id, name, age, email) VALUES(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;); 1234567@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; （2）Pom.xml修改 1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;!-- 引入SpringBoot框架 --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MybatisPlus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; （3）application.yaml修改 1234567# 配置数据源spring: datasource: username: root password: 123 url: jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver （4）创建Mapper接口 1234//继承通用Mapper@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; （5）SpringBoot主启动类 123456@SpringBootApplicationpublic class MPRun &#123; public static void main(String[] args) &#123; SpringApplication.run(MPRun.class, args); &#125;&#125; （6）测试 123456789101112@SpringBootTestpublic class SpringMPTest &#123; @Autowired private UserMapper userMapper; @Test public void mpTest1() &#123; List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125;&#125;","categories":[{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"}],"tags":[]},{"title":"【Spring】JdbcTemplate使用","slug":"【Spring】JdbcTemplate使用","date":"2021-04-16T06:30:27.000Z","updated":"2021-04-16T06:38:07.461Z","comments":true,"path":"2021/04/16/【Spring】JdbcTemplate使用/","link":"","permalink":"https://letere-gzj.github.io/2021/04/16/%E3%80%90Spring%E3%80%91JdbcTemplate%E4%BD%BF%E7%94%A8/","excerpt":"Spring整合的JDBC技术的工具JdbcTemplate使用","text":"Spring整合的JDBC技术的工具JdbcTemplate使用 1 JdbcTemplate1.1 介绍 JdbcTemplate是Spring对之前学习的Jdbc技术的封装，使得对数据库的操作更加的便捷 1.2 搭建JdbcTemplate （1）引入依赖 12345678910111213&lt;!-- JdbcTemplate --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt; （2）创建JdbcTemplate 123456789101112public JdbcTemplate getJdbTemplate() &#123; //创建数据源 DriverManagerDataSource dataSource=new DriverManagerDataSource(); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123&quot;); dataSource.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true&quot;); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); //通过数据源创建JdbcTemplate JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); return jdbcTemplate;&#125; 以上是简单创建，如果与Spring项目整合，可以将JdbcTemplate注入IOC容器中，通过注解使用 1.3 常用JdbcTemplate方法12345678910111213141516171819202122// 1. 增、删、改public int update(final String sql)；public int update(final String sql， Object... args);// 2. 批量增、删、改public int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)// 3. 查询// 查询-返回基本数据类型public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType)// 查询-返回对象public &lt;T&gt; T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, @Nullable Object... args) // 查询-返回列表public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) // 4. SQL通用执行（一般用于DDL：create alter drop）public void execute(final String sql) 1.4 使用演示 （1）数据库表和Bean准备 1234567# 建表语句CREATE TABLE `person` ( `id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;唯一标识&#x27;, `name` varchar(5) DEFAULT NULL COMMENT &#x27;姓名&#x27;, `sex` varchar(2) DEFAULT NULL COMMENT &#x27;性别&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 123456789//对应存储Bean@Data@NoArgsConstructor@AllArgsConstructorpublic class Person &#123; private Integer id; private String name; private String sex;&#125; （2）增删改 123456789101112131415161718192021222324252627//增public int addPerson() &#123; JdbcTemplate jdbTemplate = getJdbTemplate(); Person person = new Person(1, &quot;C酱&quot;, &quot;女&quot;); //如果主键自增，id可以设置为null String sql = &quot;insert into person values(?, ?, ?)&quot;; return jdbTemplate.update(sql, person.getId(), person.getName(), person.getSex());&#125;//改public int updatePerson() &#123; JdbcTemplate jdbTemplate = getJdbTemplate(); Person person = new Person(1, &quot;asaki&quot;, &quot;女&quot;); String sql = &quot;update person set name=?, sex=? where id=?&quot;; return jdbTemplate.update(sql, person.getName(), person.getSex(), person.getId());&#125;//删public int deletePerson() &#123; JdbcTemplate jdbTemplate = getJdbTemplate(); String sql = &quot;delete from person where id=?&quot;; return jdbTemplate.update(sql, &quot;1&quot;);&#125; （3）批量增、删、改 12345678910111213141516171819202122232425262728293031323334353637383940//批量增public int[] addPersons() &#123; Object[] person1 = new Object[]&#123;1, &quot;C酱&quot;, &quot;女&quot;&#125;; Object[] person2 = new Object[]&#123;2, &quot;asaki&quot;, &quot;女&quot;&#125;; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(person1); batchArgs.add(person2); String sql = &quot;insert into person values(?, ?, ?)&quot;; return getJdbTemplate().batchUpdate(sql, batchArgs);&#125;//批量改public int[] updatePersons() &#123; Object[] person1 = new Object[]&#123;&quot;咕料&quot;, &quot;男&quot;, 1&#125;; //注意顺序 Object[] person2 = new Object[]&#123;&quot;yjj&quot;, &quot;男&quot;, 2&#125;; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(person1); batchArgs.add(person2); String sql = &quot;update person set name=?, sex=? where id=?&quot;; return getJdbTemplate().batchUpdate(sql, batchArgs);&#125;//批量删public int[] deletePersons() &#123; Object[] a = new Object[]&#123;1&#125;; Object[] b = new Object[]&#123;2&#125;; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(a); batchArgs.add(b); String sql = &quot;delete from person where id=?&quot;; return getJdbTemplate().batchUpdate(sql, batchArgs);&#125; （4）查询演示 123456789101112131415161718192021222324//查询-返回基本数据类型public void queryPersonNumber() &#123; String sql = &quot;select count(*) from person&quot;; Integer num = getJdbTemplate().queryForObject(sql, Integer.class); System.out.println(num);&#125;//查询-返回对象public void queryPersonById() &#123; String sql = &quot;select * from person where id = ?&quot;; Person person = getJdbTemplate().queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Person.class), 1); System.out.println(person);&#125;//查询-返回列表public void queryPersons() &#123; String sql = &quot;select * from person&quot;; List&lt;Person&gt; persons = getJdbTemplate().query(sql, new BeanPropertyRowMapper&lt;&gt;(Person.class)); for(Person person : persons) &#123; System.out.println(person); &#125;&#125; （5）Execute演示 12345//execute使用public void executeTest() &#123; String sql = &quot;create table Test (id int primary key auto_increment, name varchar(8) not null, age int not null)&quot;; getJdbTemplate().execute(sql);&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://letere-gzj.github.io/categories/Spring/"}],"tags":[]},{"title":"【Linux】任务调度","slug":"【Linux】任务调度","date":"2021-04-15T01:21:59.000Z","updated":"2021-04-15T01:32:19.501Z","comments":true,"path":"2021/04/15/【Linux】任务调度/","link":"","permalink":"https://letere-gzj.github.io/2021/04/15/%E3%80%90Linux%E3%80%91%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/","excerpt":"关于Linux如何进行定时任务执行","text":"关于Linux如何进行定时任务执行 1 任务调度1.1 介绍 任务调度指，Linux执行一段脚本或代码 很多时候，我们需要Linux定时自己进行任务调度 所有需要使用crontab来进行Linux的定时任务调度 1.2 指令123456789# 调度语法crontab [选项]# -e --- edit 编辑定时任务# -l --- list 查询定时任务# -r --- remove 删除当前用户的所有crontab任务# 重启任务调度service crond restart 如果只是简单的任务，可以不用写脚本，直接在crontab中加入任务即可 如果是比较复杂的任务，需要些脚本 1.3 时间格式12# 时间格式* * * * * 命令 标准字符 项目 含义 范围 第一个 * 1小时中的第几分钟 0-59 第二个 * 1天当中的第几小时 0-23 第三个 * 1个月当中第几天 1-31 第四个 * 1年当中的第几月 1-12 第五个 * 星期几 0-7（0和7都代表星期日） 特殊字符 特殊字符 含义 * 代表任何时间。比如第一个*，就代表1小时中每分钟都只系1次的意思 , 代表不连续时间，比如* 5,10 * * * 命令，命令会在5点和10点执行 - 代表连续时间，比如* 5-10 * * * 命令，命令会在5点到10点之间执行 */number 代表每个多久时间执行一次，*/5 * * * * 命令，每5分钟执行1次 1.4 演示 每分钟执行1次 date &gt;&gt; /home/letere/myFile/time.txt指令 （1）corntab -e 进入编辑任务调度界面 （2）输入时间和调用指令*/1 * * * * date &gt;&gt; /home/letere/myFile/time.txt （3）保存退出，等待1分钟，查看time.txt（会自动创建）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】组管理&权限管理","slug":"【Linux】组管理-权限管理","date":"2021-04-12T14:19:51.000Z","updated":"2021-04-12T14:22:19.186Z","comments":true,"path":"2021/04/12/【Linux】组管理-权限管理/","link":"","permalink":"https://letere-gzj.github.io/2021/04/12/%E3%80%90Linux%E3%80%91%E7%BB%84%E7%AE%A1%E7%90%86-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"关于Linux的组管理和权限管理的操作","text":"关于Linux的组管理和权限管理的操作 1 组管理1.1 基本介绍 linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其他组的概念 所有者：创建文件的用户 所在组：：文件所处于的组，默认是创建文件的用户所在组 其他组：：除了所在组的所有组 1.2 所有者 常用指令1234567891011121314# 查看文件所有者ls -ahl# a --- all# h --- human# l --- list# 修改文件所有者chown 用户名 文件名# -R --- Recursion 递归# 修改文件所有者机器所有组chown 用户名:组名 文件名 演示 （1）查看所有者 （2）修改所有者 1.3 所在组 常用指令1234567# 查看文件所在组ls -ahl# 修改文件所在组chgrp 组名 文件名# -R --- Recursion 递归 演示 （1）查看所在组 （2）修改所在组 1.4 用户管理12345678# 改变用户所在组usermod -g 组名 用户名# g --- group# 改变用户登录初始目录usermod -d 目录名 用户名# d --- directory 2 权限管理2.1 权限介绍 文件类型 说明 - 普通文件 d 目录 l 软连接 c 字符设备【键盘、鼠标等】 b 块文件，硬盘 权限类型 说明 r read，读，查看文件 / ls查看目录 w write，写，修改文件，也可以删除文件，但要求文件所在目录也要有w权限才能删除 x execute，执行，执行文件 / 进入目录 - 没有权限 权限的rwx可以使用数字来表示 r = 4 w = 2 x = 1 2.2 权限管理1234567891011121314151617181920# 修改文件 / 目录权限# 方式一chmod u=[rwx], g=[rwx], o=[rwx] 文件/目录名 #例：chmod u=rwx, g=rx, o=r hello.txt# u --- user 所有者# g --- group 所在组# o --- other 其他组# a --- all 全部# 方式二chmod [ugoa][+-][rwx] 文件/目录名 #例：chmod u+r hello.txt# + --- 添加权限# - --- 移除权限# 方式三chmod [数字权限][数字权限][数字权限] 文件/目录名 #例：chmod 764 hello.txt# r=4 w=2 x=1# 7=rwx 6=rw 5=rx 3=wx# 第一个为所有者，第二为所在组，第三为其他组","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】实用指令","slug":"【Linux】实用指令","date":"2021-04-11T10:24:10.000Z","updated":"2021-04-11T10:30:52.351Z","comments":true,"path":"2021/04/11/【Linux】实用指令/","link":"","permalink":"https://letere-gzj.github.io/2021/04/11/%E3%80%90Linux%E3%80%91%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"Linux的实用指令","text":"Linux的实用指令 1 运行级别1.1 级别介绍 级别 说明 0 关机 poweroff.target 1 单用户（找回丢失密码）rescue.target 2 多用户无网络服务 3 多用户有网络服务（常用） multi-user.target 4 保留，暂无功能 5 图形界面（常用） graphical.target 6 重启 reboot.target 运行级别配置文件：/etc/inittab（旧版本） 运行级别配置文件：/lib/systemd/system目录下的xxx.target文件（CentOS7以上） 1.2 指令12345678910111213141516# 切换运行级别（旧版本）init [0123456]-------------------------------------------------# CentOS7以上# 获取当前运行级别systemctl get-default# 设置默认运行级别systemctl set-default xxx.target# 切换运行级别systemctl isolate runlevel[0123456].target # 用数字表示运行级别systemctl isolate xxx.target # 对应运行级别的名称 1.3 面试题 （1）找回root密码【CentOS5】 思路：切换运行模式到单用户模式，然后修改root密码，因为单用户模式下，root账号不需密码即可登录 1、开机界面按下enter，进入编辑模式 2、切换行至kernel / vmlinuz，按下e 3、输入 1，来切换到单用户模式，enter返回编辑模式 4、按b继续开机 5、默认以root账号进入，通过passwwd root进行密码修改 6、切换回运行等级5，图形界面 2 帮助指令2.1 介绍 Linux提供帮助指令，用来让我们了解我们不熟悉的指令 2.2 指令123456# 获取帮助信息man 命令/配置文件# 获取指令信息help 指令 3 目录指令3.1 当前工作路径12# 显示当前工作目录绝对路径pwd 3.2 查看目录信息12345# 查看信息ls [选项] [目录/文件]ls -a #显示当前目录所有文件与目录，包含隐藏的ls -l #以列表的形式显示信息 3.3 切换目录12345# 切换目录cd [目录路径]cd ~ #返回家目录cd .. #返回上级目录 3.4 创建目录1234# 创建目录mkdir [选项] 目录名mkdir -p 多级目录名 #创建多级目录 3.5 删除目录12# 删除目录rmdir [选项] 空目录名 # 只能删除空目录 4 文件指令4.1 创建文件123# 创建文件touch 文件名touch 文件名1 文件名2 #支持一次创建多个文件 4.2 复制文件12345# 复制文件cp [选项] 被复制文件/文件夹 复制的路径cp -r 被复制文件夹 复制路径 # 复制文件夹及其文件夹下所有文件\\cp ...... # 复制文件夹时，自动覆盖同名文件，不再提示请求【CentOS7以下】 4.3 删除文件12345# 删除文件rm [选项] 文件/目录rm -r 目录 #递归删除目录rm -f 文件/目录 #强制删除不提示 4.4 移动文件（重命名）123456# 重命名mv 旧文件名 新文件名 # 相当于原地剪切复制，并重新命名# 移动文件mv 文件路径 目的路径 4.5 查看文件1234567# 查看文件（无法修改）cat [选项] 文件名more 文件名 #一次性加载所有内容less 文件名 #根据内容加载文件，非一次性加载cat -n 文件名 #显示行号形式查看文件cat 文件名 | more #分页查看文件 more操作指令 功能说明 空白键（space） 翻下一页 Enter 向下一行 q 退出浏览 Ctrl + F 向下滚动一屏 Ctrl + B 返回上一屏 = 输出当前行号 :f 输出文件名和当前行号 less操作指令 功能说明 空白键 向下翻一页 pagedown 向下翻一页 pageup 向上翻一页 /关键字 向下搜索 ?关键字 向上搜索 q 退出 4.6 查看文件开头1234# 查看文件开头head [选项] 文件 #默认查看前10行head -n 5 文件 #查看开头前5行，类推 4.7 查看文件结尾12345# 查看文件尾部tail [选项] 文件 #默认后10行tail -n 5 文件 #查看后5行，类推tail -f 文件 #实时监控内容（常用） 4.8 输出重定向 和 追加123456# &gt;输出重定向（覆盖内容）内容 &gt; 文件ls -l &gt; 文件 #将列表内容写入到文件中，覆盖内容cat 文件1 &gt; 文件2 #将文件1的内容覆盖到文件2上echo &quot;内容&quot; &gt; 文件 #将自定义内容覆盖到文件上 12# 追加（文末追加内容，使用方法和&gt;一样）内容 &gt;&gt; 文件 4.9 输出信息至控制台12# 输出内容至控制台echo [选项] [内容] 4.10 软链接（符号链接） 软连接类似windows的快捷方式 123456# 创建软链接ln -s 源文件/目录 软连接名# 删除软链接rm -rf 软连接 5 历史指令123456# 查看历史指令history #显示所有已使用指令history 10 #显示最近10条已使用指令，类推!5 #执行历史编号为5的指令 6 时间日期1234567891011121314# 显示日期date #显示当前时间date +%Y #显示当前年份date +%m #显示当前月份date +%d #显示当前日份date &quot;+%Y-%m-%d %H:%M:%S&quot; #显示年月日时分秒date -s 时间字符串 #修改系统时间，例：2021-4-15 12:00:00cal #显示日历时间 7 搜索查找7.1 find指令 find指令将从指定目录向下递归遍历其各个子目录，将满足条件的文件或目录限制在终端 12345678# 查找find 查找范围 查找方式 参数find 范围 -name 文件 #通过文件名，查找文件路径，允许使用*通配符find 范围 -user 用户名 #通过用户名，查询该用户的所有文件路径find 范围 -size +文件大小 #查找大于指定大小的文件路径，大于+，小于-，等于无符号 7.2 locate指令 locate可以快速定位文件路径。locate利用实现建立的系统中所有文件名称及路径的locate数据库实现快速定位指定文件。查询速度快，但需定期更新locate时刻 123456# 创建/更新locate数据库updatedb# 查找文件locate 文件名 7.3 grep指令 和 管道符号| grep过滤查找，管道符“|”，表示将前一个命令处理的结果传递给后面的命令处理 1234567891011# 基本语法grep [选项] 查找内容 源文件cat 源文件 | grep 查找内容# 显示匹配行及行号grep -n 查找内容 源文件 # 忽略大小写grep -i 查找内容 源文件 8 压缩和解压8.1 gzip/gunzip指令123456# 压缩文件gzip 文件名 #只能压缩为*.gz，并压缩完会删除原文件# 解压文件gunzip 压缩文件 #解压会删除压缩文件 8.2 zip/unzip指令12345678910# 压缩文件zip [选项] xxx.zip 压缩内容 zip -r ..... #递归压缩，用于压缩目录# 解压文件upzip [选项] xxx.zipupzip -d 解压路径 .... #指定解压路径 8.3 tar指令 tar指令为打包指令，最后打包后的文件是.tar.gz文件 123456# 压缩文件tar [选项] xxx.tar.gz 压缩内容(可以多个，空格隔开)# 解压文件tar [选项] xxx.tar.gz [-C 解压路径] 选项 说明 -c 打包文件 -x 解压文件 -z 打包内容给gzip压缩，即具有.gz属性 -f 指定压缩/解压文件名 -v 压缩/解压显示详细信息","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】用户管理","slug":"【Linux】用户管理","date":"2021-04-10T14:15:15.000Z","updated":"2021-04-10T14:20:21.757Z","comments":true,"path":"2021/04/10/【Linux】用户管理/","link":"","permalink":"https://letere-gzj.github.io/2021/04/10/%E3%80%90Linux%E3%80%91%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/","excerpt":"关于Linux对用户进行管理的操作指令","text":"关于Linux对用户进行管理的操作指令 1 用户管理1.1 基础概念 用户组：用户组用来规定用户的权限，不同的用户会有不同的用户组，对应不同的权限，通过用户组来对用户进行分类 家目录：在Linux/home/...下，用户目录下有各个创建的用户对应的家目录，目录名称为用户名，当用户登录时，会自动的进入到自己的家目录 1.2 用户管理指令 （1）添加用户12345678910# 添加用户，默认创建同名家目录useradd 用户名# 添加用户，创建指定家目录useradd -r 家目录路径 用户名# 添加用户，并分配到指定组（组已创建）useradd -g 组名 用户名 （2）指定密码12# 指定用户密码passwd 用户名 按照要求输入两次密码即可 （3）删除用户 12345# 删除用户，但保留家目录userdel 用户名# 删除用户及其家目录userdel -r 用户名 一般删除用户都会保留家目录 （4）查看用户123456# 查看指定用户信息id 用户名# 查看当前用户whomi （5）切换用户12# 切换用户su 用户名 如果使用exit的话，会退回先前的用户 1.3 组管理指令12345678910# 创建组groupadd 组名# 删除组groupdel 组名# 修改用户所属组usermod -g 组名 用户名 1.4 用户和组的相关文件 （1）用户配置文件 路径：/etc/passwd 用户的配置文件，记录用户的各种信息 （2）口令配置文件 路径：/etc/shadow 保存用户的密码信息，但是被加密过 （3）组配置文件 路径：/etc/group 组的配置文件，里面记录Linux包含的组的信息","categories":[],"tags":[]},{"title":"【工作技能】Excel处理","slug":"【工作技能】Excel处理","date":"2021-04-10T07:41:53.000Z","updated":"2021-04-13T09:15:15.859Z","comments":true,"path":"2021/04/10/【工作技能】Excel处理/","link":"","permalink":"https://letere-gzj.github.io/2021/04/10/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD%E3%80%91Excel%E5%A4%84%E7%90%86/","excerpt":"关于Java如何操作Excel的读写","text":"关于Java如何操作Excel的读写 1 Excel处理1.1 相关技术 Apache POI easyExcel 2 POI2.1 介绍 官网：https://poi.apache.org/ POI提供API给Java程序对Micorsoft Office格式档案读和写的功能 2.2 基本功能 HSSF – 提供读写 Microsoft Excel 格式方案的功能（03版excel） XSSF – 提供读写Microsoft Excel OOXML格式档案的功能（07版excel） HWPF – 提供读写Microsoft Word 格式档案的功能 HSLF – 提供读写Microsoft PowerPoint 格式档案的功能 HDGF – 提供读写Microsoft Visio 格式档案的功能 2.3 Excel内容划分 2.4 Excel写入 （1）依赖导入12345678910111213&lt;!-- apache-poi：处理office文件（03版excel-xls） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- apache-poi (07版excel-xlsx) --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt;&lt;/dependency&gt; （2）写入代码1234567891011121314151617181920212223@Testpublic void wirte03Test() throws Exception&#123; //1、创建03版工作簿 Workbook workbook = new HSSFWorkbook(); //2、创建工作表 Sheet sheet = workbook.createSheet(&quot;测试表&quot;); //3、创建单元格 Row row0 = sheet.createRow(0); //行 Cell cell = row0.createCell(0);//列 //第一行第一列，对应excel的(1， A)单元格 //4、写入数据 cell.setCellValue(&quot;Up主名单&quot;); //5、将工作簿存储到磁盘上 FileOutputStream fos = new FileOutputStream(&quot;./src/main/resources/excel/03Excel.xls&quot;); //创建流 workbook.write(fos); //写入磁盘 fos.close(); //关闭流&#125;//03与07基本一致，创建对象该为XSSFWorkBook，存储文件后缀名改为xlsx 2.5 大数据写入 （03版）HSSF 优点：过程中写入缓存，不操作磁盘，最后一次性写入磁盘，速度快 缺点：最多处理65536行，否则会抛出异常12345678910111213141516171819202122@Testpublic void writeBig03Test() throws Exception &#123; //1、创建工作簿 Workbook workbook = new HSSFWorkbook(); //2、创建工作表 Sheet sheet = workbook.createSheet(&quot;测试表&quot;); //3、循环写入数据 for(int rowNum = 0; rowNum &lt; 65536 ; rowNum ++) &#123; Row row = sheet.createRow(rowNum); for (int cellNum = 0 ; cellNum &lt; 5 ; cellNum++) &#123; Cell cell = row.createCell(cellNum); cell.setCellValue(&quot;( &quot; + rowNum + &quot;, &quot; + cellNum + &quot; )&quot;); &#125; &#125; //4、写入磁盘 FileOutputStream fos = new FileOutputStream(&quot;./src/main/resources/excel/writeBig03.xls&quot;); workbook.write(fos); fos.close();&#125; （07版）XSSF 优点：处理的数据更多 缺点：写数据非常慢，非常消耗内存，会发生内存溢出 （07版升级）SXSSF 优点：可以写非常大的数据量，写数据的速度更快，占用更少内存 缺点：过程会产生临时文件，需要清理临时文件（默认100条记录保存在内存，超过会将前面数据写入临时文件，可以通过带参创建对象时，带定义内存保存数据个数） 通过调用其dispose()方法来处理临时文件，子类特有方法 2.6 Excel读取123456789101112131415161718192021222324@Testpublic void readExcel03Test() throws Exception &#123; //1、创建输入流 FileInputStream fis = new FileInputStream(&quot;./src/main/resources/excel/03Excel.xls&quot;); //2、根据流获取工作簿 HSSFWorkbook sheets = new HSSFWorkbook(fis); //3、获取表1 HSSFSheet sheet = sheets.getSheetAt(0); //4、获取单元格 HSSFRow row = sheet.getRow(0); //行 HSSFCell cell = row.getCell(0); // 列 //5、获取值（注意值的类型） String value = cell.getStringCellValue(); System.out.println(value); //6、关闭流 fis.close();&#125;// 07版读取与03版基本一致，注意文件后缀名以及创建的对象即可 2.7 判断读取数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Testpublic void readExcelType() throws Exception &#123; //1、创建输入流 FileInputStream fis = new FileInputStream(&quot;./src/main/resources/excel/03Excel.xls&quot;); //2、根据流获取工作簿 HSSFWorkbook workbook = new HSSFWorkbook(fis); //3、获取工作表 HSSFSheet sheet = workbook.getSheetAt(0); //4、获取单元格 HSSFRow row = sheet.getRow(1); HSSFCell cell = row.getCell(1); //5、根据数据类型获取数据 CellType cellType = cell.getCellType(); // 获取数据类型（枚举类） /* _NONE(-1), //没有数据 NUMERIC(0), //数字，判断是否普通数字还是日期 STRING(1), //字符串 FORMULA(2), //公式 BLANK(3), //空 BOOLEAN(4), //布尔型 ERROR(5); //错误 */ switch (cellType) &#123; //switch对枚举类进行分支选择读取 case _NONE: break; case NUMERIC: if(DateUtil.isCellDateFormatted(cell)) &#123; //判断是否日期 Date date = cell.getDateCellValue(); System.out.println(date); &#125;else &#123; double num = cell.getNumericCellValue(); System.out.println(num); &#125; break; case STRING: String value = cell.getStringCellValue(); System.out.println(value); break; case FORMULA: try &#123; value = String.valueOf(cell.getNumericCellValue()); &#125; catch (IllegalStateException e) &#123; value = String.valueOf(cell.getRichStringCellValue()); &#125; System.out.println(value); break; case BLANK: break; case BOOLEAN: boolean bool = cell.getBooleanCellValue(); System.out.println(bool); case ERROR: break; &#125; //6、关闭流 fis.close();&#125; 3 EasyExcel3.1 介绍 EasyExcel是阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称 EasyExcel能大大减少占用内存的主要原因在解析Excel时没有讲文件数据一次性全部加载到内存中，而是从磁盘上一行行读取数据，逐个解析 官网：https://github.com/alibaba/easyexcel 官方文档：https://www.yuque.com/easyexcel/doc/easyexcel 3.2 简单写入 （1）依赖引入123456&lt;!-- alibaba-easyExcel：excel处理 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.8&lt;/version&gt;&lt;/dependency&gt; （2）创建实体类1234567891011@Datapublic class Person &#123; @ExcelProperty(&quot;姓名&quot;) //表标题 private String name; @ExcelProperty(&quot;性别&quot;) private String sex; @ExcelIgnore //忽略字段 private Integer age;&#125; （3）写入数据123456789101112131415@Testpublic void simpleWrite() &#123; //1、创建数据（List集合） List&lt;Person&gt; data = new ArrayList&lt;&gt;(); Person person1 = new Person(); person1.setName(&quot;C酱&quot;); person1.setSex(&quot;女&quot;); data.add(person1); //2、写入数据 String fileName = &quot;./src/main/resources/excel/person.xls&quot;; EasyExcel.write(fileName, Person.class) //文件路径，写入对象 .sheet(0, &quot;表1&quot;) //工作表号，表名 .doWrite(data); //写入数据&#125; 2.3 高级写入2.4 简单读取 （1）创建监听器123456789101112131415public class PersonListener extends AnalysisEventListener&lt;Person&gt; &#123; //easyExcel会一条一条数据进行读取 //读取一条数据调用方法 @Override public void invoke(Person person, AnalysisContext analysisContext) &#123; System.out.println(person); //打印读取到的数据 &#125; //读取完所有数据调用方法 @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; System.out.println(&quot;已全部读取完毕！&quot;); &#125;&#125; （2）读取数据12345678@Testpublic void simpleRead() &#123; //1、读取数据 String fileName = &quot;./src/main/resources/excel/person.xls&quot;; EasyExcel.read(fileName, Person.class, new PersonListener()) //文件路径 对象 监听器 .sheet(0) //工作表 .doRead(); //读取&#125; 2.5 高级读取 （1）读取多表数据 12345public void repeatedRead() &#123; //读取数据 String fileName = &quot;./src/main/resources/excel/person.xls&quot;; EasyExcel.read(fileName, Person.class, new PersonListener()).doReadAll();&#125; 2.4 小结 EasyExcel并没有比较详细的讲解，因为EasyExcel是中国人所写的，有中文文档，读官方文档压力不大，也更加详细，推荐读取官方文档","categories":[{"name":"工作技能","slug":"工作技能","permalink":"https://letere-gzj.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"}],"tags":[]},{"title":"【Linux】vi&vim使用","slug":"【Linux】vi-vim使用","date":"2021-04-09T13:39:20.000Z","updated":"2021-04-09T15:19:14.591Z","comments":true,"path":"2021/04/09/【Linux】vi-vim使用/","link":"","permalink":"https://letere-gzj.github.io/2021/04/09/%E3%80%90Linux%E3%80%91vi-vim%E4%BD%BF%E7%94%A8/","excerpt":"Linux的文本编辑器介绍使用","text":"Linux的文本编辑器介绍使用 1 文本编辑器1.1 介绍 所有的Linux系统都会默认配置vi文本编辑器 vim具有程序编辑能力，可以看做vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计，而且还有代码补完，编译以及错误跳转等功能 1.2 三种模式 （1）正常模式： 打开档案默认就是此模式。在此模式，你可以使用上下左右来控制光标的移动，可以做复制、粘贴、删除等功能 （2）插入模式： 按下i、o、a、r任意一个字母即可进入插入模式，一般按i （3）命令行模式： 使用相关指令，完成读取、存盘、替换、离开vim、显示行号等功能 1.3 模式之间的转换 1.4 常用快捷键123456789101112131415161718192021222324252627282930313233343536373839# 复制【正常模式】yy数字yy #复制多行，例：5yy，copy当前行向下5行# 粘贴【正常模式】p# 删除【正常模式】dd # 删除当前行数字dd #yy同理# 光标定位【正常模式】gg #定位文章顶部G #定位文章底部数字(shitf + g) #定位指定行号，shift是按钮，不是输入shift单词# 撤销【正常模式】u--------------------------------------------------# 查找单词【命令行模式】/关键词 #查找关键词n #查找下一个# 行号设置【命令行模式】set nu #设置行号set nonu #取消行号设置# 退出编辑【命令行】q #退出wq #保存并退出q! #强制退出 更详细的快捷键，请查看：https://www.runoob.com/linux/linux-vim.html","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】Linux远程连接","slug":"【Linux】Linux远程连接","date":"2021-04-09T02:18:25.000Z","updated":"2021-04-09T02:20:10.537Z","comments":true,"path":"2021/04/09/【Linux】Linux远程连接/","link":"","permalink":"https://letere-gzj.github.io/2021/04/09/%E3%80%90Linux%E3%80%91Linux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","excerpt":"Linux远程连接的实现，以及对应的软件介绍","text":"Linux远程连接的实现，以及对应的软件介绍 1 远程操作Linux1.1 介绍 在实际开发中，linux一般都是部署在机房的，并不会在自己公司的电脑中。所以需要软件远程登录到linux，对linux进行操作。 XShell：远程登录到linux的软件，目前比较好的远程登录软件，流畅速度并完美解决中文乱码问题 XFtp：上传文件到linux和从linux上下载文件，基于window平台开发的SFTP、FTP文件传输软件 1.2 软件安装 官网（收费）：https://www.xshellcn.com/ XShell安装：https://www.jb51.net/softs/732916.html XFtp安装：https://www.jb51.net/softs/732920.html 1.3 软件使用 （1）查看软件sshd服务 XShell能够远程访问Linux的前提是：sshd服务正在运行，此服务会监听22端口 查看命令systemctl status sshd.service 若服务未启动，开启命令systemctl start sshd.service （2）查看Linux的IP地址 查看命令ifconfig （3）XShell使用 （4）XFtp使用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【Linux】Linux入门","slug":"【Linux】Linux入门","date":"2021-04-08T13:02:18.000Z","updated":"2021-04-09T15:17:28.352Z","comments":true,"path":"2021/04/08/【Linux】Linux入门/","link":"","permalink":"https://letere-gzj.github.io/2021/04/08/%E3%80%90Linux%E3%80%91Linux%E5%85%A5%E9%97%A8/","excerpt":"linux的初步入门","text":"linux的初步入门 1 linux简介1.1 介绍 linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是集群项目都在使用linux，很多软件公司考虑到开发成本都首选linux，在中国软件公司得到广泛的使用 linux发音：len la s –&gt; 林纳斯（谐音） linux吉祥物：企鹅，名字tux 1.2 主要发行版本 CentOS RedHat Ubuntu Suse 红旗Linux 1.3 学习方向 （1）linux运维工程师：维护服务器，优化服务器，保证服务器正常运行 （2）linux嵌入式工程师：在linux嵌入式系统下做开发 （3）linux下开发项目：将程序部署到linux上 1.4 应用领域 个人桌面领域：比较薄弱，不及windows 服务器领域：最强，linux免费、稳定、高效 嵌入式领域：linux运行稳定、对网络的支持良好，低成本，可以根据需要进行软件裁剪 1.5 linux与Unix关系 Ken tompson通过自己写的B语言开发了Unix系统，但由于B语言功能不是非常完善，所以他跟他另一个好友Dennls richers合作开发C语言，然后通过开发的C语言重写Unix系统，Unix正式诞生 通过Unix系统，开发许多软件，但这些软件都收费并隐藏代码。一名黑客Richard Stallman提出了GNU计划，由Linus Torbalds促进计划，开发出了linux操作系统 1.6 Linux和Windows比较 比较 Window Linux 免费与收费 收费 免费或少许收费 软件与支持 软件的数量和质量都很高，但大部分为收费软件。有微软提供支持和服务 开源自由软件，用户可以修改定制和再发布，由于基本免费，没有资金支持 安全性 经常打补丁 相比window要更安全 使用习惯 图形化，人性化界面，容易上手 虽然有图形化界面，但相比windows还是有所不足，以命令行使用居多，上手稍难 可定制性 封闭性，可定制性差 开源，可定制性强 应用场景 桌面操作系统主要使用windows 大部分软件和服务运行在linux上 2 安装 VM ware是一个在window下运行的虚拟机软件，它可以分配出虚拟空间，用来安装其他的操作系统 CentOS是linux发行版本之一 虚拟机VM ware安装：https://www.jianshu.com/p/94cd017d6996 Linux-CentOS安装：https://zhuanlan.zhihu.com/p/112122692 VM tools 安装： 2.1 网络连接方式 （1）桥连接：子虚拟机的网络ip与主机的网络ip使用同一网段，例如主机ip：192.168.0.10，虚拟机ip：192.168.0.20。同一网段的机器能够互相访问 （2）NAT：子虚拟机网络ip与主机的网络ip不处于同一网段，linux可以访问外网，但外面的机器无法访问到该linux，只有主机可以 （3）主机模式：linux是一个独立的主机，不能访问外网 3 CentOS目录结构3.1 基本介绍 Linux文件系统采用层级式树状目录结构，在此结构中的最上层是根目录”/“，然后再次目录下创建其他目录 在linux世界中，一切皆文件 3.2 目录介绍 /：根目录 /sbin：超级用户能够使用的指令 /lib：系统开机所需要的的基本连接共享库 /dev：类似于windows的设备管理器，把所有的硬件用文件形式存储 /selinux：是一种安全子系统，它能控制程序只能访问特定文件 /tmp：存放一些临时文件 重点目录： /bin：里面存放的是常用的终端指令 /home：存放普通用户的主目录，每个用户都有一个对应目录，目录名为账户名 /root：系统管理员目录 /etc：存放系统管理所需配置文件 /usr：用户的很多应用程序和文件都放在这个目录下，类似windows的progam files目录 /boot：存放启动linux的一些核心文件，包括连接文件以及镜像文件 /media：识别设备（U盘，光驱等等），识别之后，把识别的设备挂载到此目录下 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统，可以将外部的存储挂载在/mnt/上 /opt：给主机安装软件所摆放的目录 /usr/local：另一个给主机额外安装软件的安装目录，一般存放通过编译源码方式安装的程序 /var：存放不断扩充的东西，习惯将经常被修改的目录放在这个目录下 以下目录尽量别动 /proc：一个虚拟的目录，压实系统内存的映射，访问这个目录来获取系统信息 /srv：service缩写，该目录存放一些服务启动之后需要提取的数据 /sys：该目录下安装了linux2.6内核中新出现的一个文件系统 4 基础命令4.1 关机和重启12345678910111213# 关机shutdown -h now shutdown -h 数字 # xx分钟后关机halt # 重启shutdown -r nowreboot# 保存数据sync # 将内存中的数据保存在磁盘上，建议关机或重启前使用 4.2 用户登录和注销123456# 切换用户su 用户名# 用户注销logout","categories":[{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"}],"tags":[]},{"title":"【MySQL】变量&存储过程&函数&流程控制结构","slug":"【MySQL】变量-存储过程-函数-流程控制结构","date":"2021-04-08T01:23:49.000Z","updated":"2021-04-08T01:42:56.799Z","comments":true,"path":"2021/04/08/【MySQL】变量-存储过程-函数-流程控制结构/","link":"","permalink":"https://letere-gzj.github.io/2021/04/08/%E3%80%90MySQL%E3%80%91%E5%8F%98%E9%87%8F-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E5%87%BD%E6%95%B0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/","excerpt":"MySQL最后的一些基础知识","text":"MySQL最后的一些基础知识 1 变量1.1 分类 （1）系统变量 全局变量 会话变量 （2）自定义变量 用户变量 局部变量 1.2 系统变量 变量由系统提供，不是用户定义，属于服务器层面 123456789101112131415161718# 查看全局|会话变量（不写global / seesion 默认为session）show global | session variables;# 模糊查询系统变量show global | session variables like &#x27;%变量值%&#x27;;# 查看特定系统变量select @@global | session.系统变量名;# 系统变量赋值#（1）set global| session 系统变量名 = 值;#（2）set @@global | session.系统变量名 = 值; 全局变量： 作用域：服务器每次启动将为所有的全局变量赋初始值，这对所有的会话有效，但不能跨重启 会话变量： 作用域：仅仅针对当前会话有效 1.3 自定义变量 变量是用户自定义的，不是由系统提供 用户变量： 作用域：针对于当前会话有效 12345678910111213141516# 声明并初始化（三者都可以）set @用户变量名=值;ser @用户变量名:=值;select @用户变量名名:=值;# 赋值set @用户变量名=值;ser @用户变量名:=值;select @用户变量名名:=值;select 字段 into @变量名 from 表;# 使用用户变量select @用户变量名; 局部变量： 仅仅定义在它的begin end中有效 应用在 begin and 中的第一句话 123456789101112131415# 声明declare 变量名 类型;declare 变量名 类型 default 值;# 赋值（注意是否带@）set 局部变量名=值;ser 局部变量名:=值;select @局部变量名名:=值;select 字段 into 局部变量名 from 表;# 使用局部变量select 局部变量名; 1.4 总结 变量 作用域 定义和使用的位置 语法 用户变量 当前会话 会话中的任何地方 必须添加@符号，不用限定类型 局部变量 begin end 中 只能在begin end中，且为第一句话 一般不用添加@符号，需要限定类型 2 存储过程2.1 介绍 存储过程和函数：类是Java中的方法，封装了一系列的执行逻辑 优点：简化操作 2.2 存储过程 定义：一组预先编译好的SQL语句的集合 优点： （1）提高了代码的重用性，一旦编译过一次就不需再次编译 （2）简化操作 （3）减少了编译次数并且减少了和数据库服务器连接次数，提高了效率 参数模式： in：默认值，修饰的参数作为输入，需要调用方传入值 out：该参数作为输入，意思为作为返回值 inout：该参数既可以作为输入，也可以作为输出 12345678910111213141516171819202122# 创建存储过程create procedure 存储过程名(参数列表)begin 存储过程体（一组合法sql，每条sql用;隔开）end 结束标记参数列表：参数模式 参数名 参数类型# 设置结束标记（存储过程结束要用指定结束标记）delimiter 结束标记;# 方法调用call 存储过程名(实参列表) 结束标记# 删除存储过程drop procedure 存储过程名;# 查看存储过程结构show create procedure 存储过程名; 2.3 存储过程演示 （1）in演示 输入班级编号，查询班级名称 （2）out演示 输入学生姓名，返回班级编号 （3）inout演示 输入一个值，返回该值的两倍（简单运算） 3 函数3.1 介绍 函数和存储过程几乎一样，只是返回值有不同 区别： 存储过程：可以有0个返回，或有多个返回。时候做批量插入、批量更新 函数：有且仅有1个返回，适合做处理数据后返回一个结果 3.2 语法12345678910111213141516171819# 创建函数create funciton 函数名(参数列表) returns 返回类型begin 函数体（函数体最后需要return语句）end参数列表：参数名 参数类型# 调用函数select 函数名(实体参数);# 查看函数结构show create function 函数名;# 删除函数drop function 函数名; 3.3 函数演示 传入学生信息，返回学生成绩 若创建函数出现以下错误 解决方法：set global log_bin_trust_function_creators=true 4 流程控制结构4.1 介绍 顺序结构：程序从上往下依次执行 分支结构：程序从两条或多条路径中选一条出执行 循环结构：程序在满足一定条件的基础上，重复执行一段代码 4.2 分支结构 （1）if函数 语法：if(判断表达式, true表达式, false表达式) 解释：判断表达式返回true，就返回true表达式值，否则返回false表达式的值 作用域：任何地方法 （2）case结构 情况1：类似java中的switch语句，一般用于实现等值判断 情况2：类似java中的多重if语句，一般用于实现区间判断 可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end中或begin end的外面 可以作为独立的语句去使用，只能方法begin end中 12345678910111213141516# 情况1（作为语句时，最后要加case）case 变量|表达式|字段when 要判断的值 then 返回值1[语句1]when 要判断的值 then 返回值2[语句2]...else 返回值n[语句n]end [case];# 情况2casewhen 要判断的条件 then 返回值1[语句1]when 要判断的条件 then 返回值2[语句2]...else 返回值n[语句n]end [case]; （3）if结构 实现功能多重分支 应用场景：只能应用在begin end中 12345if 条件1 then 语句1;elseif 条件2 then 语句2;...else 语句n;end if; 4.3 循环控制 分类：while、loop、repeat 循环控制： iterate类似使用continue，结束本次循环，继续下一次 leave类似于break，跳出，结束 （1）while 12345678910# 一般情况while 循环条件 do 循环体end while;# 搭配循环控制使用（需要带标签）标签:while 循环条件 do 循环体end while 标签; （2）loop 一个死循环，需要循环控制来跳出循环 1234# 同while需要使用循环控制要添加标签[标签:]loop 循环体end loop [标签] （3）repeat 类似Java的do while 12345# 与上同理[标签:]repeat 循环体until 结束循环条件end repeat [标签]","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【MySQL】索引&视图&范式","slug":"【MySQL】索引-视图-范式","date":"2021-04-06T14:45:48.000Z","updated":"2021-04-06T14:47:20.926Z","comments":true,"path":"2021/04/06/【MySQL】索引-视图-范式/","link":"","permalink":"https://letere-gzj.github.io/2021/04/06/%E3%80%90MySQL%E3%80%91%E7%B4%A2%E5%BC%95-%E8%A7%86%E5%9B%BE-%E8%8C%83%E5%BC%8F/","excerpt":"MySQL索引、视图、三大范式的学习","text":"MySQL索引、视图、三大范式的学习 1 索引1.1 介绍 索引类似书的目录，通过目录可以快速的找到对应的资源 索引添加在某个字段或某些字段 主键和具有unique约束的字段会自动添加索引 模糊查询会导致索引失效 在数据库方面，查询一张表有两种检索方式： （1）全表扫描 （2）根据索引检索（效率高） 优点：索引通过缩小扫描范围，提高检索效率 缺点：一旦数据发生修改，索引需要重新排序，进行维护；如果数据经常进行DML操作，就不适合使用索引 1.2 使用场景 （1）数据量庞大 （2）索引字段很少DML操作 （3）该字段经常出现在where子句中 1.3 使用12345678910# 创建索引create index 索引名 on 表名(字段名);# 删除索引drop index 索引名 on 表名;# 查看sql执行情况explain sql语句; 1.4 索引底层原理 索引底层采用的数据结构为B + Tree 在创建索引的时候，会自动对该字段的数据进行排序和分区。所以使用索引会同一个个区域寻找，定位该区域后，在该区寻找数据。 索引会直接携带数据的物理地址，当通过索引找到对应的数据时，会直接通过物理地址取出数据，速度快 1.5 索引分类 （1）单一索引：给单个字段添加索引 （2）复合索引：给多个字段联合起来添加1个索引 （3）主键索引：主键会自动创建索引 （4）唯一索引：unique约束的字段会自动创建索引 2 视图2.1 介绍 用不同的角度看待表，即同一张表，可以截取部分字段，作为视图 对视图的CRUD操作，会影响到原表的数据 作用：截取原表的部分字段，提供给其他人进行操作，能对数据原表起到保密作用。 在面对一些隐秘性比较高的系统，一般DBA只提供视图用来进行操作，不提供原表 2.2 使用12345678910# 创建视图（类似表的复制）create view 视图名 as DQL语句;# 更新视图alter view 视图名 as DQL语句;# 删除视图drop view 视图名; 3 DBA命令1234567# 导出数据库/表（导完后该数据库/表会删除）mysqldump 数据库 [表名] &gt; 文件路径\\xxx.sql -u root -p# 导入数据(sql文件)create database xxx;use xxx;source 文件路径 4 数据库设计三范式4.1 设计范式 按照范式设计的表不会出现数据冗余 4.2介绍 第一范式：任何一张表都应该有主键，每个字段的原子性不能再分 第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部分依赖 学生姓名只依赖于学生编号，并不依赖于教师编号，不满足第二范式 解决方法：创建学生表，教师表，关系表三张表来处理多对多关系 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖 班级名称依赖于班级编号，班级标号依赖于学生编号，产生传递依赖 解决方法：创建一个班级表，用来保存班级名称。原表只有班级编号。解决一对多关系 口诀：一对多，两张表，多的加外键；多对多，三张表，关系表加外键; 在实际开发中，以满足客户的需求为主，有的时候会拿冗余度换区执行速度。一张表的执行速度，永远大于两张表 4.3 一对一设计 举例：用户信息一般分为两部分，用户登录信息和用户详细信息，用户登录信息系只保留用户名和密码，用户详细信息保留用户的其他信息 （1）主键共享 用户详细信息表的id，即是主键，也是外键。晚间关联用户登录表的id （2）添加额外外键（一对多设计） 用户详细信息表额外字段名关联用户登录表id，约束为外键和唯一约束","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【MySQL】事务&TCL","slug":"【MySQL】事务-TCL","date":"2021-04-06T10:58:25.000Z","updated":"2021-04-06T11:03:24.460Z","comments":true,"path":"2021/04/06/【MySQL】事务-TCL/","link":"","permalink":"https://letere-gzj.github.io/2021/04/06/%E3%80%90MySQL%E3%80%91%E4%BA%8B%E5%8A%A1-TCL/","excerpt":"TCL：Transaction Controller Language，事务控制语言","text":"TCL：Transaction Controller Language，事务控制语言 1 事务1.1 介绍 事务是一个完整的业务逻辑单元，不可再分，保证数据的完整和安全 多条DML语句需要一次性执行，保证同时成功，同时失败，不存在某一条语句执行成功，另一条语句执行失败 举例：转账，A账户转钱，B账户接受前要同时成功或失败。不能A转钱成功，B接受钱失败，导致数据丢失，转走的前丢失 1.2 原理 在开启事务的时候，每执行一条DML语句，不会立刻将执行结果保存在硬盘上，而是放在缓存中 一旦接受到事务commit指令，才会将缓存中的数据保存在硬盘上，然后关闭事务 一旦接收到事务rollback指令，会直接关闭事务，放弃缓存中的数据 1.3 事务特性 事务的四大特性：ACID A：原子性 — 事务是最小的工作单元，不可再分 C：一致性 — 事务保证多条DML语句同时成功或失败 I：隔离性 — 事务A与事务B之间具有隔离 D：持久性 — 数据持久化到硬盘文件 1.4 事务隔离级别 第一级别：读未提交（read uncommitted） 存在两个进行中的事务，在对方事务数据未提交时，另一个事务能够读取未提交的数据 存在读脏读现象，该数据未提交，一旦该事物的数据最后选择回滚，另一个事务读取到的数据是不存在的数据，称为脏读 第二级别：读已提交（read committed） 读取的数据只能够是已提交的数据 存在不可重复读现象，即两个事物，事物A读取数据后，事务B提交了数据，事务A再次读取数据，读取的数据不一致 第三级别：可重复读（repeatable read） 解决了不可重复读，只要事务A没有结束，无论事务B怎么提交数据，事务A读取到的数据都是事务开始前的数据 存在幻读现象，即读取到的数据不是真实的数据，是幻想 第四级别：串行化（serializable） 不允许事务并发，事务一个接一个运行 解决了所有的问题，但是运行效率差 Oracle默认使用读已提交的隔离级别 MySQL默认使用可重复读的隔离级别 1.5 TCL语句12345678910111213141516171819202122# 查询当前MySQL的事务隔离级别select @@transaction_isolation;# 设置当前窗口的MySQL事务隔离级别set transaction isolation level 隔离级别（read uncommitted ...）;# 设置数据库MySQL全局事务隔离级别set global transaction isolation level 隔离级别;# 开启事务start transaction;# 事务提交commit;# 事务回滚rollback;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【MySQL】DDL使用","slug":"【MySQL】DDL使用","date":"2021-04-06T08:44:19.000Z","updated":"2021-04-06T08:48:34.796Z","comments":true,"path":"2021/04/06/【MySQL】DDL使用/","link":"","permalink":"https://letere-gzj.github.io/2021/04/06/%E3%80%90MySQL%E3%80%91DDL%E4%BD%BF%E7%94%A8/","excerpt":"DDL：Data Denfinition Language，数据定义语言","text":"DDL：Data Denfinition Language，数据定义语言 1 创建表1.1 语法格式123456create table 表名 ( 字段名1 数据类型 约束, 字段名2 数据类型 约束, 字段名3 数据类型 约束, ...); 一般表名都是以t_或tbl_来表示这是表，与后面学习的视图进行区分 1.2 常用数据类型 类型 描述 char(长度) 定长字符串，存储空间大小固定，适合作为主键或外键 varcher(长度) 变长字符串，存储空间等于实际数据空间 double(有效数字位数, 小数位) 数值型 float(有效数字位数, 小数位) 数值型 int(长度) 整型 bigint(长度) 长整型 date 日期型：年月日 datetime 日期型：年月日 时分秒 毫秒 blob 二进制大对象(binart large object) clob 字符大对象(character large object) char 和 varchar 选择 char固定长度，无论传入数据的字符串多长，都会分配指定长度的空间来存储 varchar可变长度，根据传入的数据的大小，分配对应的空间进行存储 一般情况都是使用varchar，但例如性别只有男、女两种选项就可以使用char(1)的数据类型，速度较快 1.3 表的复制12create table 表名 as 查询结果 将查询结果作为一张新表并创建出来，该表的数据为查询结果数据 1.4 常见约束 （1）非空约束（not null） 不允许数据为null 123create table 表名( 字段名 数据类型 not null) （2）唯一性约束（unique） 修饰的字段不能重复，但可以为null 123456789101112# 正常使用（列级约束）create table 表名( 字段名 数据类型 unique)# 多字段联合唯一性（表级约束）# （不能字段1和字段2完全一样，允许字段1一样，字段2不一样）create table 表名( 字段名1 数据类型, 字段名2 数据类型, unique(字段名1,, 字段名2)) （3）主键约束（primary key） 主键不能为空，并不能重复 主键是一个行数据的唯一标识，类似身份证作用 一张表只能有一个主键 1234567891011# 单一主键create table 表名( 字段名 数据类型 primary key [auto_increment(主键自增)])# 复合主键（不建议用，违背表的三范式）create table 表名( 字段名1 数据类型, 字段名2 数据类型, primary key(字段名1, 字段名2)) （4）外键约束（foregin key） 添加外键约束，规定该字段的值是其他表上的某字段的值，不能随意填写 外键可以为null 外键引用的键必须要有唯一性 使用外键的表称为子表，被引用外键的表被称为父表 注意： 删除数据的时候，先删除子表，再删除父表 添加数据的时候，先添加父表，再添加子表 创建表的时候，先创建父表，再创建子表 删除表的时候，先删除子表，再删除父表 12345678910# 父表create table 父表( 字段1 数据类型)# 子表create table 子表( 字段2 数据类型, foregin key(字段2) references 父表(字段1)) 1.5 存储引擎 存储引擎：表的存储方式 123create table 表名( xxxxxx)engine = 存储引擎 default charset = 字符集; show engines \\g：可查看mysql支持的存储引擎 常用存储引擎 MyISAM： 是mysql最常用的存储引擎，但不是默认引擎 使用是三个文件表示每个表：（1）格式文件-存储表结构的定义(frm)；（2）数据文件-存储表行的内容（MYD）；（3）索引文件-存储表上索引（MYI） 优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率 缺点：不支持事务 InnoDB： 表的结构存储在frm文件中，数据逻辑存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读 InnoDB在MySQL数据库崩溃之后提供自动恢复机制 优点：支持事务，行级锁，外键，数据的安全得到保障 MEMORY： （1）每个表均以.frm格式的文件表示 （2）表数据及索引被存储在内存中 （3）表级锁机制 （4）不能包含text或blob字段 2 修改表 （1）修改字段名 12alter table 表名change column 旧字段名 新字段名 数据类型; （2）修改字段的数据类型 或 约束 12alter table 表名modify column 字段名 新数据类型; （3）添加或删除字段 1234567# 添加字段alter table 表名add column 字段名 数据类型 约束;# 删除字段alter table 表名drop column 字段名; （4）修改表名 12alter table 表名rename to 新表名 （5）总结 12alter table 表名add|drop|modify|change column 列名 【列类型 约束】; 3 删除表 格式：drop table 表名 删除常用指令：drop table if exists 表名，如果表名存在才删除","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【MySQL】DML使用","slug":"【MySQL】DML使用","date":"2021-04-05T07:42:01.000Z","updated":"2021-04-05T07:48:02.522Z","comments":true,"path":"2021/04/05/【MySQL】DML使用/","link":"","permalink":"https://letere-gzj.github.io/2021/04/05/%E3%80%90MySQL%E3%80%91DML%E4%BD%BF%E7%94%A8/","excerpt":"DML：Data Manipulation Language，数据操纵语言，即增删改","text":"DML：Data Manipulation Language，数据操纵语言，即增删改 1 数据插入12insert into 表名(字段名1, 字段名2, 字段名3...)values(值1, 值2, 值3...) 要求：字段的数量和值的数量相同，并且数据类型要对应相同 插入语句的字段名可以不添加，默认是表的所有字段 支持一次&amp;插入多行数据，用 , 来进行隔开 可以将查询结果插入到一张表中 1insert into 表名 查询结果 2 数据修改123update 表名set 字段名1 = 值1, 字段名2 = 值2...where 条件 注意：不添加条件，会默认修改整张表的所有数据 3 数据删除12delect from 表名where 条件 注意：不添加条件，会默认删除整张表的所有数据 删除大表数据： 由于数据库删除存在事务回滚，一旦出错，可以恢复所有数据，所以删除数据庞大的表时速度比较慢 若要快速删除，则删除时不保留事务回滚 truncate table 表名：直接只保留表头，表的数据全部剪掉，无法回滚","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【MySQL】DQL高级","slug":"【MySQL】DQL高级","date":"2021-04-05T06:00:11.000Z","updated":"2021-04-05T06:02:48.521Z","comments":true,"path":"2021/04/05/【MySQL】DQL高级/","link":"","permalink":"https://letere-gzj.github.io/2021/04/05/%E3%80%90MySQL%E3%80%91DQL%E9%AB%98%E7%BA%A7/","excerpt":"DQL查询语句的高级使用","text":"DQL查询语句的高级使用 1 连接查询（级联查询）1.1 介绍 在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张变联合查询取出最终的结果 1.2 分类 （1）年代划分 SQL92（老） SQL99（比较新） （2）连接方式划分 内连接： 等值连接 非等值连接 自连接 外连接 左外连接（左连接） 右外连接（右连接） 全连接（少用） 1.3 笛卡尔乘积现象 当两张表进行连接查询，如果不设置过滤条件(where)，查询出来结果个数为x*y 此现象为表连接查询的原理：两张表数据相乘，再进行过滤，最后得出想要的数据 上面连接查询方法为SQL92，不建议使用 1.4 内连接 内连接：假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录都查询出来。AB量表没有主副之分，两张表时平等的 1234select 字段from 表1inner join 表2on 连接过滤条件 现在普遍使用SQL99语法，因为99将连接过滤条件和连接后的过滤条件进行了分离，阅读性更好。 SQL92若要补充连接后的where条件，只能使用and来连接，使得与连接过滤条件混合 inner join 中的 inner 可以省略 （1）等值连接 顾名思义：连接过滤条件是用等于表达式进行连接 （2）非等值连接 与等值连接相反，连接过滤条件并不是用等于表达式进行连接 （3）自连接 自连接的特点：一张表当作两张表来进行连接 例：员工的领导编号 = 领导的员工编号，两个编号都在同一张员工表上 1234select a.ename &#x27;员工名&#x27;, b.ename &#x27;领导名&#x27;、from emp ainner join emp bon a.mgr = b.empno; 1.5 外连接 外连接：假设A和B表进行连接，使用外连接的话，AB两张表有一张表时主表，一张表是附表，主要查询主表中的数据，捎带查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出null与之匹配 1234select 字段from 表1left|right outer join 表2on 连接条件 左外连接（左连接）：表示左边的表是主表，使用left outer join 右外连接（右连接）：表示右边的表时主表，使用right outer join 和内连接一样，外连接的outer可省略 1.6 多表之间连接1234567select 字段from 表1join 表2on 连接条件join 表3on 连接条件...以此类推 2 子查询2.1 介绍 子查询：select语句当前嵌套select 语句，被嵌套的select语句为子查询 子查询可以出现在select、from、where后面 2.2 where使用子查询 使用思想：将子查询得出的结果理解为一个参数值 例：求出高于平均分的学生信息 2.3 from使用子查询 使用思想：将子查询得出的结果理解为一张新表 例：求出每个班级平均分的分数等级 2.4 select使用子查询 使用思想：将子查询得出的结果理解为一个带逻辑处理的字段 例：求出每个学生的班级名称（连接查询可以解决） 3 Union Union将两张表合成为一张表 合成要求：两张表的列数要一样 合成后的字段名，按照最前面合成的表 4 limit limit非常常用，一般用于分页查询 limit是mysql特有的，其他数据库中没有，不通用。（Oracle中有一个相同的机制，叫做rownum） limit作用：取结果集的部分数据 limit在sql语句中执行顺序为最后 1234limit [startIndex], [length]startIndex：数据起始位置length：数据长度 startIndex可以省略，默认从0开始","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【MySQL】DQL基础","slug":"【MySQL】DQL基础","date":"2021-04-04T07:02:18.000Z","updated":"2021-04-04T07:32:03.039Z","comments":true,"path":"2021/04/04/【MySQL】DQL基础/","link":"","permalink":"https://letere-gzj.github.io/2021/04/04/%E3%80%90MySQL%E3%80%91DQL%E5%9F%BA%E7%A1%80/","excerpt":"DQL：Data Query Language，数据查询语句学习","text":"DQL：Data Query Language，数据查询语句学习 1 简单查询1.1 基础12select 字段名1,字段名2,字段名3... from 表名; sql语句结尾要用;结尾 sql不区分大小写 *表示所有字段名，但实际开发不建议使用，效率较低 1.2 数学运算12select 字段名 +|-|*|/ 数字 from 表名; sql语句支持简单的数学运算 数据运算时有Null参与运算，无论怎么运算，最后的值都为Null 1.3 起别名12select 字段名 as 新字段名 from 表名; sql可以对查询的字段起新的字段名 标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，但不建议用，其他数据库不通用 as关键字可以省略 1.4 去重12select distinct 字段名from 表名; distinct只能出现在查询字段名的最前面，如果有多个字段，表示联合去重 2 条件查询123select 字段...from 表名where 条件; 2.1 逻辑运算 字段名 &gt; | &lt; | &gt;= | &lt;= | &lt;&gt; 参数 2.2 between…and… 字段名 between 参数1 and 参数2 between..and..是闭区间 2.3 is null 或 is not null 字段名 is null | is not null null为空，不存在值，不能够用=来衡量，要用is null 或 is not null 2.4 and 或 or where 条件1 and | or 条件2 and的优先级大于or，会与and连接的判断为一类，可以用括号来区分 例：where 条件1 and (条件2 or 条件3)，会先满足条件1，再寻找满足条件2或3的数据 例：where 条件1 and 条件2 or 条件3，会寻找满足条件1和2，或满足条件3的数据 2.5 in 或 not in 字段名 in | not in (参数1, 参数2, 参数3...)会寻找字段名 = | != 括号内参数的数据 in 是 or的一个简写 例：name = &#39;AAA&#39; or name = &#39;BBB&#39;，查询名字为AAA或BBB的数据 例：name in (&#39;AAA&#39;, &#39;BBB&#39;)，等同于上面sql条件 2.6 like-模糊查询 修饰符：%-任意多个字符，_任意一个字符 字段名 like &#39;%|_参数%|_&#39;，可以不添加修饰符，变成= 若要查询参数带”_ “字符的数据，需要”&quot;进行字符转译：name like &#39;%\\_%&#39; 3 数据排序123select 字段名from 表名order by 字段名|查询字段名的列数 asc|desc order by 字段名，通过指定字段名进行排序，默认升序，可以后接asc（升序） 或 desc（降序） 来控制 注意： 可以支持多个字段进行排序，order by 字段名1 acs|desc, 字段名2 asc|desc，向按照字段名1进行排序，如果字段名1相同的数据，按照字段名2进行排序 4 单行处理函数4.1 ifnull() 格式：ifnull(字段名，参数) 当前该字段名的值为null，就转变为指定参数值 例子：select if(grade, 0) from examstudent，当成绩为null时，默认为0 5 分组函数 分组函数 解释 count 计数 sum 求和 avg 平均值 max 最大值 min 最小值 select sum(字段名) from 表名：求出表中该字段的总和，其他分组函数使用同样道理 分组函数还有另外的别称：多行处理函数，即将多行的数据处理为一行 分组函数会自动忽略null 分组函数不可直接使用在where后面 6 分组查询6.1 group by group by：按照某个字段或者某些字段进行分组 123select 分组函数(字段名)from 表名group by 字段名 group by 查询的内容只能是分组函数和被分组字段，不能是其他字段，否则报错 sql的执行顺序：from –&gt; group by —&gt; select group by 支持多个字段进行分组，越前字段优先级越高 6.2 having having：对分组之后的数据进行再次过滤 1234select 分组函数(字段名)from 表名group by 字段名having 条件 having是对分组后的数据进行再过滤，所以必须使用group by 后才使用 having的过滤效率不及where，能使用where实现的过滤不要使用having 7 总结 sql书写顺序 123456select xxxfrom xxxwhere xxxgroup by xxxhaving xxxorder by xxx; 书写顺序不能改变，但是可以省略 sql语句的执行顺序：from –&gt; where –&gt; group by —&gt; having —&gt; select –&gt; order by","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【MySQL】MySQL入门","slug":"【MySQL】MySQL入门","date":"2021-04-03T07:51:01.000Z","updated":"2021-04-03T07:55:44.514Z","comments":true,"path":"2021/04/03/【MySQL】MySQL入门/","link":"","permalink":"https://letere-gzj.github.io/2021/04/03/%E3%80%90MySQL%E3%80%91MySQL%E5%85%A5%E9%97%A8/","excerpt":"MySQL的简单入门","text":"MySQL的简单入门 1 数据库介绍1.1 数据存储 （1）未引入数据库前： 通过IO流将数据库序列化存储到本地文件中，来对数据进行存储 通过IO流将本地文件反序列化，提取数据到java对象中 （2）引入数据库后： 通过简单的sql数据，即可对数据进行增、删、改、查操作 1.2 常用数据库管理系统 Oracle：传统企业使用居多 MySQL：互联网公司用的多（集群搭建） DB2 Sybase MS SqlServer 2 MySQL安装 安装教程1：https://zhuanlan.zhihu.com/p/37152572 安装教程2：https://blog.csdn.net/missing2011/article/details/81474857 安装教程3：https://jingyan.baidu.com/article/fc07f989bf2cc712ffe51902.html 2.1 MySQL安装测试 （1）MySQL登录 命令行输入mysql -u root -p （2）MySQL退出 命令行输入exit 3 MySQL基础知识3.1 sql、DB、DBMS关系 （1） DB：DataBase（数据库，数据库实际实际上再硬盘上是以文件的形式存在） （2）DBMS：DataBase Management System（数据库管理系统，常见有：mysql orcal…） （3）SQL：Structured Query Language（结构化查询语言，一门标准通用的语言，适用所有的数据库产品） SQL属于高级语言。只要能看懂英文，写出来的sql语句，可以读懂意思 SQL语句执行时，有DBMS进行编译，在进行执行 三者关系：DBMS编译SQL，来操作DB中的数据 3.2 表的含义 表：Table，是数据库的基本组成单位，所有的数据都以表格的形式组织，目的是可读性强。 一个表拥有行和列： 行：数据（Data） 列：字段（Column） 一个字段包含一下属性：字段名、数据类型、相关约束 3.3 SQL语句分类 （1）DQL：Data Query Language，数据查询语言，凡是select语句都是DQL （2）DML：Data Manipulation Language，数据操纵语言，对数据进行增（insert）、删（delete）、改（update） （3）DDL：Data Definition Language，数据定义语言，对表结构进行增（create）、删（drop）、改（alter） （4）TCL：Transaction Control Language，事务控制语言，提交事务（commit），回滚事务（rollback） （5）DCL：Data Control Language：数据控制语言，授权（grant），撤销权限（revoke） 3.4 sql脚本文件 sql脚本文件：以sql结尾的文件。里面编写大量的sql语句，用来以另外一种形式存储数据库。 4 MySQL常用指令1234567891011121314151617181920212223242526272829303132333435# mysql登录mysql -u root -p# 查看数据库show databases;# 创建数据库create database 数据库名;# 使用（切换）数据库use 数据库名;# 查看当前数据库中的表show tables;# 查看创建表的sql语句show create table 表名;# 执行sql文件sources sql文件路径;# 查看表结构desc 表名;# 查询当前使用的数据库select database();# 查询mysql版本select version();# 终止sql语句\\c# 退出mysqlexit","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"}],"tags":[]},{"title":"【SpringCloudAlibaba】Sentinel实现熔断和限流","slug":"【SpringCloudAlibaba】Sentinel实现熔断和限流","date":"2021-03-19T03:28:23.000Z","updated":"2021-03-19T09:46:02.897Z","comments":true,"path":"2021/03/19/【SpringCloudAlibaba】Sentinel实现熔断和限流/","link":"","permalink":"https://letere-gzj.github.io/2021/03/19/%E3%80%90SpringCloudAlibaba%E3%80%91Sentinel%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E5%92%8C%E9%99%90%E6%B5%81/","excerpt":"Sentinel用于服务降级，熔断，限流，类似Hsytrix","text":"Sentinel用于服务降级，熔断，限流，类似Hsytrix 1 Sentinel介绍1.1 简介 Github：https://github.com/alibaba/Sentinel Sentinel（哨兵）：功能类似我们之前学习的hystrix 1.2 下载和安装 下载地址：https://github.com/alibaba/Sentinel/tags ，下载sentinel-dashboard-1.8.1.jar 下载的是一个jar包，直接通过java -jar jar包名即可 但默认启动的端口是8080，要保证该端口没有被占用 也可以通过java -Dserver.port=端口号 -jar jar包名，来修改sentinel的启动端口 访问：http://localhost:8080 ，进入后台界面，登录名密码都为sentinel 1.3 使用 spring官网使用教程：https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_sentinel 2 初始化演示工程 （1）创建项目cloudalibaba-sentinel-service8401，此项目注册到nacos，并被sentinel保护 （2）依赖引入1234567891011121314151617181920&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web监控 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- nacos 服务发现 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- sentinel 服务降级 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; （3）修改配置文件123456789101112131415161718192021server: port: 8401spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 # nacos服务地址 sentinel: transport: dashboard: localhost:8080 # sentinel服务地址 port: 8719 # 假如端口被占用，自动从8719开始，依次+1，直至未被占用# 暴露服务信息management: endpoints: web: exposure: include: &quot;*&quot; （4）主启动类1234567@SpringBootApplication@EnableDiscoveryClient //注册到nacospublic class SentinelServiceMain8401 &#123; public static void main(String[] args) &#123; SpringApplication.run(SentinelServiceMain8401.class, args); &#125;&#125; （5）Controller层12345678910111213@RestControllerpublic class FlowLimitController &#123; @GetMapping(&quot;/testA&quot;) public String testA() &#123; return &quot;---- testA&quot;; &#125; @GetMapping(&quot;/testB&quot;) public String testB() &#123; return &quot;---- testB&quot;; &#125;&#125; （6）测试 项目启动，因为sentinel使用懒加载，需要访问接口后，才会显示监控对象 3 流控规则3.1 基本介绍 （1）资源名：唯一名称，默认请求路径 （2）针对来源：针对调用者进行限流，填写服务名（默认default，不区分来源） （3）阈值类型/单机阈值： QPS（每秒钟的请求数量）：当调用该api的QPS达到阈值时，进行服务限流 线程数：当调用该api达到阈值的时候，进行限流 （4）是否集群 （5）流控模式： 直接：api达到限流条件时，直接限流 关联：当关联的资源达到阈值时，限流自己 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流） （6）流控效果 快速失败：直接失败，抛出异常 Warm Up：根据codeFactor（冷加载因子，默认13）值，从阈值/codeFactory，经过预热时长，才达到设置的QPS阈值 排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效 3.2 流控模式 （1）QPS-直接-快速失败（默认） （2）线程数-直接-快速失败 当请求的线程数超过阈值，则会进行报错 （3）关联 当关联的资源达到阈值是，就限流自己 同一个服务，不同请求路径，其中B路径请求达到阈值，但是A进行限流 即B惹事，A挂了 （4）链路 https://blog.csdn.net/qq_31155349/article/details/108478190 注意spring-cloud-alibaba版本，2.1.1之前和之后 3.3 流控效果 （1）直接失败 前面出现过不多赘述 有兴趣可查看源码：com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController （2）warm up（预热） 平时网址访问量很少，突然一瞬间访问量激增，为了不让服务器崩溃，需要逐步提升访问量，然后再达到最大值，形成循环渐进的效果 公式：初始阈值：阈值/冷加载因子（默认3），一旦访问量达到预热启动值，在达到设置的预热时间后，阈值达到最大值 效果：刚开始阈值为初始阈值，比较低，会出现报错。但系统也因此提高阈值，慢慢的阈值边到最大，就不会报错 （3）匀速排队 阈值类型只能选择QPS 控制请求通过的是渐渐间隔，避免突然一秒有大量请求，达到了阈值，只能直接报错。但排队不会直接报错，而是限定了当前秒内只能通过多少个请求，其余线程在后面稍等，当请求等待时间超过我们设置的时间，则返回限流信息 4 降级规则4.1 基本介绍 慢调用比例： 慢调用，请求的响应时间大于最大响应时间。 当单位时长内，请求数大于设置的最小请求数，且慢调用比例大于阈值，则进行熔断。经过熔断时长后进入半开放状态。下一个请求响应时间小于阈值，结束熔断，否则继续熔断 异常比例（秒级）： QPS &gt;= 5 且异常比例（秒级统计）超过阈值，触发降级（熔断）；时间窗口（熔断时长）结束后，进入半开放阶段，若请求成功，关闭降级（熔断），否则继续 异常数（分钟级）： 异常数（分钟统计）超过阈值，触发降级（熔断）；时间窗口（熔断时长）结束后，进入半开放阶段，若请求成功，关闭降级（熔断），否则继续 4.2 慢调用比例 4.3 异常比例 4.4 异常数 5 热点规则5.1 基本介绍 热点参数限流，会统计请求中传入的参数，若此参数为热点参数，则对此请求进行限流 5.2 代码演示 （1）Controller层1234567891011@GetMapping(&quot;/hotKey&quot;)@SentinelResource(value = &quot;hotKey&quot;, blockHandler = &quot;deal_hotKey&quot;) //value: 唯一标识，一般与路径相同，blockHandler：服务降级方法public String hotKetTest(@RequestParam(value = &quot;p1&quot;, required = false) String p1, @RequestParam(value = &quot;p2&quot;, required = false) String p2) &#123; return &quot;--- hot-key-test&quot;;&#125;public String deal_hotKey(String p1, String p2, BlockException blockException) &#123; //参数要一致，并且需要BlockException参数 return &quot;你正在访问的是热点资源，请稍后访问！&quot;;&#125; （2）配置热点 （3）测试：访问http://localhost:8401/htoKey?p1=a ，当请求超过每秒一次，会返回我们自定义的fallback方法 5.3 参数例外项 有时候，我们希望热点参数的特定值，可以有不同的阈值，来进行分配 5.4 问题提出 @SentinelResource 的服务降级方法，仅对于sentinel-web界面配置的内容进行服务降级，例如QPS是否达到阈值之类；但不会对Java运行异常进行服务降级，后面会教如何解决 6 系统规则 Sentinel系统自适应限流从整体维度对应用入口流量进行控制 阈值类型 说明 LOAD 仅对Linux/Unix-like机器生效，当系统的load超过启发值，且系统当前的并发线程超过估算的系统容量才会触发系统保护 RT 当单台机器上所有入口流浪的平均RT达到阈值触发保护机制 线程数 所有入口流量的并发线程数达到阈值触发保护机制 入口QPS 当所有入口流量的QPS达到阈值触发保护机制 CPU使用率 当系统CPU使用率超过阈值触发系统保护机制 7 @SentinelResource注解7.1 资源名限流 和 url限流 （1）按资源名限流 @SentinelResource能给限流方法起一个资源名，如果以资源名来限流，系统不会调用默认的限流返回方法，会直接页面报错，所以在使用的时候要配置限流返回方法 @SentinelResource(value = &quot;资源名&quot;, blockHandler = &quot;限流返回方法名&quot;) 限流返回方法的参数要与原方法参数一样，并额外多出BlockException类型的参数 （2）按url限流 按url地址进行限流，系统会调用默认的限流返回方法，就算配置了@SentinelResource也是调用默认的限流返回方法，但是默认的限流返回方法，没有任何重要的消息，不太实用 7.2 限流返回方法与业务逻辑代码分离 （1）创建一个自定义的处理类123456public class CustomerBlockHandler &#123; public static String blockHandler1(BlockException blockException) &#123; //必须为静态方法 return &quot;customerHandler：这是服务降级返回的信息！&quot;; &#125;&#125; （2）Controller层引入服务降级方法1234567891011@RestControllerpublic class RateLimitController &#123; @GetMapping(&quot;/handler&quot;) @SentinelResource(value = &quot;handler&quot;, blockHandlerClass = CustomerBlockHandler.class, //自定义处理类 blockHandler = &quot;blockHandler1&quot;) //处理类中的处理方法 public String handler() &#123; return &quot;业务与降级处理分离测试！&quot;; &#125;&#125; 7.3 fallback fallback 与 blockHandler的区别 fallback处理的是Java运行的异常，而blockHandler是处理限流规则出现的异常 使用例子： 123456789101112@GetMapping(&quot;/getPayment&quot;)@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;fallbackHandler&quot;)public String getPayment(@RequestParam(value = &quot;p1&quot;, required = false) String p1) &#123; if(p1 != null) &#123; throw new RuntimeException(&quot;Java业务出现异常！，非限流问题！&quot;); &#125; return &quot;调用成功！&quot;;&#125;public String fallbackHandler(String p1, Throwable e) &#123; return e.getMessage();&#125; 正常不带参访问，没出现异常。但带p1参数进行方法，异常触发fallback处理方法，页面不会报错 7.4 其他参数 exceptionToIgnore，忽略异常 例子：@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;fallbackHandler&quot;, exceptionsToIgnore = &#123;RuntimeException.class&#125;) 当发生RuntimeException时，Sentinel会忽略此异常，不会为此异常寻找其服务降级方法，而是直接页面报错 8 Sentinel与OpenFeign整合 除了使用Sentinel的@SentinelResource来实现服务降级，还可以使用OpenFeign来实现服务降级 （1）引入OpenFegin依赖12345&lt;!-- openfeign --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; （2）修改yaml配置123feign: sentinel: enabled: true #开启sentinel对feign的支持 （3）主启动类 12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClients //使用Feignpublic class OrderMain84 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain84.class, args); &#125;&#125; （3）Service层 12345678910111213141516@Component@FeignClient(value = &quot;cloudAlibaba-provider-payment&quot;, fallback = FeignPaymentFallback.class) //fallback为自定义服务降级类，会自动根据同一方法名来寻找服务降级方法public interface FeignPaymentService &#123; @GetMapping(&quot;/getPayment&quot;) public String getPayment();&#125;@Componentpublic class FeignPaymentFallback implements FeignPaymentService&#123; @Override public String getPayment() &#123; return &quot;这是Feign的服务降级方法！&quot;; &#125;&#125; （4）Controller层 123456789101112@RestControllerpublic class OrderController &#123; //----------------Feign---------------- @Autowired private FeignPaymentService feignPaymentService; @GetMapping(&quot;/consumer/getFeignPayment&quot;) public String getFeignPayment() &#123; return feignPaymentService.getPayment(); &#125;&#125; （5）测试： 访问：http://localhost:84/consumer/getFeignPayment 测试服务降级：将服务端关闭，重新访问上面链接，出现服务降级信息 9 Sentinel持久化 （1）持久化到本地文件：https://blog.csdn.net/weixin_43831049/article/details/113647015 （2）持久化到nacos：https://zhuanlan.zhihu.com/p/283114605","categories":[{"name":"SpringCloudAlibaba","slug":"SpringCloudAlibaba","permalink":"https://letere-gzj.github.io/categories/SpringCloudAlibaba/"}],"tags":[]},{"title":"【SpringCloudAlibaba】Nacos服务注册和配置中心","slug":"【SpringCloudAlibaba】Nacos服务注册和配置中心","date":"2021-03-17T15:33:07.000Z","updated":"2021-03-18T08:40:49.417Z","comments":true,"path":"2021/03/17/【SpringCloudAlibaba】Nacos服务注册和配置中心/","link":"","permalink":"https://letere-gzj.github.io/2021/03/17/%E3%80%90SpringCloudAlibaba%E3%80%91Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/","excerpt":"用nacos来取代eurka作为服务注册中心，取代config作为配置中心","text":"用nacos来取代eurka作为服务注册中心，取代config作为配置中心 1 Nacos简介1.1 介绍 Nacos：Naming Configuration Service 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台 Nacos就是注册中心 + 配置中心的组合 Nacos = Eureka + Config + Bus 官网：https://nacos.io/zh-cn/ 1.2 功能 替代Eureka做服务注册中心 替代Config做服务配置中心 1.3 Nacos下载与安装 下载地址：https://github.com/alibaba/nacos/tags 演示下载的是windows版，解压后，进入bin文件夹 打卡命令行输入startup -m standalone，意思为单机模式运行，非集群模式 访问网址：http://localhost:8848/nacos ，就可以进入web后台 默认账号密码为：nacos，可进入后台 2 Nacos服务注册中心2.1 服务提供者搭建nacos （1）创建项目cloudAlibaba-provider-payment9001 （2）修改POM（引入依赖）1234567891011&lt;!-- nacos-discovery : 服务注册 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; （3）修改配置文件yaml12345678910server: port: 9001spring: application: name: nacos-provider-payment cloud: nacos: discovery: server-addr: localhost:8848 # nacos web地址 （4）主启动类1234567@SpringBootApplication@EnableDiscoveryClientpublic class NacosProviderMain9001 &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosProviderMain9001.class, args); &#125;&#125; （5）Controller层123456789101112@RestControllerpublic class NacosProviderController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(&quot;/payment/nacos&quot;) public String getPayment() &#123; return &quot;nacos registry -- serverPort：&quot; + serverPort; &#125;&#125; （6）测试：启动项目，访问nacos-web，”服务管理” -&gt; “服务列表” 2.2 IDEA伪集群搭建 如果懒得重新创建一个项目来用集群搭建，可以通过修改IDEA参数来达到伪集群效果 2.3 消费者搭建nacos （1）创建项目cloudAlibaba-consumer-nacos-order83 （2）引入依赖12345678910&lt;!-- nacos-discovery 服务发现 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; （3）修改配置文件1234567891011121314server: port: 83spring: application: name: nacos-consumer-order cloud: nacos: discovery: server-addr: localhost:8848#设置变量，去访问的微服务名称，用于解耦service-url: nacos-user-service: http://nacos-provider-payment （4）主启动类1234567@SpringBootApplication@EnableDiscoveryClientpublic class NacosOrderMain83 &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosOrderMain83.class, args); &#125;&#125; （5）Config类12345678910@Configurationpublic class ApplicationContextConfig &#123; @Bean//注入Bean @LoadBalanced //开启负载均衡 public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; （6）Controller层123456789101112131415@RestControllerpublic class NacosOrderController &#123; //读取配置文件中变量信息，达到代码与配置解耦 @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;) private String serviceURL; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/nacos&quot;) public String getPaymentInfo() &#123; return restTemplate.getForObject(serviceURL + &quot;/payment/nacos&quot;, String.class); &#125;&#125; （7）测试，启动提供者服务，消费者服务，访问网址：http://localhost:83/consumer/payment/nacos ， 查看是否成功负载均衡 2.4 服务注册中心对比 3 Nacos服务配置中心3.1 基础配置 （1）创建项目cloudAlibaba-nacos-config-client3377 （2）引入依赖12345678910&lt;!-- 服务配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; （3）配置文件12345678910111213# bootstrap.yamlserver: port: 3377spring: application: name: nacos-config-client cloud: nacos: config: server-addr: localhost:8848 #nacos配置中心地址 file-extension: yaml #指定yaml格式的配置 12345# application.yamlspring: profiles: active: dev # 选择开发环境 （4）主启动类123456@SpringBootApplicationpublic class NacosConfigClient3377 &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosConfigClient3377.class, args); &#125;&#125; （5）Controller层1234567891011@RestController@RefreshScope //支持Nacos的动态刷新功能public class ConfigClientController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; @GetMapping(&quot;/config/info&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; （6）在Nacos中发布配置文件，”配置管理” -&gt; “配置列表” -&gt; “+” （7）启动服务，访问：http://localhost:3377/config/info , 数据成功访问 并且nacos支持动态刷新，不再需要我们手动发送消息去刷新配置 3.2 分类配置了解 （1）Namespace+Group+Data ID三者关系 类似Java里面的package名和类名 最外层的namespace是可以用于区分部署环境，Group和DataID逻辑上区分两个目标对象 默认：Namespace=public，Group=DEFAULT_GROUP，Cluster=DEFAULT （2）具体功能使用 Namespace主要用来实现隔离，比如说我们现在有三个环境：开发、测试、生产环境，我们可以创建是哪个Namespace，不同的Namespace之间是隔离的 Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一分组里面去 Service就是微服务，一个微服务可以包含多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。比如说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，杭州机房起一个集群名为HZ，广州机房起一个集群名为GZ，还可以尽量让同一个机房的微服务滑翔调用，以提升性能 Instance，微服务实例 3.3 分类配置 （1）通过DataID切换文件 通过指定spring.profile.active和配置文件的DataID来使不同的环境下读取不同的文件 （2）通过GROUP切换文件 （3）通过NameSpace切换文件 4 Nacos集群和持久化 持久化：https://nacos.io/zh-cn/docs/deployment.html 集群：https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html 4.1 持久化配置 （1）nacos默认使用derby内嵌数据库来存储文件，例如我们之前的做配置中心的配置文件。为了持久化，我们可以将derby切换为我们自己的mysql数据库 （2）nacos安装目录/conf/nacos-mysql.sql，创建名为nacos_config的数据库，运行此sql，得到我们的mysql数据库 （3）也是在conf文件下，修改application.properties文件，迁移数据库 （4）重启nacos，进入页面，发现之前配置的文件全部不见，证明配置成功 4.2 Linux环境搭建 集群的搭建在linux上，本人使用的linux为CentOS8 Java安装 JDK下载：https://www.oracle.com/cn/java/technologies/javase-downloads.html ，选择tar.gz文件 （1）上传到linux上，在/user目录下解压sudo tar zxvf 解压文件 （2）配置环境sudo vim /etc/profile 123export JAVA_HOME=/usr/jdk1.8.0_271-amd64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin （3）加载配置source /etc/profile （4）检测是否安装成功java -version Maven安装 Maven下载：http://maven.apache.org/download.cgi ，选择bin.tar.gz文件 （1）上传到linux上，在/user目录下解压sudo tar zxvf 解压文件 （2）配置环境sudo vim /etc/profile12export M2_HOME=/usr/apache-maven-3.6.3export PATH=$PATH:$M2_HOME/bin （3）加载配置source /etc/profile （4）检测是否安装成功mvn -v Nacos安装 Nacos下载：https://github.com/alibaba/nacos/tags ，选择tar.gz文件 上传到linux，在/opt目录下解压sudo tar -zxvf 解压文件 Nginx安装 https://blog.csdn.net/qq_41967563/article/details/103868656 MySQL安装 https://blog.csdn.net/qq_38591756/article/details/82958333 4.2 集群搭建 （1）数据持久化 1234567891011121314# 登录mysql数据库mysql -u root -p# 创建nacos_config数据库create database `nacos_config`# 切换到nacos_config数据库use `nacos_config`# 运行sql文件source /opt/nacos/conf/nacos-mysql.sql# 检查是都创建表成功show tables （2）切换数据库，修改application.properties sudo vim /opt/nacos/conf/application.properties 修改内容与上文的数据持久化一样 （3）集群配置 sduo cp /opt/nacos/conf/cluster.conf.example /opt/nacos/conf/cluster.conf 获取本机的ip地址hostname -i 修改配置文件，sudo /opt/nacos/conf/cluster.conf （4）编辑启动脚本，使其可以接受不同启动端口 sudo vim /opt/nacos/bin/startup.sh 可以尝试运行sudo ./startup.sh -t 3333 若出现配置了JAVA_HOME环境，但报错说找不到，解决办法：https://blog.csdn.net/qq_29860591/article/details/106833134","categories":[{"name":"SpringCloudAlibaba","slug":"SpringCloudAlibaba","permalink":"https://letere-gzj.github.io/categories/SpringCloudAlibaba/"}],"tags":[]},{"title":"【SpringCloudAlibaba】入门简介","slug":"【SpringCloudAlibaba】入门简介","date":"2021-03-17T15:27:54.000Z","updated":"2021-03-17T15:42:40.521Z","comments":true,"path":"2021/03/17/【SpringCloudAlibaba】入门简介/","link":"","permalink":"https://letere-gzj.github.io/2021/03/17/%E3%80%90SpringCloudAlibaba%E3%80%91%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/","excerpt":"springCloudAlibaba入门了解","text":"springCloudAlibaba入门了解 1 SpringCloud Alibaba出现 Spring CLoud Netflix项目曾经进入过维护模式 维护模式： 将模块置于维护模式，意味着Spring Cloud团队将不会再想模块添加新功能，我们将修复block级别的bug以及安全问题，我们会考虑并审查社区的小型pull request 因此阿里巴巴以此为契机，创建了Spring Cloud Alibaba 来取代Spring Cloud 2 SpringCloud Alibaba介绍2.1 简介 官网：https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md Spring官网：https://spring.io/projects/spring-cloud-alibaba 2.2 功能 服务限流降级：默认支持Servelt、Feign、RestTemplate、Dubbo和RocketMQ限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metrics监控 服务注册与发现：适配SpringCloud服务注册与发现标准，默认集成了Ribbon的支持 分布式配置管理：支持分布式系统汇总的外部化配置，配置更新时自动刷新 消息驱动能力：基于Spring Cloud Steam为微服务应用构建消息驱动能力 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据 分布式任务调度：提供秒级，精准、高可靠、高可用的定时（基于Cron表达式）任务调度服务。同时提供分布式的任务执行模型、如网格任务。网格任务支持海量子任务均匀分配到所有Worker上执行 2.3 安装 在父工程的POM中引入下面依赖即可 1234567 &lt;dependency&gt;&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;&lt;type&gt;pom&lt;/type&gt;&lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 2.4 学习内容 Sentinel：阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性 Nacos：阿里巴巴的开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台 RocketMQ：Apache RocketMQ基于Java的高性能、高吞吐量的分布式消息和流计算平台 Dubbo：Apache Dubbo是一款高性能Java RPC框架 Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案 Alibaba Cloud OSS：阿里云对象存储服务（Object Storage Service，简称OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。你可以在任何应用、任何时间、任何地点存储和访问任意类型的数据 Alibaba Cloud SchedulerX：阿里中间团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务","categories":[{"name":"SpringCloudAlibaba","slug":"SpringCloudAlibaba","permalink":"https://letere-gzj.github.io/categories/SpringCloudAlibaba/"}],"tags":[]},{"title":"【SpringCloud】分布式请求链路跟踪：Sleuth","slug":"【SpringCloud】分布式请求链路跟踪：Sleuth","date":"2021-03-16T03:19:03.000Z","updated":"2021-03-16T03:23:41.503Z","comments":true,"path":"2021/03/16/【SpringCloud】分布式请求链路跟踪：Sleuth/","link":"","permalink":"https://letere-gzj.github.io/2021/03/16/%E3%80%90SpringCloud%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%EF%BC%9ASleuth/","excerpt":"追踪分布式服务的链路","text":"追踪分布式服务的链路 1 Sleuth介绍1.1 出现原理 在微服务框架中，一个客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一个复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败 所以随着服务节点的越来越多，有必要对一个服务请求，到底经过多少节点进行跟踪 1.2 Sleuth简介 官网：https://spring.io/projects/spring-cloud-sleuth#overview Spring Cloud Sleuth 提供了一套完整的服务跟踪的解决方案 在分布式系统中提供追踪解决方案并且兼容支持了zipkin 2 链路监控搭建2.1 zipkin下载与运行 zipkin官方为我们配置好了服务，我们直接下载jar包运行即可，不用我们配置服务器来查看 下载地址：https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/ （选择exec结尾的版本） 运行java -jar jar包名称即可，服务器就成功启动 访问：http://localhost:9411/zipkin/ ，可以进入其web界面 2.2 完整链路结构 链路结构类似链表结构，一个SpanId表示当前节点的id，一个TracetId表示前一个节点的id 2.3 搭建 我们以之前的项目cloud-provider-payment8001和cloud-consumer-order80来进行搭建链路跟踪 （1）引入依赖（两个项目都要）12345&lt;!-- zipkin &amp; sleuth --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; （2）修改yaml123456spring: zipkin: base-url: http://localhost:9411 #监控数据打印的位置 sleuth: sampler: probability: 1 # 采用率值介于0-1,1表示全部采集 （3）测试：启动项目，访问80消费者端接口，回到zipkin的web监控界面刷新","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】消息驱动：Stream","slug":"【SpringCloud】消息驱动：Stream","date":"2021-03-16T02:00:39.000Z","updated":"2021-03-16T02:02:13.930Z","comments":true,"path":"2021/03/16/【SpringCloud】消息驱动：Stream/","link":"","permalink":"https://letere-gzj.github.io/2021/03/16/%E3%80%90SpringCloud%E3%80%91%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8%EF%BC%9AStream/","excerpt":"Stream用于解除各种消息中间件的使用差异，将他们整合为统一接口使用","text":"Stream用于解除各种消息中间件的使用差异，将他们整合为统一接口使用 1 Stream介绍1.1 简介 诞生作用：屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型 官网：https://spring.io/projects/spring-cloud-stream#learn 中文文档：https://m.wang1314.com/doc/webapp/topic/20971999.html 应用程序通过inputs或者outputs来与spring cloud stream中的binder对象交互 通过我们配置来绑定，而spring cloud stream 的 binder对象负责与消息中间件交互 所以，我们只需要搞清楚如何与spring cloud stream交互就可以方便使用消息驱动的方式 目前仅支持RabbitMQ、Kafka 1.2 设计思想 生产者/消费者之间靠消息媒介传递信息内容（Message） 消息必须走特定的通道（Message Channel） 由（MessageHander）来进行消息接收和转发处理 通过定义绑定器作为中间层，完美实现了应用程序和消息中间件之间的隔离 通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现 Stream中的消息通信方式遵循了发布-订阅模式 1.3 标准流程套路 Binder：方便的连接中间件，屏蔽差异 Channel：通道，是队列Queue的一种抽象，在消息通讯系统汇总就是实现存储和转发的媒介，通过Channel对队列进行配置 Source和Sink：简单的可理解为参照对象时Spring Cloud Stream自身，从Stream发布消息就是输入，接受消息就是输入 1.4 API和常用注解 组成 说明 Middleware 中间件，目前只支持RabbitMQ和Kafka Binder Binder是应用于消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间，可以动态的改变消息类，这些可以通过配置文件来实现 @Input 注解标识输入通道，通过该输入通道接收到的消息进入应用程序 @Output 注解标识输出通道，发布的消息将通过该通道离开应用程序 @StreamListener 监听队列，用于消费者的队列的消息接收 @EnableBinding 指定信道channel和exchange绑定在一起 2 消息发送者2.1 搭建 （1）创建项目cloud-stream-rabbit-pub8801 （2）引入依赖12345678910&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- stream-rabbit --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; （3）修改yaml1234567891011121314151617181920212223server: port: 8801spring: application: name: cloud-stream-rabbit-pub cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称，OUTPUT表示这是消息的发送方 destination: testExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置（爆红没有关系） （4）主启动类123456@SpringBootApplicationpublic class StreamPubMain8801 &#123; public static void main(String[] args) &#123; SpringApplication.run(StreamPubMain8801.class, args); &#125;&#125; （5）service层123456789101112131415161718192021//接口public interface MessageProvider &#123; String send();&#125;//-----------------------------------------------------------------------------------//实现类@EnableBinding(Source.class) //定义消息的推送管道public class MessageProviderImp implements MessageProvider&#123; @Resource private MessageChannel output; //消息发送管道 @Override public String send() &#123; String serial = UUID.randomUUID().toString(); output.send(MessageBuilder.withPayload(serial).build()); //将消息发送到&#x27;发送管道上&#x27; System.out.println(&quot;serial：&quot; + serial); return null; &#125;&#125; （6）controller层1234567891011@RestControllerpublic class SendMessageController &#123; @Resource private MessageProvider messageProvider; @GetMapping(&quot;/sendMessage&quot;) public String sendMessage() &#123; return messageProvider.send(); &#125;&#125; 2.2 测试 （1）启动cloud-stream-rabbit-pub8801项目，进入rabbitmq页面管理 （2）查看rabbitmq交换机是否注册成功 （3）测试接口：http://localhost:8801/sendMessage，进入rabbitmq页面是否接受到消息 3 消息接受者3.1 搭建 （1）创建项目cloud-stream-rabbit-sub8802 （2）引入依赖12345678910&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- stream-rabbit --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; （3）修改yaml1234567891011121314151617181920212223server: port: 8802spring: application: name: cloud-stream-rabbit-sub cloud: stream: binders: #配置要绑定的rabbitmq的服务信息 defaultRabbit: #（自定义名称），用于与binding整合 type: rabbit #消息中间件类型 environment: #环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: input: # destination: testExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型 binder: defaultRabbit #要绑定的中间件服务 （4）主启动类123456@SpringBootApplicationpublic class StreamSubMain8802 &#123; public static void main(String[] args) &#123; SpringApplication.run(StreamSubMain8802.class, args); &#125;&#125; （5）Controller1234567891011@EnableBinding(Sink.class)public class ReceiveMessageController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @StreamListener(Sink.INPUT) //接受消息，并自动执行下面方法 public void input(Message&lt;String&gt; message) &#123; System.out.println(&quot;订阅者：&quot; + serverPort + &quot; --- &quot; + message.getPayload()); &#125;&#125; 3.2 测试 （1）先启动cloud-stream-rabbit-pub8801，再启动cloud-stream-rabbit-sub8802 （2）测试8801接受，向中间件发送消息，http://localhost:8801/sendMessage （3）观察8802后台，查看是否监听到消息的发送，并自动执行方法 4 分组消费和持久化4.1 重复消费 我们先复制一份cloud-stream-rabbit-pub8803，项目内容跟8802一模一样，做一个简单集群 然后分别运行三个项目，测试发送消息接口，发现8802，8803重复接受到了消息，这不是想要的结果，而是希望轮询接受数据 生产实际例子：订单系统我们做了集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取，那么就会造成数据错误，我们需要避免这种情况，我们就可以使用Stream中的消息分组来解决 4.2 分组解决重复消费 解决原理：当两个服务的消息中间件分组不一样，就会出现重复消费，共同获取信息。但是如果分组一样，两个服务之间就是竞争关系 修改订阅者的yaml，将两个组名改为一样 1234567891011spring: application: name: cloud-stream-rabbit-sub cloud: stream: bindings: input: # destination: testExchange content-type: application/json binder: defaultRabbit group: groupA #设置分组名 测试访问发送消息接口两次，查看8802、8803后台，发现只有一个消息，实现了轮询效果 4.3 持久化 如果我们没有手动对yaml配置group属性，若消息发送者在消息接受者未启动时发送消息，则待消息接受者启动后，会出现消息丢失的情况，没有从消息中间件中获取消息。 如果我们设置了分组，则在启动时会正常获取之前发送的消息","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】服务总线：Bus","slug":"【SpringCloud】服务总线：Bus","date":"2021-03-14T12:43:35.000Z","updated":"2021-03-14T14:08:21.732Z","comments":true,"path":"2021/03/14/【SpringCloud】服务总线：Bus/","link":"","permalink":"https://letere-gzj.github.io/2021/03/14/%E3%80%90SpringCloud%E3%80%91%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF%EF%BC%9ABus/","excerpt":"利用服务总线配合rabbitmq来达到自动化刷新配置","text":"利用服务总线配合rabbitmq来达到自动化刷新配置 1Bus介绍1.1 简介 Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、时间推送等，也可以当做微服务间的通信通道 1.2 概念 总线：在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在兴县上的各个实例，都可以方便地广播一些需要让其他连接在该主题花式虐狗的实例都知道的消息。 1.3 ConfigClien自动更新基本原理 ConfigClient实例都监听MQ（message quene）中同一个topic（默认SpringCloudBus）。当一个服务刷新数据的时候，它会把这个信息放入Topic中，这样其他监听同一个Topic的服务就能得到该通知，然后去更新自身的配置 2 RabbitMQ安装下载由于本次目的是学习SpringCloud为主，所以下载的版本是Windows版本，但真正使用建议在linux上 2.1 下载 erlang语言：https://www.erlang.org/downloads rabbitMQ是使用erlang进行编写，所以需要安装对应的语言解析 rabbitMQ下载：https://www.rabbitmq.com/install-windows.html#downloads 2.2 安装 先安装erlang语言包，一路默认安装即可 记得配置环境变量，电脑 -&gt; 属性 -&gt; 高级 -&gt; 环境变量 -&gt; path -&gt; 编辑 -&gt; 新增安装路径\\bin 安装rabbitMQ，默认安装即可 切换到安装目录\\sbin下，输入命令rabbitmq-plugins enable rabbitmq_management +若出现以下错误，可使用下方解决方法： 解决方法：https://blog.csdn.net/Keyporcelain/article/details/111599763 3 配置消息总线Bus3.1 思路选择 消息总线配置有两种思路，第一种是配置给客户端，另一种是配置给服务配置中心 因为配置给客户端，打破了客户端的独立性，给器拥有发送消息的能力，此不妥，所以选择配置给服务配置中心 3.2 服务配置中心配置信息总线 （1）引入新依赖12345678910&lt;!-- bus &amp; rabbitmq --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 监控 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; （2）修改配置文件12345678910111213spring: rabbitmq: host: localhost port: 5672 #默认端口 username: guest #默认用户名 password: guest #默认密码# 暴露bus舒心配置的端点management: endpoints: web: exposure: include: &#x27;bus-refresh&#x27; 3.2 客户端篇配置消息总线 （1）引入依赖12345&lt;!-- bus &amp; rabbitmq --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; （2）修改yaml123456spring: rabbitmq: host: localhost port: 5672 #默认端口 username: guest #默认用户名 password: guest #默认密码 3.3 测试 （1）先启动服务端，再启动客户端 （2）修改仓库中配置文件信息 （3）向服务端发送刷新指令 利用cmdcurl -X POST http://localhost:3344/actuator/bus-refresh （4）请求客户端接口，返现数据更新了，通过服务端的消息总线，向其余客户端都发送消息，更新配置信息 4 动态刷新定点通知有时候，不想要全部的客户端都更新，只想要指定的客户端进行更新，所以需要定点通知 主要发送刷新信息时添加额外参数即可 http://配置中心/actuator/bus-refresh/目标IP和端口，IP地址可用服务名称来代替 例：http://localhost:3344/actuator/bus-refresh/cloud-config-client:3355","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】服务配置：Config","slug":"【SpringCloud】服务配置：Config","date":"2021-03-13T15:30:29.000Z","updated":"2021-03-13T15:35:04.847Z","comments":true,"path":"2021/03/13/【SpringCloud】服务配置：Config/","link":"","permalink":"https://letere-gzj.github.io/2021/03/13/%E3%80%90SpringCloud%E3%80%91%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%EF%BC%9AConfig/","excerpt":"利用服务配置，可以对多个微服务进行统一配置","text":"利用服务配置，可以对多个微服务进行统一配置 1 Config介绍1.1 服务配置出现原因 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设置必不可少 SpringCLoud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个aoolication.yaml，上百个配置文件管理… （举例）同一功能的服务器集群，除了端口之外的配置不同，里面的许多配置都十分的像，所以可以提取相同的部分，减少管理压力 1.2 简介 官网：https://docs.spring.io/spring-cloud-config/docs/current/reference/html SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置 SpringCloud config分为服务端和客户端两部分 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口 客户端则是通过制定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器，默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容 1.3 功能 集中管理配置文件 不同环境不同配置，动态化的配置更新，分环境部署（dev/test/prod/beta/release） 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置 将配置信息以REST接口的形式暴露 2 Config服务端搭建2.1 前期准备 （1）在自己GitHub / Gitee上新建一个配置文件仓库 （2）本地克隆自己创建的Git仓库 （3）在本地仓库创建一个config-dev.yaml文件，里面填写一些内容即可 文件名格式一定要为xxx-xxx.yaml才可以123#填写内容举例config: info: master branch, springcloud-config/config-dev.yaml version=1.0 （4）将该文件提交到仓库上 2.2 搭建服务端 （1）创建新项目cloud-config-center3344 （2）修改POM（引入依赖）12345&lt;!-- config --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; （3）配置文件yaml1234567891011121314server: port: 3344spring: application: name: cloud-config-center # 服务名称 cloud: config: server: git: uri: https://gitee.com/letere/springcloud-config.git #git仓库地址 search-paths: - springcloud-config #仓库名称 label: master #读取仓库分支 （4）主启动类1234567@SpringBootApplication@EnableConfigServer //开启配置服务public class ConfigCenterMain3344 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigCenterMain3344.class, args); &#125;&#125; 2.3 测试 （1）启动服务端（报错可能需要给git配置ssh），访问http://localhost:3344/master/config-dev.yaml （分支/文件名） 3 Config客户端搭建3.1 客户端搭建 （1）创建项目cloud-config-client3355 （2）修改POM（依赖引入）12345678910&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- config-client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt; （3）配置bootstrap.yaml文件 application.yaml是用户及的资源配置项，bootstrap.yaml是系统级的，优先级更高 1234567891011121314server: port: 3355spring: application: name: cloud-config-client cloud: config: label: master #仓库分支 name: config #配置文件前名 profile: dev #配置文件后名（环境） uri: http://localhost:3344 #config服务端地址# 如果引入服务注册中心，可以考虑配置 （4）写个Controller接口试验是否访问到配置 1234567891011@RestControllerpublic class ConfigController &#123; @Value(&quot;$&#123;config.info&#125;&quot;) private String configInfo; //读取配置文件信息，注入到参数中 @GetMapping(&quot;/configInfo&quot;) public String getConfigInfo() &#123; return configInfo; &#125;&#125; （5）测试：启动cloud-config-server3344，再启动cloud-config-client3355 访问：http://localhost;3355/configInfo 4 Config客户端动态刷新（手动）4.1 问题发现 如果config客户端，服务端都开启的时候，直接修改远程仓库中配置文件信息 服务端接口信息会立马更新 客户端接口信息不会进行更新，只有重新客户端才可以更新 出现以上问题：所以需要客户端的动态刷新 4.2 配置动态刷新手动版 （1）修改POM（引入新依赖）12345&lt;!-- actuator监控 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; （2）修改配置文件yaml123456# 暴露监控端点management: endpoints: web: exposure: include: &quot;*&quot; （3）Controller类上面添加新的注解@refreshScope 4.3 测试 （1）更改远程仓库配置文件信息 （2）向客户端发送Post请求，提示客户端刷新配置文件信息 可利用cmd命令来发送curl -X POST &quot;http://localhost:3355/actuator/refresh&quot; （3）重新请求客户端接口，发现数据已经修改 4.4 总结 因为需要手动发送post请求提示刷新，所以称之为手动版 但可以结合下面学习的BUS总线实现自动刷新，无非手动","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】服务网关：Gateway","slug":"【SpringCloud】服务网关：Gateway","date":"2021-03-13T09:37:04.000Z","updated":"2021-03-13T09:42:19.857Z","comments":true,"path":"2021/03/13/【SpringCloud】服务网关：Gateway/","link":"","permalink":"https://letere-gzj.github.io/2021/03/13/%E3%80%90SpringCloud%E3%80%91%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%EF%BC%9AGateway/","excerpt":"关于Spring Cloud Gateway的使用","text":"关于Spring Cloud Gateway的使用 1 Gateway介绍1.1 基本介绍 官网：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html Gateway是在spring生态系统上构建的API网关服务，基于Spring5，SpringBoot2 和 Project Reactor等技术 Gateway提供亦庄简单而有效的方式来对API进行路由，以及提供一些强大的过滤能力，例如：熔断、限流、重试等 Gateway使用的Webflux种的reactor-netty响应式编程组件，底层使用了Netty 1.2 功能 反向代理 鉴权 流量控制 熔断 日志监控 1.3 使用位置 1.4 选择gateway原因 （1）zuul1.0进入了维护阶段，而Gateway是SpringCloud团队研发的，是亲儿子产品 （2）Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心 （3）Netflix虽然发布最新的Zuul2.x，但没有与SpringCloud整合的计划 2 三大核心概念2.1 Route（路由） 路由是构建网关的基本模块，它有ID，目标URI，一系列的断言和过滤器组成，如果断言为true，则匹配该路由 2.2 Predicate（断言） 断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言 开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由 2.3 Filter（过滤） 使用过滤器，可以在请求被路由前或者之后对请求进行修改 2.4 总结 web请求，通过一些匹配条件，定位到真正的服务器。并在这个转发过程的前后，进行一些精细化控制。 predicate就是我们的匹配条件 filter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由 3 Gateway工作流程 路由转发+执行过滤器链 4 Gateway配置4.1 服务搭建 （1）新建Modulecloud-gateway-gatway9527 （2）修改POM（引入依赖）12345678910&lt;!-- eureka-client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- gateway --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; （3）修改配置文件yaml1234567891011121314server: port: 9527spring: application: name: cloud-gateway #服务器名称eureka: instance: hostname: cloud-gateway-service #eureka上主机别名 client: register-with-eureka: true fetch-registry: true defaultZone: http://eurka7001.com:7001/eureka （4）主启动类1234567@SpringBootApplication@EnableEurekaClient //注册到eureka服务中心public class GatewayMain9527 &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayMain9527.class, args); &#125;&#125; 4,2 网关配置 （1）修改yaml配置12345678spring: cloud: gateway: routes: - id: payment-route # 路由ID，名字随意（建议配合服务名） uri: http://localhost:8001 #断言匹配成功后，转发的路由地址 predicates: - Path=/payment/get/** # 断言。路径相匹配的进行路由转发，注意Path是大写开头 （2）测试 启动eurka服务注册中心，启动服务器，再启动网关 5 通过编码形式配置网关 123456789101112@Configurationpublic class GatewayConfig &#123; @Bean public RouteLocator customerLocator(RouteLocatorBuilder builder) &#123; RouteLocatorBuilder.Builder routes = builder.routes(); //参数1：路径名，参数二：函数，断言匹配路径，路由转发路径 routes.route(&quot;path_name&quot;, r -&gt; r.path(&quot;/guonei&quot;).uri(&quot;https://news.baidu.com&quot;)); return routes.build(); //构建 &#125;&#125; 6 微服务名实现动态路由6.1 路由访问变化 添加网关前： 使用网关 但是上面的网关配置是将转发路由写死的，打不到负载均衡，所以需要动态路由实现负载均衡 6.2 配置动态路由 修改yaml配置文件 1234567891011spring: cloud: gateway: discovery: locator: enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由转发 routes: - id: payment-route # 路由ID，名字随意（建议配合服务名） uri: lb://cloud-payment-service #lb：loadBalance负载均衡，从服务注册中心获取对应服务名的服务器 predicates: - Path=/payment/lb/** # 断言。路径相匹配的进行路由转发，注意Path是大写开头 测试： 开启eureka7001, payment8001, payment8002，gateway9527调用接口测试 7 Predicates断言使用7.1 断言类型 官方文档说明：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories 7.2 After 后面跟指定时间，当当前时间在指定时间之后，此路径访问才生效 使用场景：提前上架服务器，但不允许服务器被访问（游戏开服） 时间格式：可以通过代码来获取时间格式1234ZonedDateTime now = ZonedDateTime.now();System.out.println(now);//2021-03-13T16:47:32.605+08:00[Asia/Shanghai]//日期 T 时间 xxxx[xx/xx] 7.3 Before 在指定时间之前，路径访问才生效，和After相反 7.4 Between 在两个指定之间之内，路径访问才生效，参数为两个时间，就比前面多一个时间参数 7.5 Cookie Cookie Route Predicate需要两个参数，一个是Cookie name，一个是正则表达式 路由规则会通过获取对应的Cookie name值（key）和正则表达式（value）去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行 1- Cookie=username, letere //要cookies要带上&quot;username=letere&quot;参数 7.6 Header 请求头和Cookie样，两个参数，kv键值对 带有此kv键值对就匹配成功，进行路由转发 8 Filter过滤器使用8.1 Filter介绍 路由过滤器可用于修改进入HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用 Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生 8.2 Filter分类 生命周期 pre post 种类 GatewayFilter：单一过滤器 官网：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories （共31个） GlobalFilter：全局过滤器 官网：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters （共10个） 8.3 自定义过滤器 （1）实现GlobalFilter和Ordered接口 （2）重写里面的方法 例子：配置一个过滤器，请求参数必须要带”uname”才放行123456789101112131415161718192021222324@Component@Slf4jpublic class LogGatewayFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info(&quot;******** come from LogGatewayFilter：&quot; + new Date()); String uname = exchange.getRequest() //获取请求 .getQueryParams() //获取查询参数 .getFirst(&quot;uname&quot;); //获取对应参数值 if(uname == null) &#123; log.info(&quot;********用户名为null，非法用户，o(╥﹏╥)o&quot;); exchange.getResponse() //获取响应 .setStatusCode(HttpStatus.NOT_ACCEPTABLE); //响应会状态码 return exchange.getResponse().setComplete(); //拦截返回信息 &#125; return chain.filter(exchange); //放行 &#125; @Override public int getOrder() &#123; //过滤器执行顺序，越小优先级越高 return 0; &#125;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【面试】Java100面试题","slug":"【面试】Java100面试题","date":"2021-03-12T16:17:22.000Z","updated":"2021-10-31T23:53:11.628Z","comments":true,"path":"2021/03/13/【面试】Java100面试题/","link":"","permalink":"https://letere-gzj.github.io/2021/03/13/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91Java100%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"Java面试题","text":"Java面试题 1 面向对象的理解 要与面向过程对比 面向过程：注重事情的每一个步骤以及顺序（直接高效） 面向对象：注重事情有哪些参与者（易于复用、拓展和维护） 面向对象的三大特性 封住：提供给外部调用的属性和方法，内部细节无需外部知道以及修改 继承：继承基类的方法，并作出自己的改变或拓展 多态：父类引向子类对象父类 变量名 = new 子类()，创建的类虽然是父类，但调用的方法的逻辑，是子类的逻辑 2 JDK JRE JVM JDK：Java Develpment Kit（Java开发工具） JRE：Java Runtime Enviroment（Java运行时环境） JVM：Java Virtual Machine（Java虚拟机） 3 ==和equals 一般笔试中用于判断true / false ==比较的是栈中的值，比较的是堆中内存对象的地址 如果创建一个对象，用==比较，比较的是地址，而不是值 equals一般与==是同一比较效果 但我们一般会对equals进行方法重写，用来比较类中的值，而不是地址 4 final （1）final作用 修饰类：表示类不可被继承 修饰方法：表示方法不可被子类覆盖（重写），但可以重载 修饰变量：表示变量一旦被赋值就不可以更改它的值 修饰成员变量123public class Finalvar &#123; final int b = 0; //在声明的时候就需要赋值；或者在代码块中赋值；或者构造器赋值&#125; 修饰局部变量12345public class Finalvar &#123; public static void main(String[] args) &#123; final int a; //局部变量可以在声明的时候不赋值，但要在使用前进行赋值 &#125;&#125; （2）局部内部类和匿名内部类 局部内部类和匿名内部类方法中的参数要添加final修饰，否者访问不到 原因： 内部类与外部类是同一级别，不会因为内部方法执行完后，会进行销毁 实际执行流程，将局部变量赋值一份作为内部类的成员变量，当方法结束，局变量变量销毁，内部类仍然可以访问局部变量，即copy的变量 复制变量的过程汇总，必须保证两个变量是一样的，所以添加一个final来修饰局部变量 5 String StringBuffer StringBuilder String是final修饰的，不可变，每次操作都会产生新的String对象 StringBuffer和StringBuilder都是在原对象上操作 StringBuffer是线程安全的，StringBuilder线程不安全 StringBuffer方法都是synchronized修饰 性能：StringBuilder &gt; StringBuffer &gt; String 场景：经常需要改变字符串内容时使用后面两个，优先使用StringBuilder，多线程使用共享变量时使用StringBuffer 6 重载和重写 （太过容易简单回答，注意要详细） 重载：发生在同一个类中，方法名相同，参数类型，个数，顺序不同，方法返回值和访问修饰符可以不同 重写：发生在父子类中，方法名、参数列表必须相同，返回值的范围小于等于父类，抛出的异常小于等于父类，访问修饰符访问大于等于父类（如果父类为private，则子类不能重写该方法） 7 接口和抽象类的区别 抽象类可以存在普通成员函数（可以有实现方法），而接口中只能存在public、abstract方法 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型 抽象类只能继承一个，接口可以实现多个 8 List和Set的区别 List：有序，按对象进入的顺序保存对象；可重复，允许多个Null元素对象，可以使用迭代器（Iterator）取出所有元素，逐一遍历，还以使用get(int index)获取指定下标的元素 Set：无序，不可重复，最多允许一个Null元素对象，取元素时只能用迭代器取出所有元素，再逐一遍历各个元素 9 hashCode与equals 如果两个对象相等，则hashCode一定也相等 两个对象相等 ，对两个对象分别调用equals方法都会返回true 两个对象有相同的hashCode值，它们也不一定是相等，因此equals你发呗覆盖过，则hashCode方法也必须被覆盖 hashCode的默认行为是对对上的对象产生独特值，如果没有重写hashCode()方法，则该class的两个对象无论润滑都不会相等（即使这两个对象指向相同的数据） 10 ArrayList和LinkedList区别 ArrayList：基于动态数组，连续内存存储，适合下标访问 如果ArrayList使用尾插法，就不会涉及元素的移动，就会极大提高性能，甚至会超过LinkedList LinkedList：基于链表，分散在内存中，适合做数据插入以及删除操作，不适合做查询 遍历LinkedList必须使用迭代器进行访问（for效率低），比较麻烦。 另外不要用IndexOf来返回元素索引，当结果为空时，会遍历整个列表 11 HashMap和HashTable区别区别 （1）HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全 （2）HashMap允许key和value为null，而HashTable不允许 底层实现：（数组和链表实现） JDK8开始链表高度到8，数组长度超过64，链表转为红黑树，元素以内部类Node节点存在 实现方法类似HashSet，利用hashcode计算数组位置，判断该位置上是否有值？没，直接插入；有和链表上的数据比较hashCode，判断是否相同？不相同，链表上插入新数据；相同，使用equals比较，判断是否相同？相同，取消插入；不相同，将原来值修改为新插入的值 12 ConcurrentHashMap 13 如何实现一个IOC容器 （1）配置文件配置包扫描路径 （2）递归包扫描获取.class文件 （3）反射、确定需要交给IOC管理的类 （4）对需要注入的类进行依赖注入 配置文件中指定需要扫描的包路径 定义一些注解，分别表示访问控制层，业务服务成… 从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个set集合中进行存储 遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象 遍历这个IOC容器，获取到每一个类的实例，判断里面是否有依赖其他类的实例，然后进行递归注入 14 什么是字节码？采用字节码的好处是什么？ Java中的编译器和解释器 Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机，这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口（实现同一Java代码，能够在不同平台之间运行） 编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统机器码执行。 Java中，供虚拟机理解代码叫做字节码（.class文件） 字节码好处 一定程度上解决传统解释型语言执行效率低的问题，同时又保留解释型语言可移植的特点，无需重新边意思便可在多种不同的计算机上运行 15 Java类加载器有哪些？ JDK自带有三个类加载器：bootstrap ClassLoader、ExClassLoader、AppClassLoader bootstrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件 ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件下的jar包和class类 AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。继承ClassLoader实现自定义类加载器 16 双亲委托（派）模型 双亲委派模型的好处： 主要是为了安全性，避免了用户自己编写类动态替换Java的一些核心类，比如String 同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class被不同的ClassLoader加载就是不同的两个类 17 Java中的异常体系 Java中的所有异常都来自顶级父类Throwable Throwable下有两个子类Exception和Error Error是程序无法处理的错误，一旦出现这个错误，即程序将被迫停止运行 Exception不糊导致程序停止，又分为两个部分RunTimeException运行时异常 和 CheckedException检查异常 RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过 18 GC如何判断对象可以被回收（JVM） 19 线程的生命周期，线程有哪些状态 线程的五种状态：创建，就绪，运行，阻塞，死亡 阻塞的情况分为三种： （1）等待阻塞：运行的线程执行了wait()方法 （2）同步阻塞：运行线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入”锁池”中 （3）其他阻塞：运行的线程执行了sleep或join方法，或发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时，join等待线程的终止或者超时。或者I/O处理完毕时，线程重新转入就绪状态。sleep是thread类的方法 创建状态（new）：新创建一个线程对象 就绪状态（Runable）：线程对象创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权 运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态 死亡状态（Dead）：线程执行完或者因一场退出了run方法，该线程结束生命周期 20 sleep()、wait()、join()、yield()区别 （1）锁池： 所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待CPU资源分配 （2）等待池： ·当我们调用wait()方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用notify()或notifyAll()后等待池的线程才会开始去竞争锁，notify()是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池中的所有线程方法哦锁池当中 sleep是Thread类的静态本地方法，wait()是Object类的本地方法 sleep方法不会释放lock，但是wait会释放，并加入等待列表中 sleep方法不依赖于同步器synchronzied，但是wait()需要依赖synchronzied关键字 sleep不需要被唤醒（时间到自动唤醒），但是wait()需要notify进行唤醒 sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信 sleep会让出CPU执行时间且强制上下文切换，而wait()则不一定，wait后可能还是有机会重新竞争到锁继续执行的 yield()执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让出这个线程获得到执行权继续执行 join() 执行后线程进入阻塞状态，例如在线程B中使用线程A的join()，那线程B会进入到阻塞队列，直到线程A结束或中断线程 21 对线程安全的理解 32 Sring是什么？ spring是一个轻量级的开源的J2EE框架，它是一个容器框架，用来装JavaBean。中间层可以起一个连接作用，整合其他框架，可以让我们的企业开发更快、更简洁 Spring是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架 从大小与开销两方面而言，Spring都是轻量级的 通过控制反转（IOC）技术到到松耦合的目的 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发 包含并管理应用对象（Bean）的配置和声明周期，这个意义上是一个容器 将简单的组件配置，组合成为复杂的应用，这个意义上是一个框架 33 对AOP的理解 系统由许多不同的组件组成，每一个组件各负责一块特定功能，除了实现自身核心功能之外，这些组件还经常承担额外的制作，例如日志，事务管理 当我们需要为分散的对象映日公共行为的时候，OOP（面向对象）则显得无能为力。OOP允许你定义从上到下的关系，但不适合定义从左到右的关系。例如日志功能。 AOP（面向切面），将程序中的交叉业务逻辑（安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某个对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后外的做一些事情 34 对IOC理解切入点：容器概念、控制反转、依赖注入 IOC容器： 实际上市一个Map(key, value)，里面存储各种对象（被注解标识的类，xml中配置的Bean）。在项目启动时，通过全限定类名使用反射创建对讲放入map里 map中拥有各种对象，通过@autowired / @resource等注解，或xml中bean节点内的ref属性 控制反转： （1）没有引入IOC容器之前，对象A依赖对象B，在对象A初始化，运行到某一点时，需要自己去创建对象B或使用已经创建的对象B，控制权都在自己的手上 （2）引入IOC之后，对象A与对象B失去了直接联系，当对象A运行到需要对象B时候，IOC会主动创建一个对象B注入到对象A需要的地方 对象A获取对象B的过程是有主动变成被动应为，控制权颠倒，称为控制反转 依赖注入： 获取依赖对象的过程有自身管理变为了有IOC容器主动注入，依赖注入是实现IOC的方法，在IOC容器运行时间，动态地将某种依赖关系注入到对象之中 35 BeanFactory和ApplicationContext区别 ApplicationContext是BeanFactory的子接口 ApplicationContext提供了更完整的功能 （1）继承了MessageSource，因此支持国际化 （2）同一的资源文件访问方式 （3）提供在监听器中注册bean的事件 （4）同时加载多个配置文件 （5）载入多个（有继承关系）上下文，使得每一个上下文都有专注于一个特定的层次 BeanFactory采用延迟加载形式来注入Bean，使用使用某个Bean时（getBean()），才对该Bean进行加载实例化 ApplicationContext，它是在容器启动时，一次性创建所有Bean。 两者相比，ApplicationContext在启动时，就能发现哪个Bean配置出现问题。而BeanFactory只有使用到相应的Bean时才知道是否出现问题。 两者相比，ApplicationContext相比于BeanFactory比较占用内存 BeanFactory通常以编程的方式被创建，Application还能以声明的方式被创建，如使用ContextLoader BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册 36 Spring Bean的生命周期 扫描路径，解析类获得BeanDefinition 如果有多个构造方法，则要推断构造方法 确定好构造方法后，进行实例化得到一个对象 对对象中的加了@autowired注解属性进行属性填充 回调Aware方法，比如BeanNameAware、BeanFactoryAware 调用BeanPostProcessor初始化前的方法 调用初始化方法 调用BeanPostProcessor的初始化后的方法，在这里会进行AOP 如果当前创建的Bean是单例的则会把Bean放入单例池 使用Bean Spring容器关闭时调用DisposableBean中的destory()方法 37 Spring支持的Bean的作用域 singleton：默认，每一个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护，该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建一个新的对象） prototype：为每一个Bean请求提供一个实例。在每次注入时都会创建一个新的对象 request：Bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象 session：与request范围类似，确保每个session中有个bean的实例，在session过期后，bean会随之失效 application：Bean被定义为ServeltContext的生命周期中复用一个单例对象 websocker：Bean被定义在websocker的生命周期中复用一个单例对象 38 Spring框架中的单例Bean是线程安全的吗 单例Bean：IOC容器中只有这么一个Bean，无论多少个线程去注入Bean，都是同一个Bean，不会额外new一个新的Bean 该单例Bean并不是线程安全的，因为框架并没有对Bean进行多线程的封装处理 如果Bean是有状态的（Bean里面存储数据），会出现线程安全问题，需要更改Bean的作用于，将默认的singleton更改为prototype，每次依赖注入时都会创建一个新的Bean 如果Bean是无状态的，只是调用Bean里面的接口，就不会发生线程安全问题 例子：DAO会操作数据库的connection，connection是带有状态的，比如数据库事务，spring事务管理器使用Threadlocal为不同线程维护了一套独立的connection副本，保证线程之间不会互相影响 39 Spring 框架使用到的设计模式 （1）简单工厂：有一个工厂类根据传入的参数，动态决定应该创建哪一个产品类 1spring中的`BeanFactory`就是简单工厂模式的体现，根据传入一个唯一的标识来获取Bean对象，但是否是在传入参数后创建，还是传入参数前创建就根据具体的情况来决定 （2）工厂方法： 1实现了`FactoryBean`接口的bean是一类叫做factory的bean，其特点是，spring会在使用getBean()调用火哥该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getObject()方法的返回值 （3）单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点1spring对单例的实现，spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory，但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象 （4）适配器模式：1Spring定义一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替Controller执行相应的方法，这样在拓展Controller时，只需要加一个适配器类就完成了SpringMVC的扩展了 （5）装饰器模式：动态给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活12345Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有wrapper，另一种是类名中含有Desorator``` + （6）动态代理： 切面在应用运行的时刻被织入，在织入切面时，AOP容器会为目标对象动态创建一个代理对象,SpringAOP就是以这种方式织入切面织入：把切面应用到目标对象并创建新的代理对象的过程 40 Spring事务的实现方式和原理以及隔离级别","categories":[{"name":"面试","slug":"面试","permalink":"https://letere-gzj.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[]},{"title":"【SpringCloud】服务降级：Hystrix","slug":"【SpringCloud】服务降级：Hystrix","date":"2021-03-07T04:32:56.000Z","updated":"2021-03-07T04:36:38.102Z","comments":true,"path":"2021/03/07/【SpringCloud】服务降级：Hystrix/","link":"","permalink":"https://letere-gzj.github.io/2021/03/07/%E3%80%90SpringCloud%E3%80%91%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%EF%BC%9AHystrix/","excerpt":"Hystrix实现服务降级，服务熔断介绍","text":"Hystrix实现服务降级，服务熔断介绍 1 Hystrix简介1.1 介绍 Hystrix是一个用于处理分布式系统的延迟和容错的开源库 Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性 “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的，可处理的备选相应（FallBack），而不是长时间的等待或抛出调用方法无法处理的异常，这样就保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩 1.2 功能 服务降级 服务熔断 接近实时的监控 1.3 资料 官方：https://github.com/Netflix/Hystrix 2 Hystrix重要概念2.1 服务降级（fallback） 如果当前对方服务不可用，给出一个解决方法来 类似我们的if-else判断语句 举例：”服务器繁忙，请稍后再试！”，不让客户端等待并立刻返回一个友好提示（fallback） 发生降级的情况; （1）程序运行异常 （2）超时 （3）服务熔断触发服务降级 （4）线程池 / 信号量打满导致服务降级 2.2 服务熔断（break） 类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示 类似保险丝 2.3 服务限流（flowlimit） 秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行 3 Hystrix使用3.1 服务端简单搭建环境 （1） 创建cloud-provider-hystrix-payment8001项目 （2）依赖导入 123456789101112131415&lt;!-- hystrix --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; （3）yaml配置文件 12345678910111213141516server: port: 8001 #端口spring: application: name: cloud-provider-hystrix-payment #服务名称eureka: instance: instance-id: hystrix-payment8001 # eureka中服务名称 prefer-ip-address: true # 访问路径是否可以显示IP地址 client: register-with-eureka: true # 是否注册进eureka服务端 fetch-registry: true # 是否从eureka server从获取已有的注册信息，默认true。单节点无所谓，集群的话需要 service-url: defaultZone: http://localhost:7001/eureka （4）主启动类1234567@SpringBootApplication@EnableEurekaClient //表示此服务器是eureka clientpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class, args); &#125;&#125; （5）Serviec层123456789101112131415161718@Servicepublic class PaymentService &#123; //模拟服务正常 public String paymentInfo_OK(Integer id) &#123; return &quot;线程池：&quot; + Thread.currentThread().getName() + &quot;\\n-- OK --\\nid：&quot; + id; &#125; //模拟服务异常：超时 public String paymentInfo_Timeout(Integer id) &#123; try &#123; //沉睡3秒 TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;线程池：&quot; + Thread.currentThread().getName() + &quot;\\n-- Timeout --\\nid：&quot; + id; &#125;&#125; （6）Controller层12345678910111213141516@RestControllerpublic class PaymentController &#123; @Resource PaymentService paymentService; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String getOKInfo(@PathVariable(&quot;id&quot;) Integer id) &#123; return paymentService.paymentInfo_OK(id); &#125; @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String getTimeInfo(@PathVariable(&quot;id&quot;) Integer id) &#123; return paymentService.paymentInfo_Timeout(id); &#125;&#125; 3.2 客户端简单环境搭建 （1）创建项目cloud-consumer-openfeign-hystrix-order （2）依赖引入 1234567891011121314151617181920&lt;!-- hystrix --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- openfeign：内整合了ribbon --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; （3）yaml配置 12345678910spring: application: name: cloud-consumer-openfeign-hystrix-ordereureka: client: register-with-eureka: true # 是否注册进eureka服务端 fetch-registry: true # 是否从eureka server从获取已有的注册信息，默认true。单节点无所谓，集群的话需要 service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka/ （4）主启动类 12345678@SpringBootApplication@EnableEurekaClient@EnableFeignClients //表示自己是OpenFeign的客户端public class OrderOpenFeignHystrixMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderOpenFeignHystrixMain80.class, args); &#125;&#125; （5）feign接口12345678910@Component@FeignClient(value = &quot;cloud-provider-hystrix-payment&quot;) //对应服务器的名词public interface PaymentFeignClient &#123; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String getOKInfo(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String getTimeInfo(@PathVariable(&quot;id&quot;) Integer id);&#125; （6）Controller1234567891011121314151617@RestControllerpublic class OrderFeignController &#123; @Autowired PaymentFeignClient paymentFeignClient; @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;) public String getOKInfo(@PathVariable(&quot;id&quot;) Integer id) &#123; return paymentFeignClient.getOKInfo(id); &#125; @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;) public String getTimeInfo(@PathVariable(&quot;id&quot;) Integer id) &#123; return paymentFeignClient.getTimeInfo(id); &#125;&#125; 3.2 服务降级配置 （1）解决服务端超时 服务端设置自身调用超时时间峰值，峰值内正常运行 超过峰值，需要有兜底的方法进行处理，作为服务降级fallback 1234567891011121314151617//模拟服务异常：超时@HystrixCommand(fallbackMethod = &quot;timeoutHandler&quot;, commandProperties = &#123; @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;3000&quot;) //设置超时时间为3秒&#125;) //出现异常时，调用处理方法public String paymentInfo_Timeout(Integer id) &#123; try &#123; //沉睡3秒 TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;线程池：&quot; + Thread.currentThread().getName() + &quot;\\n-- Timeout --\\nid：&quot; + id;&#125;//异常处理方法public String timeoutHandler(Integer id) &#123; //注意参数要与方法一致，才能被成功调用 return &quot;o(╥﹏╥)o！服务器繁忙，请稍后再试！&quot;;&#125; 123456789//主启动类@SpringBootApplication@EnableEurekaClient //表示此服务器是eureka client@EnableCircuitBreaker //使用hystrixpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class, args); &#125;&#125; （2）客户端配置 1234567891011@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)@HystrixCommand(fallbackMethod = &quot;timeoutHandler&quot; , commandProperties = &#123; @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;)&#125;)public String getTimeInfo(@PathVariable(&quot;id&quot;) Integer id) &#123; return paymentFeignClient.getTimeInfo(id);&#125;public String timeoutHandler(Integer id) &#123; return &quot;这里是客户端80！服务端正在忙，请稍后再来！o(╥﹏╥)o&quot;;&#125; 12345678910//主启动类@SpringBootApplication@EnableEurekaClient@EnableFeignClients //表示自己是OpenFeign的客户端@EnableCircuitBreaker //使用hystrixpublic class OrderOpenFeignHystrixMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderOpenFeignHystrixMain80.class, args); &#125;&#125; 4 问题出现与解决4.1 问题 （1）如果每一个业务方法都要有一个服务降级的方法，会导致代码膨胀 （2）业务方法与服务降级方法写在了一起，会十分的不舒服，不适合维护 4.2 代码膨胀解决 在类头添加注解@DefaultProperties(defaultFallback = &quot;&quot;) 会自动对添加了@HystrixCommand的注解默认使用此服务降级方法 123456789101112131415161718@RestController@DefaultProperties(defaultFallback = &quot;globalHandler&quot;)public class OrderFeignController &#123; @Autowired PaymentFeignClient paymentFeignClient; @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;) @HystrixCommand //直接用注解，不用配置参数 public String getTimeInfo(@PathVariable(&quot;id&quot;) Integer id) &#123; return paymentFeignClient.getTimeInfo(id); &#125; public String globalHandler() &#123; //注意全局方法不能有参数 return &quot;这里是客户端80！现在全局方法进行信息返回：服务端正在忙，请稍后再来！o(╥﹏╥)o&quot;; &#125;&#125; 4.3 业务方法降级方法分离 我们可以通过使用feign对hystrix方法的支持，来实现分离 在feign接口头上的注解新增属性：@FeignClient(value = &quot;&quot;, fallback = &quot;&quot;)，参数为一个类 123456789101112@Component //记得能够被扫描到public class paymentClientFallback implements PaymentFeignClient&#123; @Override public String getOKInfo(Integer id) &#123; //要服务降级时，会寻找同名方法来调用，所以直接实现接口最好 return &quot;这里是OK端的返回信息哦！&quot;; &#125; @Override public String getTimeInfo(Integer id) &#123; return &quot;这里是Timeout端的返回信息哦！&quot;; &#125;&#125; 12345678910@Component@FeignClient(value = &quot;cloud-provider-hystrix-payment&quot;, fallback = paymentClientFallback.class) //fallback参数为对应自己的实现类public interface PaymentFeignClient &#123; @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;) public String getOKInfo(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;) public String getTimeInfo(@PathVariable(&quot;id&quot;) Integer id);&#125; 123feign: hystrix: enabled: true #yaml配置文件开启feign对hystrix的支持 5 服务熔断5.1 服务熔断理论 closed –&gt; open：达到服务器极限，开启熔断 open –&gt; half open：一段时间后，尝试取消熔断 half open –&gt; closed：没有异常，关闭熔断 5.2 配置服务熔断 官网参数详情：https://github.com/Netflix/Hystrix/wiki/Configuration 或者SpringBoot项目搜HystrixCommandProperties.class查看可配置参数 以下案例在服务端进行配置 123456789101112131415161718//paymentService@HystrixCommand(fallbackMethod = &quot;circuitBreaker_handler&quot;, commandProperties = &#123; @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;), //是否开启断路器（熔断） @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;), //请求次数 @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;), //失败率 @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;) //沉睡时间 //以上配置意思为：开启熔断服务；10次请求的失败率达到60%，就开启服务熔断；在一定的沉睡时间后，尝试让一个请求进来，如果成功，就关闭服务熔断&#125;)public String circuitBreaker(Integer id) &#123; if(id &lt; 0) &#123; //当传参为负数时报错 throw new RuntimeException(&quot;不能负数&quot;); &#125; return &quot;方法调用成功哦！(*^▽^*)*！&quot;;&#125;public String circuitBreaker_handler(Integer id) &#123; return &quot;这里是服务熔断提醒你：id不能负数哦！&quot;;&#125; 测试：自己配一个对应的Controller接口，用负数进行错误请求达到6次以上，再用正数进行正确请求，会发现无法进行正确请求，因为服务器处于熔断状态。10秒后再进行请求，发现可以正常请求，服务器处理熔断关闭阶段 6 服务监控HystrixDashboard6.1 介绍 Hystrix提供了准实时的调用监控(Hystrix Dashborad)。Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户。 6.2 搭建HystrixDashboard （1）创建一个新工程cloud-provider-hystrix-dashboard （2）依赖引入12345678910&lt;!-- hystrix-dashboard --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; （3）yaml配置文件12server: port: 9001 （4）主启动类1234567@SpringBootApplication@EnableHystrixDashboard //开启HystrixDashboardpublic class HystrixDashboardMain9001 &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardMain9001.class, args); &#125;&#125; （5）测试：输入网址：http://localhost:9001/hystrix 6.3 服务监控测试 以下例子在cloud-provider-hystrix-payment8001来实现 （1）引入依赖 12345&lt;!--监控--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; （2）修改yaml配置文件12345management: endpoints: web: exposure: include: &#x27;hystrix.stream&#x27; #暴露hystrix监控端点 （3）启动服务器并返回hystrix dashboard","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】服务调用：OpenFeign","slug":"【SpringCloud】服务调用：OpenFeign","date":"2021-03-06T07:12:22.000Z","updated":"2021-03-06T07:14:33.017Z","comments":true,"path":"2021/03/06/【SpringCloud】服务调用：OpenFeign/","link":"","permalink":"https://letere-gzj.github.io/2021/03/06/%E3%80%90SpringCloud%E3%80%91%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%EF%BC%9AOpenFeign/","excerpt":"OpemFeign的基本使用","text":"OpemFeign的基本使用 1 OpenFeign简介1.1 介绍 官网：https://spring.io/projects/spring-cloud-openfeign Fegin是一个声明式WebService客户端，使用Fegin能让编写WebService客户端更加简单 使用方法是顶一个服务接口让后在上面添加注解 Feign也支持可拔插式的编码器和解码器 Feign可以与Eureka和Ribbon组合使用以支持负载均衡（即Feign自带负载均衡，不用配置） 1.2 功能 Feign在于使编写Java Http客户端变得更容易 实际开发中，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端来包装这些依赖服务的调用 Feign来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它，即可完成对服务提供方的接口绑定 2 OpenFeign使用2.1 依赖引入1234567891011121314151617181920212223242526&lt;!-- eureka client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- openfeign：内整合了ribbon --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 公共项目 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.letere.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;!-- web支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--监控--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 修改主启动类12345678@SpringBootApplication@EnableEurekaClient@EnableFeignClients //表示自己是OpenFeign的客户端public class OrderOpenFeignMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderOpenFeignMain80.class, args); &#125;&#125; 2.3 创建接口映射方法12345678@Component@FeignClient(value = &quot;cloud-payment-service&quot;) //对应服务器的名称public interface PaymentFeignClient &#123; //接口是对应服务器Controller中的方法，包括mapping注解 @GetMapping(&quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125; 2.4 Controller引用接口方法123456789101112@RestControllerpublic class OrderFeignController &#123; @Autowired PaymentFeignClient paymentFeignClient; @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult getPayment(@PathVariable(&quot;id&quot;) Long id) &#123; return paymentFeignClient.getPaymentById(id); //通过openFeign直接调用服务器Controller的方法，不再需要RestTemplate来发送post / Get请求 &#125;&#125; 3 OpenFeign超时控制OpenFeign内部整合了Ribbon，默认的超时时间为1s，非常短 （1）模拟超时123456789101112//服务器Controller//测试Feign超时@GetMapping(&quot;/payment/feign/timeout&quot;)public String feignTimeout() &#123; try &#123; TimeUnit.SECONDS.sleep(3); //沉睡3秒，使业务逻辑操作时间超过3秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return serverPort;&#125; 12345678//映射接口@Component@FeignClient(value = &quot;cloud-payment-service&quot;) //对应服务器的名词public interface PaymentFeignClient &#123; @GetMapping(&quot;/payment/feign/timeout&quot;) public String feignTimeout();&#125; 12345678910111213//客户端Controller@RestControllerpublic class OrderFeignController &#123; @Autowired PaymentFeignClient paymentFeignClient; @GetMapping(&quot;/consumer/payment/feign/timeout&quot;) public String feignTimeout() &#123; //feign整合ribbon，默认超时1s就会报错 return paymentFeignClient.feignTimeout(); &#125;&#125; （2）测试 （3）修改yaml配置文件 123456feign: client: config: default: connectTimeout: 5000 # 连接超时时间 readTimeout: 5000 # 读取资源超时时间 4 OpenFeign日志打印Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http请求的细节 4.1 日志级别 参数 解释 NONE 默认，不显示任何日志 BASIC 仅记录请求方法、URL、响应状态码以及执行时间 HEADERS 除了BASIC中定义的信息之外，还有请求响应的头信息 FULL 除了HEADERS中定义的信息之外，还有请求和形影的正文及原数据 4.2 配置12345678910feign: client: config: default: loggerLevel: full # 日志级别logging: level: com.letere.springcloud.feign.PaymentFeignClient: debug #feign日志监听那个接口","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】负载均衡：Ribbon","slug":"【SpringCloud】负载均衡：Ribbon","date":"2021-03-06T02:37:41.000Z","updated":"2021-03-06T02:42:22.396Z","comments":true,"path":"2021/03/06/【SpringCloud】负载均衡：Ribbon/","link":"","permalink":"https://letere-gzj.github.io/2021/03/06/%E3%80%90SpringCloud%E3%80%91%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9ARibbon/","excerpt":"负载均衡的实现，Ribbon使用","text":"负载均衡的实现，Ribbon使用 1 Ribbon入门1.1 Ribbon介绍 Ribbon是基于Netflix Ribbon实现的一套客户端，负载均衡的工具 主要功能是提供客户端的软件负载均衡（Load Balancer）算法和服务调用 官网：https://github.com/Netflix/ribbon 1.2 功能 实现负载均衡（LB） 负载均衡：将用户的请求平摊到多个服务器上，从而达到系统的高可用 集中式LB：在服务端实现负载均衡，代表：Nginx 进程内LB：在客户端实现负载均衡，也就是Ribbon 1.3 总结 Ribbon = 负载均衡 + RestTemplate调用 2 Ribbon使用2.1 依赖引入123456789101112&lt;!--一般情况引入--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--但是引入最新版的eureka的包，里面就包含了ribbon--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 RestTemplate使用 getForObject和getForEntity getForObject：返回对象为响应中数据转化为的对象，基本上可以理解为Json getForEntity：返回对象为ResponseEntity对象，包含了响应中一些重要信息，比如响应头、响应状态码、响应体 123456789101112//getForEntity使用例子@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)public CommonResult getPayment2(@PathVariable(&quot;id&quot;) Long id) &#123; ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + &quot;/payment/get/&quot; + id, CommonResult.class); if (entity.getStatusCode().is2xxSuccessful())&#123; //获取状态码，判断状态码是否200左右 return entity.getBody(); &#125; else &#123; return new CommonResult(400, &quot;请求失败！&quot;); &#125;&#125; Post请求也是一样道理 2.3 Ribbon自带的负载均衡策略 IRule：根据特定算法从服务列表中选取一个要访问的服务 所以负载均衡算法都是IRule的实现类 实现类 说明 com.netflix.loadbalancer.RoundRobinRule 轮询 com.netflix.loadbalancer.RandomRule 随机 com.netflix.loadbalancer.RetryRule 先按照轮询的策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用服务 WeightedReponseTimeRule 对轮询的拓展，响应速度越快的实例选择权重就越大，越容易被选择 BestAvaliableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 AvaliablilityFilteringRule 会先过滤故障实例，再选择并发较小的实例 ZoneAvoidanceRule 默认规则，复合判断server所在区域的性能和server的可用性选择服务器 2.4 替换负载均衡策略 注意：自定义配置类，不能放在@ComponentScan所扫描的当前包下以及子包，否则此自定义的配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的 因为@SpringBootApplication此注解包含了@ComponentScan，所以主启动类同级包，以及子包都不能放自定义配置类 （1）创建自定义配置类 12345678@Configurationpublic class MySelfRule &#123; @Bean public IRule myRule() &#123; return new RandomRule(); //随机算法 &#125;&#125; （2）修改主启动类 12345678@SpringBootApplication@EnableEurekaClient@RibbonClient(name = &quot;cloud-payment-service&quot;, configuration = MySelfRule.class) //告诉Ribbon不要使用默认策略，要使用我们配置的策略public class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class, args); &#125;&#125; 2.5 轮询算法原理与实现 轮询算法：rest接口第几次请求数 %(求余) 服务器集群总数量 = 实际调用服务器位置下标吗，每次服务重启后rest接口计数从1开始 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//源码分析public Server choose(ILoadBalancer lb, Object key) &#123; //初始化 if (lb == null) &#123; log.warn(&quot;no load balancer&quot;); return null; &#125; else &#123; Server server = null; int count = 0; while(true) &#123; if (server == null &amp;&amp; count++ &lt; 10) &#123; List&lt;Server&gt; reachableServers = lb.getReachableServers(); //获取可到达的服务（活着的服务器） List&lt;Server&gt; allServers = lb.getAllServers(); //获取所有的服务器 int upCount = reachableServers.size(); int serverCount = allServers.size(); if (upCount != 0 &amp;&amp; serverCount != 0) &#123; //当两种服务数量都不等于0时，才正常执行算法 int nextServerIndex = this.incrementAndGetModulo(serverCount); //通过算法获取下标 server = (Server)allServers.get(nextServerIndex); //通过下标获取需要访问的服务器 if (server == null) &#123; Thread.yield(); &#125; else &#123; if (server.isAlive() &amp;&amp; server.isReadyToServe()) &#123; return server; //返回该服务器 &#125; server = null; &#125; continue; &#125; log.warn(&quot;No up servers available from load balancer: &quot; + lb); return null; &#125; if (count &gt;= 10) &#123; log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot; + lb); &#125; return server; &#125; &#125;&#125;//求余获取下标算法private int incrementAndGetModulo(int modulo) &#123; int current; //当前请求数 int next; //下一次下标 do &#123; current = this.nextServerCyclicCounter.get(); next = (current + 1) % modulo; //求余 &#125; while(!this.nextServerCyclicCounter.compareAndSet(current, next)); return next;&#125; 手写轮询算法 123456789101112131415161718192021222324public class MyLB &#123; //当前网络请求次数 private AtomicInteger atomicInteger = new AtomicInteger(0); //请求数自增 private final int getAndIncrement() &#123; int current; int next; do &#123; current = this.atomicInteger.get(); next = current &gt; Integer.MAX_VALUE ? 0 : current + 1; //三元运算 &#125;while (!this.atomicInteger.compareAndSet(current, next)); log.info(&quot;**** 当前网络请求数：&quot; + next); return next; &#125; //获取需要访问服务的实例 public ServiceInstance instance(List&lt;ServiceInstance&gt; serviceInstances) &#123; int index = getAndIncrement() % serviceInstances.size(); //求余 return serviceInstances.get(index); &#125;&#125;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】服务注册中心：Consul","slug":"【SpringCloud】服务注册中心：Consul","date":"2021-03-05T12:49:34.000Z","updated":"2021-03-05T12:53:36.523Z","comments":true,"path":"2021/03/05/【SpringCloud】服务注册中心：Consul/","link":"","permalink":"https://letere-gzj.github.io/2021/03/05/%E3%80%90SpringCloud%E3%80%91%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9AConsul/","excerpt":"另一种服务注册中心使用：Consul","text":"另一种服务注册中心使用：Consul 1 Consul简介1.1 介绍 官网：https://www.consul.io/docs/intro Consul是一套开源的分布式服务发现和配置管理系统 提供微服务系统中的服务治理，配置中心，控制总线等功能 1.2 功能 服务发现：提供http和dns两种发现方式 健康监测：支持多种方式，http，tcp，docker，shell脚本定制化 KV存储：key，value存储方式 多数据中心：Consul支持多数据中心 可视化Web界面 1.3 下载地址https://www.consul.io/downloads 1.4 使用教程 官网：https://learn.hashicorp.com/collections/consul/getting-started 中文翻译网站：https://www.springcloud.cc/spring-cloud-consul.html 2 Consul安装 （1）下载解压得到：consul.exe （2）命令行：consul agent -dev进行打开 （3）访问http://localhost:8500 3 服务端安装consul （1）创建项目cloud-provider-consul-payment8006 （2）引入依赖 1234567891011121314&lt;!-- consul --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; （3）修改yaml 123456789101112server: port: 8006 #端口spring: application: name: consul-payment-service #服务名称 cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; （4）主启动类 1234567@SpringBootApplication@EnableDiscoveryClient // 表示自己是客户端public class PaymentMain8006 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8006.class, args); &#125;&#125; （5）Controller 1234567891011@RestControllerpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(&quot;/payment/consul&quot;) public String paymentConsul() &#123; return &quot;spring-cloud with consul, port: &quot; + serverPort; &#125;&#125; （6）启动测试 4 客户端安装consul 客户端安装大部分与服务端一样，下面只列举需要更改的地方 （1）更改端口号，以及服务名称 123456server: port: 81spring: application: name: consul-order-service （2）配置Bean 1234567@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate getTemplate() &#123; return new RestTemplate(); &#125;&#125; （3）更改Controller 12345678910111213@RestControllerpublic class OrderConsulController &#123; private static final String PAYMENT_URL = &quot;http://consul-payment-service&quot;; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/consul&quot;) public String paymentInfo() &#123; return restTemplate.getForObject(PAYMENT_URL + &quot;/payment/consul&quot;, String.class); &#125;&#125; 5 三种注册中心的异同 组件名 语言 CAP 服务健康检查 对外暴露接口 Spring Cloud集成 Eureka Java AP 可配支持 HTTP 已集成 Zookeeper Java CP 支持 客户端 已集成 Consul Java CP 支持 HTTP/DNS 已集成 CAP： C：Consistency（强一致性） A：Availability（可用性） P：Partition tolerance（分区容错性） AP：Eureka CP：Zookeeper / Consul","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】服务注册中心：Eureka","slug":"【SpringCloud】服务注册中心：Eureka","date":"2021-03-05T07:34:47.000Z","updated":"2021-03-05T07:36:01.644Z","comments":true,"path":"2021/03/05/【SpringCloud】服务注册中心：Eureka/","link":"","permalink":"https://letere-gzj.github.io/2021/03/05/%E3%80%90SpringCloud%E3%80%91%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9AEureka/","excerpt":"服务注册中心：Eureka的基本使用","text":"服务注册中心：Eureka的基本使用 1 服务中心作用 用于监控权限，浏览管控，来进行服务器的调度协调 类似病人看医生，需要去前台挂号，前台负责分配哪些病人访问哪些医生，进行协调 2. 基础知识2.1 服务治理 在传统的rpc远程调用框架中，管理每个服务和服务之间依赖关系比较复杂，所以诞生了服务治理 服务治理，用于管理服务与服务之间的关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册 2.2 服务注册 Eureka作为服务注册的服务器，它是服务注册的中心 系统中的其他微服务，使用Eurka的客户端连接到Eurka Server并维持心跳连接，这样维护人员就可以通过Eureka Server来监控微服务是否正常运行 2.3 Eurka组件 Eureka Server：提供服务注册服务 EurkaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到 Eureka Client：通过注册中心进行访问 一个Java客户端，用于简化Eureka Server的交互 启动后，会向Eureka Server发送信条（默认周期30秒）。如果Eureka Server在多个心跳周期内没有接收到某个检点的心跳，Eureka Server会从服务注册表中把这个服务器节点移除（默认90秒） 3 单机构建Eureka3.1 安装Eureka Server （1）创建maven项目cloud-eureka-server7001 （2）引入依赖 12345678910&lt;!-- Eureka Server --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; （3）配置yaml 1234567891011server: port: 7001eureka: instance: hostname: localhost #eureka服务器的实例名称 client: register-with-eureka: false #不向eureka-server注册自己 fetch-registry: false # 表示是否从Eureka Server获取注册信息，默认为true。因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据 service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与eureka server交互的地址，查询服务和注册服务都需要这个地址 （4）启动类 1234567@SpringBootApplication@EnableEurekaServer //表示此启动时eureka serverpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class, args); &#125;&#125; （5）运行，访问http://localhost:7001即可 注意：若运行报错，可能是端口被占用，可以重启IDEA或改端口 3.2 服务器安装Eureka Client （1）引入依赖 12345&lt;!-- eureka client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; （2）修改yaml 123456eureka: client: register-with-eureka: true # 是否注册进eureka服务端 fetch-registry: true # 是否从eureka server从获取已有的注册信息，默认true。单节点无所谓，集群的话需要 service-url: defaultZone: http://localhost:7001/eureka （3）主启动类 1234567@SpringBootApplication@EnableEurekaClient //表示此服务器是eureka clientpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class, args); &#125;&#125; （4）启动 将eureka server 和 eureka client都启动，进入http://localhost:7001 3.3 客户端安装eureka client 方法步骤和服务器的一样，只需要主要yaml配置文件中server.application.name是该客户端的名字 运行结果： 4 集群构建Eureka集群用来解决eureka发生故障时，仍能继续工作，而不是整个系统瘫痪 4.1 Eureka集群原理 一句话概括：互相注册、互相守望 4.2 Eureka Server集群搭建 （1）创建一个与端口7001一摸一样的服务器，端口7002 （2）修改本机的映射 由于我们只有一台机器，所有只能用不同的端口号来映射同一个地址 去C:Windows\\System32\\drivers\\etc的hosts文件 添加127.0.0.1 eurka7001.com和127.0.0.1 eureka7002.com （3）修改yaml文件 123456789101112131415161718192021222324# eureka7001server: port: 7001eureka: instance: hostname: eureka7001.com # eureka服务器的实例名称 client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://eureka7002.com:7002/eureka/ # 注册地址改成eureka7002的 # eureka7002server: port: 7002eureka: instance: hostname: eureka7002.com client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://eureka7001.com:7001/eureka/ # 注册地址改成eureka7001的 （4）启动效果 4.3 服务器和客户端注册到集群 操作非常简单：只需要修改yaml中的eureka server的地址即可 123eureka: client: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka/ 5 服务器集群搭建不仅ekure server需要集群，服务器也要进行集群，避免服务器挂了，整个服务都瘫痪 （1）创建一份与payment8001的服务器payment8002 （2）修改Controller 为了知道我们访问链接时，是哪个端口提供服务 123456789@GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id) &#123; Payment payment = paymentService.getPaymentById(id); log.info(&quot;****查询结果：&quot; + payment); if(payment != null ) &#123; return new CommonResult(200, &quot;查询成功, 端口号：xxxx&quot;, payment); //返回结果添加端口号信息，8001, 8002都要写 &#125; return new CommonResult(400, &quot;查询失败&quot;, null);&#125; （3）运行测试 （4）客户端开启负载均衡 123//修改OrderController// private static final String PAYMENT_URL = &quot;http://localhost:8001&quot;; private static final String PAYMENT_URL = &quot;http://cloud-payment-service&quot;; //不写死端口号，只写服务器名称 123456789//修改ApplicationContextConfig@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced //负载均衡，自动分配请求集群的端口 public RestTemplate getTemplate() &#123; return new RestTemplate(); &#125;&#125; 6 actuator微服务信息完善 通过修改yaml配置文件可以优化以上问题1234eureka: instance: instance-id: payment8002 # eureka中服务名称 prefer-ip-address: true # 访问路径是否可以显示IP地址 7 服务Discovery 服务的discovery可以显示服务器的一些信息 12345678910111213141516171819//修改PaymentController来演示@Autowiredprivate DiscoveryClient discoveryClient;@GetMapping(&quot;/payment/discovery&quot;)public Object discovery() &#123; List&lt;String&gt; services = discoveryClient.getServices(); //获取服务器名称 for(String service : services) &#123; log.info(&quot;**** &quot; + service); &#125; List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;cloud-payment-service&quot;); //获取服务器实例信息 for (ServiceInstance instance : instances) &#123; log.info(&quot;**** &quot; + instance.getServiceId() + &quot;\\t&quot; + instance.getUri()); &#125; return discoveryClient;&#125; 8 Eureka自我保护理论知识8.1 自我保护理论 当Eureka出现一下红字时，证明处理了自我保护中 出现原因：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存，避免因为网络延迟导致无法接受到心跳，导致错误删除服务 8.2 关闭自我保护12345# 服务端修改yamleureka: server: enable-self-preservation: false # 是否开启自动保护机制 关闭后会出现以下提示","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】微服务架构编码构建","slug":"【SpringCloud】微服务架构编码构建","date":"2021-03-04T12:55:29.000Z","updated":"2021-03-04T12:59:46.563Z","comments":true,"path":"2021/03/04/【SpringCloud】微服务架构编码构建/","link":"","permalink":"https://letere-gzj.github.io/2021/03/04/%E3%80%90SpringCloud%E3%80%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A0%81%E6%9E%84%E5%BB%BA/","excerpt":"简单搭建一个微服务框架，进而了解微服务","text":"简单搭建一个微服务框架，进而了解微服务 1. 父工程构建 构建总父工程（Maven项目） 选择maven-archetyp-site 注意：选择Maven选择自己的Maven版本 注解生效激活 setting -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Annotation Processors 勾选Enable annotation processing File Type过滤（过滤多余文件） setting -&gt; Editor -&gt; File Types 在Ignore Files and Folders中添加 *.idea;*.iml; 2. 修改pom.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;groupId&gt;com.letere.springcloud&lt;/groupId&gt;&lt;artifactId&gt;cloud2020&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;!--统一管理jar包和版本--&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;8.0.18&lt;/mysql.version&gt; &lt;druid.verison&gt;1.1.16&lt;/druid.verison&gt; &lt;mybatis.spring.boot.verison&gt;1.3.0&lt;/mybatis.spring.boot.verison&gt;&lt;/properties&gt;&lt;!--子模块继承之后，提供作用：锁定版本+子module不用谢groupId和version--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot 2.2.2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud Hoxton.SR1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.verison&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-springboot整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.boot.verison&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 知识补充 dependenciesManagement：用来锁定子模块依赖的版本，子模块写依赖时可以省略版本号，而且此并不会引入依赖 Maven跳过单元测试：IDEA -&gt; 右侧栏maven -&gt; 圆形闪电 4. 支付模块构建目的：用户端口为80，去引用8001端口的支付功能 4.1 微服务模块 （1）建module （2）改POM （3）写YML （4）主启动 （5）业务类 以上5步总结为：新建一个SpringBoot项目 4.2 新建module 4.3 改POM1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;dependencies&gt;&lt;!-- spring boot网络服务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--监控--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- mybatis与springboot整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--druid连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql-connector-java--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- 快速生成JavaBean注解 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;!-- SpringBoot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4.4 写YML 12345678910111213141516server: port: 8001 #端口spring: application: name: cloud-payment-service #服务名称 datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver #mysql驱动 url: jdbc:mysql://localhost:3306/springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8 username: root password: 123mybatis: mapper-locations: classpath:mapper/*.xml #mapper文件的位置 type-aliases-package: com.letere.springcloud.entities #所有Entity别名类所在包 4.5 创建主启动类 123456@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class, args); &#125;&#125; 4.6 业务类 （1）数据库表 12345CREATE TABLE `payment` ( `id` bigint NOT NULL AUTO_INCREMENT, `serial` varchar(200) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; （2）创建实体类 1234567@Data@NoArgsConstructor@AllArgsConstructorpublic class Payment implements Serializable &#123; //序列化：分布式部署需要 private Long id; private String serial;&#125; 12345678910111213//结果集@Data@NoArgsConstructor@AllArgsConstructorpublic class CommonResult&lt;T&gt; &#123; private Integer code; private String message; private T data; public CommonResult(Integer code, String message) &#123; this(code, message, null); &#125;&#125; （3）创建DAO接口 123456@Mapperpublic interface PaymentDao &#123; public int create(Payment payment); public Payment getPaymentById(Long id);&#125; （4）创建Mapper文件 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.springcloud.dao.PaymentDao&quot;&gt; &lt;resultMap id=&quot;PaymentMap&quot; type=&quot;com.letere.springcloud.entities.Payment&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt; &lt;id column=&quot;serial&quot; property=&quot;serial&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getPaymentById&quot; parameterType=&quot;Payment&quot; resultMap=&quot;PaymentMap&quot;&gt; &lt;!--配置了别名类--&gt; select * from `payment` where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;create&quot; parameterType=&quot;Payment&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!--插入成功返回数据--&gt; insert into `payment`(serial) values(#&#123;servial&#125;) &lt;/insert&gt;&lt;/mapper&gt; （5）Service层 12345public interface PaymentService &#123; public int create(Payment payment); public Payment getPaymentById(Long id);&#125; 123456789101112131415@Servicepublic class PaymentServiceImp implements PaymentService&#123; @Resource private PaymentDao paymentDao; @Override public int create(Payment payment) &#123; return paymentDao.create(payment); &#125; @Override public Payment getPaymentById(Long id) &#123; return paymentDao.getPaymentById(id); &#125;&#125; （6）Controller层 12345678910111213141516171819202122232425262728@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @PostMapping(&quot;/payment/create&quot;) public CommonResult create(@RequestBody Payment payment) &#123; int result = paymentService.create(payment); log.info(&quot;****插入结果：&quot; + result); if(result &gt; 0) &#123; return new CommonResult(200, &quot;插入成功&quot;, null); &#125; return new CommonResult(400, &quot;插入失败&quot;, null); &#125; @GetMapping(&quot;/payment/get/&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id) &#123; Payment payment = paymentService.getPaymentById(id); log.info(&quot;****查询结果：&quot; + payment); if(payment != null ) &#123; return new CommonResult(200, &quot;查询成功&quot;, payment); &#125; return new CommonResult(400, &quot;查询失败&quot;, null); &#125;&#125; 5. 消费者模块消费者模块 与 支付模块差不多，所以重复的地方不说了 5.1 依赖引入1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5.2 写YML12server: port: 81 5.3 实体类 和 支付模块一样的两个类 5.4 注入RestTemplate RestTemplate是Spring用来模拟客户端来发送请求 1234567@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate getTemplate() &#123; return new RestTemplate(); &#125;&#125; 5.5 Controller123456789101112131415161718192021@RestController@Slf4jpublic class OrderController &#123; private static final String PAYMENT_URL = &quot;http://localhost:8001&quot;; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/create&quot;) public CommonResult&lt;Payment&gt; create(Payment payment) &#123; //模拟客户端发送Post请求 return restTemplate.postForObject(PAYMENT_URL + &quot;/payment/create&quot;, payment, CommonResult.class); //参数：1、请求地址， 2、请求参数， 3、返回结果类型 &#125; @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;) public CommonResult getPayment(@PathVariable(&quot;id&quot;) Long id) &#123; //模拟客户端发送Get请求 return restTemplate.getForObject(PAYMENT_URL + &quot;/payment/get/&quot; + id, CommonResult.class); //参数：1、请求地址， 2、返回结果类型 &#125;&#125; 6. 工程重构6.1 新建共用工程 创建Maven项目：cloud-api-commons 6.2 修改POM 引入依赖1234567891011121314151617181920&lt;!-- SpringBoot热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- 快速创建JavaBean --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- hutool工具包 --&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt;&lt;/dependency&gt; 6.3 install项目 6.4 引入依赖 其他项目引入此公共项目依赖即可 12345&lt;dependency&gt; &lt;groupId&gt;com.letere.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】SpringCloud基础准备","slug":"【SpringCloud】SpringCloud基础准备","date":"2021-03-04T03:05:06.000Z","updated":"2021-03-04T03:12:51.867Z","comments":true,"path":"2021/03/04/【SpringCloud】SpringCloud基础准备/","link":"","permalink":"https://letere-gzj.github.io/2021/03/04/%E3%80%90SpringCloud%E3%80%91SpringCloud%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87/","excerpt":"关于SpringCloud版本选择以及组件的更新情况","text":"关于SpringCloud版本选择以及组件的更新情况 1. SpringCloud与SpringBoot的版本依赖 大概版本查看：https://spring.io/projects/spring-cloud#overview 详细版本查看（Json）：https://start.spring.io/actuator/info Json在线处理：https://tool.lu/json/ 官方推荐版本：https://spring.io/projects/spring-cloud#learn 2 SpringCloud组件更新 服务注册中心 Eureka：停更 Zookeeper：可以替代Eureka Consul Nacos（推荐）：完美替换Eureka 服务调用 Ribbon：进入维护阶段 LoadBalancer：初步发展 服务调用2 Fegin：停更 OpenFegin：取代Fegin 服务降级 Hystrix：停更 resilience4j：国外推荐，国内使用少 sentienl：推荐，国内使用多 服务网关 Zuul：停更 gateway：Spring推荐 服务配置 config：不常使用 Nacos：主流使用 服务总线 Bus：不常用 Nacos：主流使用","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【SpringCloud】微服务架构与SpringCloud","slug":"【SpringCloud】微服务架构与SpringCloud","date":"2021-03-04T03:03:27.000Z","updated":"2021-03-04T03:04:31.189Z","comments":true,"path":"2021/03/04/【SpringCloud】微服务架构与SpringCloud/","link":"","permalink":"https://letere-gzj.github.io/2021/03/04/%E3%80%90SpringCloud%E3%80%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8ESpringCloud/","excerpt":"SpringCloud零基础入门","text":"SpringCloud零基础入门 1 微服务架构概述1.1 微服务 微服务架构是一种架构模式，将单一应用程序划分为一组小服务，服务之间互相协调、互相配合。 1.2 基于分布式的微服务架构 服务注册与发现 服务调用 服务熔断 负载均衡 服务降级 服务消息队列 配置中心管理 服务网关 服务监控 全链路追踪 自动化构建部署 服务定时任务调度操作 2 SpringCloud简介2.1 是什么 SpringCloud = 分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶 2.2 SpringCloud集成的项目 Spring Cloud Config Spring Cloud Bus EUREKA Hystrix Zuul Archaius Consul Spring Cloud Sleuth Spring Cloud Data Flow Spring Cloud Security Spring Cloud Zookeeper Spring Cloud String Spring Cloud Cli Ribbon Feign Spring Cloud Task Spring Cloud Connectors Spring Cloud Cluster Spring Cloud Starters Spring Cloud for Cloud Foundry Turbine 3 SpringCloud技术栈 服务注册与发现：Eureka 服务负载与调用：Netflix OSS Ribbon / Netflix Feign 服务熔断降级：Hystrix 服务网关：Zuul 服务分部式配置：Spring Cloud Config 服务开发：Spring Boot","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"}],"tags":[]},{"title":"【CSS】CSS定位","slug":"【CSS】CSS定位","date":"2021-02-24T07:57:40.000Z","updated":"2021-02-24T08:04:02.025Z","comments":true,"path":"2021/02/24/【CSS】CSS定位/","link":"","permalink":"https://letere-gzj.github.io/2021/02/24/%E3%80%90CSS%E3%80%91CSS%E5%AE%9A%E4%BD%8D/","excerpt":"页面布局常用方式之二：定位，将详细介绍定位的使用","text":"页面布局常用方式之二：定位，将详细介绍定位的使用 1 定位1.1 使用场景 定位可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 1.2 定位组成 定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子 定位 = 定位模式 + 边偏移 定位模式：用于指定一个元素在文档中的定位方式 边偏移：决定了该元素的最终位置 1.3 边偏移 边偏移：定位的盒子移动到最终位置，有top, bottom, left, right 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离 left left: 80px 左侧偏移量，定义定义元素相对于其父元素左边线的距离 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 一般”上下”和”左右”选一个值出来即可 如果top、bottom同时出现，优先执行top 如果left、right同时出现，优先执行left 1.4 定位模式 定位模式决定了元素的定位方式，它通过CSS的Position属性设置，值有以下四种 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 （1）静态定位 静态定位是元素的默认定位方式，无定位的意思 语法：选择器 &#123;position: static;&#125; 静态定位按照标准流特性摆放位置，他没有边偏移 （2）相对定位 相对定位是元素在移动位置的时候，是相对于它原来的位置来说的（自恋型） 语法：选择器 &#123;position: relative;&#125; 移动位置的时候是参照原来自己的位置进行移动 相对定位后，原先在标准流占有的位置依然存在，不会像浮动那样消失 （3）绝对定位 绝对定位是在元素移动位置的时候，是相对于它祖父元素来说的（拼爹型） 语法：选择器 &#123;position: absolute&#125; 如果没有祖父元素或祖父元素没有进行定位，则以浏览器为主进行定位 如果祖父元素有了定位后，会以其最近有定位的祖父元素作为参考点 绝对定位会脱离标准流，不再占有原来的位置，类似浮动 （4）固定定位 固定定位：使元素固定于浏览器可视区的位置 主要使用场景：在浏览器页面滚动时元素的位置不会改变 语法：选择器 &#123;position: fixed&#125; 固定定位是以浏览器可视化窗口为参照 固定定位不占位置，脱离标准流 1.5 定位小技巧 （1）子绝父相 如果要使用绝对定位，一般来说参照物都是父元素，所以需要给父元素使用定位，于是相对定位比较好。 相对定位是不脱离标准流的，不会影响页面的布局 （2）固定定位到版心 通过边偏移水平调整到页面的一半：left: 50% 通过外边距水平调整版心宽度的一半：margin-left: 版心宽度一半 （3）绝对定位盒子水平居中 加了绝对定位的盒子，不能够使用margin: 0 auto来实现水平居中 通过边偏移水平调整到页面的一半：left: 50% 通过外边距水平调整到（负数）盒子宽度的一半: margin-left: -盒子宽度的一半 1.6定位叠放次序 使用定位布局时，可能会出现盒子重叠的情况，可以使用z-index来控制盒子的前后次序（z轴） 语法：选择器 &#123;z-index: 1;&#125; 数值可以是正整数或负整数。默认为auto，数值越大，盒子图层越上 若数值一样大，后写的在上面 只有定位的盒子才能设置z-index属性 1.7 拓展：粘性定位 粘性定位：可以认为是相对定位和固定定位的混合 语法：选择器 &#123;position: sticky; top: 10px&#125; 解释：当距离顶部为10px的时候，变成固定定位 特点： 以浏览器可视窗口作为参照点 粘性定位占有原先的位置，不脱离标准流 必须添加top, bottom, left, right其中一个属性才生效 1.8 拓展：定位特性 加了绝对定位/固定定位的盒子可以直接设置宽高，类似浮动 若块级元素添加了绝对定位/固定定位，宽高会默认为盒子内容的大小 浮动会影响标准流的盒子，但不会影响文字和图片，不会覆盖它们 绝对定位，固定定位会连文字和图片都会影响 2 案例：淘宝焦点图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;淘宝焦点图&lt;/title&gt; &lt;style&gt; /*消除页面自带内外边距*/ * &#123; margin: 0; padding: 0; &#125; /*消除a标签的下划线*/ a &#123; text-decoration: none; &#125; /*清除列表原点*/ li &#123; list-style: none; &#125; /*轮播图父盒子：相对定位，宽，高，外边距*/ .tb-promo &#123; position: relative; width: 520px; height: 280px; margin: 100px auto; &#125; /*轮播图片：宽， 高*/ .tb-promo img &#123; width: 520px; height: 280px; &#125; /*左右切换图片按钮：绝对定位，外边距，宽， 高，行高居中，水平居中，文字颜色，透明背景色*/ .prev, .next &#123; position: absolute; top: 50%; margin-top: -15px; width: 20px; height: 30px; line-height: 30px; text-align: center; color: white; background-color: rgba(0, 0, 0, 0.3); &#125; /*左侧按钮：水平位置，圆角位置*/ .prev &#123; left: 0; border-radius: 0 15px 15px 0; &#125; /*右侧按钮：水平位置，圆角位置*/ .next &#123; right: 0; border-radius: 15px 0 0 15px; &#125; /*底部导航栏：绝对定位，水平位置，垂直位置，宽，高，透明背景色，圆角*/ .promo-nav &#123; position: absolute; left: 50%; bottom: 15px; width: 70px; height: 13px; margin-left: -35px; background-color: rgba(255, 255, 255, 0.3); border-radius: 7px; &#125; /*圆点按钮：浮动，宽，高，背景色，圆角，外边距*/ .promo-nav li &#123; float: left; width: 8px; height: 8px; background-color: white; border-radius: 4px; margin: 3px; &#125; /*圆点被点击后的样式*/ .promo-nav .selected &#123; background-color: #ff5000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tb-promo&quot;&gt; &lt;img src=&quot;image/淘宝轮播图.jpg&quot; alt=&quot;&quot;/&gt; &lt;a class=&quot;prev&quot; href=&quot;#&quot;&gt;&lt;&lt;/a&gt; &lt;a class=&quot;next&quot; href=&quot;#&quot;&gt;&gt;&lt;/a&gt; &lt;ul class=&quot;promo-nav&quot;&gt; &lt;li class=&quot;selected&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3 元素的显示与隐藏3.1 display属性 隐藏对象：display: none 元素隐藏后不会再占有原来的位置 显示对象：display: block 3.2 visibility属性 值 介绍 inherit 继承上一个父对象的可见性 visible 对象显示 hidden 对象隐藏 collapse 隐藏表格的行和列 visibility对象隐藏后会保留原来的位置 3.3 overflow属性 值 介绍 visible 不剪切内容，也不添加滚动条 auto 是body和textarea的默认值；在需要时剪切内容并添加滚动条 hidden 不显示超出对象尺寸的内容 scroll 溢出部分用滚动条查看 3.4 案例：土豆网鼠标经过显示遮罩 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;土豆网隐藏遮罩&lt;/title&gt; &lt;style&gt; .potato &#123; position: relative; width: 444px; height: 320px; margin: 100px auto; &#125; .potato img &#123; width: 100%; height: 100%; &#125; .potato .mask &#123; position: absolute; display: none; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.3); &#125; .potato:hover .mask &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;potato&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;image/凌波.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://letere-gzj.github.io/categories/CSS/"}],"tags":[]},{"title":"【CSS】页面布局案例：学成在线页面","slug":"【CSS】页面布局案例：学成在线页面","date":"2021-02-22T03:32:55.000Z","updated":"2021-02-22T03:43:49.469Z","comments":true,"path":"2021/02/22/【CSS】页面布局案例：学成在线页面/","link":"","permalink":"https://letere-gzj.github.io/2021/02/22/%E3%80%90CSS%E3%80%91%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A1%B5%E9%9D%A2/","excerpt":"案例的源码和素材：https://gitee.com/letere/studyPage案例来源：Pink老师","text":"案例的源码和素材：https://gitee.com/letere/studyPage案例来源：Pink老师 1 header 1.1 模块分析 1.2 html 与 css12345678910111213141516171819202122&lt;!--头部--&gt;&lt;div class=&quot;header w&quot;&gt; &lt;!--logo标识--&gt; &lt;div class=&quot;logo&quot;&gt; &lt;img src=&quot;imgs/logo.png&quot;&gt; &lt;/div&gt; &lt;!--导航栏模块--&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;课程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;职业规划&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--搜索模块--&gt; &lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入关键字&quot;&gt; &lt;button&gt;&lt;/button&gt; &lt;/div&gt; &lt;!--用户信息模块--&gt; &lt;div class=&quot;user&quot;&gt; 莱特雷 &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/*清除页面自带内外边距*/* &#123; margin: 0; padding: 0;&#125;/*清除所有ul的原点*/ul &#123; list-style: none;&#125;/*清除所有a标签的下划线*/a &#123; text-decoration: none;&#125;/*版心*/.w &#123; width: 1200px; margin: 0 auto;&#125;/* ------- header ------- *//*页面头部布局*/.header &#123; height: 42px; /*background-color: pink;*/ margin: 30px auto;&#125;/*头部 logo布局*/.header .logo &#123; float: left; width: 198px; height: 42px;&#125;/*导航栏布局*/.header .nav &#123; float: left; margin-left: 60px;&#125;/*导航栏列表布局*/.header .nav li &#123; float: left; margin: 0 13px;&#125;/*导航栏列表中a标签布局*/.header .nav li a &#123; display: block; padding: 0 10px; height: 42px; line-height: 42px; font-size: 18px; color: #050505;&#125;/*鼠标经过导航栏的变化*/.header .nav li a:hover &#123; border-bottom: 2px solid #00a4ff;&#125;/*搜索模块*/.header .search &#123; float: left; width: 412px; height: 42px; margin-left: 70px;&#125;/*搜索输入框*/.header .search input &#123; float: left; width: 346px; height: 40px; padding-left: 15px; border: 1px solid #00a4ff; border-right: 0; font-size: 14px;&#125;/*搜索按钮*/.header .search button &#123; float: left; width: 50px; height: 42px; border: 0; background-color: #00a4ff; background-image: url(&quot;imgs/fa-search.png&quot;); background-repeat: no-repeat; background-position: center;&#125;/*用户模块*/.header .user &#123; float: right; height: 42px; line-height: 42px; margin-right: 30px; padding-left: 32px; background-image: url(&quot;imgs/avatar.png&quot;); background-repeat: no-repeat; background-position: left center; font-size: 14px; color: #666666;&#125; 2 banner 2.1 模块分析 2.2 html 和 css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!--banner：横幅--&gt; &lt;div class=&quot;banner&quot;&gt; &lt;!--版心--&gt; &lt;div class=&quot;w&quot;&gt; &lt;!--侧边导航栏--&gt; &lt;div class=&quot;sub-nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 前端开发 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 后端开发 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 移动开发 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 人工智能 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 商业预测 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 云计算&amp;大数据 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 运维&amp;从测试 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; UI设计 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 产品 &lt;span&gt;&gt;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--课程表模块--&gt; &lt;div class=&quot;course&quot;&gt; &lt;h2&gt;我的课程表&lt;/h2&gt; &lt;div class=&quot;bd&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;h4&gt;继续学习 程序语言设计&lt;/h4&gt; &lt;p&gt;正在学习-使用对象&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h4&gt;继续学习 程序语言设计&lt;/h4&gt; &lt;p&gt;正在学习-使用对象&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h4&gt;继续学习 程序语言设计&lt;/h4&gt; &lt;p&gt;正在学习-使用对象&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;#&quot;&gt;全部课程&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* ---------- banner ---------- *//*banner模块*/.banner &#123; height: 421px; background-color: #1c036c;&#125;/*banner中版心*/.banner .w &#123; height: 412px; background: url(&quot;imgs/banner.png&quot;) no-repeat center center;&#125;/*侧边导航栏*/.banner .sub-nav &#123; float: left; width: 190px; height: 421px; background: rgba(0, 0, 0, 0.3);&#125;/*链接列表*/.banner .sub-nav ul li &#123; height: 45px; line-height: 45px; padding: 0 20px;&#125;/*侧边栏链接*/.banner .sub-nav ul li a &#123; color: white;&#125;/*鼠标经过侧边栏链接*/.banner .sub-nav ul li a:hover &#123; color: #00a4ff;&#125;/*链接中的&quot;&gt;&quot;*/.banner .sub-nav ul li a span &#123; float: right;&#125;/*课程表模块*/.banner .course &#123; float: right; width: 230px; height: 300px; margin-top: 50px; background-color: white;&#125;/*课程表标题*/.banner .course h2 &#123; height: 48px; line-height: 48px; text-align: center; font-size: 18px; color: white; background-color: #9bceea;&#125;/*课程表内容*/.banner .course .bd &#123; padding: 0 20px;&#125;/*内容列表*/.banner .course .bd ul li &#123; padding: 14px 0; border-bottom: 1px solid #eaeaea;&#125;/*列表上层内容*/.banner .course .bd ul li h4 &#123; font-size: 14px; color: #4e4e4e;&#125;/*列表下层内容*/.banner .course .bd ul li p &#123; font-size: 12px; color: #a5a5a5;&#125;/*“查看全部课程”*/.banner .course .bd a &#123; display: block; height: 38px; margin-top: 5px; line-height: 38px; text-align: center; font-size: 16px; color: #00a4ff; border: 1px solid #00a4ff;&#125; 3 goods 3.1 模块分析 3.2 html 和 css12345678910111213&lt;!--goods：精品--&gt;&lt;div class=&quot;goods w&quot;&gt; &lt;h3&gt;精品推荐&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Spark&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;MySQL&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;JavaWeb&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Vue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;#&quot;&gt;修改兴趣&lt;/a&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243/* ---------- goods ----------*//*goods模块整体布局*/.goods &#123; height: 60px; margin-top: 10px; background-color: white; box-shadow: 0 2px 3px 3px rgba(0, 0, 0, 0.1);&#125;/*goods中左标题*/.goods h3 &#123; float: left; height: 60px; line-height: 60px; margin: 0 30px; font-size: 16px; color: #00a4ff;&#125;/*goods中间的列表*/.goods ul li &#123; float: left; height: 60px; line-height: 60px;&#125;/*goods列表中链接*/.goods ul li a &#123; padding: 0 30px; font-size: 16px; color: #050505; border-left: 1px solid #cccccc;&#125;/*goods右链接*/.goods&gt;a &#123; float: right; height: 60px; line-height: 60px; margin-right: 30px; font-size: 14px; color: #00a4ff;&#125; 4 box 4.1 模块分析 4.2 html 和 css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!--box：精品推荐大模块--&gt;&lt;div class=&quot;box w&quot;&gt; &lt;div class=&quot;box-hd&quot;&gt; &lt;h3&gt;精品推荐&lt;/h3&gt; &lt;a href=&quot;#&quot;&gt;查看全部&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;box-bd&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;imgs/goods.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;Think PHP 5.0 博客系统实战项目演示&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span style=&quot;color: #ff7c2d;&quot;&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* ---------- box ----------*//*整体盒子布局*/.box &#123; margin-top: 30px; overflow: hidden;&#125;/*盒子内标题布局*/.box .box-hd &#123; height: 45px;&#125;/*标题左内容*/.box .box-hd h3 &#123; float: left; font-size: 20px; color: #494949;&#125;/*标题右内容*/.box .box-hd&gt;a &#123; float: right; margin-top: 10px; margin-right: 30px; font-size: 12px; color: #a5a5a5;&#125;/*调整整合ul大小，避免加上子内容外边距超出盒子大小*/.box .box-bd ul &#123; width: 1215px;&#125;/*列表子内容布局*/.box .box-bd ul li&#123; float: left; width: 228px; height: 270px; margin-right: 15px; margin-bottom: 15px; background-color: white;&#125;/*调整图片跟盒子一样大*/.box .box-bd ul li img &#123; width: 100%;&#125;/*列表内容1*/.box .box-bd ul li h4 &#123; margin: 20px 20px 20px 25px; font-size: 14px; color: #050505; font-weight: 400;&#125;/*列表内容2*/.box .box-bd ul li .info &#123; margin: 0 20px 0 25px; font-size: 12px; color: #999;&#125; 5 footer 5.1 模块分析 5.2 html 和 css12345678910111213141516171819202122232425262728293031323334353637&lt;!--footer：页脚--&gt;&lt;div class=&quot;footer&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;copy-right&quot;&gt; &lt;img src=&quot;imgs/logo.png&quot; alt=&quot;&quot;&gt; &lt;p&gt;学成在线致力于普及中国最好的教育它与中国一流大学和机构合作提供在线课程。 © 2017年XTCG Inc.保留所有权利。-沪ICP备15025210号&lt;/p&gt; &lt;a href=&quot;#&quot;&gt;下载APP&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;links&quot;&gt; &lt;dl&gt; &lt;dt&gt;关于学成网&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;管理团队&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;工作机会&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;客户服务&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;帮助&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;关于学成网&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;管理团队&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;工作机会&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;客户服务&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;帮助&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;关于学成网&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;管理团队&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;工作机会&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;客户服务&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;帮助&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* ---------- footer ---------- *//*页脚布局*/.footer &#123; height: 415px; padding-top: 35px;&#125;/*页脚版心左边部分*/.footer .w .copy-right &#123; float: left;&#125;/*左部分的文字*/.footer .w .copy-right p &#123; width: 430px; margin-top: 25px; font-size: 12px; color: #666666;&#125;/*左部分的按钮*/.footer .w .copy-right a &#123; display: block; width: 120px; height: 36px; margin-top: 15px; line-height: 36px; text-align: center; border: 1px solid #00a4ff; font-size: 16px; color: #00a4ff;&#125;/*页脚版心右部分*/.footer .w .links &#123; float: right;&#125;/*右部分的一行盒子*/.links dl &#123; float: left; margin-left: 120px;&#125;/*右部分的标题*/.links dl dt &#123; margin-bottom: 15px; font-size: 16px; color: #7d7d7d;&#125;/*右部分的内容*/.links dl dd a &#123; font-size: 12px; color: #333333;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://letere-gzj.github.io/categories/CSS/"}],"tags":[]},{"title":"【CSS】CSS浮动","slug":"【CSS】CSS浮动","date":"2021-02-20T04:48:18.000Z","updated":"2021-02-20T04:51:57.525Z","comments":true,"path":"2021/02/20/【CSS】CSS浮动/","link":"","permalink":"https://letere-gzj.github.io/2021/02/20/%E3%80%90CSS%E3%80%91CSS%E6%B5%AE%E5%8A%A8/","excerpt":"介绍页面布局十分常用的方法：浮动","text":"介绍页面布局十分常用的方法：浮动 1 浮动1.1 传统网页布局 （1）普通流（标准流） 标签按照规定好的默认方式排列 （2）浮动 （3）定位 一般网页布局包含了这三种布局方式 1.2 浮动介绍 float属性用于创建度佛那个框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘 1float: 属性值; 属性值 描述 none 元素不浮动（默认） left 元素向左浮动 right 元素向右浮动 1.3 浮动特性 （1）浮动元素会脱离标准流 浮动类似在原有的图层上再创建一个图层 浮动之后，不会再保留原先的位置 （2）如果多个盒子设置了浮动，会按照属性值在一行内显示并且元素顶部对齐 只有浮动盒子和浮动盒子之间才会在同一行 前一个盒子没有浮动，后一个盒子浮动了，也不会变成在同一行显示（浮动只会影响后面标准流的盒子，不影响前面的） （3）浮动元素具有行内块元素特性（可以设置宽高，可以在一行内显示，可以按照内容自动设置宽度） 不管什么元素，添加了浮动，都具有行内块元素特性 1.4 使用技巧 浮动元素经常和标准流父级搭配使用 2 浮动实例2.1 小米布局1 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小米布局&lt;/title&gt; &lt;style&gt; /*父盒子布局*/ .box &#123; width: 1200px; height: 460px; background-color: pink; margin: 100px auto; &#125; /*左子盒子布局*/ .box .left &#123; width: 230px; height: 460px; background-color: #b0b0b0; float: left; &#125; /*右子盒子布局*/ .box .right &#123; width: 970px; height: 460px; background-color: #ff8500; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.2 小米布局2 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小米布局2&lt;/title&gt; &lt;style&gt; /*清除页面自带内外边距*/ * &#123; margin: 0; padding: 0; &#125; /*父盒子布局*/ ul &#123; width: 1226px; height: 285px; background-color: pink; margin: 100px auto; &#125; /*子盒子布局*/ ul li &#123; width: 296px; height: 285px; background-color: #cccccc; list-style: none; float: left; margin-right: 14px; &#125; /*清除最后一个子盒子的外边距，避免塞不进同一行*/ ul .last &#123; margin-right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class=&quot;last&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2.3 小米布局3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小米布局3&lt;/title&gt; &lt;style&gt; /*父盒子布局*/ .box &#123; width: 1226px; height: 615px; background-color: pink; margin: 100px auto; &#125; /*左子盒子布局*/ .box .left &#123; float: left; width: 234px; height: 615px; background-color: #cccccc; &#125; /*右子盒子布局*/ .box .right &#123; float: left; width: 992px; height: 615px; background-color: skyblue; &#125; /*右子子盒子布局*/ .box .right&gt;div &#123; float: left; width: 234px; height: 300px; background-color: greenyellow; margin-left: 14px; margin-bottom: 14px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3 常见网页布局 4 清除浮动 有时候，在一个标准流的父盒子里不清楚要装多少个浮动的子盒子，就不适宜把父盒子的高度定死。但是盒子一旦浮动就会脱离标准流，不能自动撑开父盒子，所以需要使用浮动清除来解决。 4.1 清除浮动本质 清除浮动的本质，就是清除浮动后造成的影响 清除浮动后，父盒子会根据浮动的子盒子自动检测高度。父盒子有高度后，就不会影响下面的标准流 4.2 使用1clear 属性值 属性值 描述 left 不允许左侧有浮动元素（消除左侧浮动的影响） right 不允许右侧有浮动元素（消除右侧浮动的影响） both 同时清除左右两侧浮动的影响 4.3 清除浮动的方法 （1）额外标签法（隔离法） 在最后一个浮动的标签后面，添加一个新的块级空标签，样式为clear: both 例：&lt;div style=&quot;clear: both&quot; /&gt; （2）父级添加overflow属性 给标签添加overflow: hidden | auto | scroll三者都可以 （3）父级添加after属性 额外标签法的升级版，after伪元素类似在标签后面创建一个新的空标签，只是用css来生成，不是直接写在网页上12345678910111213/*写法固定，暂不作解析*/.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;&#125;/*IE6、7专有*/.clearfix &#123; *zoom: 1;&#125; （4）父级添加双伪元素12345678910111213/*在前后都插入一个空标签*/.clearfix:before, .clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;/*IE6、7专有*/.clearfix &#123; *zoom: 1;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://letere-gzj.github.io/categories/CSS/"}],"tags":[]},{"title":"【CSS】盒子美化","slug":"【CSS】盒子美化","date":"2021-02-19T07:27:11.000Z","updated":"2021-02-19T07:27:58.291Z","comments":true,"path":"2021/02/19/【CSS】盒子美化/","link":"","permalink":"https://letere-gzj.github.io/2021/02/19/%E3%80%90CSS%E3%80%91%E7%9B%92%E5%AD%90%E7%BE%8E%E5%8C%96/","excerpt":"介绍一些美化盒子的操作","text":"介绍一些美化盒子的操作 1 圆角边框1.1 使用 在CSS3中，加入圆角边框样式，通过border-radius: ...px | ...%设置 1.2 原理 原理：圆角边框设置的值是圆的半径，通过半径画出的圆与边框四角重叠，来画出圆角 1.3 使用技巧 （1）画出圆形 123width: 200px;height: 200px;border-radius: 100px | 50%; /*半径设置为正方形盒子的长度一半*/ （2）画出圆角矩形 123width: 200px;height: 100px;border-radius: 50px; /*半径为长方形高度的一半*/ （3）自定义圆角 12345border-top-left-radius: ..px;border-top-right-radius: ..px;border-bottom-right-radius: ..px;border-bottom-left-radius: ..px;broder-radius: 左上 右上 右下 左下; /*可以按顺序分别设置四个角所的圆形大小*/ 2 盒子阴影 1box-shadow: h-shadow v-shadow blur spread color inset; 值 描述 h-shadow 必需，水平阴影的位置，允许负值 v-shadow 必需，垂直阴影的位置，允许负值 blur 可选，模糊距离 spread 可选，阴影尺寸 color 可选，阴影的颜色 inset 可选，将外部阴影改成内部阴影 推荐参数：box-shadow: 5px 5px 5px 0 rgba(0, 0, 0, 0.3); 注意： 默认使用外阴影(outset)，但不可以写上这个单词，否则阴影无效 盒子阴影不占用空间，不会影响其他盒子排列 3 文字阴影 1text-shadow: h-shadow v-shadow blur color 值 描述 h-shadow 必需，水平阴影的位置，允许负值 v-shadow 必需，垂直阴影的位置，允许负值 blur 可选，模糊举例 color 可选，阴影的颜色","categories":[{"name":"CSS","slug":"CSS","permalink":"https://letere-gzj.github.io/categories/CSS/"}],"tags":[]},{"title":"【CSS】盒子模型","slug":"【CSS】盒子模型","date":"2021-02-19T04:22:13.000Z","updated":"2021-02-19T04:27:01.272Z","comments":true,"path":"2021/02/19/【CSS】盒子模型/","link":"","permalink":"https://letere-gzj.github.io/2021/02/19/%E3%80%90CSS%E3%80%91%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"简单概述页面布局基础，盒子模型的认识，以及综合案例","text":"简单概述页面布局基础，盒子模型的认识，以及综合案例 1 网页布局的本质 网页布局的过程： （1）准备好相关的网页元素，网页元素都基本是盒子Box （2）利用CSS设置好盒子样式，然后摆放到相应的位置 （3）往盒子里面装内容 网页布局的本质：摆放盒子 2 盒子模型组成 盒子模型：被html页面中的布局元素看做是一个矩形的盒子，也就是一个盛装内容的容器 CSS盒子模型：封装着边框，外边距，内边距，和实际内容 3 边框 可以通过border来设置边框的宽度，样式，颜色 123456789101112131415161718192021222324252627282930/*设置边框宽度*/border-width: ..px;/*设置边框样式*/border-style: none hidden dotted /*点线*/ dashed /*虚线*/ solid /*实线*/ doubled /*双实线*/ groove /*3D凹槽*/ ridge /*菱形边框*/ inset /*3D凹边*/ outset /*3D凸边*//*设置边框颜色*/border-color: red;/*边框整合写法：顺序无要求*/border: border-width | border-style | border-color;/*可以按照边框的上下左右设置*/border-top: border-width | border-style | border-color;border-buttom: border-width | border-style | border-color;border-left: border-width | border-style | border-color;border-right: border-width | border-style | border-color;/*合并相邻的边框*/border-collapse: collapse 边框会影响盒子的大小，添加边框后的，盒子实际的大小=边框宽度 + 盒子宽度 4 内边距4.1 css使用123456789101112/*上下左右内边距*/padding-top: ..px;padding-buttom: ..px;padding-left: ..px;padding-right: ..px;/*内边距复合写法*/padding: ..px /*1个值，就上下左右内边距都是这值*/ ..px ..px /*2个值*，第一个是上下边距值，第二个是左右边距值/ ..px ..px ..px /*3个值，第一个值是上边距，第二个是左右边距，第三个是下边距*/ ..px ..px ..px ..px /*4个值，分别是上右下左边距值，即顺时针算*/ 内边距也会影响盒子的大小，盒子的实际大小 = 内边距大小 + 盒子宽度 若盒子没有给定宽度大小，则内边距不会撑开盒子大小 5 外边距5.1 css使用123456789101112/*上下左右外边距*/margin-top: ..pxmargin-buttom: ..px;margin-left: ..px;margin-right: ..px/*外边距复合写法：和padding使用方法一样*/margin: ..px ..px ..px ..px ..px ..px ..px ..px ..px ..px 5.2 外边距应用 （1）块级盒子水平居中 1、盒子指定宽度； 2、左右外边距设置为auto，即margin: 0 auto; （2）行内元素、行内块元素水平居中 在其父元素添加text-align: center即可 5.3 外边距合并 对于两个嵌套关系（父子关系）的块元素，子元素的外边距不会影响自己，反而是影响父元素的外边距 解决方法： （1）为父元素定义上边框 （2）为父元素定义上内边距 （3）为父元素添加overflow: hidden 6 清除网页自带内外边距 一些浏览器会自带内外边距，会影响我们的页面布局，所以在布局前，先清除内外边距 12345/* css的第一行代码 */* &#123; margin: 0; padding: 0;&#125; 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距 7 综合案例7.1 新浪导航栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;新浪导航栏&lt;/title&gt; &lt;style&gt; .nav &#123; /*边框*/ border-top: 3px solid #ff8500; border-bottom: 1px solid #edeef0; /*大小，背景*/ height: 41px; background-color: #fcfcfc; /*调整文字位置*/ line-height: 41px; &#125; .nav a &#123; /*转变成行内块元素，可以调整高度，也可以在同一行显示*/ display: inline-block; height: 41px; /*文字调整*/ font-size: 12px; color: #4c4c4c; text-decoration: none; /*内边距，利用内边距撑开盒子的宽度，而不是给固定的大小*/ padding: 0 20px; &#125; a:hover &#123; background-color: #eee; color: #ff8500; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;a href=&quot;#&quot;&gt;新浪导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;手机新浪网&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;移动客户端&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7.2 产品模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;产品模块&lt;/title&gt; &lt;style&gt; /*消除网页自带的内外边距*/ * &#123; margin: 0; padding: 0; &#125; body &#123; background-color: #f5f5f5; &#125; .box &#123; width: 298px; height: 415px; /*水平居中*/ margin: 0 auto; background-color: white; &#125; .box img &#123; /*跳转图片大小与父元素一样宽*/ width: 100%; &#125; .review &#123; font-size: 14px; height: 70px; margin-top: 28px; padding: 0 28px; &#125; .appraise &#123; font-size: 12px; color: #b0b0b0; margin-top: 20px; padding: 0 28px; &#125; .info h4&#123; display: inline-block; font-size: 14px; margin: 15px 28px 0; /*文字不加粗*/ font-weight: 400; &#125; .info span &#123; font-size: 14px; color: #ff6700; border-left: 2px solid #ebe4e0; padding-left: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;img.jpg&quot;/&gt; &lt;p class=&quot;review&quot;&gt;快递牛，整体不错蓝牙可以说秒连。红米给力&lt;/p&gt; &lt;div class=&quot;appraise&quot;&gt; 来自于117384232的评价 &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;h4&gt;Redmi AirDots真无线蓝...&lt;/h4&gt; &lt;span&gt;99.9元&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 7.3 快报模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;快报模块&lt;/title&gt; &lt;style&gt; /*清除页面自带内外边距*/ * &#123; margin: 0; padding: 0; &#125; /*最外层盒子布局（宽，高，边框，位置）*/ .box &#123; width: 248px; height: 163px; border: 1px solid #ccc; margin: 100px auto; &#125; /*标题布局（文字大小，取消加粗，高，行高居中，下边框，内边距）*/ .box h3 &#123; font-size: 14px; font-weight: 400; height: 32px; line-height: 32px; border-bottom: 1px dotted #ccc; padding-left: 15px; &#125; /*列表整体布局（上外边距）*/ .box ul &#123; margin-top: 7px; &#125; /*无序列表布局（去除列表原点，高，行高居中，左内边距）*/ .box ul li &#123; list-style: none; height: 23px; line-height: 23px; padding-left: 20px; &#125; /*列表链接布局（文字大小，颜色，无下划线）*/ .box ul li a &#123; font-size: 12px; color: #666666; text-decoration: none; &#125; /*鼠标浏览链接（下划线）*/ .box ul li a:hover &#123; text-decoration: underline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;h3&gt;品优购快报&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;【特惠】爆款耳机5折秒！&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;【特惠】母亲节，健康好礼低至5折！&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;【特惠】9.9元洗100张照片！&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;【特惠】NS只需1999元购买！&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;【特惠】怪物猎人Rise只需300元！&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://letere-gzj.github.io/categories/CSS/"}],"tags":[]},{"title":"【CSS】CSS基础补充","slug":"【CSS】CSS基础补充","date":"2021-02-16T02:21:57.000Z","updated":"2021-02-16T02:33:13.997Z","comments":true,"path":"2021/02/16/【CSS】CSS基础补充/","link":"","permalink":"https://letere-gzj.github.io/2021/02/16/%E3%80%90CSS%E3%80%91CSS%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85/","excerpt":"这是CSS样式的深入学习之前CSS样式学习地址：https://letere.gitee.io/blog/2020/11/16/【JavaWeb】html和css","text":"这是CSS样式的深入学习之前CSS样式学习地址：https://letere.gitee.io/blog/2020/11/16/【JavaWeb】html和css 1 CSS文本属性12345678910111213141516171819202122/* 文本颜色 */color: red; /* 预设 | 十六进制 | RGB *//* 文本水平对齐 */text-align: left /*左对齐*/ right /*右对齐*/ center /*居中对齐*//* 文本装饰 */text-decoration: none /* 默认，没有装饰 */ underline /* 下划线 */ overline /* 上划线 */ line-through /* 删除线 *//* 文本缩进 */text-indent: [..px | ..% | ..em] /*推荐使用em，em相对单位，1单位=1个文字大小，所有文章首行缩进选择2em*//* 行间距 *//* 行间距 = 上间距 + 文字高度 + 下间距 */line-hight: [..px] 2 CSS的引入2.1 内部样式表（嵌入式） 将所用的CSS样式抽取到一个&lt;style&gt;标签中 12345&lt;style&gt; div &#123; color: red; &#125;&lt;/style&gt; 2.2 行内样式表（行内式） 简单修改一个标签，可以直接在标签添加style=&quot;&quot;进行样式修改 1&lt;p style=&quot;color: red; font-size: 16px;&quot;&gt;Hello World!&lt;/p&gt; 2.3 外部样式表（链接式） 当样式比较多时，将样式写进一个.css文件，然后引入到html页面中 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt; 3 Emment语法3.1 简介 Emmet语法是来调高html/css的编写速度 3.2 使用Emmet快速生成html （1）生成标签：标签名 + tab （2）生成多个标签：标签名*数量 + tab （3）生成父子级标签：父标签名&gt;子标签名 + tab （4）生成兄弟关系标签：标签1+标签2 + tab （5）生成带有类名的标签：标签名.类名 + tab （6）生成带有id名的标签：标签名#id名 + tab （7）生成有序号带类名的标签：标签名.类名$*数量 + tab p.demo$*5，会生成demo1 ---- demo5类名的标签 （8）生成标签带有内容：标签名&#123;内容&#125; + tab 3.3 使用Emment快速生成css 快速生成都是取首字母的简写方式 例：text-align: center == tac + tab 4 复合选择器4.1 简介 根据选择器的类型可以把选择器分为两类：基础选择器和复合选择器 复合选择器是建立在基础选择器上，对基本选择器进行组合形成的 复合选择器可以更准确，更高效的选择目标元素 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成 常用复合选择器：后代选择器，子选择器，并集选择器，伪类选择器等等 4.2 后代选择器 后代选择器有称为包含选择器，可以选择父元素里面子元素 格式：父元素 子元素 &#123;样式&#125; 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;style&gt; /*只选择出ol下面的li进行样式添加*/ ol li &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ol&gt; &lt;li&gt;我会变色&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;我不会变&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 4.3 子选择器 子选择器也称为子元素选择器，只能选择作为某元素的最近一级子元素。 格式：父元素 &gt; 子元素 &#123;样式&#125; 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;style&gt; /*只对子元素a标签进行修改*/ div &gt; a &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;a&gt;我是儿子&lt;/a&gt; &lt;p&gt; &lt;a&gt;我是孙子&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 4.4 并集选择器 并集选择器可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明 并集选择器，可以让任何形式的选择器作为元素 格式：元素1, 元素2 &#123;样式&#125; 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;style&gt; /*两个标签同时进行修改*/ div, p &#123; color: red; &#125; /*格式规范，一般&#x27;,&#x27;之后换下一行再写，不要写在同一行*/ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;咕料&lt;/div&gt; &lt;p&gt;C酱&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 4.5 伪类选择器 伪类选择器用于向某些选择器添加特殊效果，比如给链接添加特殊效果，或选择第1个，第n个元素 伪类选择器有链接伪类、结构伪类等等 格式：标签:参数 &#123;样式&#125; （1）链接伪类选择器 1234a:link /*选择所有未被访问的链接*/a:visited /*选择所有已访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/a:active /*选择活动链接（鼠标按下未弹起的链接）*/ 注意事项： 为了保证生效，按照link, visited, hover, active顺序进行书写 （2）focus焦点伪类选择器 1input:focus /*当前光标选中的input*/ 5 元素显示模式5.1 简介 元素显示模式：元素以什么方式进行显示，比如div自己占一行，比如一行可以放多个span html元素分为：块元素和行内元素 5.2 块元素 常见块元素：&lt;h1&gt;~&lt;h6&gt;，&lt;p&gt;，&lt;div&gt;，&lt;ul&gt;，&lt;ol&gt;，&lt;li&gt; 块元素特点： 自己独占一行 高度，宽度，外边距，内边距都可以控制 宽度默认是容器（父级宽度）的100% 是一个容器，里面可以放行内元素或块元素 注意： 文字类的元素内不能使用块元素 &lt;p&gt;，&lt;h1&gt;~&lt;h6&gt;里面只能放文字，不能存放其他块元素，尤其是&lt;div&gt; 5.3 行内元素 常见行内元素：&lt;a&gt;，&lt;strong&gt;，&lt;b&gt;，&lt;em&gt;，&lt;del&gt;，&lt;s&gt;，&lt;ins&gt;，&lt;u&gt;，&lt;span&gt;等 行内元素特点： 一行可以显示多个 高、宽直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其他行内元素 注意： 链接里面不允许再放链接 特殊情况链接&lt;a&gt;里面是可以放块及元素，但是给&lt;a&gt;转换一下块级模式最安全 5.4 行内块元素 在行内元素中有几个特殊的标签：&lt;img/&gt;，&lt;input/&gt;, &lt;td&gt;，它们同时具有块元素和行内元素特点 行内块元素特点： 和相邻的行内元素在一行上，但是它们之间或有空白缝隙，一行可以显示多个 默认宽度就是它本身内容的宽度 高度，行高，外边距以及内边距都可以控制 5.5 元素显示模式转换 特殊情况下，我们需要元素模式的转换，简单理解：一个模式的元素需要另外一种模式的特性，比如想要增加链接&lt;a&gt;的触发范围 12345display: block /*将行内元素转变成块元素*/display: inline /*将块元素转变成行内元素*/display: inline-block /*转变成行内块元素*/ 5.6 案例：小米侧边栏123456789101112131415161718192021222324252627282930313233343536&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;小米侧边栏&lt;/title&gt; &lt;style&gt; a &#123; /*转为块级元素*/ display: block; width: 230px; height: 40px; background-color: #55585a; /*设置文字样式*/ font-size: 14px; color: #fff; text-decoration: none; /*设置文字位置*/ text-indent: 2em; line-height: 40px; /*行高=高度：达到垂直居中*/ &#125; a:hover &#123; background-color: #ff6700; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot;&gt;手机 电话卡&lt;/a&gt; &lt;a href=&quot;&quot;&gt;电视 盒子&lt;/a&gt; &lt;a href=&quot;&quot;&gt;出行 穿戴&lt;/a&gt; &lt;a href=&quot;&quot;&gt;智能 路由器&lt;/a&gt; &lt;a href=&quot;&quot;&gt;健康 儿童&lt;/a&gt; &lt;a href=&quot;&quot;&gt;耳机 音响&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 6 背景6.1 背景颜色12backgroud-color: transparent | color/*transparent为透明色*/ 6.2 背景图片 background-image属性描述了元素的背景图像。实际开发常见于logo或者一些装饰性的小图片，或者是超大的背景图片，有点事非常便于控制文职 12background-image: none | url(url)/*url填写相对路径*/ 6.3 背景平铺 如果需要在html页面对背景进行平铺，可以使用background-repeat属性 12background-repeat: repeat | no-repeat | repeat-x | repeat-y/*平铺 | 不平铺 | 水平平铺 | 垂直平铺*/ 6.4 背景图片位置 可以通过background-position属性修改图片在背景中的位置 12background-position: x y;/*x坐标和y坐标，可以使用方位名词或者精确单位*/ 参数值 说明 精确单位 百分比、浮点数字或单位标识符组成的长度值 方位名词 top、bottom、left、right、center 注意： 如果使用的是方位名词，xy前后顺序没有区别，即top left和left top一样，都是在左上位置 如果只指定了一个方位名词，另一个省略，默认是center 精确单位和方位名词可以混合使用，但是前后顺序不能改变 6.5 背景图像固定（背景附着） background-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动 12background-attachment： scroll | fixed/*滚动 | 固定，默认滚动*/ 6.6 背景符合写法 为了简化背景属性的代码，可以通过background来集中写 可以写背景颜色、背景图片、背景平铺、背景图像滚动、背景图片位置 书写顺序不固定，但建议按照上面顺序进行书写 6.7 背景色透明12background: rgba(red, green, blue, alpha);/*参数为三原色和不透明度，不透明度在0~1之间选择，0是完全透明，1是不透明*/ 7 三大特性7.1 层叠性 相同选择器设置相同的样式，此时后面的选择器会覆盖前面选择器的样式。层叠性主要用于解决样式冲突问题 层叠性原则： 样式冲突，遵循就近原则 样式不冲突，不会层叠 7.2 继承性 子标签会继承父标签的某些样式，如文本颜色和字号 子元素可以继承父元素的样式（text-，font-，line-这些元素的开头可以继承，以及color属性） 7.3 优先级 当同一个元素指定多个选择器时，就会有优先级的产生 优先级：!important &gt; 行内样式style &gt; ID选择器 &gt; class选择器/伪类选择器 &gt; 标签选择器 &gt; 继承或* 1234/*!important使用*/div &#123; color: red!important;&#125; 7.4 权重叠加 复合选择器会有权重叠加的情况 1234567ul li &#123; /*权重为0.0.0.1 + 0.0.0.1 = 0.0.0.2*/ color: red;&#125;li &#123; color: green&#125; 范围越是精确，权重越大","categories":[{"name":"CSS","slug":"CSS","permalink":"https://letere-gzj.github.io/categories/CSS/"}],"tags":[]},{"title":"【Docker】Docker常用命令","slug":"【Docker】Docker常用命令","date":"2021-02-04T03:36:04.000Z","updated":"2021-02-04T07:46:04.807Z","comments":true,"path":"2021/02/04/【Docker】Docker常用命令/","link":"","permalink":"https://letere-gzj.github.io/2021/02/04/%E3%80%90Docker%E3%80%91Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Docker简单入门，常用的命令介绍","text":"Docker简单入门，常用的命令介绍 1 帮助命令12345docker version #查看Docker版本信息docker info #查看Docker系统信息docker [命令] --help #查看该命令的帮助信息 官方命令帮助文档：https://docs.docker.com/reference/ 2 镜像命令 官方镜像仓库：https://hub.docker.com/ 1234567891011docker images [options] #查看本地主机的所有镜像，可通过帮助命令查看可选optionsdocker search [options] 镜像名 #从dockerhub中寻找镜像 --filter=starts=3000 #过滤寻找收藏大于3000的镜像docker pull [options] 镜像名[:tag(版本)] #下载镜像到本机，默认下载最新版，可以自定义版本docker rmi [options] 镜像 [多个镜像...] #从本机中删除镜像docker rmi -f $&#123;docker images -aq&#125; #删除所有镜像（命令组合使用） 3 容器命令123456789101112131415161718192021222324252627282930313233docker run [OPTIONS] IMAGE [COMMAND] [ARG...] # 新建容器并启动 --name=&quot;容器名&quot; # 创建容器时给容器命名 -d # 以后台形式运行容器 -it /bin/bash # 使用交互方式运行，进入容器查看内容 -P 主机端口:端口号 # 指定容器的端口 -p # 随机指定端口docker ps [OPTIONS] # 查看当前运行的容器 -a # 查看当前运行容器 和 历史运行容器 -n=NUMBER # 按数量显示最近创建的容器 -q # 只显示容器的编号exit # 容器停止并退出按钮&lt;ctrl&gt; + &lt;P&gt; + &lt;Q&gt; # 容器不停止退出docker rm [OPTIONS] CONTAINER [CONTAINER...] # 删除容器 -f $(docker ps -aq) # 删除所有容器docker start [OPTIONS] CONTAINER [CONTAINER...] # 启动容器docker restart [OPTIONS] CONTAINER [CONTAINER...] # 重启容器docker stop [OPTIONS] CONTAINER [CONTAINER...] # 停止当前正在运行容器docker kill [OPTIONS] CONTAINER [CONTAINER...] # 强制停止当前正在运行的容器 4 其他常用命令4.1 后台启动容器 docker run -d IMAGE 出现问题：容器自动停止 常见的坑：容器后台进行，就必须要有一个前台进程。Docker发现没有应用，会自动停止 4.2 查看日志 docker logs [OPTIONS] CONTAINER 常用例子：docker logs -tf --tail NUMBER CONTAINER，显示指定行数的日志 4.3 查看容器中进程信息 docker top CONTAINER [ps OPTIONS] 4.4 查看容器信息 docker inspect [OPTIONS] NAME|ID [NAME|ID...] 4.5 进入当前正在运行的容器 我们通常开启容器是以后台的形式运行，所以需要了解如何进入容器，修改一些配置 docker exec -it CONTAINER /bin/bash：进入容器后开启一个新的终端，可以在里面操作 docker attach CONTAINER：进入容器正在执行的终端 4.6 从容器中拷贝文件到主机上 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH","categories":[{"name":"Docker","slug":"Docker","permalink":"https://letere-gzj.github.io/categories/Docker/"}],"tags":[]},{"title":"【Docker】Docker安装","slug":"【Docker】Docker安装","date":"2021-02-03T11:35:33.000Z","updated":"2021-02-04T03:33:31.890Z","comments":true,"path":"2021/02/03/【Docker】Docker安装/","link":"","permalink":"https://letere-gzj.github.io/2021/02/03/%E3%80%90Docker%E3%80%91Docker%E5%AE%89%E8%A3%85/","excerpt":"Docker的安装和配置介绍","text":"Docker的安装和配置介绍 1 Docker的基本组成 镜像(image)：Docker镜像类似一个模板，可以通过这个模板来创建容器服务。一个镜像可以创建多个容器 容器(container)：Docker利用容器技术，独立运行一个或一组应用，通过镜像来创建 仓库(repostory)：用于存放镜像的地方。仓库分为公有仓库和私有仓库。 2 安装Docker Docker下载地址：https://docs.docker.com/get-docker/ 本人是安装在linux-ubuntu上的，以下教程都以此为主 12--卸载旧版Docker（若安装了旧版，没安装跳下一步）sudo apt-get remove docker docker-engine docker.io containerd runc 1234--安装环境sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common 12--阿里云GPG（不建议使用官方教程里的GPG，国外，慢）:curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 12--验证可用密钥sudo apt-key fingerprint 0EBFCD88 12--写入Docker stable版本阿里云镜像软件源（不建议使用官方的，慢）sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; 1234--安装Dockersudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io 若上诉步骤出现以下问题，请使用下面的解决方法 12sudo rm /var/lib/apt/lists/locksudo rm /var/cache/apt/archives/lock 3 Hello World 测试Docker是否安装成功 使用Docker命令权限不足解决方案：https://blog.csdn.net/fj3704/article/details/100742719 12345--启动Docker服务systemctl start docker--查看Docker版本（正常显示即安装成功）(运行Docker命令需要管理员权限)sudo Docker version 运行hello-world 1sudo Docker run hello-world Docker默认工作路径：/var/lib/docker 4 阿里云镜像加速 （1）注册阿里云账号：https://www.aliyun.com （2）寻找容器镜像服务： （3）选择对应的版本并执行相应命令: 5 Docker run 运行流程","categories":[{"name":"Docker","slug":"Docker","permalink":"https://letere-gzj.github.io/categories/Docker/"}],"tags":[]},{"title":"【Docker】Docker概述","slug":"【Docker】Docker概述","date":"2021-02-03T11:32:10.000Z","updated":"2021-02-03T11:33:31.368Z","comments":true,"path":"2021/02/03/【Docker】Docker概述/","link":"","permalink":"https://letere-gzj.github.io/2021/02/03/%E3%80%90Docker%E3%80%91Docker%E6%A6%82%E8%BF%B0/","excerpt":"Docker的简单介绍","text":"Docker的简单介绍 1 Docker的出现 开发一款产品会因为环境没有配置好的问题导致无法使用 配置环境十分的麻烦 产生需求：发布项目时，顺便把环境进行打包发布 Docker给出了解决方法：项目打包带上会环境（镜像）–镜像放置在Docker仓库–从仓库下载镜像–直接运行 2 Docker历史 2010年，在美国成立公司dotCloud，做一些pass的云计算服务，LXC有关的容器技术 他们将自己的容器化技术命名为Docker Docker刚刚诞生的时候，并没有引起行内的注意，dotCloud也因此活不下去。 2013年，Docker选择了开源，开源吸引了许多人，越来越多的人发现了Docker的优点，Docker因此变得火了 Docker的火在于，相对比虚拟机技术，Docker更加的轻便，小巧 2014年4月9日，Docker1.0发布 3 Docker介绍 Docker官网：https://www.docker.com/ Docker官方文档：https://docs.docker.com/ Docker仓库地址：https://hub.docker.com/ （类似github，用来管理镜像） 4 Docker作用 （1）虚拟机技术 虚拟机技术缺点： 资源占用大 冗余步骤多 启动慢 （2）容器化技术 容器化技术不是模拟一个完整的系统 （3）Docker与虚拟机技术比较： 虚拟机技术：虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内核，容器没有自己的内核，没有虚拟硬件，变得轻便，每个容器键是互相隔离，每个容器内都有一个属于自己的文件系统，互补影响","categories":[{"name":"Docker","slug":"Docker","permalink":"https://letere-gzj.github.io/categories/Docker/"}],"tags":[]},{"title":"【拓展】Mybatis操作blob类型数据","slug":"【拓展】Mybatis操作blob类型数据","date":"2021-02-02T07:51:31.000Z","updated":"2021-02-02T07:53:10.426Z","comments":true,"path":"2021/02/02/【拓展】Mybatis操作blob类型数据/","link":"","permalink":"https://letere-gzj.github.io/2021/02/02/%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91Mybatis%E6%93%8D%E4%BD%9Cblob%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/","excerpt":"如何使用Mybatis操作blob类型的数据方法介绍","text":"如何使用Mybatis操作blob类型的数据方法介绍 一、写入Blob1.1 操作步骤 获取文件的byte类型数组 直接将此byte[]作为参数插入到数据库即可（前提数据库相应的字段类型要为Blob） 1.2 实例 （1）数据库 （2）接口 和 实现类（基于SpringBoot搭建的mybatis） 12345//接口@Mapperpublic interface FileMapper &#123; void addFile(@Param(&quot;filename&quot;) String filename, @Param(&quot;image&quot;) byte[] image);&#125; 1234567891011//实现类@Servicepublic class FileServiceImp implements FileMapper &#123; @Autowired FileMapper fileMapper; @Override public void addFile(String filename, byte[] image) &#123; fileMapper.addFile(filename, image); &#125;&#125; （3）Mapper映射文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.dao.FileMapper&quot;&gt; &lt;insert id=&quot;addFile&quot;&gt; insert into `filetest`(filename, image) value (#&#123;filename&#125;, #&#123;image&#125;) &lt;/insert&gt;&lt;/mapper&gt; （4）测试插入[写入]代码 1234567891011121314151617181920212223242526@SpringBootTestclass CodeTests &#123; @Autowired FileServiceImp fileServiceImp; @Test void addFileTest() throws Exception &#123; //创建相应的文件输入流（不要省略创建File对象的过程） File file = new File(&quot;./src/main/java/com/letere/林克.jpg&quot;); FileInputStream fis = new FileInputStream(file); //获取文件大小，文件名，并创建相应大小的byte[]数组 String filename = file.getName(); long length = file.length(); byte[] image = new byte[(int)length]; //将文件输入流中的数据保存[读入]到byte[]数组中 fis.read(image); //执行数据库插入操作，将byte[]数组作为参数插入 fileServiceImp.addFile(filename, image); //关闭流 fis.close(); &#125;&#125; 二、读取Blob数据2.1 方法一 将要读取的数据封装为一个JavaBean，Blob数据对应的Java类型为byte[] （1）创建JavaBean 12345678//使用了lombok注解来快速创建，也可以按照常规创建get, set 和 toString方法@Data @AllArgsConstructor@NoArgsConstructorpublic class FileBean &#123; private String filename; private byte[] image;&#125; （2）创建接口 和 实现类 12345//接口@Mapperpublic interface FileMapper &#123; FileBean readFile1(); //需要查询多条数据，用List&lt;FileBean&gt;作为返回类型&#125; 1234567891011//实现类@Servicepublic class FileServiceImp implements FileMapper &#123; @Autowired FileMapper fileMapper; @Override public FileBean readFile1() &#123; return fileMapper.readFile1(); &#125;&#125; （3）Mapper映射文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.dao.FileMapper&quot;&gt; &lt;!-- resultType选择封装的JavaBean位置 --&gt; &lt;select id=&quot;readFile1&quot; resultType=&quot;com.letere.bean.FileBean&quot;&gt; select * from `filetest` limit 1 -- 为了方便测试，暂时只查询一条数据 -- 如果需要查询多条数据，只需在接口和实现方法的返回类型改成List集合来封装即可，resultType不用修改 &lt;/select&gt;&lt;/mapper&gt; （4）测试读取Blob代码 12345678910111213141516171819202122@SpringBootTestclass CodeTests &#123; @Autowired FileServiceImp fileServiceImp; @Test public void readFile1() throws Exception&#123; //读取数据库中的数据 FileBean fileBean = fileServiceImp.readFile1(); //将Bean中的参数提取出来 String filename = fileBean.getFilename(); byte[] image = fileBean.getImage(); //创建文件输出流，将文件存储在本地 FileOutputStream fos = new FileOutputStream(&quot;./&quot; + filename); fos.write(image); //关闭流 fos.close(); &#125;&#125; 2.2 方法二 利用resultMap来封装从数据库中读取的数据，不用JavaBean来封装，封装为一个Map集合 （1）接口 和 实现类 12345//接口@Mapperpublic interface FileMapper &#123; Map readFile2(); //需要返回多个数据时，返回类型为List&lt;Map&gt;&#125; 1234567891011//实现类@Servicepublic class FileServiceImp implements FileMapper &#123; @Autowired FileMapper fileMapper; @Override public Map readFile2() &#123; return fileMapper.readFile2(); &#125;&#125; （2）Mapper映射文件 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.dao.FileMapper&quot;&gt; &lt;!--自定义返回数据类型--&gt; &lt;resultMap id=&quot;fileType&quot; type=&quot;map&quot;&gt; &lt;!-- type=&quot;map&quot;：返回一个map集合的数据--&gt; &lt;result column=&quot;filename&quot; property=&quot;filename&quot; javaType=&quot;String&quot; /&gt; &lt;result column=&quot;image&quot; property=&quot;image&quot; jdbcType=&quot;BLOB&quot; javaType=&quot;_byte[]&quot;/&gt; &lt;!-- 数据库字段名 map的key值 字段的类型 value的类型--&gt; &lt;/resultMap&gt; &lt;select id=&quot;readFile2&quot; resultMap=&quot;fileType&quot;&gt; select * from `filetest` limit 1 -- 为了方便测试，暂时只查询一条数据 -- 如果需要查询多条数据，只需将接口和实现方法的返回值类型给该成用List封装map的集合，resultType不用修改 &lt;/select&gt;&lt;/mapper&gt; （3）测试读取Blob代码 12345678910111213141516171819202122@SpringBootTestclass CodeTests &#123; @Autowired FileServiceImp fileServiceImp; @Test public void readFile2() throws Exception&#123; //读取数据库中的数据 Map map = fileServiceImp.readFile2(); //将map中的元素提取出来 String filename = (String) map.get(&quot;filename&quot;); byte[] image = (byte[]) map.get(&quot;image&quot;); //创建文件输出流，将文件存储在本地 FileOutputStream fos = new FileOutputStream(&quot;./&quot; + filename); fos.write(image); //关闭流 fos.close(); &#125;&#125;","categories":[{"name":"拓展","slug":"拓展","permalink":"https://letere-gzj.github.io/categories/%E6%8B%93%E5%B1%95/"}],"tags":[]},{"title":"【SpringMVC】拦截器","slug":"【SpringMVC】拦截器","date":"2021-02-02T07:39:59.000Z","updated":"2021-02-02T07:47:16.237Z","comments":true,"path":"2021/02/02/【SpringMVC】拦截器/","link":"","permalink":"https://letere-gzj.github.io/2021/02/02/%E3%80%90SpringMVC%E3%80%91%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"关于SpringMVC的拦截器介绍","text":"关于SpringMVC的拦截器介绍 1.拦截器概述 拦截器是SpringMVC框架自己的，只有使用了SpringMVC工程才能使用 拦截器只会拦截访问的控制器方法，不会拦截jsp/html/css/image/js 2.自定义拦截器12345678910//配置简单的Controller@RestControllerpublic class InterceptController &#123; @GetMapping(&quot;/test&quot;) public String test() &#123; System.out.println(&quot;controller执行了&quot;); return &quot;跳转成功&quot;; &#125;&#125; 2.1 创建自定义拦截器12345678910111213141516171819public class MyInterceptor implements HandlerInterceptor &#123; //实现handleInterceptor @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //return true: 放行； return false：拦截 System.out.println(&quot;Controller处理前&quot;); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;Controller处理后&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;清理&quot;); &#125;&#125; 2.2 配置拦截器123456789&lt;!-- 在web.xml文件中配置 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--添加要拦截的路径--&gt; &lt;mvc:mapping path=&quot;/test&quot; /&gt; &lt;!--对应的自定义拦截器--&gt; &lt;bean class=&quot;com.letere.config.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 2.3 执行结果1234Controller处理前controller执行了Controller处理后清理","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://letere-gzj.github.io/categories/SpringMVC/"}],"tags":[]},{"title":"【项目总结】MarkerHub个人博客系统","slug":"【项目总结】MarkerHub个人博客系统","date":"2021-02-02T04:51:16.000Z","updated":"2021-02-08T06:27:09.935Z","comments":true,"path":"2021/02/02/【项目总结】MarkerHub个人博客系统/","link":"","permalink":"https://letere-gzj.github.io/2021/02/02/%E3%80%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91MarkerHub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/","excerpt":"关于视频vue+springboot个人博客开发一些技巧的总结视频地址：https://www.bilibili.com/video/BV1PQ4y1P7hZ","text":"关于视频vue+springboot个人博客开发一些技巧的总结视频地址：https://www.bilibili.com/video/BV1PQ4y1P7hZ 1 后端结果集封装 可以将后端要返回给前端的数据，封装在一个类中，该类有以下参数“code, message, data”。code为状态码，message为向前端的返回信息，data为要向前端返回的内容 并且为了方便调用，可以在该类创建静态方法，直接调用，不用创建对象后再调用 1234567891011121314151617181920212223242526272829@Datapublic class Result &#123; private int code; //200正常， 非200异常 private String message; //异常信息 private Object data; //私有构造器 private Result(int code, String message, Object data) &#123; this.code = code; this.message = message; this.data = data; &#125; //封装静态方法，直接调用，不用进行new 对象 //自定义结果 public static Result result(int code, String message, Object data) &#123; return new Result(code, message, data); &#125; //数据正常 public static Result success(Object data) &#123; return result(200, null, data); &#125; //数据异常 public static Result failure(String message) &#123; return result(400, message, null); &#125;&#125; 2 后端分页方法123456//Dao层@Mapperpublic interface BlogMapper &#123; //分页查询 List&lt;Blog&gt; getListByPage(@Param(&quot;start&quot;) Integer start, @Param(&quot;limit&quot;) Integer limit);&#125; 1234567&lt;!--对应的SQL语句--&gt; &lt;select id=&quot;getListByPage&quot; resultType=&quot;com.letere.bean.Blog&quot;&gt; select * from blog order by `id` desc limit #&#123;start&#125;, #&#123;limit&#125; &lt;/select&gt; 123456789101112//service层@Servicepublic class BlogService implements BlogMapper &#123; @Autowired BlogMapper blogMapper; @Override public List&lt;Blog&gt; getListByPage(Integer currentPage, Integer limit) &#123; //传递参数为当前页面，一页多少条数据 Integer start = (currentPage - 1) * limit; //通过当前页，计算查询数据开始的位置 return blogMapper.getListByPage(start, limit); &#125;&#125; 3 前端登录异常处理 一般处理方式是等数据axios请求完后，在then中做相应的逻辑处理 新的思路是可以通过axios的拦截器进行处理 12345678910111213141516171819202122232425import Axios from &quot;axios&quot;;import Element from &quot;element-ui&quot;export function request(config) &#123; const instance = Axios.create(&#123; baseURL: &quot;/api&quot; &#125;); //前置拦截（请求发送前） instance.interceptors.request.use(config =&gt; &#123; return config; //放行 &#125;) //后置拦截（响应接受前） instance.interceptors.response.use(res =&gt; &#123; if(res.data.code === 200) &#123; return res; &#125; else &#123; Element.Message.error(res.data.message, &#123;duration: 3*1000&#125;); //Element-ui弹窗显示错误信息 return Promise.reject(&#x27;reason: &#x27; + res.data.message); //直接报错，不执行此网络请求后续步骤 &#125; &#125;); return instance(config);&#125; 4 页面markdown处理4.1 markdown编辑器 一般在博客后台，需要一个markdown编辑器来编辑博客 因此需要使用npm install --save mavon-editor 官方文档：https://codechina.csdn.net/mirrors/hinesboy/mavoneditor/-/blob/master/README.md 安装后的配置(记得在’main.js’中导入配置文件) 123456import Vue from &quot;vue&quot;;import MavonEditor from &#x27;mavon-editor&#x27;;import &quot;mavon-editor/dist/css/index.css&quot;Vue.use(MavonEditor); 使用方法 页面使用标签&lt;mavon-editor v-model=&quot;&quot;&gt;&lt;/mavon-editor&gt;即可 4.2 页面渲染markdown语法 需要安装npm install --save markdown-it 使用方法 12345import MarkDownIt form &#x27;markdown-it&#x27; //导入markdown-itconst md = new MarkDownIt(); //创建对象const html = md.render(&quot;markdown语法内容&quot;); //渲染成html语法 12&lt;!--页面使用html语法--&gt;&lt;div v-html=&quot;html语法内容&quot;&gt;&lt;/div&gt; 4.3 使用markdown样式 需要安装npm install github-markdown-css 使用方法 1import &quot;github-markdown-css/github-markdown.css&quot; //导入样式 12&lt;!--页面使用样式--&gt;&lt;div class=&quot;markdown-body&quot; v-html=&quot;&quot;&gt;&lt;/div&gt;","categories":[{"name":"项目总结","slug":"项目总结","permalink":"https://letere-gzj.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"【JWT】JWT学习","slug":"【JWT】JWT学习","date":"2021-01-26T06:50:13.000Z","updated":"2021-01-26T06:51:44.301Z","comments":true,"path":"2021/01/26/【JWT】JWT学习/","link":"","permalink":"https://letere-gzj.github.io/2021/01/26/%E3%80%90JWT%E3%80%91JWT%E5%AD%A6%E4%B9%A0/","excerpt":"关于如何使用JWT来进行用户登录验证，实现网络安全","text":"关于如何使用JWT来进行用户登录验证，实现网络安全 1. JWT介绍 JWT：JSON Web Token（JSON网路令牌） JWT官网：https://jwt.io JWT通过JSON形式作为Web应用中的令牌，用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、前面等相关处理 2. JWT作用 （1）授权： JWT的最常见方案，一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌徐云的路由，服务和资源。 （2）信息交换 JWT是各方之间安全传输信息的好方法。因为可以对JWT进行签名，可以确保发件人没有变化。 3.选择JWT理由3.1 基于传统的Session认证 客户向服务器登录后，服务器会生成一个Session对象，将用户ID保存在里面，并在第一次响应客户端时，发送一个包含SessionID的Cookie；客户端每次访问服务器时都会带上次Cookie，来判断是否已经登录验证。 暴露问题： （1）Session保存在内存中，随着用户量增大，服务器开销增大 （2）Session保存在内存中，导致在分布式系统中，用户永远只能访问此服务器，限制了负载均衡能力 （3）基于Cookie进行用户验证，如果Cookie被拦截，容易受到攻击 （4）前后端分离系统中，可以需要多个代理才发送带后端，每次转发都携带Cookie，十分麻烦 3.2 基于JWT认证 JWT优势： （1）简洁：可以通过URL， POST参数或者在http header发送，因为数据量小，传输速度也很快 （2）自包含：负载中包含了所有用户所需要的信息，避免了多次查询数据库 （3）跨语言：基于Json加密形式保存在客户端，原则上任何web形式都支持 （4）不需要再服务器的session中保存，特别适合永野芽郁分布式系统 4. JWT结构4.1 令牌组成 由标头（header）、有效载荷（payload）、签名（signature）组成 组成形式为：header.payload.signature，中间有’.’隔开 4.2 Header header由两部分组成：令牌类型和所使用的签名算法（HMAC、SHA256、RSA）。后端会使用Base64编码组成header 1234&#123; &quot;alg&quot;: &quot;HS356&quot;, //算法 &quot;typ&quot;: &quot;JWT&quot; //类型&#125; 4.3 Payload payload，其中包含声明。声明式有关实体和其他数据，按照实际情况返回。同样会使用base64编码组成 12345&#123; &quot;sub&quot;: 123456789, &quot;name&quot;: &quot;letere&quot;, &quot;admin&quot;: true&#125; 4.4 Signature signature需要编码后的header和payload以及一个密钥，然后使用header中的算法进行签名，签名的作用是保证JWT没有被篡改过。 例：算法（编码后的header + “.” + 编码后的payload, 密钥） 5. JWT基本使用5.1 依赖导入123456&lt;!-- JWT --&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt;&lt;/dependency&gt; 5.2 生成令牌12345678910111213141516@Testpublic void test() &#123; Calendar date = Calendar.getInstance(); date.add(Calendar.SECOND, 120); //设置时间120秒 Map&lt;String, Object&gt; header = new HashMap&lt;String, Object&gt;(); String token = JWT.create() .withHeader(header) //header，传入一个map&lt;String, Object&gt;，可省略，默认值一样 .withClaim(&quot;userId&quot;, 12) //payload，可以设置多个 .withClaim(&quot;userName&quot;, &quot;letere&quot;) .withClaim(&quot;sex&quot;, &quot;男&quot;) .withExpiresAt(date.getTime()) //设置token过期时间 .sign(Algorithm.HMAC256(&quot;XJBX&quot;)); //signature，算法类选一个算法，参数为密钥 System.out.println(token);&#125; 5.3 验证令牌12345678910111213@Testpublic void test2() &#123; //JWT验证对象 JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;XJBX&quot;)).build(); //验证令牌（注意令牌是否过期） DecodedJWT verify = jwtVerifier.verify(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzZXgiOiLnlLciLCJ1c2VyTmFtZSI6ImxldGVyZSIsInVzZXJJZCI6MTJ9.DEwv6wVClwxjVO_wsMBojPSOkckJh3PEaAv543bSy-w&quot;); //参数为生成的token //获取令牌中数据 System.out.println(verify.getClaim(&quot;userId&quot;).asInt()); System.out.println(verify.getClaim(&quot;userName&quot;).asString()); System.out.println(verify.getClaim(&quot;sex&quot;).asString());&#125; 6. 与SpringBoot的结合使用6.1 依赖引入123456&lt;!-- JWT --&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt;&lt;/dependency&gt; 6.2 接口创建 由于只是个简单的demo，所以身份验证连接数据库就行验证，只是个简单的判断 123456789101112131415161718192021//Service层public Map&lt;String, Object&gt; login(String userName, String password) &#123; Map&lt;String, Object&gt; message = new HashMap&lt;&gt;(); if(&quot;admin&quot;.equals(userName) &amp;&amp; &quot;123456&quot;.equals(password)) &#123; //生成token Calendar date = Calendar.getInstance(); date.add(Calendar.DATE, 7); String token = JWT.create() .withClaim(&quot;userName&quot;, userName) .withExpiresAt(date.getTime()) .sign(Algorithm.HMAC256(&quot;XJBX&quot;)); message.put(&quot;state&quot;, true); message.put(&quot;msg&quot;, &quot;认证成功&quot;); message.put(&quot;token&quot;, token); &#125;else &#123; message.put(&quot;state&quot;, false); message.put(&quot;msg&quot;, &quot;认证失败&quot;); &#125; return message;&#125; 12345678910111213//Controller层@RestControllerpublic class UserController &#123; @Autowired private UserServiceImp usi; @GetMapping(&quot;/login&quot;) public Map&lt;String, Object&gt; login(String userName, String password) &#123; return usi.login(userName, password)); &#125; //测试地址：http://localhost:8080/login?userName=admin&amp;password=123456、 //返回JSON：&#123;&quot;msg&quot;:&quot;认证成功&quot;,&quot;state&quot;:true,&quot;token&quot;:&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyTmFtZSI6ImFkbWluIiwiZXhwIjoxNjEwNTIzNTc3fQ.JJIrf0TdBwZgmrNxOu9cf-cbXrgN_ZiOuq_2UVEByMs&quot;&#125;&#125; 6.3 token拦截 返回前端的token，在下次发送请求时，一般都将token放在请求头中，而后端用拦截器拦截请求，来验证token 1234567891011121314151617181920212223242526//创建JWT拦截器//拦截器public class JwtIntercepter implements HandlerInterceptor &#123; //alt + shift + p @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取请求头中的token String token = request.getHeader(&quot;token&quot;); //jwt验证器 try &#123; JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;XJBX&quot;)).build(); return true; //无异常，放行 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Map&lt;String, String&gt; message = new HashMap&lt;&gt;(); message.put(&quot;wrong&quot;, &quot;出现异常&quot;); //转成JSON发送给前端 String json = new ObjectMapper().writeValueAsString(message); response.setContentType(json); response.getWriter().println(json); return false; &#125;&#125; 1234567891011//SpringBoot配置自定义拦截器@Configurationpublic class IntercepterConfig implements WebMvcConfigurer &#123; //alt + shift + p @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new JwtIntercepter()) .addPathPatterns(&quot;/user/**&quot;); //添加要拦截的路径，链式编程 &#125;&#125;","categories":[{"name":"JWT","slug":"JWT","permalink":"https://letere-gzj.github.io/categories/JWT/"}],"tags":[]},{"title":"【Redis】Java连接Redis（Jedis）","slug":"【Redis】Java连接Redis（Jedis）","date":"2021-01-15T08:36:48.000Z","updated":"2021-01-19T06:31:53.222Z","comments":true,"path":"2021/01/15/【Redis】Java连接Redis（Jedis）/","link":"","permalink":"https://letere-gzj.github.io/2021/01/15/%E3%80%90Redis%E3%80%91Java%E8%BF%9E%E6%8E%A5Redis%EF%BC%88Jedis%EF%BC%89/","excerpt":"Java使用Jedis来进行对Redis的连接","text":"Java使用Jedis来进行对Redis的连接 1. Java连接Redis1.1 修改配置文件 （1）无密码连接 将bind 127.0.0.1注释掉，bind [ip]配置是只允许当前ip地址使用redis，即liunx本机，使得其他机器无法访问使用。 将保护模式关闭protected-mode no （2）需要密码进行连接 将bind 127.0.0.1注释掉 设置密码requirepass [密码] 1.2 查看linux的ip地址123sudo apt install net-tools --安装网络工具（不同版本linux，语法不同）ifconfig -a --查看所有网络信息 1.3 Java连接 （1）jar包导入 jedis.xxxx.jar 123456&lt;!-- Maven依赖：Jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; （2）代码测试 1234567//无密码连接public class ConnectTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.xx.xx&quot;, 6379); System.out.println(jedis.ping()); //返回&quot;PONG&quot;表示连接成功 &#125;&#125; 12345678//密码连接public class ConnectTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.xx.xx&quot;, 6379); jedis.auth(&quot;123456&quot;); //身份验证 System.out.println(jedis.ping()); //返回&quot;PONG&quot;表示连接成功 &#125;&#125; 2. Jedis常用API Jedis的API就是redis的命令，参数都是一样，所以直接参考Redis的命令那一章节的内容进行使用即可 3. Jedis事务使用3.1 正常使用123456789101112131415@Testpublic void normalTest() &#123; Jedis jedis = new Jedis(&quot;192.168.xx.xx&quot;, 6379); //开启事务 Transaction transaction = jedis.multi(); //业务逻辑 transaction.decrBy(&quot;balance&quot;, 10); transaction.incrBy(&quot;debt&quot;, 10); //执行事务 transaction.exec(); //放弃执行 //transaction.discard();&#125; 3.2 加锁使用12345678910111213141516171819@Testpublic void lockTest() &#123; Jedis jedis = new Jedis(&quot;192.168.85.130&quot;, 6379); //监控&quot;balance&quot; jedis.watch(&quot;balance&quot;); //事务开始前数据发生修改 jedis.set(&quot;balance&quot;, &quot;500&quot;); //若发生此情况，执行不会报错，但事务不会执行，自动放弃 //开启事务 Transaction transaction = jedis.multi(); //业务逻辑 transaction.decrBy(&quot;balance&quot;, 10); transaction.incrBy(&quot;debt&quot;, 10); //执行事务 transaction.exec();&#125; 4. Jedis主从复制 一般不会使用Java来设置从机，一般都会在linux上设置好，再来使用，一下内容作为了解即可 （1）开启两个主机 记得修改配置，让其他机器也能访问Redis （2）Java代码实现主从复制 123456789101112@Testpublic void replicationTest() &#123; Jedis master = new Jedis(&quot;192.168.xx.xx&quot;, 6379); Jedis slave = new Jedis(&quot;192.168.xx.xx&quot;, 6380); //绑定从机 slave.slaveof(&quot;192.168.xx.xx&quot;, 6379); //主写从读 master.set(&quot;message&quot;, &quot;this is master&#x27;s message&quot;); System.out.println(slave.get(&quot;message&quot;));&#125; （3）去linux上重新查看信息 5. JedisPool使用 池子的使用一般都封装为一个工具类 5.1 依赖导入12345678910111213&lt;!-- jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; 5.2 工具类封装12345678910111213141516171819202122232425262728293031323334353637//单例模式public class JedisPoolUtil&#123; private static volatile JedisPool jedisPool = null; //构造器私有化 private JedisPoolUtil() &#123;&#125;; //用静态方法来构造 public static JedisPool getJedisPoolInstance() &#123; if(jedisPool == null) &#123; //同步 synchronized (JedisPoolUtil.class) &#123; //进入同步后，还是为空，就才创建实例【有可能在判断是否为空后，没进同步前，另外一个线程创建一个实例】 if (jedisPool == null) &#123; //池配置 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(1000); //控制一个pool最大可分配多少个Jedis实例 poolConfig.setMaxIdle(32); //控制一个pool最多有多少个Idle（空闲的）jedis实例 poolConfig.setMaxWaitMillis(100*1000); //当borrow一个jedis实例时，最大的等待时间 poolConfig.setTestOnBorrow(true); //获取一个jedis实例时是否检查连接可用性 //创建池子 jedisPool = new JedisPool(poolConfig, &quot;192.168.85.130&quot;, 6379); &#125; &#125; &#125; return jedisPool; &#125; //释放资源 public static void release(Jedis jedis) &#123; if(jedis != null) &#123; //jedisPool.returnSourceObject(jedis); //方法属性变成protected，无法调用了 jedis.close(); &#125; &#125;&#125; 5.3 JedisPoolConfig介绍 属性 解释 maxTotal 控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted maxIdle 控制一个pool最多有多少个状态为idle(空闲)的jedis实例 whenExhaustedAction 表示当pool中的jedis实例都被allocated完时，pool要采取的操作；默认有三种。WHEN_EXHAUSTED_FAIL –&gt; 表示无jedis实例时，直接抛出NoSuchElementException；WHEN_EXHAUSTED_BLOCK –&gt; 则表示阻塞住，或者达到maxWait时抛出JedisConnectionException；WHEN_EXHAUSTED_GROW –&gt; 则表示新建一个jedis实例，也就说设置的maxActive无用； MaxWaitMillis 表示当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛JedisConnectionException； testOnBorrow 获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的； testOnReturn return 一个jedis实例给pool时，是否检查连接可用性（ping()）； testWhileIdle 如果为true，表示有一个idle object evitor线程对idle object进行扫描，如果validate失败，此object会被从pool中drop掉；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义； timeBetweenEvictionRunsMillis 表示idle object evitor两次扫描之间要sleep的毫秒数； numTestsPerEvictionRun 表示idle object evitor每次扫描的最多的对象数 minEvictableIdleTimeMillis 表示一个对象至少停留在idle状态的最短时间，然后才能被idle object evitor扫描并驱逐；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义 softMinEvictableIdleTimeMillis 在minEvictableIdleTimeMillis基础上，加入了至少minIdle个对象已经在pool里面了。如果为-1，evicted不会根据idle time驱逐任何对象。如果minEvictableIdleTimeMillis&gt;0，则此项设置无意义，且只有在timeBetweenEvictionRunsMillis大于0时才有意义 lifo borrowObject返回对象时，是采用DEFAULT_LIFO（last in first out，即类似cache的最频繁使用队列），如果为False，则表示FIFO队列 5.4 工具类使用12345678910111213141516public static void main(String[] args) &#123; Jedis resource = null; try &#123; //获取线程池 JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance(); //获取Jedis实例 resource = jedisPoolInstance.getResource(); //Jedis业务逻辑 resource.set(&quot;message&quot;, &quot;hello JedisPool&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //释放Jedis JedisPoolUtil.release(resource); &#125;&#125;","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Redis】Redis的复制","slug":"【Redis】Redis的复制","date":"2021-01-15T04:16:24.000Z","updated":"2021-01-15T04:23:27.329Z","comments":true,"path":"2021/01/15/【Redis】Redis的复制/","link":"","permalink":"https://letere-gzj.github.io/2021/01/15/%E3%80%90Redis%E3%80%91Redis%E7%9A%84%E5%A4%8D%E5%88%B6/","excerpt":"Redis的复制功能介绍，开发可能不用你配，但必须得懂","text":"Redis的复制功能介绍，开发可能不用你配，但必须得懂 1. 复制介绍 复制，也就是主从复制，主机数据更新后，根据配置和策略，自动同步到备份机的master / slaver机制。 Master以写为主，Slave以读为主 2. 复制功能的使用2.1 配从（库）不配主（库） （1）从库配置：执行命令slaveof 主库IP 主库端口 （2）注意： 每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件 2.2 配置文件操作 （1）拷贝多个redis.conf文件，作为从机加载时的配置 （2）修改端口号：port 63xx （3）修改进程管道名字：pidfile /var/run/redis_63xx.pid （4）修改log文件位置和名字： logfile /xx/xx/xx/63xx.log （5）修改dump.rdb名字： dbfilename dump63xx.rdb （6）修改dump.rdb的位置：dir /xx/xx/xx 1234567目录结构 |master |redis6379.conf | |slave |redis6380.conf |redis6381.conf 报错解决： 方法一：修改存储logfile文件夹和dump.rbd文件夹的权限：sudo chmod 777 /xx/xxx/xxxx 方法二：以管理员权限启动redissudo redis-cli -p 63xx 2.3 常用3招 （1）一主二仆 （2）薪火相传 一个传一个，去中心化，减轻master负担 （3）反客为主 从机可以使用slaveof no one来重新变成主机 3. 复制原理 Slave启动成功连接到master后会发送一个sync命令 Master接到命令启动后台的存盘进程，同时收集所有接受到用于修改数据集的命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步 全量复制：而Slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master继续将新的所有收集到的修改命名一次传给Slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将自动执行 4. 哨兵模式（sentinel）4.1 介绍 哨兵模式，是反客为主的自动版，主机一旦挂了，自动从机中选一台作为主机，并其余从机重新绑定此主机。 可以后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 4.2 使用 （1）创建一个sentinel.conf文件，文件名不能错误 （2）填写在里面内容为：entinel monitor [主机名称（随意填）] [IP地址] [端口号] 1，1是让哨兵自动选出新主机。可以填写多个，用来监控多个主机。 （3）演示 5. 复制的缺点 由于所有的写操作都在master上进行，然后同步更新slave上，所以从master同步到slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，slave机器数量增加也会使这个问题更加严重","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Redis】Redis的发布订阅","slug":"【Redis】Redis的发布订阅","date":"2021-01-14T12:17:19.000Z","updated":"2021-01-14T12:20:51.167Z","comments":true,"path":"2021/01/14/【Redis】Redis的发布订阅/","link":"","permalink":"https://letere-gzj.github.io/2021/01/14/%E3%80%90Redis%E3%80%91Redis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"Redis也是拥有消息中间件的功能，但一般不是用redis来做消息中间件","text":"Redis也是拥有消息中间件的功能，但一般不是用redis来做消息中间件 1. 介绍 进程间的一种消息通信模式：发送者(pub)发送信息，订阅者(sub)接收信息 订阅 / 发布消息图 2. 命令 命令 描述 psubcribe [pattem …] 订阅一个或多个符合给定模式的频道 pubsub [subcommand] [argument …] 查看订阅与发布系统状态 publish [channel] [message] 将信息发送到指定的频道 punsubscribe [pattem …] 退订所有给定模式的频道 subscribe [channel …] 订阅给定的一个或多个频道的信息 unsubscrible [channel …] 退订给定的频道 3. 案例","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Redis】Redis的事务","slug":"【Redis】Redis的事务","date":"2021-01-14T07:39:49.000Z","updated":"2021-01-14T11:10:18.125Z","comments":true,"path":"2021/01/14/【Redis】Redis的事务/","link":"","permalink":"https://letere-gzj.github.io/2021/01/14/%E3%80%90Redis%E3%80%91Redis%E7%9A%84%E4%BA%8B%E5%8A%A1/","excerpt":"虽然Redis是非关系型数据库，但是也是拥有一定的事务功能","text":"虽然Redis是非关系型数据库，但是也是拥有一定的事务功能 1. 事务介绍 可以一次执行多个命令，本质是一组命令的集合。 一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞 2.事物使用 在命令行使用multi，命令行会返回一个OK，表示事务开启，这时候可以输入一系列操作命令。 输入完一系列操作命令，使用exec来执行事事务 一旦不想使用事务的时候，命令行输入discard来取消使用事务 3.事务操作指令3.1 常用指令 命令 描述 multi 标记一个事务块的开启 discard 取消事务，放弃执行事务块内的所有事物 exec 执行所有事物块里面的命令 watch [key …] 监视一个或多个key，如果在事务执行之前key被其他命令所改动，事务中断 unwatch 取消watch命令对所有key的监视 3.2 正常执行 3.3 放弃执行 3.4 全体连坐 3.5 冤头债主 与全体连坐的区别： 全体连坐在编译的时候已经报错了，所以执行全部不执行 冤头债主则是编译没有报错，所以执行时出现错误不影响其他语句执行 总结：Redis的事务是部分支持，不是全部都支持 3.6 watch监控 锁 乐观锁：在每条记录后面都添加一个版本号(Version)，对记录进行操作时获取当前版本号，操作完准备提交前也获取一次版本号，一旦版本号不同，报出异常。版本号一样就成功提交。 悲观锁：一旦数据被人拿来就修改，就将整个数据库锁起来，等修改完后，才能给下一个人进行修改。 watch使用例子（乐观锁）：信用卡可用余额和欠债 取消监控： （1）输入命令unwatch （2）一旦事务使用exec执行后，自动取消监控 4. 总结4.1 事务三阶段 （1）开启：用multi命令开启一个事务 （2）入队：将多个命令入队到十五中，接到这些命令并不会立即执行，而是方法哦等待执行的事务队列里面 （3）执行：用exec命令执行事务 4.2 事务三特性 （1）单独的隔离操作：事务中的所用命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断 （2）没有隔离级别的概念：队列中的命令没有提交之前都不会实际的执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里面的更新，在事务外查询不能看到”这个让人万分头疼的问题 （3）不保证原子性：redis同一个事务中如果有一条命令执行失败，气候的命令仍然会被执行，没有回滚","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Redis】Redis的持久化","slug":"【Redis】Redis的持久化","date":"2021-01-13T13:26:31.000Z","updated":"2021-01-13T13:27:43.623Z","comments":true,"path":"2021/01/13/【Redis】Redis的持久化/","link":"","permalink":"https://letere-gzj.github.io/2021/01/13/%E3%80%90Redis%E3%80%91Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"Redis的数据持久化介绍","text":"Redis的数据持久化介绍 1. RDB1.1 RDB介绍 RDB：Redis Database 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的snapshot快照，它恢复时是将快照文件直接读到内存中。 Redis会单独创建（fork）一个子进程进行持久化，会先将数据写到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，按RDB发方法要比AOF方式更加高效. RDB的缺点：最后一次持久化的数据可能丢失。 1.2 Fork Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等），数值都和原进程一直，但是是一个全新的进程，并作为原进程的子进程。 1.3 配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081################################ SNAPSHOTTING ################################## Save the DB on disk: 保存DB在磁盘中## save &lt;seconds&gt; &lt;changes&gt;## Will save the DB if both the given number of seconds and the given 一旦符合给定的秒数内执行的操作数，就会保存DB# number of write operations against the DB occurred.## In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed 15分钟内修改1次# after 300 sec (5 min) if at least 10 keys changed 5分钟内修改300次# after 60 sec if at least 10000 keys changed 1分钟内修改10000次## Note: you can disable saving completely by commenting out all &quot;save&quot; lines.## It is also possible to remove all the previously configured save# points by adding a save directive with a single empty string argument# like in the following example:## save &quot;&quot;save 900 1save 300 10save 60 10000# By default Redis will stop accepting writes if RDB snapshots are enabled 后台保存失败的时候停止前台继续写入# (at least one save point) and the latest background save failed.# This will make the user aware (in a hard way) that data is not persisting# on disk properly, otherwise chances are that no one will notice and some# disaster will happen.## If the background saving process will start working again Redis will# automatically allow writes again.## However if you have setup your proper monitoring of the Redis server# and persistence, you may want to disable this feature so that Redis will# continue to work as usual even if there are problems with disk,# permissions, and so forth.stop-writes-on-bgsave-error yes# Compress string objects using LZF when dump .rdb databases? 是否使用LZF算法压缩dump.rdb# For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.# If you want to save some CPU in the saving child set it to &#x27;no&#x27; but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes# Since version 5 of RDB a CRC64 checksum is placed at the end of the file. 是否使用CRC64算法来进行数据校验# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files, so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes# The filename where to dump the DB 将DB写入磁盘的文件名dbfilename dump.rdb# Remove RDB files used by replication in instances without persistence# enabled. By default this option is disabled, however there are environments# where for regulations or other security concerns, RDB files persisted on# disk by masters in order to feed replicas, or stored on disk by replicas# in order to load them for the initial synchronization, should be deleted# ASAP. Note that this option ONLY WORKS in instances that have both AOF# and RDB persistence disabled, otherwise is completely ignored.## An alternative (and sometimes better) way to obtain the same effect is# to use diskless replication on both master and replicas instances. However# in the case of replicas, diskless is not always an option.rdb-del-sync-files no# The working directory.## The DB will be written inside this directory, with the filename specified DB写入到指定文件目录下# above using the &#x27;dbfilename&#x27; configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here, not a file name.dir ./ 1.4 如何触发RDB快照 （1）配置文件中save设置 （2）使用命令save或bgsave save：只管保存，保存是全部阻塞，等保存完后才能重新使用 bgsave：Redis会在后台异步进行快照操作 （3）执行flushall命令，但没有意义，数据被清空了 1.5 数据恢复 将备份文件移动的redis安装目录，并启动服务器即可 1.6 优势 适合大规模的数据恢复 对数据完整性和一致性要求不高 1.7 劣势 在一定时间间隔做一次备份，所以如果Redis以外关闭掉的话，就会丢失最后一次快照后的所有修改 Frok的时候，内存中的数量被克隆了一份，大致2倍的膨胀性需要考虑 2. AOF2.1 AOF介绍 AOF：Append Only File AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加维诺健但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 2.2 配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128############################## APPEND ONLY MODE ################################ By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems. AOF与RDB可以同时共存，没有问题# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no 是否启动aof# The name of the append only file (default: &quot;appendonly.aof&quot;) aof文件名字appendfilename &quot;appendonly.aof&quot;# The fsync() call tells the Operating System to actually write data on disk# instead of waiting for more data in the output buffer. Some OS will really flush# data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster. 不同步数据，只要让操作系统在需要的时候刷新数据即可，快。# always: fsync after every write to the append only log. Slow, Safest. 每次写操作都同步添加到日志，慢，最安全# everysec: fsync only one time every second. Compromise. 每秒同步日志一次。妥协版本。## The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between# speed and data safety. It&#x27;s up to you to understand if you can relax this to# &quot;no&quot; that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that&#x27;s snapshotting),# or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use &quot;everysec&quot;.# appendfsync alwaysappendfsync everysec# appendfsync no# When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it&#x27;s possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as &quot;appendfsync none&quot;. In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).## If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as# &quot;no&quot; that is the safest pick from the point of view of durability.no-appendfsync-on-rewrite no 重写时是否可以使用Appendfsync# Automatic rewrite of the append only file. 自动重写AOF# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.## This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is 当前大小大于设定的百分比，触发重写# bigger than the specified percentage, the rewrite is triggered. Also 也要设定一个触发重写的最小大小# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100 原来的两倍就会触发重写auto-aof-rewrite-min-size 64mb 文件超过64MB就会触发重写# An AOF file may be found to be truncated at the end during the Redis# startup process, when the AOF data gets loaded back into memory.# This may happen when the system where Redis is running# crashes, especially when an ext4 filesystem is mounted without the# data=ordered option (however this can&#x27;t happen when Redis itself# crashes or aborts but the operating system still works correctly).## Redis can either exit with an error when this happens, or load as much# data as possible (the default now) and start if the AOF file is found# to be truncated at the end. The following option controls this behavior.## If aof-load-truncated is set to yes, a truncated AOF file is loaded and# the Redis server starts emitting a log to inform the user of the event.# Otherwise if the option is set to no, the server aborts with an error# and refuses to start. When the option is set to no, the user requires# to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart# the server.## Note that if the AOF file will be found to be corrupted in the middle# the server will still exit with an error. This option only applies when# Redis will try to read more data from the AOF file but not enough bytes# will be found.aof-load-truncated yes# When rewriting the AOF file, Redis is able to use an RDB preamble in the# AOF file for faster rewrites and recoveries. When this option is turned# on the rewritten AOF file is composed of two different stanzas:## [RDB file][AOF tail]## When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;# string and loads the prefixed RDB file, and continues loading the AOF# tail.aof-use-rdb-preamble yes 2.3 RDB与AOP RDB与AOF可以同时存在，启动服务器的时候优先使用AOF，一旦AOF出现问题，服务器启动失败。 通过使用redis-check-aof --fix appendonly.aof，对AOF进行修复 2.4 重写 AOF采用文件追加方式，文件会越来越大，为了避免此种情况，新增了重写机制 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令bgwriteaof手动启动内容压缩功能 重写原理： AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后在rename），遍历新进程的内存中数据，每条记录有一条Set语句。重写aof文件的操作，并没有读取就的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件。 触发机制： Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小时上次rewrite后大小的一倍且文件大于64M时触发 2.5 优势 可以灵活配置AOF的备份策略，可以每秒同步，每次修改同步，不同步 2.6 劣势 相同数据集的数据而言，aof文件要远大于rdb文件，恢复速度慢于rdb aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb一样 3. 总结 RDB持久化方式能在指定的时间间隔对你的数据进行快照存储 AOF持久化方式记录每次对服务器的写操作，当服务器重启时会重新执行这些命令来恢复原始数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾 Redis还支持AOF文件进行后台重写，使得AOF文件的体积不至于过大 只做缓存：如果只希望你的数据在服务器运行的时候存在，可以不适用任何的持久化方式 同时开始两种持久化： 重启Redis时会优先载入AOF文件来恢复原始的数据，因为RDB不同时，所以导致只会寻找AOF文件 但是不建议只使用AOF，RDB更合适备份数据库，并且留着作为一个万一的手段 性能建议 RDB文件只用作后备用途，建议只保留15分钟内修改1次的备份条件即可 AOF好处在与最恶劣情况只丢失2秒的数据，但带来了持续的IO。而且AOF最后会需要重写，重写会造成一定的阻塞。建议AOF重写的基础大小设置为5G以上。 后面会有Master-Slave Replication来代替AOF，可以省掉一大笔IO。代价是如果Master/Slave同时挂掉，会丢失十几分钟的数据。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Redis】配置文件解析","slug":"【Redis】配置文件解析","date":"2021-01-13T05:49:36.000Z","updated":"2021-01-13T05:54:47.037Z","comments":true,"path":"2021/01/13/【Redis】配置文件解析/","link":"","permalink":"https://letere-gzj.github.io/2021/01/13/%E3%80%90Redis%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/","excerpt":"配置文件的简单解析，剩下的会在后面中间介绍","text":"配置文件的简单解析，剩下的会在后面中间介绍 1. 单位 2. Include 3. Network 4. General 5. Limit一些限制性的设置 6. 常见配置redis.conf介绍12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697981. Redis默认不是以守护进程的方式进行，可以通过该配置项修改，使用yes启动守护进程 daemonize yes 2. 当Redis以守护进程方式运行时，Redis默认把pid写入/var/run/redis.pid文件，可以通过pidfile制定 pidfile /var/run/redis.pid 3. 制定Redis监听端口，默认端口6379 port 6379 4. 绑定的主机地址 bind 127.0.0.1 5. 当用户空闲多长时间关闭连接，如果指定为0，表示关闭该功能 timeout 300 6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning loglevel notice 7.日志记录方式 logfile stdout 8. 数据库数量 database 16 9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒内有1次修改，300秒内有10次修改，60秒内有10000次修改 10. 指定存储至本地数据库时是否压缩数据 rdbcompression yes 11. 指定本地数据库文件名，默认dump.rdb dbfilename dump.rdb 12. 指定本地数据库存放的位置 dir ./ 13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt; 14. 当master服务设置了密码保护时，slav服务连接master密码 masterauth &lt;master-password&gt; 15. 设置Redis连接密码，设置密码后，连接Redis时，要输入auth &lt;password&gt;密码进行身份验证 requirepass foobared 16. 设置同一时间最大客户端连接数 maxclients 128 17. 指定Redis最大内存限制 maxmemory &lt;bytes&gt; 18. 指定是否每次更新操作后进行日志记录 appendonly no 19. 指定更新日志文件名，默认appendonly.aof appendfilename appendonly.aof 20. 指定更新日志条件，有三个可选项 no：等操作系统缓存同步到磁盘 always：表示每次更新操作后手动调用fsync()，将数据写到磁盘 everysec：表示每秒同步一次 appendfsync everysec 21. 指定是否启用虚拟内存机制 vm-enabled no 22. 虚拟内存文件路径，默认/tmp/redis.swap vm-swap-file /tmp/redis.swap 23. 将所有大于vm-max-memory的数据存入虚拟内存 vm-max-memory 0 24. 设置分页大小，Redis swap文件分成很多page vm-page-size 32 25. 设置swap文件中的page数量 vm-pages 134217728 26. 设置访问swap文件的线程数 vm-max-threads 4 27. 设置在向客户端应答时，是否将较小的包合并为一个包发送 glueoutputbuf yes 28. 指定在超过一定数量或最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 29. 指定是否激活重置哈希 activerehashing yes 30. 指定包含其他配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Git】Git的基础使用","slug":"【Git】Git的基础使用","date":"2021-01-12T15:47:06.000Z","updated":"2021-07-28T03:51:52.531Z","comments":true,"path":"2021/01/12/【Git】Git的基础使用/","link":"","permalink":"https://letere-gzj.github.io/2021/01/12/%E3%80%90Git%E3%80%91Git%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"git的最基础使用","text":"git的最基础使用 1. 版本控制1.1 介绍 版本控制：一种在开发骨偶成中用于管理我们对文件、目录或工程的等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术 1.2 版本控制工具 （1）Git （2）SVN（Subversion） （3）CVS（Concurrent Version System） （4）VSS（Micorosoft Visual SourceSafe） （5）TFS（Team Foundation Server） （6）Visual Studio Online 1.2 分类 （1）集中版本控制 所有版本的数据都存在服务器上，用户的本地只有自己以前所同步的版本。而且所有数据都保存在一个服务器上，一旦服务器挂了，影响非常大【代表：SVN】 （2）分布式版本控制 所有版本信息仓库全部同步到本地的每一个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交。【代表：Git】 2.Git环境配置2.1 下载 官网：https://git-scm.com/ 淘宝镜像：http://npm.taobao.org/mirrors/git-for-windows 2.2 安装 除了安装路径以外，全部默认安装即可 安装后鼠标右键出现”Git Bash””Git GUI”即安装成功 Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD：Windows风格的命令行 Git GUI：图形界面的Git，不建议初学者使用，经理先熟悉常用命令 2.3 linux常用命令1234567891011121314cd: 改变目录pwd：显示当前所在的目录路径ls：都是列出当前目录文件touch：新建一个文件，如`touch index.js`就会生成一个index.jsrm：删除一个文件，如`rm index.js`就会移除index.jsmkdir：新建一个文件夹，如`mkdir 测试`就会创建名为测试的文件夹rm -r：删除一个文件夹，如`rm -r src`删除src文件夹mv：移动文件，如`mv index.js src`移动index.js文件到src文件夹下reset：重新初始化终端clear：清屏history：产看历史命令help：帮助exit：退出#：表示注释 2.4 Git配置 （1）系统配置 git config --system --list：查看系统配置 文件路径：安装目录/etc/gitconfig （2）用户配置（必须配置） git config --global user.name &quot;用户名&quot;：配置用户名 git config --global user.email &quot;邮箱&quot;：配置邮箱 git config --global --list：查看用户配置 文件路径：C:\\Users\\计算机用户名.gitconfig 3. Git基本理论 Git本地有三个工作区域： 工作目录（working Directory）：平时存放代码的地方 暂存区（Stage / Index）：用于临时存放你的改动，事实上只是一个文件，保存将要提交到文件列表信息 本地仓库（Repository / Git Drectory）：安全存放数据库的位置。其中HEAD文件指向最新放入仓库的版本 Git远程工作区域 git仓库（Remote Directory）：托管代码的服务器 工作区之间的关系 4. Git项目搭建4.1 创建仓库 （1）创建全新本地仓库 git init：会自动生成.git的隐藏文件 （2）克隆远程仓库 git clone 仓库地址 仓库地址可以用github / gitee 寻找 5. Git文件操作5.1 文件的4种状态 （1）Untracked：未追踪；此文件在文件夹中，但并没有加入的git库，不参与版本控制，通过git add将状态转变为Staged （2）Unmodify：未修改；即版本库中的文件快照内容与文件夹完全一致 （3）Modified：文件已修改；仅仅是修改，没有进行其他操作。可通过git add暂存为staged状态，使用git checkout丢弃修改，返回未修改的状态 （4）Staged：暂存状态；执行git commit则将修改同步到库中，此时库中的文件和本地文件一致。 5.2 查看文件的状态 （1）git status [filename]：查看指定文件状态 （2）git status：查看所有文件状态 5.3 Git常见提交指令 （1）git add .：添加所有文件到暂存区 （2）git commit -m &quot;提交信息&quot;：将暂存区的文件提交到本地仓库 5.4 忽略提交文件 创建.gitignore，里面配置要忽略的文件 123456#为注释*.txt #忽略所有.txt结尾的文件!lib.txt #lib.txt不忽略/temp #仅忽略temp文件夹下的文件，子目录文件不忽略build/ #忽略build/目录下的所有文件，包含子目录doc/*.txt #仅会忽略doc文件夹下的.txt文件，子目录不会忽略 6. Gitee使用6.1 生成免密公钥公钥可以在本地仓库提交到远程仓库是免密提交 （1）执行命令ssh-keygen：生成公钥，生成时可以填写一些基本信息 （2）打开本地文件：C:/Users/计算机用户名/.ssh，将生成的id_rsa里面的内容复制到gitee上 6.2 使用远程仓库 方式一：新建仓库，然后克隆到本地即可 方式二：通过仓库地址，用git指令关联 12345//关联仓库地址(xxxx.git)git remote add origin 仓库地址//第一次上传仓库git push -u origin master 7 分支Branch7.1 介绍7.2 常用命令12345678910111213141516171819202122232425# 查看分支git branch #查看本地分支列表git branch -r #查看远程分支列表git branch -a #查看本地和远程分支列表# 创建分支git branch 分支名 #新建一个本地分支，但仍然停留在当前分支git checkout -b 分支名 #新建一个本地分支，并切换到该分支# 切换本地分支git checkout 分支名# 合并分支git merge 分支名 #将当前分支和指定分支合并# 删除分支git branch -d 分支名 #删除本地分支git branch -D 分支名 #强制删除本地分支git branch -dr 分支名 #删除远程分支git push origin --delete 分支名 #删除远程分支 8 缓存Stash8.1 介绍 git stash是git一个很有用的命令，它的作用是把当前未提交的修改暂存起来，让仓库还原到最后一次提交的状态 一般用户代码拉取(pull)时，为了防止自己修改的设置被覆盖，一般将修改内容放入缓存，再拉取代码，代码拉取成功之后，将缓存中的数据进行覆盖 8.2 常用指令12345678910111213141516171819# 放入缓存git stashgit stash save &quot;信息&quot; #放入缓存带自定义信息# 查看缓存git stash list #查看缓存列表，缓存以&#x27;stash@&#123;缓存id&#125;&#x27;列表保存git show stash@&#123;缓存id&#125; #查看缓存详细信息# 取出缓存（取出后自动删除）git stash pop #默认取出第一条缓存git stash pop stash@&#123;缓存id&#125; #取出指定缓存# 删除缓存git stash drop #默认删除第一条缓存git stash drop stash@&#123;缓存id&#125; #删除指定缓存git stash clear #删除所有缓存 9 工作常见情况9.1 提交特定的代码 遇到这种需求，使用IDEA来进行代码的提交会比较稳妥 9.2 commit取消 工作中出现commit错的代码，如何将此commit取消 9.3 仓库代码回退 当将错误的commit提交到远程仓库后，需要对仓库代码进行回退 此时本地的代码已经回退了，接下来就是将本地的代码提交到远程仓库中","categories":[{"name":"Git","slug":"Git","permalink":"https://letere-gzj.github.io/categories/Git/"}],"tags":[]},{"title":"【Redis】Redis数据类型","slug":"【Redis】Redis数据类型","date":"2021-01-12T15:37:20.000Z","updated":"2021-01-12T15:38:49.820Z","comments":true,"path":"2021/01/12/【Redis】Redis数据类型/","link":"","permalink":"https://letere-gzj.github.io/2021/01/12/%E3%80%90Redis%E3%80%91Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"关于在linux中如何操作Redis不同的数据类型","text":"关于在linux中如何操作Redis不同的数据类型 1. Redis五大数据类型 （1）String（字符串） （2）Hash（哈希，类似Java里的Map） （3）List（列表） 底层实际是一个链表 （4）Set （集合） （5）Zset（sorted set：有序集合） 2. Redis操作数据库命令 http://redisdoc.com/ 3. Redis Key常用操作1234567891011121314151617181920212223242526//查询当前数据库key数量key *//添加键值set [key] [value]//获取键值get [key]//删除键值del [key]//判断是否存在指定key（1存在，0不存在）exists [key]//移动指定key到指定数据库move [key] [database]//为指定key设置过期时间（单位：秒）exprie [key] [time]//查看指定key还是多少时间过期（-1表示永不过期，-2表示已过期，过期就会移除当前key）ttl [key]//查看指定key的数据类型type [key] 4. Redis String常用操作1234567891011121314151617181920212223242526272829303132333435//在原有字符串拼接新数据append [key] [value]//对于数字类型String自增1incr [key]//对于数字类型String自减1decr [key]//对于数字类型String增加特定值incrby [key] [value]//对于数学类型String减少特定值decrby [key] [value]//获取字符串指定范围值（0， -1获取全部）getrange [key] [start] [end]//给字符串特定位置开始填加新值setrange [key] [start] [value]//新增键值的同时设置过期时间（单位：秒）setex [key] [time] [value]//新增键值时判断该键是否存在，存在就不覆盖setnx [key] [value]//一次新增多个键值mset [key1] [value1] [key2] [value2] ...//一次获取多个键值mget [key1] [key2] ...//一次新增多个键值并判断是否存在，一旦有一个存在，直接取消新增msetnx [key1] [value1] [key2] [value2] ... 5. Redis List常用操作1234567891011121314151617181920212223242526272829303132333435//从左边为新数据进行插入列表数据lpush [list] [value1] [value2] [value3] ...//从右边做为新数据进行插入列表数据rpush [list] [value1] [value2] [value3] ...//按指定范围查看列表数据lrange [list] [start] [end]//出栈最左边的数据lpop [list]//出栈最右边的数据rpop [list]//按角标索引数据lindex [list] [index]//获取列表长度llen [list]//删除列表中指定次数的值lrem [list] [times] [value] //例：lren list01 2 3：删除list01中值为3数据，删除两次//按范围截取指定列表的值，并重新覆盖该列表ltrim [list] [start] [end]//将列表1最右边数据移除，并将该数据添加到列表2的最右边（两个命令的结合）rpoplpush [list1] [list2]//将指定下标的数据进行替换lset [list] [index] [value]//在指定列表的指定值(value1)前面/后面插入数据(value2)linsert [list] before/after [value1] [value2] 6. Redis Set常用操作Set和List差不多，只是Set的数据不允许重复，List数据允许 1234567891011121314151617181920212223242526272829//新增set型数据（自动过滤重复数据）sadd [set] [value1] [value2] [value3] ...//获取set集合数据smembers [set]//判断set集合中是否存在指定数据sismenber [set] [value]//删除set集合指定数据srem [set] [value]//随机获取指定数量的数据srandmember [set] [number]//随机出栈（可返回查询信息）一个数据spop [set]//将set集合(set1)中一个指定数据移动到另一个set集合(set2)中smove [set1] [set2] [value]//查询两个集合的差集（以set1为准）sdiff [set1] [set2]//查询两个集合的交集sinter [set1] [set2]//查询两个集合并集sunion [set1] [set2] 7. Redis Hash常用操作hash可以暂时理解为K-V形式，key是String类型，value是个对象深层次理解为KV模式，但value是一个键值对 1234567891011121314151617181920212223242526272829303132333435363738//新增hashhset [key] [v-key] [v-value]//获取hashhget [key] [v-key]//一次添加多个hashhmset [key] [v-key1] [v-value1] [v-key2] [v-value2] ...//一次获取多个hash（仅返回值）hmget [key] [v-key1] [v-key2] ...//一次获取多个hash（返回键和值）hgetall [key]//删除hashhdel [key] [v-key]//返回键的长度hlen [key]//判断指定hash是否存在某个v-keyhexists [key] [v-key]//获取某个hash里面的所有v-keyhkeys [key]//获取某个hash里面的所有v-valuehvals [key]//对于某个hash里面的数字型v-value增加指定数字 （没有自减，需要减使用负数）hincrby [key] [v-key] [number]//对于某个hash里面的数字型v-value增加指定浮点数字hincrbyfloat [key] [v-key] [float-number]//新增hash时判断该v-key是否存在，存在就取消新增hsetnx [key] [v-key] [v-value] 8. Redis Zset常用操作Zset 是 sort set 的简称zset是在原有set的基础上，添加了个score值 1234567891011121314151617181920212223242526272829303132333435363738394041424344//新增一个zsetzadd [zset] [score1] [value1] [score2] [value2] [score3] [value3] ...//按指定范围获取zset的数据（只获取value）zrange [zset] [start] [end]//按指定范围获取zset的数据（获取value和score）zrange [zset] [start] [end] withscores//按指定score范围获取zset的数据（只获取value）zrangebyscore [zset] [score-start] [score-end] //例：zrangebyscore student 60 100 获取60-100分的学生信息//按指定score范围获取zset的数据（只获取value）（&#x27;(&#x27;为不包含）zrangebyscore [zset] ([score-start] ([score-end] //例：zrangebyscore student (60 (100 获取61-99分的学生信息，不包含60和100//按指定score范围获取zset的数据（获取value和score）zrangebyscore [zset] [score-start] [score-end] withscores//按指定score范围获取zset的数据，并指定下标开始截取指定长度数据zrangebyscore [zset] [score-start] [score-end] limit [start] [number]//删除zset的数据（会自动删除对应的score）zrem [zset] [value]//获取zset的长度zcard [zset]//根据指定score范围统计获取长度zcount [zset] [score-start] [score-end]//获取value对应的下标zrank [zset] [value]//获取指定value对应的scorezscore [zset] [value]//逆序（从右到左）获取value对应的下标zrevrank [zset] [value]//按指定范围逆序获取zset数据zrevrange [zset] [start] [end]//按指定分数返回逆序获取zset数据（注意：分数也要反转）zrevrangebyscore [zset] [score-end] [score-start]","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Redis】Redis入门介绍","slug":"【Redis】Redis入门介绍","date":"2021-01-12T15:29:12.000Z","updated":"2021-01-12T15:31:50.018Z","comments":true,"path":"2021/01/12/【Redis】Redis入门介绍/","link":"","permalink":"https://letere-gzj.github.io/2021/01/12/%E3%80%90Redis%E3%80%91Redis%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/","excerpt":"Redis的简单入门，下载和安装","text":"Redis的简单入门，下载和安装 1.入门概述1.1 Redis介绍 Redis：Remote Dictionary Server（远程字典服务器） 是完全开源免费的，用C语言编写的，遵循BSD协议，是一个高性能（key/value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当下最热门的NoSQL数据库之一，也被人们称为数据结构服务器 1.2 Redis特点 （1）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用 （2）Redis不仅仅支持简单的key-value类型的数据，同时还提供list、set、zset、hash等数据结构的存储 （3）Redis支持数据的备份，即master-slave模式的数据备份 1.3 下载地址 官网：http://redis.io/ 中国镜像：http://www.redis.cn/ 2.安装RedisRedis一般使用linux，不会使用windows，官方也推荐使用linux进行使用。演示的linux版本为ubuntu，不同版本可能导致命令些许不同 2.1 环境准备 gcc：是linux下的一个编译程序，是C程序的编译工具 12345//安装gccsudo apt-get install gcc//安装makesudo apt-get install make 2.2 通过安装包安装1234567891011121314151617//移动文件夹到optsudo mv redis-6.0.6-tar.gz /opt//切换到opt文件夹cd /opt//解压文件sudo tar -jxvf redis-6.0.6-tar.gz//切换到到解压后的文件夹cd redis-6.0.6//安装sudo make//安装检验sudo make install 2.3 修改配置123456//在etc下创建文件夹sudo mkdir /etc/redis//将配置文件复制到该文件夹下sudo cp redis.conf /etc/redis/ 修改配置文件 3. HelloWorld redis程序启动位置：/user/local/bin 12345//服务器加载配置文件redis-server /etc/redis/redis.conf//启动服务器，设置端口redis-cli -p 6379 测试 4.Redis启动后杂项基础知识 （1）redis为单进程 单进程模型来处理客户端的请求。对读写等时间的响应是通过epoll函数的包装来做到的。Redis的实际处理速度完全依赖主程序的执行效率 Epollshi Linux内核为处理大批量文件描述符而作的改进的eppll，是Linux下多路复用IO接口select/poll的增强版本，他能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率 （2）默认16个数据库，类似数组下标从0开始，初始使用0号库 可以通过select 数据库下标来切换数据库 dbsize查看当前key的数量 key *查看当前数据库所有key flushdb清除当前数据库的所有key flushall清除所有数据库的所有key （3）Redis默认端口为6379","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【Redis】NoSQL概述","slug":"【Redis】NoSQL概述","date":"2021-01-12T15:22:03.000Z","updated":"2021-01-12T15:26:49.131Z","comments":true,"path":"2021/01/12/【Redis】NoSQL概述/","link":"","permalink":"https://letere-gzj.github.io/2021/01/12/%E3%80%90Redis%E3%80%91NoSQL%E6%A6%82%E8%BF%B0/","excerpt":"先了解NoSQL的知识，方便后面的Redis学习","text":"先了解NoSQL的知识，方便后面的Redis学习 1. 入门概述1.1 为什么使用NoSQL数据量的激增，传统的关系型数据库无法支撑传统的业务，需要使用NoSQL来解决 1.2 NoSQL概述NoSQL = （not only SQL），意思为“不仅仅是SQL”，泛指非关系型数据库 1.3 NoSQL特点 （1）易拓展：数据之间无关系，变得容易拓展 （2）大数据量高性能：由于NoSQL的数据库结构简单，可以存储大量数据。NoSQL的cache时纪录级，表更新并不会立马失效，性能较好。 （3）多样灵活的数据模型：NoSQL无需事先建立存储字段，可以随时自定义字段，十分灵活 1.4 NoSQL使用推荐三种NoSQL （1）Mongdb：最像关系型数据库的非关系数据库 （2）Memcache：高速缓存 （3）Redis：存储数据类型丰富 2. 3V+3高2.1 大数据时代的3V （1）海量Volume （2）多样Variety （3）实时Velocity 2.2 互联网需求的3高 （1）高并发 （2）高可扩 （3）高性能 3. NoSQL数据模型简介使用BSON来表示，BSON = Binary JSON，和JSON一样，支持内嵌的文档对象和数组对象 聚合模型： KV键值对 BSON 列族 图形 4. NoSQL数据库的四大分类 （1）KV键值对：Berkeley+Redis、Redis+Tair、Memcache+Redis （2）文档型数据库（BOSN格式比较多）：CouchDB、MongoDB （3）列存储数据库：Cassandra、HBase （4）图关系数据库：Neo4J、InfoGrid 5. 分布式数据库中CAP原理5.1 传统ACID A：Atomicity（原子性） C：Consistency（一致性） I：Isolation（独立性） D：Durability（持久性） 5.2 NoSQL的CAP C：Consistency（强一致性） A：Availability（可用性） P：Partition tolerance（分区容错性） 5.3 CAP的3进2 CAP理论在分布式存储系统中，最多只能实现上面两点 CA：传统数据库 AP：大多数网站架构的选择 CP：Redis、MongoDB 分区容忍性是必须要实现的，所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点 5.4 BASE BASE是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方法 BA：Basically Available（基本可用） S：Soft state（软状态） E：Eventutally consistent（最终一致）","categories":[{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"}],"tags":[]},{"title":"【智能算法】实验：传教士过河","slug":"【智能算法】实验：传教士过河","date":"2021-01-03T04:30:53.000Z","updated":"2021-01-03T04:34:19.083Z","comments":true,"path":"2021/01/03/【智能算法】实验：传教士过河/","link":"","permalink":"https://letere-gzj.github.io/2021/01/03/%E3%80%90%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E3%80%91%E5%AE%9E%E9%AA%8C%EF%BC%9A%E4%BC%A0%E6%95%99%E5%A3%AB%E8%BF%87%E6%B2%B3/","excerpt":"智能算法基本实验之一：传教士，野人渡河问题的Java解决方案（自定义人数）","text":"智能算法基本实验之一：传教士，野人渡河问题的Java解决方案（自定义人数） 一、问题描述123有 N 个传教士和 N 个野人来到河边渡河，河岸有一条船，每次至多可供 k 人乘渡。问：传教士为了安全起见，应如何规划摆渡方案，使得任何时刻， 河两岸以及船上的野人数目总是不超过传教士的数目(否则不安全，传教士有可能被野人吃掉)。 即求解传教士和野人从左岸全部摆渡到右岸的过程中，任何时刻满足 M (传教土数) ≥ C 野人数)和 M+C≤k 的摆渡方案 二、代码实现 参考代码：https://blog.csdn.net/joebug/article/details/78302544 上面算法最大的问题在于渡河人数，船限载人数都规定死了，不灵活 需要对上面算进一步封装，抽离 2.1 代码优化(Java)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//记录河两岸状态的类public class RiverState &#123; private int missionaryLeft; //左岸传教士数量 private int savageLeft; //左岸野人数量 private int missionaryRight; //右岸传教士数量 private int savageRight; //右岸野人数量 private int boat; //船的位置，左1，右-1; //构造器 public RiverState()&#123;&#125;; public RiverState(int missionaryLeft, int savageLeft, int missionaryRight, int savageRight, int boat) &#123; this.missionaryLeft = missionaryLeft; this.savageLeft = savageLeft; this.missionaryRight = missionaryRight; this.savageRight = savageRight; this.boat = boat; &#125; //get、set方法 public int getMissionaryLeft() &#123; return missionaryLeft; &#125; public void setMissionaryLeft(int missionaryLeft) &#123; this.missionaryLeft = missionaryLeft; &#125; public int getSavageLeft() &#123; return savageLeft; &#125; public void setSavageLeft(int savageLeft) &#123; this.savageLeft = savageLeft; &#125; public int getMissionaryRight() &#123; return missionaryRight; &#125; public void setMissionaryRight(int missionaryRight) &#123; this.missionaryRight = missionaryRight; &#125; public int getSavageRight() &#123; return savageRight; &#125; public void setSavageRight(int savageRight) &#123; this.savageRight = savageRight; &#125; public int getBoat() &#123; return boat; &#125; public void setBoat(int boat) &#123; this.boat = boat; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196//优化后算法，可以自定义渡河人数，以船限载人数public class CrossRiver &#123; private int count = 0; //记录方案种类 private int person; //传教士、野人人数（保持相同） private int boat; //船限载人数（小于person数） //构造器 public CrossRiver(int person, int boat) &#123; this.person = person; this.boat = boat; &#125;; /** * 计算渡河方法 * @return crossMethods */ public List&lt;String&gt; getCrossMethods() &#123; List&lt;String&gt; crossMethods = new ArrayList&lt;&gt;(); for(int i=0; i&lt;=person; i++) &#123; //传教士数 for(int j=0; j&lt;=person; j++) &#123; //野人数 if(i != 0 || j !=0) &#123; //过河必须有人，不能两者为0 if(i+j &lt;= boat) &#123; crossMethods.add(i + &quot; &quot; + j); &#125; &#125; &#125; &#125; return crossMethods; &#125; /** * 运河，并返回运河操作信息 * @param riverState 两岸状态 * @param missionary 运送传教士数 * @param savage 运送野人数 * @return 操作信息 */ private String acrossRiver(RiverState riverState, int missionary, int savage) &#123; //初始状态信息（记录操作） String startState = &quot;[左：传&quot; + riverState.getMissionaryLeft() + &quot;, 野&quot; + riverState.getSavageLeft() + &quot;] | &quot; + &quot;[右：传&quot; + riverState.getMissionaryRight() + &quot;, 野&quot; + riverState.getSavageRight() + &quot;]&quot;; //以船在左岸为基准，右移为正，左移为负 int direction = riverState.getBoat(); //修改传教士数 if (missionary &gt; 0) &#123; riverState.setMissionaryLeft(riverState.getMissionaryLeft() - missionary * direction); riverState.setMissionaryRight(riverState.getMissionaryRight() + missionary * direction); &#125; //修改野人数 if (savage &gt; 0) &#123; riverState.setSavageLeft(riverState.getSavageLeft() - savage * direction); riverState.setSavageRight(riverState.getSavageRight() + savage * direction); &#125; //修改船的状态 riverState.setBoat(-riverState.getBoat()); //结束状态信息（记录操作） String endState = &quot;[左：传&quot; + riverState.getMissionaryLeft() + &quot;, 野&quot; + riverState.getSavageLeft() + &quot;] | &quot; + &quot;[右：传&quot; + riverState.getMissionaryRight() + &quot;, 野&quot; + riverState.getSavageRight() + &quot;]&quot;; //操作信息 String operation = &quot;&quot;; if (riverState.getBoat() == 1) &#123; operation = &quot; &lt;---（传&quot; + missionary + &quot;, 野&quot; + savage + &quot;）---- &quot;; return endState + operation + startState; &#125; else &#123; operation = &quot; ----（传&quot; + missionary + &quot;, 野&quot; + savage + &quot;）---&gt; &quot;; return startState + operation + endState; &#125; &#125; /** * 判断数据是否出错，会出现负数情况 * @param riverState 两岸状态 * @return true/false */ private boolean isWrong(RiverState riverState) &#123; if (riverState.getMissionaryLeft() &lt; 0 || riverState.getSavageLeft() &lt; 0 || riverState.getMissionaryRight() &lt; 0 || riverState.getSavageRight() &lt; 0) &#123; return true; &#125; return false; &#125; /** * 判断是否发生吃人 * @param riverState 两岸状态 * @return true/false */ private boolean isEat(RiverState riverState) &#123; //判断左岸 if (riverState.getMissionaryLeft() &lt; riverState.getSavageLeft() &amp;&amp; riverState.getMissionaryLeft() != 0) &#123; return true; &#125; //判断右岸 if (riverState.getMissionaryRight() &lt; riverState.getSavageRight() &amp;&amp; riverState.getMissionaryRight() != 0) &#123; return true; &#125; return false; &#125; /** * 判断是否达成目标 * @param riverState 两岸状态 * @return true/false */ private boolean isFinish(RiverState riverState) &#123; if (riverState.getMissionaryLeft() == 0 &amp;&amp; riverState.getSavageLeft() == 0 &amp;&amp; riverState.getBoat() == -1) &#123; return true; &#125; return false; &#125; /** * 复制对象（对象作为参数是地址引用，修改对象时最好复制一份，方便还原） * @param riverState 两岸状态 * @return RiverState */ private RiverState copyRiverState(RiverState riverState) &#123; return new RiverState( riverState.getMissionaryLeft(), riverState.getSavageLeft(), riverState.getMissionaryRight(), riverState.getSavageRight(), riverState.getBoat() ); &#125; /** * 判断是否重复操作（即：左向右传2野人， 右向左也传2野人，死循环） * @param riverState 两岸状态 * @param history 历史数据 * @return true/false */ private boolean isRepeat(RiverState riverState, List&lt;RiverState&gt; history) &#123; for (int i = 0; i &lt; history.size() - 1; i++) &#123; //遍历历史数据，查看是否有重复数据，有重复数据及循环回原点 if (riverState.getMissionaryLeft() == history.get(i).getMissionaryLeft() &amp;&amp; riverState.getSavageLeft() == history.get(i).getSavageLeft()) &#123; if (riverState.getBoat() == history.get(i).getBoat()) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 算法主程序（只有此为public） * @param riverState * @param history * @param operations */ public void run(RiverState riverState, List&lt;RiverState&gt; history, List&lt;String&gt; operations) &#123; //判断数据是否出错 if (isWrong(riverState)) &#123; return; &#125; //判断是否被吃 if (isEat(riverState)) &#123; return; &#125; //判断重复 if (isRepeat(riverState, history)) &#123; return; &#125; //判断是否完成 if (isFinish(riverState)) &#123; count ++; System.out.println(&quot;第&quot; + count + &quot;种渡河方法：&quot;); for (String operation : operations) &#123; System.out.println(operation); //打印操作 &#125; System.out.println(); return; &#125; String message = &quot;&quot;; RiverState currentState = new RiverState(); List&lt;String&gt; crossMethods = getCrossMethods(); for (String crossMethod : crossMethods) &#123; //遍历渡河方法 String[] s = crossMethod.split(&quot; &quot;); //按空格切割字符串，s[0]为传教士数，s[1]为野人数 currentState = copyRiverState(riverState); //创建一个新对象，用于修改后不影响原对象 message = acrossRiver(currentState, Integer.valueOf(s[0]), Integer.valueOf(s[1]));//调用渡河方法 operations.add(message); //新增记录用数据 history.add(currentState); run(currentState, history, operations); //递归 operations.remove(operations.size() - 1); //递归失败后清除新增的数据，恢复原样 history.remove(history.size() - 1); &#125; &#125;&#125; 123456789101112//调用算法运行public class Main &#123; public static void main(String[] args) &#123; RiverState riverState = new RiverState(3, 3, 0, 0, 1); List&lt;RiverState&gt; history = new ArrayList&lt;&gt;(); history.add(riverState); //把初始状态添加到历史状态中 List&lt;String&gt; operations = new ArrayList&lt;&gt;(); CrossRiver crossRiver = new CrossRiver(3, 2); //经典3传教士，3野人，船限载2人问题 crossRiver.run(riverState, history, operations); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152运行结果：第1种渡河方法：[左：传3, 野3] | [右：传0, 野0] ----（传0, 野2）---&gt; [左：传3, 野1] | [右：传0, 野2][左：传3, 野2] | [右：传0, 野1] &lt;---（传0, 野1）---- [左：传3, 野1] | [右：传0, 野2][左：传3, 野2] | [右：传0, 野1] ----（传0, 野2）---&gt; [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] &lt;---（传0, 野1）---- [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] ----（传2, 野0）---&gt; [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] &lt;---（传1, 野1）---- [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] ----（传2, 野0）---&gt; [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] &lt;---（传0, 野1）---- [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] ----（传0, 野2）---&gt; [左：传0, 野1] | [右：传3, 野2][左：传0, 野2] | [右：传3, 野1] &lt;---（传0, 野1）---- [左：传0, 野1] | [右：传3, 野2][左：传0, 野2] | [右：传3, 野1] ----（传0, 野2）---&gt; [左：传0, 野0] | [右：传3, 野3]第2种渡河方法：[左：传3, 野3] | [右：传0, 野0] ----（传0, 野2）---&gt; [左：传3, 野1] | [右：传0, 野2][左：传3, 野2] | [右：传0, 野1] &lt;---（传0, 野1）---- [左：传3, 野1] | [右：传0, 野2][左：传3, 野2] | [右：传0, 野1] ----（传0, 野2）---&gt; [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] &lt;---（传0, 野1）---- [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] ----（传2, 野0）---&gt; [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] &lt;---（传1, 野1）---- [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] ----（传2, 野0）---&gt; [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] &lt;---（传0, 野1）---- [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] ----（传0, 野2）---&gt; [左：传0, 野1] | [右：传3, 野2][左：传1, 野1] | [右：传2, 野2] &lt;---（传1, 野0）---- [左：传0, 野1] | [右：传3, 野2][左：传1, 野1] | [右：传2, 野2] ----（传1, 野1）---&gt; [左：传0, 野0] | [右：传3, 野3]第3种渡河方法：[左：传3, 野3] | [右：传0, 野0] ----（传1, 野1）---&gt; [左：传2, 野2] | [右：传1, 野1][左：传3, 野2] | [右：传0, 野1] &lt;---（传1, 野0）---- [左：传2, 野2] | [右：传1, 野1][左：传3, 野2] | [右：传0, 野1] ----（传0, 野2）---&gt; [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] &lt;---（传0, 野1）---- [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] ----（传2, 野0）---&gt; [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] &lt;---（传1, 野1）---- [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] ----（传2, 野0）---&gt; [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] &lt;---（传0, 野1）---- [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] ----（传0, 野2）---&gt; [左：传0, 野1] | [右：传3, 野2][左：传0, 野2] | [右：传3, 野1] &lt;---（传0, 野1）---- [左：传0, 野1] | [右：传3, 野2][左：传0, 野2] | [右：传3, 野1] ----（传0, 野2）---&gt; [左：传0, 野0] | [右：传3, 野3]第4种渡河方法：[左：传3, 野3] | [右：传0, 野0] ----（传1, 野1）---&gt; [左：传2, 野2] | [右：传1, 野1][左：传3, 野2] | [右：传0, 野1] &lt;---（传1, 野0）---- [左：传2, 野2] | [右：传1, 野1][左：传3, 野2] | [右：传0, 野1] ----（传0, 野2）---&gt; [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] &lt;---（传0, 野1）---- [左：传3, 野0] | [右：传0, 野3][左：传3, 野1] | [右：传0, 野2] ----（传2, 野0）---&gt; [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] &lt;---（传1, 野1）---- [左：传1, 野1] | [右：传2, 野2][左：传2, 野2] | [右：传1, 野1] ----（传2, 野0）---&gt; [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] &lt;---（传0, 野1）---- [左：传0, 野2] | [右：传3, 野1][左：传0, 野3] | [右：传3, 野0] ----（传0, 野2）---&gt; [左：传0, 野1] | [右：传3, 野2][左：传1, 野1] | [右：传2, 野2] &lt;---（传1, 野0）---- [左：传0, 野1] | [右：传3, 野2][左：传1, 野1] | [右：传2, 野2] ----（传1, 野1）---&gt; [左：传0, 野0] | [右：传3, 野3]","categories":[],"tags":[]},{"title":"【智能算法】蚁群优化算法","slug":"【智能算法】蚁群优化算法","date":"2021-01-03T04:18:30.000Z","updated":"2021-01-03T04:20:42.738Z","comments":true,"path":"2021/01/03/【智能算法】蚁群优化算法/","link":"","permalink":"https://letere-gzj.github.io/2021/01/03/%E3%80%90%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E3%80%91%E8%9A%81%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","excerpt":"智能算法之一：蚁群优化算法初步了解以及Java实现","text":"智能算法之一：蚁群优化算法初步了解以及Java实现 一、算法介绍具体百度 1.1 三个重要式子 （1）每条路选中概率 其中alpha 和 beta 参数自定义 alpha为信息因子占的权重，权重过高，蚂蚁选中已走的路概率越高，开始走新路概率低 beta为两点距离的权重（能见度），权重过高，蚂蚁优先走两点最短距离的路 （2）信息素更新 信息素更新包括：信息素挥发 以及 信息素新增 蚂蚁走完一遍所有城市后，就开始先计算挥发，再计算新增 二、Java实现代码（TSP问题）2.1 TSP问题 简单来说，就是寻找一条访问所有城市，最短的一条路线 前提：所有城市之间是互通的，任意两个城市可以来往 2.2 Java实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//创建一个蚂蚁类 Ant.javapublic class Ant &#123; private List&lt;Integer&gt; route = new ArrayList&lt;Integer&gt;(); //路线：记录蚂蚁行走的路线 private Integer currentCity; //当前城市：记录蚂蚁当前所在城市的ID private List&lt;Integer&gt; citys = new ArrayList&lt;Integer&gt;(); //城市：记录需要行走的城市ID private double[][] pheromoneMatrix; //信息素矩阵 private int[][] distanceMatrix; //距离矩阵（整型方便查看） //构造器 public Ant(List&lt;Integer&gt; citys, double[][] pheromoneMatrix, int[][] distanceMatrix) &#123; this.citys = citys; this.pheromoneMatrix = pheromoneMatrix; this.distanceMatrix = distanceMatrix; &#125; /** * 添加路线 * @param cityId */ private void addRoute(Integer cityId) &#123; route.add(cityId); //路线中添加城市ID currentCity = cityId; //当前城市修改为城市ID citys.remove(cityId); //需要行走的城市移除当前城市ID &#125; /** * 随机选择初始城市 */ private void randomSelectCity() &#123; Random random = new Random(); Integer cityId = random.nextInt(citys.size())+1; addRoute(cityId); &#125; /** * 选择下一个城市 */ private void selectNextCity() &#123; if(citys.size() == 1) &#123; addRoute(citys.get(0)); addRoute(route.get(0)); //路线添加最开始的城市 return; &#125; Double alpha = 1.0; //信息素因子权重 Double beta = 2.0; //路线距离权重 Map&lt;Integer, Double&gt; molecules = new HashMap&lt;Integer, Double&gt;(); //计算选路概率公式中的分子 for (Integer city : citys) &#123; //城市从1开始数，数组从0开始数，所以涉及数组都要‘-1’ Double molecule = Math.pow(pheromoneMatrix[currentCity-1][city-1], alpha) * Math.pow(1.0 / distanceMatrix[currentCity-1][city-1], beta); molecules.put(city, molecule); &#125; //计算选路概率公式中的分母 Double totalMolecule = 0.0; for(Integer city : molecules.keySet()) &#123; totalMolecule += molecules.get(city); &#125; //轮盘赌选择下一个城市 double random = Math.random(); Double temp = 0.0; for(Integer city : molecules.keySet()) &#123; temp += molecules.get(city) / totalMolecule; if(temp &gt;= random) &#123; addRoute(city); break; &#125; &#125; &#125; /** * 蚂蚁开始旅行所有城市 */ public void tour() &#123; int cityQuantity = citys.size(); randomSelectCity(); for(int i=0; i&lt;cityQuantity; i++) &#123; selectNextCity(); &#125; &#125; /** * 获取路线 * @return */ public List&lt;Integer&gt; getRoute() &#123; return route; &#125; /** * 计算路线总距离 * @return */ public Integer getRouteLength() &#123; Integer length = 0; for(int i=0; i&lt;route.size()-1; i++) &#123; length += distanceMatrix[route.get(i)-1][route.get(i+1)-1]; &#125; return length; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//创建一个AOC类：是蚁群优化算法主要实现类public class ACO &#123; List&lt;Integer&gt; citys = new ArrayList&lt;Integer&gt;(); //城市集合 private double[][] pheromoneMatrix; //信息素矩阵 private int[][] distanceMatrix; //距离矩阵 private int times; //运行次数 private int antQuantity; // 蚂蚁数量 private List&lt;Integer&gt; bestRoute; //最佳路线 private Integer bestLength = -1; //最佳距离 //构造器 public ACO(List&lt;Integer&gt; citys, double[][] pheromoneMatrix, int[][] distanceMatrix, int times, int antQuantity) &#123; this.citys = citys; this.pheromoneMatrix = pheromoneMatrix; this.distanceMatrix = distanceMatrix; this.times = times; this.antQuantity = antQuantity; &#125; /** * 更新信息素 * @param ants 蚂蚁群 */ private void update(List&lt;Ant&gt; ants) &#123; //信息素挥发 double volatilizationRate = 0.5; //挥发率 for(int i=0; i&lt;citys.size(); i++) &#123; for(int j=0; j&lt;citys.size(); j++) &#123; pheromoneMatrix[i][j] = pheromoneMatrix[i][j] * (1.0-volatilizationRate); &#125; &#125; //信息素新增 for(Ant ant : ants) &#123; List&lt;Integer&gt; route = ant.getRoute(); for(int i=0; i&lt;route.size()-1; i++)&#123; pheromoneMatrix[route.get(i)-1][route.get(i+1)-1] += 1.0 / ant.getRouteLength(); &#125; &#125; &#125; /** * 记录最佳路径和最佳距离 */ private void recordBest(List&lt;Ant&gt; ants) &#123; //给bestLength赋予初始值 if(bestLength == -1.0) &#123; bestLength = ants.get(0).getRouteLength(); bestRoute = ants.get(0).getRoute(); &#125; //遍历比较最佳 for(Ant ant : ants) &#123; if(bestLength &gt; ant.getRouteLength()) &#123; bestLength = ant.getRouteLength(); bestRoute = ant.getRoute(); &#125; &#125; &#125; /** * 运行蚁群优化算法 */ private void runAlgorithm()&#123; //创建蚂蚁集合存储蚂蚁 List&lt;Ant&gt; ants = new ArrayList&lt;Ant&gt;(); for(int i=0; i&lt;antQuantity; i++)&#123; //复制城市集合(集合为地址引用，为了不影响原参数，复制一个新集合) List&lt;Integer&gt; cityCopy = new ArrayList&lt;Integer&gt;(); for (Integer city : citys) &#123; cityCopy.add(city); &#125; //创建蚂蚁，并开始旅行所有城市 Ant ant = new Ant(cityCopy, pheromoneMatrix, distanceMatrix); ant.tour(); ants.add(ant); &#125; update(ants); //更新信息素 recordBest(ants); //记录最佳路线与距离 &#125; /** * 多次运行蚁群优化算法（蚂蚁算法的运行入口） */ public void run() &#123; for(int i=0; i&lt;times; i++)&#123; runAlgorithm(); &#125; &#125; /** * 获取最佳路线 */ public List&lt;Integer&gt; getBestRoute() &#123; return bestRoute; &#125; /** * 获取最佳距离 */ public Integer getBestLength() &#123; return bestLength; &#125;&#125; 针对TSP问题的蚂蚁优化算法就写好了，只要创建AOC，传入对应的参数，运行run()方法就会跑起来，通过getXxxx获取路线以及路线长度 12345678910111213141516171819202122232425//主程序代码演示public class Main &#123; public static void main(String[] args) &#123; //自定义距离矩阵 int[][] distanceMatrix = new int[][]&#123;&#123;0, 1, 3, 1&#125;, &#123;1, 0, 3, 2&#125;, &#123;3, 3, 0, 2&#125;, &#123;1, 2, 2, 0&#125;&#125;; //创建信息素矩阵并赋初值 double[][] pheromoneMatrix = new double[4][4]; for(int i=0; i&lt;distanceMatrix.length; i++) &#123; for(int j=0; j&lt;distanceMatrix.length; j++) &#123; pheromoneMatrix[i][j] = 0.1; &#125; &#125; //创建城市集合 List&lt;Integer&gt; citys = new ArrayList&lt;Integer&gt;(); for(int i=0; i&lt;4; i++) &#123; citys.add(i+1); &#125; //运行蚁群优化算法 ACO aco = new ACO(citys, pheromoneMatrix, distanceMatrix, 50, 6); aco.run(); System.out.println(aco.getBestRoute()); System.out.println(aco.getBestLength()); &#125;&#125; 2.3 自定义工具类 由于自己定义距离矩阵，信息素矩阵觉得麻烦，就创建一个工具类实现创建 （1）将城市信息存储在一个txt文件中 城市ID X轴 Y轴 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849481 6734 14532 2233 103 5530 14244 401 8415 3082 16446 7608 44587 7573 37168 7265 12689 6898 188510 1112 204911 5468 260612 5989 287313 4706 267414 4612 203515 6347 268316 6107 66917 7611 518418 7462 359019 7732 472320 5900 356121 4483 336922 6101 111023 5199 218224 1633 280925 4307 232226 675 100627 7555 481928 7541 398129 3177 75630 7352 450631 7545 280132 3245 330533 6426 317334 4608 119835 23 221636 7248 377937 7762 459538 7392 224439 3484 282940 6271 213541 4985 14042 1916 156943 7280 489944 7509 323945 10 267646 6807 299347 5185 325848 3023 1942 （2）创建工具类来读取txt信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class Utils &#123; /** * 读取文件内容，将每一行文本封装为字符串集合 * @return * @throws Exception */ private static List&lt;String&gt; readFile()&#123; //文件路径，按照自己情况进行修改 String filePath = &quot;D:\\\\WorkSpace\\\\IDEA_workspace\\\\智能算法\\\\蚁群优化算法\\\\src\\\\main\\\\java\\\\data\\\\position.txt&quot;; List&lt;String&gt; texts = null; BufferedReader br = null; //异常处理 try &#123; br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath))); //创建读取文件流 texts = new ArrayList&lt;String&gt;(); //创建集合存储字符串 while(true) &#123; String text = br.readLine(); if(text == null) &#123; //直到下一行没有内容，退出循环 break; &#125; texts.add(text); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return texts; &#125; /** * 创建城市Id集合 * @return */ public static List&lt;Integer&gt; getCitys() &#123; Integer cityQuantity = Integer.valueOf(readFile().get(0)); List&lt;Integer&gt; citys = new ArrayList&lt;Integer&gt;(); for(int i=0; i&lt;cityQuantity; i++) &#123; citys.add(i+1); &#125; return citys; &#125; /** * 创建距离矩阵 * @return */ public static int[][] getDistanceMatrix() &#123; List&lt;String&gt; texts = readFile(); Integer cityQuantity = Integer.valueOf(texts.get(0)); int[][] distanceMatrix = new int[cityQuantity][cityQuantity]; for(int i=0; i&lt;cityQuantity; i++) &#123; distanceMatrix[i][i] = 0; for (int j=i+1; j&lt;cityQuantity; j++) &#123; //按空格分割字符串 String[] city1 = texts.get(i + 1).split(&quot; &quot;); String[] city2 = texts.get(j + 1).split(&quot; &quot;); //两点距离公式（整数方便查看） double distance = Math.pow((Integer.valueOf(city1[1]) - Integer.valueOf(city2[1])), 2) + Math.pow((Integer.valueOf(city1[2]) - Integer.valueOf(city2[2])), 2); distanceMatrix[i][j] = (int) Math.sqrt(distance); distanceMatrix[j][i] = distanceMatrix[i][j]; &#125; &#125; return distanceMatrix; &#125; /** * 初始化信息素矩阵 * @param value 初始值 * @return */ public static double[][] getPheromoneMatrix(double value) &#123; Integer cityQuantity = Integer.valueOf(readFile().get(0)); double[][] pheromoneMatrix = new double[cityQuantity][cityQuantity]; for(int i=0; i&lt;cityQuantity; i++) &#123; for(int j=0; j&lt;cityQuantity; j++) &#123; pheromoneMatrix[i][j] = value; //赋予初始信息素值 &#125; &#125; return pheromoneMatrix; &#125;&#125; （3）通过使用工具类的主程序 123456789101112public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; citys = Utils.getCitys(); //城市集合 double[][] pheromoneMatrix = Utils.getPheromoneMatrix(1.0); //信息素矩阵 int[][] distanceMatrix = Utils.getDistanceMatrix(); //距离矩阵 ACO aco = new ACO(citys, pheromoneMatrix, distanceMatrix, 150, 72); aco.run(); System.out.println(aco.getBestRoute()); System.out.println(aco.getBestLength()); &#125;&#125;","categories":[{"name":"智能算法","slug":"智能算法","permalink":"https://letere-gzj.github.io/categories/%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"【Vue】Vue实战项目","slug":"【Vue】Vue实战项目","date":"2020-12-24T13:50:12.000Z","updated":"2020-12-24T13:54:33.760Z","comments":true,"path":"2020/12/24/【Vue】Vue实战项目/","link":"","permalink":"https://letere-gzj.github.io/2020/12/24/%E3%80%90Vue%E3%80%91Vue%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/","excerpt":"Vue总结性实战项目","text":"Vue总结性实战项目 一、项目开发1.1 目录结构划分 开发中先把大概的目录结构划分好，使开发变得简洁 1.2 css文件引入 （1）normalize.css https://github.com/necolas/normalize.css/tree/master （2）base.css 基础的css样式设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@import &quot;./normalize.css&quot;;/*:root -&gt; 获取根元素html*/:root &#123; --color-text: #666; --color-high-text: #ff5777; --color-tint: #ff8198; --color-background: #fff; --font-size: 14px; --line-height: 1.5;&#125;*,*::before,*::after &#123; margin: 0; padding: 0; box-sizing: border-box;&#125;body &#123; font-family: &quot;Helvetica Neue&quot;,Helvetica,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;微软雅黑&quot;,Arial,sans-serif; user-select: none; /* 禁止用户鼠标在页面上选中文字/图片等 */ -webkit-tap-highlight-color: transparent; /* webkit是苹果浏览器引擎，tap点击，highlight背景高亮，color颜色，颜色用数值调节 */ background: var(--color-background); color: var(--color-text); /* rem vw/vh */ width: 100vw;&#125;a &#123; color: var(--color-text); text-decoration: none;&#125;.clear-fix::after &#123; clear: both; content: &#x27;&#x27;; display: block; width: 0; height: 0; visibility: hidden;&#125;.clear-fix &#123; zoom: 1;&#125;.left &#123; float: left;&#125;.right &#123; float: right;&#125; （3）去App.vue中引入base.css 1234...&lt;style&gt; @import &quot;./assets/css/base.css&quot;;&lt;/style&gt; 1.3 设置额外配置 （1）创建一个vue.config.js文件，里面填写配置信息 123456789101112module.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; //配置别名 //&#x27;@&#x27;: &quot;src&quot;, 默认配置 &#x27;assets&#x27;: &quot;@/assets&quot;, &quot;common&quot;: &quot;@/common&quot;, &quot;network&quot;: &quot;@/network&quot; &#125; &#125; &#125;&#125; （2）弄一个.editorconfig文件，来统一小组开发的代码风格 123456789root = true[*]charset = utf-8indent_style = spaceindent_size = 2end_of_line = lfinsert_final_newline = truetrim_trailing_whitespace = true 1.4 引入Tabbar 把之前做的前端路由小案例引入进来，具体看之前的文章 二、首页开发2.1 导航栏的封装和使用 （1）因为多个页面都会使用导航栏，所以将导航栏的插件放在./components/common/navbar/NavBar.vue中 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;nav-bar&quot;&gt; &lt;!--为了适用多个页面，生成三个具名插槽--&gt; &lt;div class=&quot;left&quot;&gt; &lt;!--为了能够设置插槽的大小，用div包装起来，在div中设置--&gt; &lt;solt name=&quot;left&quot;&gt;&lt;/solt&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;slot name=&quot;center&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;NavBar&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; .nav-bar &#123; display: flex; height: 44px; line-height: 44px; /* 顶部导航栏一般大小为44px */ text-align: center; /* 文字居中 */ box-shadow: 0 1px 1px rgba(100, 100, 100, .1); /* 边框渐变色 */ &#125; .left, .right &#123; width: 44px; /* 设置左右宽度 */ &#125; .center &#123; flex: 1; /* 把中间的部分占满 */ &#125;&lt;/style&gt; （2）在首页组件使用导航栏 1234567891011121314151617181920&lt;template&gt; &lt;div id=&quot;home&quot;&gt; &lt;nav-bar class=&quot;home-nav&quot;&gt; &lt;div slot=&quot;center&quot;&gt; &lt;!--使用中间的具名插槽--&gt; 购物街 &lt;/div&gt; &lt;/nav-bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ...&lt;/script&gt;&lt;style scoped&gt; .home-nav &#123; /* 设置首页导航栏特有的样式 */ background-color: pink; color: white; &#125;&lt;/style&gt; 2.2 请求首页多个数据 （1）封装axios网络请求 好处：减少项目对此的依赖，解耦 12345678910import Axios from &quot;axios&quot;;export function request(config) &#123; const instance = Axios.create(&#123; baseURL: &quot;http://123.207.32.32:8000&quot;, timeout: 5000 &#125;); return instance(config)&#125; （2）封装首页的网络请求 好处：方便管理，解耦 123456789import &#123;request&#125; from &quot;./request&quot;;//对所有请求的首页数据进行封装，方便管理export function getHomeMultidata() &#123; return request(&#123; url: &quot;/home/multidata&quot;, method: &quot;get&quot; &#125;);&#125; （3）Home.vue保存请求的数据 12345678910111213141516171819202122...&lt;script&gt; import &#123;getHomeMultidata&#125; from &quot;network/home&quot; export default &#123; ... data() &#123; //保存网络请求的数据 return &#123; banners: [], recommends: [] &#125; &#125;, created() &#123; getHomeMultidata().then(res =&gt; &#123; //请求数据，并保存在data中 console.log(res.data); this.banners = res.data.data.banner.list; this.recommends = res.data.data.recommend.list; &#125;) &#125; &#125;&lt;/script&gt;... 2.3 实现轮播图 （1）创建一个新文件夹swiper来保存轮播图组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246&lt;!--Swiper.vue--&gt;&lt;template&gt; &lt;div id=&quot;hy-swiper&quot;&gt; &lt;div class=&quot;swiper&quot; @touchstart=&quot;touchStart&quot; @touchmove=&quot;touchMove&quot; @touchend=&quot;touchEnd&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;slot name=&quot;indicator&quot;&gt; &lt;/slot&gt; &lt;div class=&quot;indicator&quot;&gt; &lt;slot name=&quot;indicator&quot; v-if=&quot;showIndicator &amp;&amp; slideCount&gt;1&quot;&gt; &lt;div v-for=&quot;(item, index) in slideCount&quot; class=&quot;indi-item&quot; :class=&quot;&#123;active: index === currentIndex-1&#125;&quot; :key=&quot;index&quot;&gt;&lt;/div&gt; &lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Swiper&quot;, props: &#123; interval: &#123; type: Number, default: 3000 &#125;, animDuration: &#123; type: Number, default: 300 &#125;, moveRatio: &#123; type: Number, default: 0.25 &#125;, showIndicator: &#123; type: Boolean, default: true &#125; &#125;, data: function () &#123; return &#123; slideCount: 0, // 元素个数 totalWidth: 0, // swiper的宽度 swiperStyle: &#123;&#125;, // swiper样式 currentIndex: 1, // 当前的index scrolling: false, // 是否正在滚动 &#125; &#125;, mounted: function () &#123; // 1.操作DOM, 在前后添加Slide setTimeout(() =&gt; &#123; this.handleDom(); // 2.开启定时器 this.startTimer(); &#125;, 3000) &#125;, methods: &#123; /** * 定时器操作 */ startTimer: function () &#123; this.playTimer = window.setInterval(() =&gt; &#123; this.currentIndex++; this.scrollContent(-this.currentIndex * this.totalWidth); &#125;, this.interval) &#125;, stopTimer: function () &#123; window.clearInterval(this.playTimer); &#125;, /** * 滚动到正确的位置 */ scrollContent: function (currentPosition) &#123; // 0.设置正在滚动 this.scrolling = true; // 1.开始滚动动画 this.swiperStyle.transition =&#x27;transform &#x27;+ this.animDuration + &#x27;ms&#x27;; this.setTransform(currentPosition); // 2.判断滚动到的位置 this.checkPosition(); // 4.滚动完成 this.scrolling = false &#125;, /** * 校验正确的位置 */ checkPosition: function () &#123; window.setTimeout(() =&gt; &#123; // 1.校验正确的位置 this.swiperStyle.transition = &#x27;0ms&#x27;; if (this.currentIndex &gt;= this.slideCount + 1) &#123; this.currentIndex = 1; this.setTransform(-this.currentIndex * this.totalWidth); &#125; else if (this.currentIndex &lt;= 0) &#123; this.currentIndex = this.slideCount; this.setTransform(-this.currentIndex * this.totalWidth); &#125; // 2.结束移动后的回调 this.$emit(&#x27;transitionEnd&#x27;, this.currentIndex-1); &#125;, this.animDuration) &#125;, /** * 设置滚动的位置 */ setTransform: function (position) &#123; this.swiperStyle.transform = `translate3d($&#123;position&#125;px, 0, 0)`; this.swiperStyle[&#x27;-webkit-transform&#x27;] = `translate3d($&#123;position&#125;px), 0, 0`; this.swiperStyle[&#x27;-ms-transform&#x27;] = `translate3d($&#123;position&#125;px), 0, 0`; &#125;, /** * 操作DOM, 在DOM前后添加Slide */ handleDom: function () &#123; // 1.获取要操作的元素 let swiperEl = document.querySelector(&#x27;.swiper&#x27;); let slidesEls = swiperEl.getElementsByClassName(&#x27;slide&#x27;); // 2.保存个数 this.slideCount = slidesEls.length; // 3.如果大于1个, 那么在前后分别添加一个slide if (this.slideCount &gt; 1) &#123; let cloneFirst = slidesEls[0].cloneNode(true); let cloneLast = slidesEls[this.slideCount - 1].cloneNode(true); swiperEl.insertBefore(cloneLast, slidesEls[0]); swiperEl.appendChild(cloneFirst); this.totalWidth = swiperEl.offsetWidth; this.swiperStyle = swiperEl.style; &#125; // 4.让swiper元素, 显示第一个(目前是显示前面添加的最后一个元素) this.setTransform(-this.totalWidth); &#125;, /** * 拖动事件的处理 */ touchStart: function (e) &#123; // 1.如果正在滚动, 不可以拖动 if (this.scrolling) return; // 2.停止定时器 this.stopTimer(); // 3.保存开始滚动的位置 this.startX = e.touches[0].pageX; &#125;, touchMove: function (e) &#123; // 1.计算出用户拖动的距离 this.currentX = e.touches[0].pageX; this.distance = this.currentX - this.startX; let currentPosition = -this.currentIndex * this.totalWidth; let moveDistance = this.distance + currentPosition; // 2.设置当前的位置 this.setTransform(moveDistance); &#125;, touchEnd: function (e) &#123; // 1.获取移动的距离 let currentMove = Math.abs(this.distance); // 2.判断最终的距离 if (this.distance === 0) &#123; return &#125; else if (this.distance &gt; 0 &amp;&amp; currentMove &gt; this.totalWidth * this.moveRatio) &#123; // 右边移动超过0.5 this.currentIndex-- &#125; else if (this.distance &lt; 0 &amp;&amp; currentMove &gt; this.totalWidth * this.moveRatio) &#123; // 向左移动超过0.5 this.currentIndex++ &#125; // 3.移动到正确的位置 this.scrollContent(-this.currentIndex * this.totalWidth); // 4.移动完成后重新开启定时器 this.startTimer(); &#125;, /** * 控制上一个, 下一个 */ previous: function () &#123; this.changeItem(-1); &#125;, next: function () &#123; this.changeItem(1); &#125;, changeItem: function (num) &#123; // 1.移除定时器 this.stopTimer(); // 2.修改index和位置 this.currentIndex += num; this.scrollContent(-this.currentIndex * this.totalWidth); // 3.添加定时器 this.startTimer(); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; #hy-swiper &#123; overflow: hidden; position: relative; &#125; .swiper &#123; display: flex; &#125; .indicator &#123; display: flex; justify-content: center; position: absolute; width: 100%; bottom: 8px; &#125; .indi-item &#123; box-sizing: border-box; width: 8px; height: 8px; border-radius: 4px; background-color: #fff; line-height: 8px; text-align: center; font-size: 12px; margin: 0 5px; &#125; .indi-item.active &#123; background-color: rgba(212,62,46,1.0); &#125;&lt;/style&gt; 1234567891011121314151617181920212223&lt;!--SwiperItem.vue--&gt;&lt;template&gt; &lt;div class=&quot;slide&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Slide&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; .slide &#123; width: 100%; flex-shrink: 0; &#125; .slide img &#123; width: 100%; &#125;&lt;/style&gt; 12345678//index.jsimport Swiper from &#x27;./Swiper&#x27;import SwiperItem from &#x27;./SwiperItem&#x27;export &#123; Swiper, SwiperItem&#125;//统一导出 （2）使用轮播图 123456789101112131415161718192021222324252627282930313233343536&lt;!--HomeSwiper.vue：用来整合Swiper和SwiperItem--&gt;&lt;template&gt; &lt;div&gt; &lt;swiper&gt; &lt;swiper-item v-for=&quot;banner in banners&quot;&gt; &lt;!--循环遍历轮播图数据--&gt; &lt;a :href=&quot;banner.link&quot;&gt; &lt;img :src=&quot;banner.image&quot; alt=&quot;&quot;/&gt; &lt;/a&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;Swiper, SwiperItem&#125; from &quot;../../../components/common/swiper/index&quot;; export default &#123; name: &quot;homeSwiper&quot;, components: &#123; Swiper, SwiperItem &#125;, props: &#123; //从父组件获取数据 banners: &#123; type: Array, default() &#123; return [] &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 1234567891011121314151617181920&lt;!--在Home.vue首页使用整合好的轮播图（适当省略内容）--&gt;&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;home-swiper :banners=&quot;banners&quot;/&gt; &lt;!--绑定参数传给子组件--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... import HomeSwiper from &quot;./childComponents/HomeSwiper&quot;; export default &#123; ... components: &#123; HomeSwiper &#125; &#125;&lt;/script&gt;... 2.4 推荐信息123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--RecommendView.vue--&gt;&lt;template&gt; &lt;div class=&quot;recommend&quot;&gt; &lt;div v-for=&quot;recommend in recommends&quot; class=&quot;recommend-item&quot;&gt; &lt;a :href=&quot;recommend.link&quot;&gt; &lt;img :src=&quot;recommend.image&quot;/&gt; &lt;div&gt;&#123;&#123;recommend.title&#125;&#125;&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;RecommendView&quot;, props: &#123; //从父组件获取数据 recommends: &#123; type: Array, default() &#123; return [] &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .recommend &#123; display: flex; /* 水平布局 */ width: 100%; padding: 5px 0 15px; /* 上下间隔 */ border-bottom: 8px solid #eee; /* 底部边框 */ &#125; .recommend-item &#123; text-align: center; &#125; .recommend-item img &#123; width: 80%; &#125;&lt;/style&gt; 1234567891011121314151617181920&lt;!--在Home.vue中使用推荐栏组件（适当省略）--&gt;&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;RecommendView :recommends=&quot;recommends&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... import RecommendView from &quot;./childComponents/RecommendView&quot;; export default &#123; ... components: &#123; RecommendView &#125; &#125;&lt;/script&gt;... 2.5 FeatureView 由于FeatureView和推荐信息制作方法几乎没有区别，就直接用图片来代替 1234567891011121314151617181920&lt;!--FeatureView.vue--&gt;&lt;template&gt; &lt;div class=&quot;feature&quot;&gt; &lt;a herf=&quot;https://act.mogujie.com/zzlx67&quot;&gt; &lt;img src=&quot;~assets/img/home/recommend_bg.jpg&quot;/&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;FeatureView&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; .feature img &#123; width: 100%; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;!--Home使用FeatureView组件，并按时解决滚动问题（适当省略）--&gt;&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;feature-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... import FeatureView from &quot;./childComponents/FeatureView&quot;; export default &#123; ... components: &#123; FeatureView &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /* 解决滚动问题 */ .home-nav &#123; ... position: fixed; /* 固定位置 */ left: 0; right: 0; top: 0; z-index: 9; &#125; #home &#123; padding-top: 44px; padding-bottom: 45px; &#125;&lt;/style&gt; 2.6 TabControl实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!--TabControl.vue--&gt;&lt;template&gt; &lt;div class=&quot;tabControl&quot;&gt; &lt;div v-for=&quot;(title, index) in titles&quot; class=&quot;tab-control-item&quot; :class=&quot;&#123;active: currentIndex === index&#125;&quot; @click=&quot;itemClick(index)&quot;&gt; &lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;TabController&quot;, props: &#123; titles: &#123; type: Array, default() &#123; return []; &#125; &#125; &#125;, data() &#123; return &#123; currentIndex: 0 &#125; &#125;, methods: &#123; itemClick(index) &#123; this.currentIndex = index; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .tabControl &#123; display: flex; text-align: center; height: 40px; line-height: 40px; background-color: #fff; &#125; .tab-control-item &#123; flex: 1; &#125; .tab-control-item span &#123; padding: 5px; &#125; .active &#123; color: var(--color-high-text); &#125; .active span &#123; border-bottom: 3px solid var(--color-tint); &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!--在首页Home.vue中使用TabControl(适当省略)--&gt;&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;tab-control class=&quot;tab-control&quot; :titles=&quot;titles&quot;/&gt; &lt;h2&gt;测试数据&lt;/h2&gt; &lt;h2&gt;测试数据&lt;/h2&gt; &lt;h2&gt;测试数据&lt;/h2&gt; &lt;h2&gt;测试数据&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... //components import TabControl from &quot;../../components/common/tabControl/TabControl&quot;; export default &#123; ... components: &#123; TabControl &#125;, data() &#123; return &#123; ... titles: [&quot;流行&quot;, &quot;新款&quot;, &quot;精选&quot;] &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ... /* 解决TabControl滚动问题 */ .tab-control &#123; position: sticky; top: 44px; &#125;&lt;/style&gt; 2.8 请求商品数据 （1）network/home.js添加新的接口请求 1234567891011121314//home.js（适当省略）import &#123;request&#125; from &quot;./request&quot;;...//请求商品数据（接口已过时）export function getHomeGoods(type, page) &#123; return request(&#123; url: &quot;/home/data&quot;, method: &quot;get&quot;, params: &#123; type: type, page: page &#125; &#125;)&#125; （2）在home.vue中接收数据并保存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//home.vue（适当省略）&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; ... //network import &#123;getHomeMultidata, getHomeGoods&#125; from &quot;network/home&quot;; export default &#123; ... data() &#123; return &#123; ... //保存货物信息数据 goods: &#123; &quot;pop&quot;: &#123;page: 0, list: []&#125;, &quot;new&quot;: &#123;page: 0, list: []&#125;, &quot;sell&quot;: &#123;page: 0, list: []&#125; &#125; &#125; &#125;, created() &#123; this.getHomeMultidata(); this.getHomeGoods(&quot;new&quot;); this.getHomeGoods(&quot;pop&quot;); this.getHomeGoods(&quot;sell&quot;); &#125;, //封装数据请求，以便复用 methods: &#123; getHomeMultidata() &#123; getHomeMultidata().then(res =&gt; &#123; console.log(res.data); this.banners = res.data.data.banner.list; this.recommends = res.data.data.recommend.list; &#125;) &#125;, //请求商品数据 getHomeGoods(type) &#123; const page = this.goods[type].page + 1; getHomeGoods(type, page).then(res =&gt; &#123; this.goods[type].list.push(...res.data.data.list); //将两个数组的数据合并为一个数组（特殊语法） this.goods[type].page += 1; //数据成功获取之后再修改页码 &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; 2.9 展示商品数据 （1）创建商品列表子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!-- GoodsListItem.vue --&gt;&lt;template&gt; &lt;div class=&quot;goodsListItem&quot;&gt; &lt;img :src=&quot;singleGoods.show.img&quot; /&gt; &lt;div class=&quot;goodsInfo&quot;&gt; &lt;p&gt;&#123;&#123;singleGoods.title&#125;&#125;&lt;/p&gt; &lt;span class=&quot;price&quot;&gt;&#123;&#123;singleGoods.price&#125;&#125;&lt;/span&gt; &lt;span class=&quot;collect&quot;&gt;&#123;&#123;singleGoods.cfav&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;GoodsListItem&quot;, props: &#123; singleGoods: &#123; type: Object, default() &#123; return null; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .goodsListItem &#123; padding-bottom: 40px; position: relative; width: 48%; &#125; .goodsListItem img &#123; width: 100%; border-radius: 5px; &#125; .goodsInfo &#123; font-size: 12px; position: absolute; bottom: 5px; left: 0; right: 0; overflow: hidden; text-align: center; &#125; .goodsInfo p &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-bottom: 3px; &#125; .goodsInfo .price &#123; color: var(--color-high-text); margin-right: 20px; &#125; .goodsInfo .collect &#123; position: relative; &#125; .goodsInfo .collect::before &#123; content: &#x27;&#x27;; position: absolute; left: -15px; top: -1px; width: 14px; height: 14px; background: url(&quot;~assets/img/common/collect.svg&quot;) 0 0/14px 14px; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- GoodsList.vue --&gt;&lt;template&gt; &lt;div class=&quot;goods&quot;&gt; &lt;goods-list-item v-for=&quot;singleGoods in goods&quot; :single-goods=&quot;singleGoods&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import GoodsListItem from &quot;./GoodsListItem&quot;; export default &#123; name: &quot;GoodsList&quot;, components: &#123; GoodsListItem &#125;, props: &#123; goods: &#123; type: Array, default() &#123; return []; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .goods &#123; display: flex; flex-wrap: wrap; justify-content: space-evenly; &#125;&lt;/style&gt; （2）在Home.vue使用商品列表组件 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;goods-list :goods=&quot;goods[type].list&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... import GoodsList from &quot;../../components/context/goods/GoodsList&quot;; export default &#123; ... name: &quot;Home&quot;, components: &#123; GoodsList &#125;, data() &#123; type: &quot;pop&quot; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ... /* 解决TabControl滚动问题 */ .tab-control &#123; position: sticky; top: 44px; z-index: 9; &#125;&lt;/style&gt; 2.10 点击切换商品列表 （1）在TabControl监听点击并发送事件给父组件 1234567891011121314151617181920&lt;!-- TabControl.vue --&gt;&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; export default &#123; ... methods: &#123; itemClick(index) &#123; this.currentIndex = index; this.$emit(&#x27;tabClick&#x27;, index); //向父组件发送事件并传参 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; （2）父组件接收参数，并修改商品列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;tab-control class=&quot;tab-control&quot; :titles=&quot;titles&quot; @tabClick=&quot;tabClick&quot;/&gt; &lt;!-- 接收发送事件 --&gt; &lt;goods-list :goods=&quot;goods[type].list&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... export default &#123; data() &#123; //保存网络请求的数据 return &#123; goods: &#123; &quot;pop&quot;: &#123;page: 0, list: []&#125;, &quot;new&quot;: &#123;page: 0, list: []&#125;, &quot;sell&quot;: &#123;page: 0, list: []&#125; &#125;, type: &quot;pop&quot; //决定商品类型 &#125; &#125;, methods: &#123; /** * 事件监听相关方法 */ tabClick(index) &#123; switch (index) &#123; //根据参数决定商品类型 case 0: this.type = &quot;pop&quot;; break; case 1: this.type = &quot;new&quot;; break; case 2: this.type = &quot;sell&quot;; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; 三、知识补充：Better-Scroll 由于原生代码实现的滚动在项目部署的时候会比较卡，所以引入第三方框架来实现滚动（听说，还没实际部署过） 官方文档：https://github.com/ustbhuangyi/better-scroll/blob/master/README_zh-CN.md 3.1 Better-Scroll安装 npm run better-scroll --save 3.2 实现局部滚动1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;roll&quot;&gt; ...滚动内容 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import BS from &#x27;better-scroll&#x27;; export default &#123; name: &quot;Category&quot;, mounted() &#123; new BS(&#x27;.wrapper&#x27;, &#123;&#125;); //创建BetterScroll对象 &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /* 原生CSS实现局部滚动 */ /* .roll &#123; height: 200px; background-color: aliceblue; overflow-y: scroll; &#125; */ /* 使用Better-scroll实现局部滚动 */ .wrapper &#123; height: 200px; background-color: aliceblue; overflow: hidden; &#125;&lt;/style&gt; 3.3 Better-Scroll参数12345678910111213141516const bs = new BS(&#x27;.wrapper&#x27;, &#123; probeType: 3, //0, 1都不实时侦测，2监听手指移动的位置，离开后不监听，3只要滚动，都侦测 pullUpLoad: true, //开启上拉加载&#125;);//默认情况下，BetterScroll不能实时监听，需要在创建时设置额外参数//监听：类型(滚动)bs.on(&#x27;scroll&#x27;, (position) =&gt; &#123; console.log(position);&#125;)//监听：类型(上拉加载)bs.on(&quot;pullingUp&quot;, () =&gt; &#123; console.log(&quot;上拉加载更多&quot;); bs.finishPullUp(); //支持多次上拉加载&#125;) 3.4 Better-Scroll封装和使用 （1）将Better-Scroll封装成一个组件，利用插槽选择要滚动的内容 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;wrapper&quot; ref=&quot;wrapper&quot;&gt; &lt;!--用ref标签引用标签元素更准确--&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import BScroll from &quot;better-scroll&quot;; export default &#123; name: &quot;Scroll&quot;, data() &#123; return &#123; bScroll: null &#125; &#125;, mounted() &#123; this.bScroll = new BScroll(this.$refs.wrapper, &#123; click: true, //解决作为子组件使用后按钮无法点击 observeDOM: true //解决作为子组件使用后无法滚动 &#125;); &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; （2）使用封装后的组件，以项目的Home.vue为例1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;Scroll class=&quot;roll&quot;&gt; &lt;!-- 使用better-scroll组件 --&gt; &lt;home-swiper :banners=&quot;banners&quot;/&gt; &lt;RecommendView :recommends=&quot;recommends&quot;/&gt; &lt;feature-view /&gt; &lt;tab-control class=&quot;tab-control&quot; :titles=&quot;titles&quot; @tabClick=&quot;tabClick&quot;/&gt; &lt;goods-list :goods=&quot;goods[type].list&quot;/&gt; &lt;/Scroll&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... import Scroll from &quot;../../components/common/scroll/Scroll&quot;; export default &#123; name: &quot;Home&quot;, components: &#123; Scroll &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ... #home &#123; padding-top: 44px; height: 100vh; /* 视口高度 */ &#125; .roll &#123; padding-top: 44px; height: calc(100% - 49px); overflow: hidden; &#125;&lt;/style&gt; 四、首页开发·续4.1 BackTop：返回顶部 （1）创建BackTop.vue组件 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=&quot;back-top&quot;&gt; &lt;img src=&quot;../../../assets/img/common/top.png&quot; /&gt; &lt;!--只是使用了一张图片--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;BackTop&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; .back-top &#123; position: fixed; right: 10px; bottom: 55px; &#125; .back-top img &#123; width: 43px; height: 43px; &#125;&lt;/style&gt; （2）首页Home.vue使用组件，并监听点击，返回顶部 1234567891011121314151617181920212223242526272829&lt;!-- Home.vue --&gt;&lt;template&gt; &lt;div id=&quot;home&quot;&gt; 。。。 &lt;BackTop @click.native=&quot;backClick&quot;/&gt; &lt;!--监听组件点击(原生事件)要使用.native修饰，才能进行监听--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; 。。。 import BackTop from &quot;../../components/common/backTop/BackTop&quot;; export default &#123; 。。。 components: &#123; BackTop &#125;, methods: &#123; backClick() &#123; // this.$refs.scroll.bScroll.scrollTo(0, 0, 1000); // scrollTo(x, y, rollTime)：滚动到指定位置 this.$refs.scroll.scrollTo(0, 0, 1000); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; 。。。&lt;/style&gt; 12345678910111213141516171819&lt;template&gt; 。。。&lt;/template&gt;&lt;script&gt; 。。。 export default &#123; methods: &#123; //封装scrollTo方法，方便父组件调用 scrollTo(x, y, time=1000) &#123; this.bScroll.scrollTo(x, y, time); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; （3）监听滚动的位置，来决定是否显示BackTop 123456789101112131415161718192021222324252627282930313233&lt;!-- Scroll.vue --&gt;&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; import BScroll from &quot;better-scroll&quot;; export default &#123; ... props: &#123; probeType: &#123; //为了更好的封装性，由父组件决定监听滚动类型 type: Number, default() &#123; return 0; &#125; &#125; &#125; mounted() &#123; this.bScroll = new BScroll(this.$refs.wrapper, &#123; ... probeType: this.probeType //监听滚动位置 &#125;); this.bScroll.on(&#x27;scroll&#x27;, position =&gt; &#123; this.$emit(&#x27;scrollPosition&#x27;, position); //向父组件返回事件，并传递位置参数 &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;Scroll class=&quot;roll&quot; ref=&quot;scroll&quot; :probe-type=&quot;3&quot; @scrollPosition=&quot;contentScroll&quot;&gt; &lt;!--传参，并接受事件--&gt; ... &lt;/Scroll&gt; &lt;BackTop @click.native=&quot;backClick&quot; v-show=&quot;isShowBackTop&quot;/&gt; &lt;!--v-show决定显示--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... export default &#123; ... data() &#123; //保存网络请求的数据 return &#123; ... isShowBackTop: false &#125; &#125; methods: &#123; //接受子组件发送的事件，根据位置，决定是否显示 contentScroll(position) &#123; this.isShowBackTop = position.y &lt; -1000 ? true : false; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; 4.2 实现上拉加载更多功能 （1）基本实现 1234567891011121314151617181920212223242526272829303132333435&lt;!-- Scroll.vue --&gt;&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; ... export default &#123; ... props: &#123; ... pullUpLoad: &#123; type: Boolean, default() &#123; return false; &#125; &#125; &#125;, mounted() &#123; this.bScroll = new BScroll(this.$refs.wrapper, &#123; ... pullUpLoad: this.pullUpLoad //是否监听上拉加载 &#125;); ... //监听上拉事件 this.bScroll.on(&#x27;pullingUp&#x27;, () =&gt; &#123; this.$emit(&#x27;pullingUp&#x27;); this.bScroll.finishPullUp(); //支持多次加载更多 &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- Home.vue --&gt;&lt;template&gt; &lt;div id=&quot;home&quot;&gt; ... &lt;Scroll class=&quot;roll&quot; ref=&quot;scroll&quot; :probe-type=&quot;3&quot; :pull-up-load=&quot;true&quot; @scrollPosition=&quot;contentScroll&quot; @pullingUp=&quot;loadMore&quot;&gt; ... &lt;/Scroll&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ... export default &#123; ... methods: &#123; ... getHomeGoods(type) &#123; const page = this.goods[type].page + 1; getHomeGoods(type, page).then(res =&gt; &#123; this.goods[type].list.push(...res.data.data.list); //将两个数组的数据合并为一个数组（特殊语法） this.goods[type].page += 1; //数据成功获取之后再修改页码 &#125;) &#125;, loadMore() &#123; this.getHomeGoods(this.type); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; （2）解决上拉加载滑动区域bug bug出现的原因：Better-Scroll在加载数据时会计可滑动的区域大小，但图片加载可能有点慢，在Better-Scroll计算完后还没有加载完，导致超出可滑动区域 12345678910111213141516171819202122232425262728// main.js：利用事件总线解决组件联系跨度大...Vue.prototype.$bus = new Vue(); //创建一个全局变量（事件总线）...``` ```html&lt;!-- GoodListItem.vue 监听图片加载完成 --&gt;&lt;template&gt; &lt;div class=&quot;goodsListItem&quot;&gt; &lt;img :src=&quot;singleGoods.show.img&quot; @load=&quot;imageLoad&quot;/&gt; &lt;!--监听加载--&gt; ... &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; ... methods: &#123; imageLoad() &#123; this.$bus.$emit(&#x27;itemImageLoad&#x27;); //利用事件总线发送事件 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; 123456789101112131415161718192021222324&lt;!-- Home.vue：接受事件总线事件，并刷新Better-Scroll重新计算可滑动高度 --&gt;&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; ... export default &#123; ... mounted() &#123; //接收图片加载完成事件 this.$bus.$on(&quot;itemImageLoad&quot;, () =&gt; &#123; // if(this.$refs.scroll) &#123; // this.$refs.scroll.refresh(); // &#125; this.$refs.scroll &amp;&amp; this.$refs.scroll.refresh(); //利用短路与实现简单判断，如果前面对象为null，会判断为false，就不执行后面方法 &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...&lt;/style&gt; 1234567891011121314151617181920212223&lt;!-- Scroll.vue：封装refresh()方法，并解决空指针错误 --&gt;&lt;template&gt; ...&lt;/template&gt;&lt;script&gt; ... export default &#123; ... methods: &#123; ... //封装refresh()方法，方便父组件调用 refresh() &#123; this.bScroll &amp;&amp; this.bScroll.refresh(); //利用短路与实现简单判断 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; （3）解决刷新Better-Scroll频率过高","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】Axios","slug":"【Vue】Axios","date":"2020-12-07T13:02:19.000Z","updated":"2020-12-07T13:06:09.311Z","comments":true,"path":"2020/12/07/【Vue】Axios/","link":"","permalink":"https://letere-gzj.github.io/2020/12/07/%E3%80%90Vue%E3%80%91Axios/","excerpt":"Vue官方推荐使用的网络异步请求框架","text":"Vue官方推荐使用的网络异步请求框架 一、axios框架基本使用1.1 axios请求方式123456789101112131415axios(config)axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, config])axios.put(url[, config])axios.patch(url[, config]) 1.2 axios框架安装vue-cli项目运行npm install axios -save 1.3 基本使用12345678910111213//在main.js中测试...//框架导入import axios from &quot;axios&quot;;...//请求方式一axios(&#123; url: &quot;http://123.207.32.32:8000/home/multidata&quot;, //此接口已经在后端解决跨域问题了，所以暂时不用思考跨域问题 method: &quot;get&quot;&#125;).then(res =&gt; &#123; console.log(res);&#125;) 123456//请求方式二axios.get(&quot;http://123.207.32.32:8000/home/multidata&quot;, &#123; //配置内容&#125;).then(res =&gt; &#123; console.log(res);&#125;) 1234567891011//请求带参数axios(&#123; url: &quot;http://123.207.32.32:8000/home/data&quot;, method: &quot;get&quot;, params: &#123; type: &quot;sell&quot;, page: 1 &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;) 二、axios实现并发请求之前在学Promise中了解多了并发请求的解决方法，axios也有属于自己的并发请求解决操作 1234567891011121314151617//发送并发请求，利用axios.all静态方法axios.all([ axios(&#123; //请求1 url: &quot;http://123.207.32.32:8000/home/multidata&quot; &#125;), axios(&#123; //请求2 url: &quot;http://123.207.32.32:8000/home/data&quot;, params: &#123; type: &quot;sell&quot;, page: 1 &#125; &#125;)]).then(res =&gt; &#123; //返回的是一个数组 console.log(res[0]); console.log(res[1]);&#125;) 补充：axios.spread静态方法 123456axios.all([ ...]).then(axios.spread((res1, res2) =&gt; &#123; //axios.spread自动展开数组 console.log(res1); console.log(res2);&#125;)) 三、axios配置3.1 全局配置12345678axios(&#123; baseURL: &quot;http://123.207.32.32:8000&quot;, //常用参数 url: &quot;/home/multidata&quot;, method: &quot;get&quot;, timeout: 5 //常用参数&#125;).then(res =&gt; &#123; console.log(res);&#125;) 像上面例子，baseURL和timeout参数是非常常用的，可以将这些参数抽取出来，变成全局配置，每个axios请求自带这些参数 1234567891011//全局配置实例//利用axios.defaults来设置全局配置axios.defaults.baseURL = &quot;http://123.207.32.32:8000&quot;;axios.defaults.timeout = 5000;axios(&#123; url: &quot;/home/multidata&quot;, method: &quot;get&quot;&#125;).then(res =&gt; &#123; console.log(res);&#125;) 3.2 常见的配置选项1234567891011121314151617181920212223242526272829303132333435363738394041//请求地址 url: &quot;/xx/xx/xx&quot;//请求类型 method: &quot;get&quot;//请求根路径 baseURL: &quot;http://xxx.com&quot;//请求前数据处理 transformRequest: [function(data) &#123;&#125;]//请求后数据处理 transformResponse: [function(data) &#123;&#125;]//自定义请求头 headers: &#123;&#x27;x-Requested-With&#x27;:&#x27;XMLHttpREquest&#x27;&#125;//URL查询对象 params: &#123;id: 12&#125;//查询对象序列化函数 paramsSerializer: function(params) &#123;&#125;//request body(post请求参数存放位置) data: &#123;key: value&#125;//超时设置 timeout: 1000//跨域是否带Token withCredentials: false//自定义请求处理 adapter: function(resolve, reject, config)//身份验证信息 auth: &#123;username: &quot;&quot;, pwd: &quot;123456&quot;&#125;//响应的数据格式 responseType: &quot;json&quot; 四、axios实例在分布式项目中，不是每个请求都是请求同一个服务器，这样导致而配置了全局默认配置baseURL写死了，不能切换服务器，这时候要考虑创建一个单独的实例，每个实例有自己对应的服务器 123456789101112131415161718192021222324//创建单独的axios实例const axiosInstance = axios.create(&#123; //利用create方式创建实例，里面的参数为全局默认配置 baseURL: &quot;http://123.207.32.32:8000&quot;, timeout: 5000&#125;);//之前的请求以实例的方式实现axiosInstance(&#123; url: &quot;/home/multidata&quot;, method: &quot;get&quot;&#125;).then(res =&gt; &#123; console.log(res);&#125;)axiosInstance(&#123; url: &quot;/home/data&quot;, method: &quot;get&quot;, params: &#123; type: &quot;cell&quot;, page: 1 &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;) 五、axios模块化封装在开发中，利用第三方框架时，我们要有意识对框架进行封装，不要每个组件都导入框架，使用框架。这样会导致对此框架的依赖十分严重，一旦此框架不再维护或者出现巨大bug时候，会导致每一个组件都要进行修改，十分蛋疼，所有要对框架进行封装解决，避免出现此问题 5.1 封装方式一 新建一个文件夹network，存放axios相关的js文件。新建一个request.js文件，里面存放主要的请求代码 传递三个参数，利用回调函数的方式来执行请求后的相关代码 1234567891011121314151617//request.jsimport axios from &quot;axios&quot;;export function request(config, success, failure) &#123; //1.创建axios实例 const instance = axios.create(&#123; baseURL: &quot;http://123.207.32.32:8000&quot;, timeout: 5000 &#125;); //2.发送网络请求 instance(config).then(res =&gt; &#123; success(res); //成功，失败都回调函数 &#125;).catch(err =&gt; &#123; failure(err); &#125;)&#125; 12345678910//使用方法import &#123;request&#125; from &quot;./network/request&quot;;request(&#123; url: &quot;/home/multidata&quot;, method: &quot;get&quot;&#125;,res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err);&#125;); 5.2 封装方式二 对回调函数，封装在一个参数中 123456789101112131415//request.jsimport axios from &quot;axios&quot;;export function request2(config) &#123; const instance = axios.create(&#123; baseURL: &quot;http://123.207.32.32:8000&quot;, timeout: 5000 &#125;); instance(config.baseConfig).then(res =&gt; &#123; config.success(res); &#125;).catch(err =&gt; &#123; config.failure(err); &#125;)&#125; 1234567891011121314//使用方法import &#123;request2&#125; from &quot;./network/request&quot;;request2(&#123; baseConfig: &#123; url: &quot;/home/multidata&quot;, method: &quot;get&quot; &#125;, success(res) &#123; console.log(res); &#125;, failure(err) &#123; console.log(err); &#125;&#125;) 5.3 封装方式三 封装成一个promise对象进行返回，使用方法变得和axios原生方式相似 1234567891011121314151617//request.jsimport axios from &quot;axios&quot;;export function request3(config) &#123; return new Promise((resolve, reject) =&gt; &#123; const instance = axios.create(&#123; baseURL: &quot;http://123.207.32.32:8000&quot;, timeout: 5000 &#125;); instance(config).then(res =&gt; &#123; resolve(res); &#125;).catch(err =&gt; &#123; reject(err); &#125;) &#125;)&#125; 12345678910//使用方法import &#123;request3&#125; from &quot;./network/request&quot;;request3(&#123; url: &quot;/home/multidata&quot;, method: &quot;get&quot;&#125;).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 5.4 封装方式四（推荐） 由于axios的实例对象本身就是一个Promise对象，所以没有必要封装到一个Promise对象中进行返回，直接返回一个axios实例对象 使用方法和方式三一样 1234567891011//request.jsimport axios from &quot;axios&quot;;export function request4(config) &#123; const instance = axios.create(&#123; baseURL: &quot;http://123.207.32.32:8000&quot;, timeout: 5000 &#125;); return instance(config)&#125; 六、拦截器6.1 请求拦截12345678910111213141516171819const instance = axios.create(&#123; baseURL: &quot;http://123.207.32.32:8000&quot;, timeout: 5000&#125;);//拦截请求instance.interceptors.request.use(config =&gt; &#123; //拦截下来的是一些配置信息 console.log(&quot;请求拦截成功！&quot;); return config; //拦截完后记得放行&#125;, err =&gt; &#123; console.log(&quot;请求拦截失败！&quot;)&#125;); /* 请求拦截使用场景： （1）config中一些信息不符合服务器需求，进行修改 （2）请求过程中，显示一些加载画面 （3）某些网络请求，必须携带一特殊的信息 */ 6.2 响应拦截1234567//拦截响应 instance.interceptors.response.use(res =&gt; &#123; console.log(&quot;响应拦截成功！&quot;); return res; //拦截完后记得放行 &#125;, err =&gt; &#123; console.log(&quot;响应拦截失败！&quot;); &#125;);","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】Vuex","slug":"【Vue】Vuex","date":"2020-12-06T15:43:07.000Z","updated":"2020-12-07T13:01:39.894Z","comments":true,"path":"2020/12/06/【Vue】Vuex/","link":"","permalink":"https://letere-gzj.github.io/2020/12/06/%E3%80%90Vue%E3%80%91Vuex/","excerpt":"Vuex为Vue的一个状态管理插件，用于管理不同组建的同一状态","text":"Vuex为Vue的一个状态管理插件，用于管理不同组建的同一状态 一、认识Vuex1.1 简单介绍 Vuex是专门为Vue.js应用程序开发的状态管理工具 状态管理可以简单认为是一组变量，用来存储状态 使用共享的状态情况 例如：用户的登录状态，用户的名称，头像，地理位置等等。 例如：商品的收藏，购物车的物品 二、单页面到多页面状态管理切换2.1 单页面状态管理 拿一个计数器作为例子来介绍单页面 2.2 多页面状态管理 使用Vuex来管理计算器的counter变量 （1）安装Vuex npm install Vuex --save （2）配置Vuex 创建一个新的文件夹store，在里面创建index.js来配置Vuex 123456789101112131415161718192021222324252627import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;//1.插件安装Vue.use(Vuex);//2.创建Vuex对象const store = new Vuex.Store(&#123; state: &#123; counter: 100, &#125;,//保存状态 mutations: &#123; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;);//3.导出storeexport default store; （3）main.js挂载Vuex的配置 1234567...import store from &quot;./store&quot;; //导入Storenew Vue(&#123; ... store //挂载Store&#125;) （4）使用Vuex管理的状态(变量) 123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;$store.state.counter++&quot;&gt;+&lt;/button&gt; &lt;!--此方法修改状态，官方并不推荐--&gt; &lt;button @click=&quot;$store.state.counter--&quot;&gt;-&lt;/button&gt; &lt;!--因为当多个页面修改此变量时，无法追踪是哪个页面进行修改--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ...&lt;/script&gt;&lt;style&gt; ...&lt;/style&gt; 三、Vuex的状态修改 官方推荐通过修改actions来操作mutations，再通过mutations来修改state 当然，官方也推荐直接操作mutations，actions操作只是支持异步操作，mutations是同步操作 为了追踪状态的修改，官方提供浏览器插件devtools来进行追踪 3.1 devtools安装和使用 （1）安装 （2）使用 3.2 使用mutations修改状态123456789101112131415161718// ./store/index.js...const store = new Vuex.Store(&#123; state: &#123; counter: 100, &#125;,//保存状态 mutations: &#123; //方法 increment(state) &#123; state.counter++; &#125;, decrement(state) &#123; state.counter--; &#125; &#125;&#125;);... 123456789&lt;!--使用mutations方法--&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;$store.commit(&#x27;increment&#x27;)&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.commit(&#x27;decrement&#x27;)&quot;&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;... 四、Vuex的核心概念4.1 State 单一状态树：单一数据源，即无论表示状态的数据有多少，都放在同一个store对象中，不允许创建新的store来分类存放其他状态 4.2 Getters getters使用方法类似于Vue的计算属性，对数据进行一定操作后返回 （1）基本使用 123456789101112//Vuex配置文件const store = new Vuex.Store(&#123; ... state: &#123; counter: 100, &#125;, getters: &#123; x2Counter(state) &#123; return state.counter * 2; &#125; &#125;&#125;); 123456&lt;!--页面使用--&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;&quot;x2：&quot; + $store.getters.x2Counter&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt; （2）进阶使用 12345678910111213141516171819202122//Vue配置文件const store = new Vuex.Store(&#123; state: &#123; counter: 100, &#125; getters: &#123; x2Counter(state) &#123; return state.counter * 2; &#125;, x4Counter(state, getters)&#123; //支持两个参数，参数2可以为getter，直接调用属性 return getters.x2Counter * 2; &#125;, xNCounter(state)&#123; //支持返回函数 return function (n) &#123; return state.counter * n; &#125; // return n =&gt; state.counter * n; 箭头函数 &#125; &#125;&#125;); 1234567&lt;!--页面使用--&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;&quot;x4：&quot; + $store.getters.x4Counter&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;&quot;xN：&quot; + $store.getters.xNCounter(8)&#125;&#125;&lt;/h2&gt; &lt;!--相当于 8 =&gt; state.counter * 8--&gt; &lt;/div&gt;&lt;/template&gt; 4.3 Mutation （1）mutation传递参数 1234567891011121314//修改Vuex配置文件...const store = new Vuex.Store(&#123; state: &#123; counter: 100, &#125;, mutations: &#123; customIncrement(state, n)&#123; //mutation可以接收参数 state.counter += n; &#125; &#125; ...&#125;);... 1234567&lt;!--页面使用--&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;$store.commit(&#x27;customIncrement&#x27;, 5)&quot;&gt;+5&lt;/button&gt; &lt;!--传递的参数为payload，称为负载--&gt; &lt;/div&gt;&lt;/template&gt; （2）mutation另一种提交风格 12345678910111213...const store = new Vuex.Store(&#123; state: &#123; counter: 100, &#125;, mutations: &#123; customIncrement2(state, payload)&#123; state.counter += payload.n; &#125; &#125; ...&#125;);... 123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;$store.commit(&#123;type: &#x27;customIncrement2&#x27;, n: 10&#125;)&quot;&gt;+10&lt;/button&gt; &lt;!--另一种提交风格，直接提交一个对象--&gt; &lt;/div&gt;&lt;/template&gt; （3）mutation响应规则 （4）mutation的类型常量 为了组件中使用mutation方法时不写错，可以定义一个常量来保存方法名，然后倒入此常量进行调用 类似Java的枚举类 1234//新建一个mutation-type.js文件来定义常量export const INCREMENT = &quot;increment&quot;;export const DECREMENT = &quot;decrement&quot;;export const CUSTOMINCREMENT = &quot;customIncrement&quot;; 123456789101112131415&lt;!-- 导入mutation-types.js文件，使用常量 --&gt;&lt;script&gt; ... import &#123;INCREMENT, DECREMENT, CUSTOMINCREMENT&#125; from &quot;./store/mutation-types&quot;; export default &#123; ... methods: &#123; increment() &#123; // this.$store.commit(&#x27;increment&#x27;); this.$store.commit(INCREMENT); //直接使用常量 &#125; &#125; &#125;&lt;/script&gt; 1234567891011121314151617//为了统一使用常量来替换，修改./store/index.jsimport &#123;INCREMENT, DECREMENT, CUSTOMINCREMENT&#125; from &quot;./store/mutation-types&quot;;...const store = new Vuex.Store(&#123; ... mutations: &#123; /* increment(state) &#123; state.counter++; &#125; */ [INCREMENT](state) &#123; state.counter++; &#125; &#125;&#125;); 4.4 Actions actions是类似mutation，但是用来代替mutation来实现异步操作 （1）基本使用 1234567891011121314151617//在Vuex配置文件中配置actionsconst store = new Vuex.Store(&#123; ... mutations: &#123; updateInfo(state)&#123; this.state.info.name = &quot;C酱&quot;; &#125; &#125;, actions: &#123; aUpdateInfo(context) &#123; //参数不是state，是context，大概理解context为store对象 setTimeout(() =&gt; &#123; context.commit(&#x27;updateInfo&#x27;); //异步操作中修改数据要使用mutation进行修改 &#125;, 1000) &#125; &#125;&#125;); 123456789101112&lt;!--页面使用actions方法--&gt;&lt;script&gt; ... export default &#123; ... methods: &#123; updateInfo() &#123; this.$store.dispatch(&#x27;aUpdateInfo&#x27;); //使用actions方法，用dispatch &#125; &#125; &#125;&lt;/script&gt; （2）支持参数传递 1234567891011121314151617const store = new Vuex.Store(&#123; ... mutations: &#123; updateInfo(state)&#123; this.state.info.name = &quot;C酱&quot;; &#125; &#125;, actions: &#123; aUpdateInfo2(context, payload)&#123; //支持带参 setTimeout(() =&gt; &#123; context.commit(&#x27;updateInfo&#x27;); console.log(payload); &#125;, 1000) &#125; &#125;&#125;); 1234567891011&lt;script&gt; ... export default &#123; ... methods: &#123; updateInfo2() &#123; this.$store.dispatch(&#x27;aUpdateInfo2&#x27;, &quot;我是payLoad!&quot;); //参数传递类似于mutation &#125; &#125; &#125;&lt;/script&gt; （3）进阶使用 12345678910111213141516171819202122const store = new Vuex.Store(&#123; ... mutations: &#123; updateInfo(state)&#123; this.state.info.name = &quot;C酱&quot;; &#125; &#125;, actions: &#123; aUpdateInfo3(context, payload)&#123; //后台处理数据，完成后前台打印信息提示已完成 //方法一：可以playload传递函数，数据处理完成时，回调函数，前台会打印信息 //方法二：actions支持返回值，可以返回一个Promise对象 setTimeout(() =&gt; &#123; context.commit(&#x27;updateInfo&#x27;); return new Promise(resolve =&gt; &#123; console.log(payload); &#125;) //可以在这里直接.then()，也可以去前台使用then() &#125;) &#125; &#125;&#125;); 12345678910111213&lt;script&gt; ... export default &#123; ... methods: &#123; updateInfo3() &#123; this.$store.dispatch(&#x27;aUpdateInfo3&#x27;, &quot;我是前台消息&quot;).then(() =&gt; &#123; console.log(&quot;前台打印：处理已完成！&quot;) &#125;) &#125; &#125; &#125;&lt;/script&gt; 4.5 Modules 因为Vuex要求使用单一状态树，会导致state会变得很臃肿，所以可以在modules中设置store对象，进行进一步细分 1234567891011121314151617181920212223242526272829303132333435//在Vuex的配置文件中配置const a = &#123; state: &#123; name: &quot;C酱&quot; &#125;, mutations: &#123; changeName(state) &#123; state.name = &quot;莱特雷&quot;; &#125; &#125;, actions: &#123; aChangeName(context) &#123; setTimeout(() =&gt; &#123; context.commit(&#x27;changeName&#x27;); &#125;, 1000) &#125; &#125;, getters: &#123; fullName(state) &#123; return &quot;秃头&quot; + state.name; &#125;, connect(state, getters, rootState)&#123; //在modules中的getters支持三个参数 return getters.fullName + &quot; plus &quot; + rootState.info.name; &#125; &#125;&#125;//2.创建Vuex对象const store = new Vuex.Store(&#123; ... modules: &#123; a &#125;&#125;); 1234567891011&lt;!--在页面中使用--&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- Modules使用--&gt; &lt;h2&gt;----- Modules使用 -----&lt;/h2&gt; &lt;h3&gt;&#123;&#123;$store.state.a.name&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;$store.commit(&#x27;changeName&#x27;)&quot;&gt;mutations使用&lt;/button&gt; &lt;button @click=&quot;$store.dispatch(&#x27;aChangeName&#x27;)&quot;&gt;actions使用&lt;/button&gt; &lt;h3&gt;&#123;&#123;$store.getters.connect + &#x27;(getters使用)&#x27;&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 五、Vuex的目录结构将Vuex中的参数提取出来，放在单独的文件中，方便管理 六、ES6语法补充：解构6.1 对象解构 将一个对象里面的变量提取出来，作为一个新的变量12345678910111213141516//ES6语法补充：对象解构const obj = &#123; name: &quot;莱特雷&quot;, age: 18, sex: &quot;男&quot;&#125;//普通方法/*const name = obj.name;const age = obj.age;const sex = obj.sex; *///ES6语法const &#123;name, age, sex&#125; = obj; //里面变量顺序可随意，赋值按照变量名并不是顺序 6.2 数组解构 将数组中的元素提取出来，作为一个单独的新变量123456789101112//ES6语法补充：数组解构const names = [&quot;莱特雷&quot;, &quot;C酱&quot;, &quot;咕料&quot;];//普通方法/*const name1 = names[0];const name2 = name[1];const name3 = name[2]; *///ES6语法const [name1, name2, name3] = names;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】Promise","slug":"【Vue】Promise","date":"2020-12-06T15:38:55.000Z","updated":"2020-12-06T15:41:03.206Z","comments":true,"path":"2020/12/06/【Vue】Promise/","link":"","permalink":"https://letere-gzj.github.io/2020/12/06/%E3%80%90Vue%E3%80%91Promise/","excerpt":"多重异步操作的优雅写法，为axios框架铺垫基础","text":"多重异步操作的优雅写法，为axios框架铺垫基础 一、Promise的介绍和基本使用1.1 什么是Promise Promise是ES6中非常重要且非常好用的特性 Promise是异步编程的一种解决方案，对异步操作变得优雅 异步操作一般用于网络请求 1.2 Promise基本使用1234567//简单的异步操作setTimeout(() =&gt; &#123; console.log(&quot;Hello Vue!&quot;); setTimeout(() =&gt; &#123; console.log(&quot;Hello Promise!&quot;) &#125;, 1000);&#125;, 1000); 将上面的异步操作使用Promise进行封装 123456789101112131415161718192021222324/* 使用Promise封装异步操作* new Promise(函数) --&gt; 函数：(resolve, reject) =&gt; &#123;异步操作&#125;* resolve 和 reject本身又是函数* 使用方式为链式编程*/new Promise((resolve, reject) =&gt; &#123; //第一次网络请求 setTimeout(() =&gt; &#123; resolve(); &#125;, 1000);&#125;).then(() =&gt; &#123; //第一次网络请求的处理结果 console.log(&quot;Hello Vue!&quot;); return new Promise((resolve, reject) =&gt; &#123; //第二次网络请求 setTimeout(() =&gt; &#123; resolve() &#125;, 1000); &#125;);&#125;).then(() =&gt; &#123; //第二次网络请求的处理结果 console.log(&quot;Hello Promise!&quot;);&#125;); 1.3 resolve和reject使用1234567891011121314// resolve 和 reject 的使用// resolve：解析， reject：拒绝//没有出错就进行解析，出现错误就拒绝new Promise((resolve, reject) =&gt; &#123; if(true) &#123; resolve(&quot;成功调用哦！&quot;); &#125;else &#123; reject(&quot;调用失败！&quot;); &#125;;&#125;).then((success) =&gt; &#123; //resolve执行此方法 console.log(success);&#125;).catch((error) =&gt; &#123; //reject执行此方法 console.log(error);&#125;) 二、Promise基本使用补充2.1 Promise三种状态 pending：等待状态，比如正在进行网络请求，或者定时器没有到时间 fulfill：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then() reject：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch() 2.2 resolve和reject的另一种写法123456789101112//resolve和reject的另一种写法new Promise((resolve, reject) =&gt; &#123; if(true) &#123; resolve(&quot;成功调用哦！&quot;); &#125;else &#123; reject(&quot;调用失败！&quot;); &#125;;&#125;).then(success =&gt; &#123; //then可以直接传入两个函数，参数1为resolve调用，参数2为reject调用 console.log(success);&#125;, error =&gt; &#123; console.log(error);&#125;); 三、Promise的链式调用3.1 基本实现例子12345678910111213141516//需求：第一个异步操作后，再进行拼接字符new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, 1000);&#125;).then(() =&gt; &#123; const data = &quot;Hello&quot;; //假设还有其他异步代码 return new Promise(resolve =&gt; &#123; resolve(data); &#125;);&#125;).then(data =&gt; &#123; data = data + &quot; Promise!&quot;; //拼接字符串 console.log(data);&#125;); 3.2 使用Promise静态方法123456789101112131415//但是拼接字符串的操作并没有进行异步使用，不太需要创建一个新的Promise对象//Promise提供方法进行调用new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, 1000);&#125;).then(() =&gt; &#123; const data = &quot;Hello&quot;; //假设还有其他异步代码 return Promise.resolve(data); //直接调用静态方法resolve()&#125;).then(data =&gt; &#123; data = data + &quot; Promise!&quot;; //拼接字符串 console.log(data);&#125;); 3.3 最终简化1234567891011121314//Promise官方还支持更加简洁的写法new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(); &#125;, 1000);&#125;).then(() =&gt; &#123; const data = &quot;Hello&quot;; //假设还有其他异步代码 return data; //直接返回字符串&#125;).then(data =&gt; &#123; data = data + &quot; Promise!&quot;; //拼接字符串 console.log(data);&#125;); 3.4 reject简化 reject的简化和resolve基本一样 12345//（1）Promise.reject(&quot;使用静态方法&quot;)//（2）等同于resolve的 return 字符串;throw &quot;手动抛出异常！&quot; 四、all方法需求：一个处理需要发送两个请求才能开始处理 4.1 普通方法实现1234567891011121314151617181920212223242526let resulet1 = false; //定义变量判断请求完成状态let resulet2 = false;$.ajax(&#123; url: &quot;url1&quot;, success: function (data) &#123; console.log(&quot;结果一&quot;); resulet1 = true; handle(); //由于网络请求不确定谁快谁慢，所以两个请求都追加处理方法 &#125;&#125;);$.ajax(&#123; url: &quot;url2&quot;, success(data) &#123; console.log(&quot;结果二&quot;); resulet2 = true; handle(); &#125;&#125;)function handle() &#123; if (resulet1 &amp;&amp; resulet2)&#123; console.log(&quot;结果已处理！&quot;) &#125;&#125; 4.2 使用Promise实现1234567891011121314151617181920212223242526//用promise的all方法解决两个请求同时处理的问题//all方法传递一个数组，数组内容为异步操作Promise.all([ new Promise(resolve =&gt; &#123; $.ajax(&#123; url: &quot;url1&quot;, success(data)&#123; console.log(&quot;结果一&quot;); resolve(data) &#125; &#125;) &#125;), new Promise(resolve =&gt; &#123; $.ajax(&#123; url: &quot;url1&quot;, success(data)&#123; console.log(&quot;结果2&quot;); resolve(data) &#125; &#125;) &#125;)]).then(result =&gt; &#123; console.log(result); console.log(&quot;结果已处理&quot;)&#125;) &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】前端路由小实例：Tabbar","slug":"【Vue】前端路由小实例：Tabbar","date":"2020-12-06T15:35:10.000Z","updated":"2020-12-06T15:36:48.583Z","comments":true,"path":"2020/12/06/【Vue】前端路由小实例：Tabbar/","link":"","permalink":"https://letere-gzj.github.io/2020/12/06/%E3%80%90Vue%E3%80%91%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%B0%8F%E5%AE%9E%E4%BE%8B%EF%BC%9ATabbar/","excerpt":"前端路由实例练手：Tabber功能实现","text":"前端路由实例练手：Tabber功能实现 一、基础框架实现1.1 目录结构 1.2 代码内容12345/* base.css */body &#123; padding: 0; margin: 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;tab-bar&quot;&gt; &lt;div class=&quot;tab-bar-item&quot;&gt;首页&lt;/div&gt; &lt;div class=&quot;tab-bar-item&quot;&gt;分类&lt;/div&gt; &lt;div class=&quot;tab-bar-item&quot;&gt;购物车&lt;/div&gt; &lt;div class=&quot;tab-bar-item&quot;&gt;我的&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;&#125;&lt;/script&gt;&lt;style&gt; /* 引用样式 */ @import &quot;./assets/css/base.css&quot;; #tab-bar &#123; display: flex; /* tab-bar水平分步 */ background: #f6f6f6; /* tabbar放置底部 */ position: fixed; left: 0; right: 0; bottom: 0; /* 设置阴影过度：水平位移 垂直位移 阴影宽度 颜色 */ box-shadow: 0 -3px 1px rgba(100, 100, 100 .1) ; &#125; /* tabbar均等分，且文字居中 */ .tab-bar-item &#123; flex: 1; text-align: center; height: 49px; &#125;&lt;/style&gt; 1.3 效果图 二、对TabBar进行封装2.1 目录结构 2.2 代码内容 内容中的为了方便，没有下载图片进行测试，若要使用图片，可以去https://www.iconfont.cn进行下载 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 封装tabbar --&gt;&lt;template&gt; &lt;div id=&quot;tab-bar&quot;&gt;&lt;!-- &lt;div class=&quot;tab-bar-item&quot;&gt;--&gt;&lt;!-- &lt;div&gt;图片1&lt;/div&gt;--&gt;&lt;!-- 首页--&gt;&lt;!-- &lt;/div&gt;--&gt;&lt;!-- &lt;div class=&quot;tab-bar-item&quot;&gt;--&gt;&lt;!-- &lt;div&gt;图片2&lt;/div&gt;--&gt;&lt;!-- 分类--&gt;&lt;!-- &lt;/div&gt;--&gt;&lt;!-- &lt;div class=&quot;tab-bar-item&quot;&gt;--&gt;&lt;!-- &lt;div&gt;图片3&lt;/div&gt;--&gt;&lt;!-- 购物车--&gt;&lt;!-- &lt;/div&gt;--&gt;&lt;!-- &lt;div class=&quot;tab-bar-item&quot;&gt;--&gt;&lt;!-- &lt;div&gt;图片4&lt;/div&gt;--&gt;&lt;!-- 我的--&gt;&lt;!-- &lt;/div&gt;--&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!--使用插槽分离tabbar-item内容--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;TabBar&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; #tab-bar &#123; display: flex; /* tab-bar水平分步 */ background: #f6f6f6; /* tabbar放置底部 */ position: fixed; left: 0; right: 0; bottom: 0; /* 设置阴影过度：水平位移 垂直位移 阴影宽度 颜色 */ box-shadow: 0 -3px 1px rgba(100, 100, 100 .1); &#125;&lt;/style&gt; 123456789101112131415161718192021222324&lt;!-- 封装tabbar-item --&gt;&lt;template&gt; &lt;div class=&quot;tab-bar-item&quot;&gt;&lt;!-- &lt;div&gt;图片&lt;/div&gt;--&gt;&lt;!-- &lt;div&gt;动态内容&lt;/div&gt;--&gt; &lt;slot name=&quot;item-icon&quot;&gt;&lt;/slot&gt; &lt;!--为了不写死内容，动态使用插槽--&gt; &lt;slot name=&quot;item-text&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;TabBarItem&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; /* tabbar均等分，且文字居中 */ .tab-bar-item &#123; flex: 1; text-align: center; height: 49px; &#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 重新修改App.vue内容 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;TabBar&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;首页&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片2&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;分类&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片3&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;购物车&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片4&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;我的&lt;/div&gt; &lt;/TabBarItem&gt; &lt;/TabBar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//导入组件import TabBar from &quot;./components/tabbar/TabBar&quot;;import TabBarItem from &quot;./components/tabbar/TabBarItem&quot;;export default &#123; name: &#x27;App&#x27;, //组件注册 components: &#123; TabBar, TabBarItem &#125;&#125;&lt;/script&gt;&lt;style&gt; /* 引用样式 */ @import &quot;./assets/css/base.css&quot;;&lt;/style&gt; 2.3 效果图 三、页面激活状态3.1 目录结构 3.2 代码内容123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 修改: TabBarItem.vue --&gt;&lt;template&gt; &lt;div class=&quot;tab-bar-item&quot;&gt; &lt;div v-if=&quot;!isActive&quot;&gt; &lt;!--判断激活状态使用对应的图片--&gt; &lt;slot name=&quot;item-icon&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;slot name=&quot;item-icon-active&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div :class=&quot;&#123;active: isActive&#125;&quot;&gt; &lt;slot name=&quot;item-text&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;TabBarItem&quot;, data() &#123; return &#123; isActive: false //判断是否激活 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; /* tabbar均等分，且文字居中 */ .tab-bar-item &#123; flex: 1; text-align: center; height: 49px; &#125; /* 激活状态文字颜色 */ .active &#123; color: pink; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627&lt;!-- 修改: App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;TabBar&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片1&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片1-1&lt;/div&gt; &lt;!--添加激活状态的图片--&gt; &lt;div slot=&quot;item-text&quot;&gt;首页&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片2&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片2-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;分类&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片3&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片3-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;购物车&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片4&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片4-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;我的&lt;/div&gt; &lt;/TabBarItem&gt; &lt;/TabBar&gt; &lt;/div&gt;&lt;/template&gt; 3.3 效果图 四、结合vue-router前端路由4.1 目录结构 4.2 代码内容1234567891011121314&lt;!-- Home、Categories、ShoppingCart、Profile.vue --&gt;&lt;template&gt; &lt;h2&gt;首页&lt;/h2&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Home&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 123456789101112131415161718192021222324&lt;!-- 修改TabBarItem.vue --&gt;&lt;template&gt; &lt;div class=&quot;tab-bar-item&quot; @click=&quot;itemClick()&quot;&gt; &lt;!--监听点击--&gt; ...省略 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; ...省略 props: &#123; path: String //从父组件获取要跳转的路径 &#125;, methods: &#123; itemClick() &#123; this.$router.push(this.path).catch(err =&gt; err); //页面跳转，并解决重复点击报错 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ...省略&lt;/style&gt; 12345678910111213141516171819202122232425262728&lt;!-- 修改App.vue文件 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!--接收路由跳转内容--&gt; &lt;TabBar&gt; &lt;TabBarItem path=&quot;/home&quot;&gt; &lt;!--向子组件传递要跳转的地址--&gt; ... &lt;/TabBarItem&gt; &lt;TabBarItem path=&quot;/categories&quot;&gt; ... &lt;/TabBarItem&gt; &lt;TabBarItem path=&quot;/shoppingCart&quot;&gt; ... &lt;/TabBarItem&gt; &lt;TabBarItem path=&quot;/profile&quot;&gt; ... &lt;/TabBarItem&gt; &lt;/TabBar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ...省略&lt;/script&gt;&lt;style&gt; ...省略&lt;/style&gt; 4.3 效果图 五、激活状态颜色控制5.1 目录结构 没有变化，并没创建新文件 5.2 代码内容123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--修改：TabBarItem.vue--&gt;&lt;template&gt; &lt;div class=&quot;tab-bar-item&quot; @click=&quot;itemClick()&quot;&gt; ... &lt;div :style=&quot;activeStyle&quot;&gt; &lt;!--动态绑定样式--&gt; &lt;slot name=&quot;item-text&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; path: String, activeColor: &#123; //让他人使用可以自定义颜色，而不用接触vue底层源码 type: String, default: &#x27;pink&#x27; &#125; &#125;, // data() &#123; // return &#123; // isActive: false // &#125; // &#125;, 用计算属性来代替isActive computed: &#123; isActive() &#123; //return this.$route.path.indexOf(this.path) !== -1; return this.$route.path === this.path; //跟当前活跃路由和组件中路由进行对比，相同就是激活状态 &#125;, activeStyle() &#123; return this.isActive ? &#123;color: this.activeColor&#125; : &#123;&#125;; //三元表达式决定样式 &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; ... /*.active &#123;*/ /* color: pink;*/ /*&#125; 不再需要激活样式了，动态决定激活样式 */ &lt;/style&gt; 123456789101112131415161718192021&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;TabBar&gt; &lt;TabBarItem path=&quot;/home&quot; activeColor=&quot;blue&quot;&gt; &lt;!--可以传递activeColor来决定激活字体的颜色，实现完全封装，不需要其他人接触vue的源码--&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片1&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片1-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;首页&lt;/div&gt; &lt;/TabBarItem&gt; ... &lt;/TabBar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; ...&lt;/script&gt;&lt;style&gt; ...&lt;/style&gt; 5.3 效果图 六、第二次封装6.1 目录结构 6.2 代码内容123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- MainTabBar.vue --&gt;&lt;template&gt; &lt;TabBar&gt; &lt;TabBarItem path=&quot;/home&quot;&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片1&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片1-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;首页&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem path=&quot;/categories&quot;&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片2&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片2-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;分类&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem path=&quot;/shoppingCart&quot;&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片3&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片3-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;购物车&lt;/div&gt; &lt;/TabBarItem&gt; &lt;TabBarItem path=&quot;/profile&quot;&gt; &lt;div slot=&quot;item-icon&quot;&gt;图片4&lt;/div&gt; &lt;div slot=&quot;item-icon-active&quot; style=&quot;color: pink&quot;&gt;图片4-1&lt;/div&gt; &lt;div slot=&quot;item-text&quot;&gt;我的&lt;/div&gt; &lt;/TabBarItem&gt; &lt;/TabBar&gt;&lt;/template&gt;&lt;script&gt; import TabBar from &quot;./TabBar&quot;; //记得修改路径 import TabBarItem from &quot;./TabBarItem&quot;; export default &#123; name: &quot;MainTabBar&quot;, components: &#123; TabBar, TabBarItem &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 12345678910111213141516171819202122232425&lt;!-- 修改App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;MainTabBar&gt;&lt;/MainTabBar&gt; &lt;!-- 进一步抽取，是App.vue整洁 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//导入组件import MainTabBar from &quot;./components/tabbar/MainTabBar&quot;;export default &#123; name: &#x27;App&#x27;, //组件注册 components: &#123; MainTabBar &#125;&#125;&lt;/script&gt;&lt;style&gt; /* 引用样式 */ @import &quot;./assets/css/base.css&quot;;&lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】vue-router前端路由","slug":"【Vue】vue-router前端路由","date":"2020-11-29T12:58:42.000Z","updated":"2020-11-29T13:03:48.090Z","comments":true,"path":"2020/11/29/【Vue】vue-router前端路由/","link":"","permalink":"https://letere-gzj.github.io/2020/11/29/%E3%80%90Vue%E3%80%91vue-router%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/","excerpt":"关于前端路由的讲解，前端路由的讲解暂时以cli2.x进行","text":"关于前端路由的讲解，前端路由的讲解暂时以cli2.x进行 一、前后端渲染和路由1.1 后端路由阶段 （1）后端渲染 jsp / php，通过html+css+java技术，在后端（服务器）渲染页面，然后发送给用户 （2）后端路由：后端处理URL和页面之间的映射关系 缺点：整个页面都是交给后端来处理 1.2 前后端分离阶段 后端只负责提供数据，不负责任何前端页面的内容 前端渲染： 浏览器中显示的页面中大部分内容，都是前端些的js代码在浏览器中执行，最终渲染出来的页面 1.3 单页面富应用阶段 简称SPA(single page application) 特点：在前后端分离的基础上，加了一层前端路由 二、URL变化页面不刷新2.1 hash值 2.2 HTML5history模式 （1）pushState() 因为pushState()本质是将路由url存放在栈里，所以可以执行以下操作 （2）history.back() 返回上一页面 （3）history.forward() 进入下一页面 （4）history.go(-1) == history.back() （5）history.go(1) == history.forward() 三、vue-router安装和配置3.1 安装 （1）webpack项目： npm install vue-router --save （2）vue cli项目 创建的时候选择vue-router即可 3.2 配置路由 （1）webpack项目： 12345678910111213141516//创建一个router文件夹进行管理//在router文件夹创建index.js进行配置//配置路由的相关信息import Vue from &#x27;vue&#x27; //导入Vueimport Router from &#x27;vue-router&#x27; //导入路由插件Vue.use(Router) //安装路由插件const routes = []; //配置路由跳转信息const router = new Router(&#123; routes //es6语法 routes: routes&#125;);export default router; //导出 12345678910//在main.js使用路由import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router/index.js&#x27; //导入，可以省略/index，会自动寻找index文件new Vue(&#123; el: &#x27;#app&#x27;, router, //挂载路由，es6语法 render: h =&gt; h(App)&#125;) （2）vue cli项目 默认设置即可 四、路由映射配置4.1 创建路由组件123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是首页&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;home&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 4.2 配置路由映射12345678910111213141516171819import Vue from &#x27;vue&#x27; import Router from &#x27;vue-router&#x27; import Home from &quot;../components/home&quot; //导入组件Vue.use(Router) //配置路由映射，一个映射对应一个对象const routes = [ &#123; path: &quot;/home&quot;, //路径 component: Home //映射的组件 &#125;]const router = new Router(&#123; routes &#125;);export default router; 4.3 首页设置123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;!--路由映射链接标签--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!--接收路由组件内容，和组件开发slot插槽类似--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 4.4 配置默认路径1234567891011//router/index.jsconst routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/home&#x27; //重定向到首页 &#125;, &#123; path: &quot;/home&quot;, component: Home &#125;] 4.5 使用history模式 vue-router路由跳转，默认使用hash跳转，所以页面会出现localhost:8080/#/home，为了去掉’#’，可以使用history模式 12345// router/index.jsconst router = new Router(&#123; routes, mode: &#x27;history&#x27;&#125;); 五、router-link属性补充5.1 tag属性1&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot;&gt;首页&lt;/router-link&gt; 页面最终渲染&lt;router-link&gt;标签默认为&lt;a&gt;标签，可以通过tag属性修改要渲染的标签 5.2 replace属性1&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace&gt;首页&lt;/router-link&gt; 如果该前端路由使用history模式，但是不想该页面跳转可以返回，用replace来禁止页面返回跳转 5.3 active-class属性 &lt;router-link&gt;标签被点击时，会在class产生一个’router-link-active’属性，可以通过该属性来设置点击时的样式，但是如果嫌名称过长，可以通过active-class来进行修改 1&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt; 如果修改的router-link标签过多，可以在router的index.js进行统一设置 1234const router = new Router(&#123; routes, //es6语法 linkActiveClass: &#x27;active&#x27; //统一修改active-class&#125;); 六、路由代码跳转 我们可以不使用&lt;router-link&gt;标签，通过其他标签，监听点击，在方法中通过代码实现路由跳转 1234567891011121314151617181920212223&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;homeClick()&quot;&gt;首页&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, methods: &#123; homeClick() &#123; //push 和 replace都可以，只是能不能返回的问题而已 // this.$router.push(&quot;/home&quot;); this.$router.replace(&quot;/home&quot;); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 七、动态路由 前端路由跳转时，跳转的参数时不确定的，动态的实现方法 7.1 搭建基础的路由12345678910111213141516&lt;!--创建 components/user.vue--&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是用户&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;user&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 1234567891011121314151617181920// router/index.js，配置路由映射import Vue from &#x27;vue&#x27; //导入Vueimport Router from &#x27;vue-router&#x27; //导入路由插件import User from &quot;../components/user&quot;Vue.use(Router) //安装路由插件const routes = [ &#123; path: &quot;/user&quot;, component: User &#125;]const router = new Router(&#123; routes, mode: &#x27;history&#x27;,&#125;);export default router; 123456789101112131415161718&lt;!--./App.vue：设置首页--&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/user&quot; replace tag=&quot;button&quot;&gt;用户&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 7.2 进行动态设置12345678910//修改./router/index.js...const routes = [ &#123; path: &quot;/user/:userName&quot;, //&#x27;:userName&#x27;，动态接受数据 component: User &#125;]... 12345678910111213141516171819&lt;!--修改 ./App.vue--&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link :to=&quot;&#x27;/user/&#x27; + userName&quot; replace tag=&quot;button&quot;&gt;用户&lt;/router-link&gt; &lt;!--使用v-bind 绑定数据--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; userName: &quot;莱特雷&quot; //创建数据 &#125; &#125;&#125;&lt;/script&gt;... 12345678&lt;!--修改 ./components/user.vue 接受数据--&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是用户&lt;/h2&gt; &#123;&#123;$route.params.userName&#125;&#125; &lt;!--接受动态数据，注意是&#x27;$route&#x27;，不是&#x27;$router&#x27;--&gt; &lt;/div&gt;&lt;/template&gt;... 八、路由懒加载8.1 打包目录解析 8.2 懒加载认识 因为打包时会把所有业务代码打包在一个app的js文件上，会导致文件巨大，加载该文件时，可能会出现短暂的空白 使用懒加载，将不同路由组件打包成不同的代码块，用户访问到该路由时再加载，用户体验上升 8.3 懒加载使用 （1）写法一 结合Vue异步组件和Webpack代码的分析（旧） 12345const Home = resolve =&gt; &#123; require.ensure([&#x27;..componets/Home.vue&#x27;], () =&gt; &#123; resolve(require(&#x27;../components/Home.vue&#x27;)) &#125;)&#125; （2）写法二 AMD写法 1const Home = resolve =&gt; require([&#x27;../components/Home.vue&#x27;], resolve) （3）写法三 ES6写法，组织Vue异步组件和Webpack的代码分割 1const Home = () =&gt; import(&#x27;..components/Home.vue&#x27;) 8.4 例子改写和打包结果12345678// import Home from &quot;../components/home&quot;const Home = () =&gt; import(&quot;../components/home&quot;);// import About from &quot;../components/about&quot;const About = () =&gt; import(&quot;../components/about&quot;);// import User from &quot;../components/user&quot;const User = () =&gt; import(&quot;../components/user&quot;); 打包结果 九、路由嵌套 在home的页面下创建一个子路由”/home/news” 9.1 创建组件12345678910111213141516// ./components/homeNews.vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;这里是新闻哦！&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;homeNews&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 9.2 路由注册12345678910111213141516171819202122232425...const HomeNews = () =&gt; import(&quot;../components/homeNews&quot;)...const routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/home&#x27; &#125;, &#123; path: &quot;/home&quot;, component: Home, children: [ //子路由 &#123; path: &quot;&quot;, redirect: &quot;news&quot; //默认路径 &#125;, &#123; path: &quot;news&quot;, //子路径不要添加&#x27;/&#x27;，否则识别不出来 component: HomeNews &#125; ] &#125;]... 9.3 home页面修改12345678&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是首页&lt;/h2&gt; &lt;router-link to=&quot;/home/news&quot; tag=&quot;button&quot;&gt;新闻&lt;/router-link&gt; &lt;!--跳转子路由--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!--显示子路由信息--&gt; &lt;/div&gt;&lt;/template&gt;... 十、参数传递10.1 动态路由的方式 动态路由在上面有说，就不在此再讲 10.2 query类型 （1）搭建一个’profile’路由 1234567&lt;!-- 创建：./components/profile.vue ---&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;这里是profile组件&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;... 1234567891011// 注册路由： ./router/index.jsconst Profile = () =&gt; import(&quot;../components/profile&quot;);...const routes = [ ... &#123; path: &quot;/profile&quot;, component: Profile &#125;] 123456789&lt;!-- 修改首页: ./App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; ... &lt;router-link to=&quot;/profile&quot; tag=&quot;button&quot;&gt;档案&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;... （2）参数传递 12345678910&lt;!-- 修改首页: ./App.vue --&gt;&lt;template&gt; ... &lt;!--利用v-bind将to交给vue管理，传递一个对象，path为跳转路径，query为传递参数的对象--&gt; &lt;router-link :to=&quot;&#123;path: &#x27;/profile&#x27;, query: &#123;name: &#x27;莱特雷&#x27;, age: 18, sex: &#x27;男&#x27;&#125;&#125;&quot; tag=&quot;button&quot;&gt;档案&lt;/router-link&gt; &lt;!--页面结果：http://localhost:8080/profile?name=莱特雷&amp;age=18&amp;sex=男，类似后端的get请求--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;... （3）参数接收 1234567891011&lt;!-- 修改profile文件： ./components/profile.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;这里是profile组件&lt;/h2&gt; &lt;h3&gt;&#123;&#123;$route.query&#125;&#125;&lt;/h3&gt; &lt;!--提取对象--&gt; &lt;h3&gt;&#123;&#123;$route.query.name&#125;&#125;&lt;/h3&gt; &lt;!--提取对象属性--&gt; &lt;h3&gt;&#123;&#123;$route.query.age&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;$route.query.sex&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;... 十一、全局导航守卫 实现功能：在每次页面跳转时，修改当前标题为当前页面名称 11.1 利用生命周期函数实现 created()：在页面生成时，会自动调用此函数，利用此来进行修改页面标题 123456789101112131415&lt;!--举例：./components/about.vue--&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是关于&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;about&quot;, created() &#123; document.title = &quot;关于&quot; &#125; &#125;&lt;/script&gt; 11.2 利用全局导航守卫 （1）函数源码分析 利用路由器对象的beforeEach()方法进行使用全局导航守卫，路由跳转时会使用自动调用此函数 12345678beforeEach(guard: NavigationGuard): Function||跳转NavigationGuardexport type NavigationGuard&lt;V extends Vue = Vue&gt; = ( //箭头函数，参数为to, from, next to: Route, //跳转目标路由 from: Route, //跳转处罚路由 next: NavigationGuardNext&lt;V&gt; //执行导航守卫下一步) =&gt; any （2）使用全局导航守卫实现需求 123456789101112131415//给每个路由添加一个标题原数据 ./router/index.jsconst routes = [ &#123; path: &quot;/&quot;, redirect: &#x27;/home&#x27; &#125;, &#123; path: &quot;/home&quot;, //路径 component: Home, //映射的组件 meta: &#123; title: &quot;首页&quot; &#125; &#125;...以此类推] 12345678910//使用beforeEach()函数 ./router/index.jsconst router = new Router(&#123; routes&#125;);router.beforeEach((to, from, next) =&gt; &#123; //document.title = to.meta.title; 对于使用嵌套路由的页面获取不了数据 document.title = to.matched[0].meta.title; next(); //必须要先执行下一步，否则程序会暂停在此&#125;) 11.3 全局导航守卫补充 （1）全局守卫处理beforeEach之外，还有afterEach，分别在路由跳转前/路由跳转后执行 1234//通过afterEach实现需求router.afterEach((to, from) =&gt; document.title = to.matched[0].meta.title);//不需要next参数，并且不需要调用 （2）处了全局导航守卫之外，还有组件内的守卫和路由独享的守卫 具体可以看官方文档进行学习：https://router.vuejs.org/zh/guide/advanced/navigation-guards.html 十二、keep-alive keep-alive 是Vue内置的一个组件，可以是被包含的组件保留状态，或避免重新渲染 route-view也是一个组件，如果直接被抱在keep-alive里面，所有的路径匹配到的视图组件都被缓存，不会立即销毁 12.1 keepp-alive实现功能 需求，点击首页的子路由时，记录点击的子路由，返回首页时，自动跳转到该子路由，而不是默认了的子路由 12345678910111213&lt;!-- 主页面添加keep-alive：./App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt; &lt;router-link :to=&quot;&#x27;/user/&#x27; + userName&quot; replace tag=&quot;button&quot;&gt;用户&lt;/router-link&gt; &lt;!--使用v-bind 绑定数据--&gt; &lt;router-link :to=&quot;&#123;path: &#x27;/profile&#x27;, query: &#123;name: &#x27;莱特雷&#x27;, age: 18, sex: &#x27;男&#x27;&#125;&#125;&quot; tag=&quot;button&quot;&gt;档案&lt;/router-link&gt; &lt;!--添加keep-alive 缓存路由内容--&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617181920&lt;!-- 修改首页: ./components/home.vue --&gt;&lt;script&gt; export default &#123; name: &quot;home&quot;, data() &#123; return &#123; path: &quot;/home/news&quot; //记录路径 &#125; &#125;, //注意：activated只有使用keep-alive标签包裹后才会生效 activated() &#123; this.$router.replace(this.path); //首页被激活时，跳转路径 &#125;, //组件守卫 beforeRouteLeave(to, from, next) &#123; this.path = from.path; //页面跳转时，记录当前路径，下一次页面激活时，跳转该路径 next(); &#125; &#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】vue cli脚手架","slug":"【Vue】vue-cli脚手架","date":"2020-11-29T12:53:01.000Z","updated":"2020-11-29T12:55:03.769Z","comments":true,"path":"2020/11/29/【Vue】vue-cli脚手架/","link":"","permalink":"https://letere-gzj.github.io/2020/11/29/%E3%80%90Vue%E3%80%91vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"关于前端模块化整合工具cli脚手架的介绍和使用","text":"关于前端模块化整合工具cli脚手架的介绍和使用 一、脚手架安装 （1）安装8.9版本以上的node （2）安装webpack （3）安装脚手架 npm install -g @vue/cli （4）拉脚手架2.x模板 npm install -g @vue/cli-init 二、vue cli2项目初始化 命令行运行vue init webpack 项目名称（非中文） 目录结构介绍 三、runtime-compiler和runtime-only3.1 区别 Vue cli 编译流程 runtime-compiler 流程：template =&gt; ast =&gt; render =&gt; vdom =&gt; UI runtime-only 流程：render =&gt; vdom =&gt; dom 总结： 1、runtime-only的性能比runtime-compiler性能好 2、runtime-only需要的代码量更少 3.2 runtime-compiler使用render 使用render，需要使用到createElement函数 使用方法： （1）createElement(标签，&#123;标签的属性&#125;, [标签内容]) 123createElement(&#x27;h2&#x27;, &#123;class: &#x27;box&#x27;&#125;, [&#x27;Hello World!&#x27;])等同于&lt;h2 class=&quot;box&quot;&gt;Hello World!&lt;/h2&gt; （2）createElement(组件对象) 1234567891011const test = &#123; template: `&lt;di&gt;&#123;&#123;message&#125;&#125;&lt;/di&gt;`, data() &#123; return &#123; message: &quot;我是组件对象！&quot; &#125; &#125; &#125;createElement(test);等同于&lt;div&gt;我是组件对象！&lt;/div&gt; 四、cli3/4项目初始化4.1 项目创建 命令行执行：vue create 项目名称 4.2 目录结构 cli3之后，按照‘0配置’的原理进行更新，所有最开始的两个项目配置文件被隐藏 4.3 main.js改变12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;Vue.config.productionTip = false //产品提示信息，开发是不提示，打包时再提示new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) //$mount(&#x27;#app&#x27;)等同于el: &#x27;#app&#x27; 五、cli3/4配置5.1 官方UI界面 在命令行输入：vue ui 5.2 寻找被隐藏的配置文件 文件路径：node_modules\\@vue\\cli-service\\lib 5.3 创建配置文件 在根目录下创建一个名为“vue.config.js”的文件，里面填写webpack的配置 123module.exports = &#123; //会自动跟webpack的配置文件进行合并&#125; 六、箭头函数6.1 箭头函数的使用12345678910//普通函数const 参数名 = function(参数) &#123; 函数体;&#125;//箭头函数const 参数名 = (参数) =&gt; &#123;函数体;&#125;//注意：1、如果参数 或 函数体 只有一个时&#x27;()&#x27;&#x27;&#123;&#125;&#x27;可以被省略// 2、函数体只有一行代码，并且是return语句，return可以被省略 6.2 箭头函数this的使用 箭头函数的this，引用的时最近作用域中的this 箭头函数this，会往上一层的this寻找","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】Webpack","slug":"【Vue】Webpack","date":"2020-11-29T12:46:44.000Z","updated":"2020-11-29T12:50:27.000Z","comments":true,"path":"2020/11/29/【Vue】Webpack/","link":"","permalink":"https://letere-gzj.github.io/2020/11/29/%E3%80%90Vue%E3%80%91Webpack/","excerpt":"关于前端模块化工具webpack的使用","text":"关于前端模块化工具webpack的使用 一、CommonJS模块化语法1.1 导出123456789module.exports = &#123; flag: true, test(a, b)&#123; return a + b; &#125;, demo(a, b)&#123; return a * b; &#125;&#125; 1.2 导入1let &#123;flag, test, demo&#125; = require(&#x27;js文件路径&#x27;) 二、ES6模块化语法2.1 导出 （1）统一导出 1234567891011var flag = truefunction sum(a, b)&#123; return a + b;&#125;//导出方式一export &#123; flag, sum&#125; （2）定义变量的同时进行导出 1234567891011121314//在变量前添加export修饰符export var money = 1000 export function add() &#123; console.log(&quot;调用导出方法成功&quot;)&#125;export class Person&#123; name = &quot;莱特雷&quot; age = 20 eat()&#123; console.log(&quot;吃饭&quot;) &#125;&#125; （3）默认导出 默认导出只能导出一个变量，默认导出用于导出的变量被引用时可以重命名，变量名不固定 12const city = &quot;广州&quot;export default city //export default 导出只能有一个 2.2 导入 （1）统一导入 1import * as A from &quot;./a.js&quot;; //&#x27;A&#x27;为别名，引用数据格式为A.xxxx （2）选择导入 1import &#123;flag, sum&#125; from &quot;./a.js&quot;; //在&#x27;&#123;&#125;&#x27;中选择要导入的数据，使用数据直接用变量名即可 （3）默认导出的数据导入 1import c from &quot;./a.js&quot;; //&#x27;c&#x27;为默认变量的新的变量名，直接调用新变量名使用数据 三、webpack介绍和安装webpack是一个现代的JavaScript应用的静态模块打包工具webpack官网：https://www.webpackjs.com/ 3.1 webpack安装 webpack要正常使用，需要node环境 node环境为了可以正常使用多种代码，需要各种包 安装node时一般会自动安装npm工具，会管理各种包之间的依赖 （1）node.js安装 官网：https://nodejs.org/zh-cn/ 下载长期支持版，处理安装路径，一路默认安装即可 安装后，打开命令行’node -v’查看，有版本号显示，即安装成功 （2）webpack安装 webpack安装利用node.js的npm来进行安装 建议安装webpack3.6.0，使用的时vue cli2版本，可以看见各种各样的webpack配置。高版本使用vue cli3版本，隐藏了webpack的配置 安装：打开命令行敲’npm install &#119;&#x65;&#98;&#112;&#97;&#x63;&#107;&#x40;&#51;&#46;&#54;&#46;&#x30; -g’进行安装 检查安装：命令行敲’webpack -version’查看，有版本号显示，安装成功 四、webpack的基本使用4.1 模块化的目录结构项目|—-src （存放各种静态资源文件）|—-dist (用来存放打包好的文件) 4.2 webpack打包 对于js文件，一般会使用main.js作为js的主程序 所以打包方式为：在命令行敲’webpack ./src/main.js ./dist/bundle.js’ 解释：将main.js文件包括其依赖，打包为bundle.js 五、webpack基础配置5.1 简易打包命令实现命令行敲’webpack’，直接打包，不用敲后面参数 （1）在项目根目录创建一个webpack.config.js文件 （2）配置文件设置 12345678910const path = require(&#x27;path&#x27;) //node语法，是node核心模块，存放项目绝对路径的一个对象module.exports = &#123; entry: &#x27;./src/main.js&#x27;, //入口 output: &#123; //出口 path: path.resolve(__dirname, &#x27;dist&#x27;), //需要绝对路径，利用node获取当前目路的绝对路径__dirname，后面添加的参数为路径的拼接 filename: &#x27;bundle.js&#x27; &#125; &#125; 5.2 使用局部webpack （1）在项目敲’npm init’来创建一个package.json文件，除了文件名非中文外，其余默认即可 （2）安装局部webpack，在项目的命令行下’npm install &#119;&#x65;&#98;&#112;&#97;&#99;&#x6b;&#x40;&#x33;&#46;&#x36;&#46;&#48;‘，因为webpack是开发时才使用的，发布时不使用，可以执行’npm install &#119;&#101;&#98;&#112;&#x61;&#x63;&#107;&#x40;&#51;&#46;&#54;&#x2e;&#x30; –save-dev’ （3）因为命令行使用webpack命令默认使用全局webpack的，但是可以利用npm的脚本，默认会先从本地寻找命令，在package.json中设置 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack&quot; 添加脚本命令映射，执行&#x27;npm run build&#x27; == &#x27;webpack&#x27;&#125; 六、webpack使用css文件webpack本身只支持js代码的打包，不支持css。需要向webpack拓展对相应的loader即可 官方文档：https://www.webpackjs.com/loaders/css-loader/ 6.1 环境创建 （1）随便创建一个css文件，写一个简单的css语法 123body&#123; background-color: red;&#125; （2）main.js引入css文件 12//依赖css文件require(&#x27;./css/normal.css&#x27;); 6.2 安装配置相应的loader查看官方文档，发现要打包css要使用到两个loader，css-loader和style-loader （1）loader安装 跟官方文档一样，只是由于我们使用的webpack版本较低，新版本的css-loader会不支持，建议使用2.0.2版本 12npm install --save-dev css-loader@2.0.2npm install --save-dev style-loader （2）loader配置 跟官方文档一样，在webpack.config.js中配置即可 12345678910111213module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, //正则表达式，对.css结尾的文件进行处理 //css-loader负责将css文件进行加载 //style-loader负责将样式添加到DOM中 //webpack使用多个loader时，是从右到左进行读取，所以顺序不能反 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125; ] &#125;&#125; 执行npm run build 执行打包，并在页面引入生成bundle.js 七、打包图片文件7.1 环境搭建 在之前的案例进行修改，将css文件背景颜色改成背景图片1234body&#123; /*background-color: black;*/ background: url(&quot;../img/link.jpg&quot;);&#125; 7.2 url-loader安装和配置 官方文档：https://www.webpackjs.com/loaders/url-loader/ 步骤按官方文档即可，注意点webpack3.6.0版使用&#x75;&#x72;&#x6c;&#45;&#x6c;&#111;&#97;&#x64;&#101;&#x72;&#64;&#x31;&#46;&#49;&#46;&#50;版本 1npm install --save-dev url-loader@1.1.2 1234567891011121314151617module: &#123; rules: [ //配置图片文件 &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 40000, //限制图片大小，若图片小于限制，则会用base64编码来显示图片 //大于限制，需要使用file-loader，会生成一个hash编码图片到dist文件中，不需要配置 &#125; &#125; ] &#125; ] &#125; 先让图片的大小 &lt; 限制的大小 7.3 file-loader安装 当图片大小 &gt; 限制大小时，则需要安装file-loader才能打包图片 由于&#119;&#x65;&#x62;&#x70;&#x61;&#99;&#107;&#x40;&#x33;&#x2e;&#54;&#x2e;&#x30;版本原因，建议安装&#x66;&#105;&#108;&#x65;&#45;&#108;&#111;&#97;&#x64;&#x65;&#x72;&#x40;&#51;&#x2e;&#x30;&#x2e;&#x31; 1npm install --save-dev file-loader@3.0.1 安装完后无需任何的配置 打包发现图片会复制一份到dist目录，而网页无法正确访问到该图片 解决方法： （1）将网页放在dist路径下 （2）修改webpack.config.js配置文件 12345module.exports = &#123; output: &#123; publicPath: &#x27;./dist/&#x27; //图片资源文件寻找的路径 &#125; &#125; 7.4 url-loader高阶设置123456789101112&#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 40000, name: &#x27;img/[name].[hash:8].[ext]&#x27; //按照此命名规范，对大于限制的文件进行生成，生成一个img目录，&#x27;名字.8位hash值.拓展名&#x27;的格式 &#125; &#125; ]&#125; 八、ES6转ES5 除了傻逼IE，绝大部分的浏览器支持es6语法 将ES6语法转变成ES5，需要使用到babel-loader 官方文档：https://www.webpackjs.com/loaders/babel-loader/ 8.1 安装和配置 由于只是简单的配置，就不完全按照官方文档来操作 安装 1npm install --save-dev babel-loader@7 babel-core babel-preset-es2015 配置 123456789101112131415module: &#123; rules: [ //ES6转ES5 &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, //排除掉这些目录下的js文件 use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;es2015&#x27;] &#125; &#125; &#125; ]&#125; 九、webpack使用Vue （1）通过npm安装Vue 1npm install vue --save （2）JS代码引用Vue 123456789//引入Vueimport Vue from &#x27;vue&#x27;; //Vue默认到导出为export default，所有引入时可以起别名const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;Hello Vue!&quot; &#125;&#125;); （3）页面创建对应的模板 123&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; （4）报错解决 编译完后运行，会出现报错，只使用了runtime-only runtime-only：代码中，不可以有任何的template runtime-compiler：代码中，可以有template，因为compiler可以用于编译template 12345678修改webpack.config.jsmodule.exports = &#123; resolve: &#123; alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27; //指定vue的路径，按照该路径寻找vue，vue.esm.js包括了runtime-compiler &#125; &#125;&#125; 十、Vue使用最佳方案10.1 template和el在前端的开发中，我们并不希望过多的修改index.html页面，所以需要把页面代码抽取出来 12345678&lt;body&gt; &lt;!-- 在同时使用&#x27;el&#x27;和&#x27;template&#x27;时，&#x27;template&#x27;会替换掉&#x27;el&#x27; --&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 1234567891011121314//引入Vueimport Vue from &#x27;vue&#x27;; const app = new Vue(&#123; el: &quot;#app&quot;, template:` //将前端代码提取到template属性中 &lt;div&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; `, data: &#123; message: &quot;Hello Vue!&quot; &#125;&#125;); template会替换el的代码 10.2 抽取组件进行优化可以将template单独抽取为组件来使用，变得简洁 12345678910111213141516171819202122232425//引入Vueimport Vue from &#x27;vue&#x27;;//抽取成为组件const App = &#123; template: ` &lt;div&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; `, data() &#123; return &#123; message: &quot;Hello Vue!&quot; &#125; &#125;&#125;new Vue(&#123; el: &quot;#app&quot;, template: &#x27;&lt;App&gt;&lt;/App&gt;&#x27;, //局部注册组件 components: &#123; App //ES6语法：App: App &#125;&#125;); 10.3 组件抽取再一步优化 （1）创建一个vue文件夹，里面创建app.js，存放组件 123456789101112export default &#123; template: ` &lt;div&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; `, data() &#123; return &#123; message: &quot;Hello Vue!&quot; &#125; &#125;&#125; （2）main.js导入组件并使用 1234567891011import Vue from &#x27;vue&#x27;; //导入组件import App from &quot;./vue/app.js&quot;new Vue(&#123; el: &quot;#app&quot;, template: &#x27;&lt;App&gt;&lt;/App&gt;&#x27;, components: &#123; App //ES6语法：App: App &#125;&#125;); 10.4 使用vue文件（最终方法） （1）IDEA支持vue文件 （2）创建Vue文件，并将组件内容移动到里面 12345678910111213141516171819202122232425&lt;!--模板--&gt;&lt;template&gt; &lt;div class=&quot;title&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;!--脚本--&gt;&lt;script&gt; export default &#123; name: &quot;App&quot;, data() &#123; return &#123; message: &quot;Hello Vue!&quot; &#125; &#125; &#125;&lt;/script&gt;&lt;!--样式--&gt;&lt;style scoped&gt; .title &#123; color: yellow; &#125;&lt;/style&gt; （3）main.js引入vue文件 1234567891011import Vue from &#x27;vue&#x27;; //Vue默认到导出为export default，所有引入时可以起别名import App from &quot;./vue/App.vue&quot; //引入vue文件new Vue(&#123; el: &quot;#app&quot;, template: &#x27;&lt;App&gt;&lt;/App&gt;&#x27;, components: &#123; App //ES6语法：App: App &#125;&#125;); （4）安装和配置vue-loader 12//安装npm install --save-dev vue-loader vue-template-compiler 12345678910111213141516171819//webpack.config.js配置//14以上的版本，需要引入一个插件才能使用const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; module: &#123; rules: [ //配置vue-loader &#123; test: /\\.vue$/, use: [&#x27;vue-loader&#x27;] &#125; ] &#125;, plugins: [ // 引入插件 new VueLoaderPlugin() ] 10.5 小知识 可以通过设置，引入文件是可以省略后缀名 123456//webpack.config.js配置module.exports = &#123; resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.css&#x27;, &#x27;.vue&#x27;] //省略后缀名 &#125;&#125; 十一、Vue插件使用11.1 横幅插件 横幅插件使用打包时声明一些信息，例如版权等等123456789//webpack.config.jsconst webpack = require(&#x27;webpack&#x27;)module.export = &#123; ... plugins: [ new webpack.BannerPlugin(&#x27;最终版权归letere所有！&#x27;) ]&#125; 11.2 打包html插件 将文件中的index.html打包到dist目录下 （1）安装和配置 12//插件安装 webpack@3.6.0npm install html-webpack-plugin@3.2.0 --save-dev 123456789101112//配置//webpack.config.jsconst htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; ... plugins: [ new htmlWebpackPlugin(&#123; template: &#x27;index.html&#x27; //打包页面的位置 &#125;) ]&#125; （2）index.html修改 1234567&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;!--js导入会在打包时自动生成，不用我们添加 记得把之间在webpack.config.js文件中设置静态资源位置注释掉--&gt; 11.3 js压缩（丑化） js压缩，会将多余的空格删掉，并将很长的变量名以一个简单的字符来替换，进而减小代码的大小 高版本的webpack自带压缩 12//安装npm install uglifyjs-webpack-plugin@1.1.1 --save-dev 123456789//webpack.config.js配置const UglifyjsWebpackPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;);module.exports = &#123; ... plugins: [ new UglifyjsWebpackPlugin() ]&#125; 十二、搭建本地服务器 为了方便调试，在开发阶段可以自己搭建一个本地服务器，自动编译，不用每次都打包，自己点击网页运行 12//安装npm install --save-dev webpack-dev-server@2.9.1 12345678//webpack.config.js配置module.exports = &#123; //配置本地服务器 devServer: &#123; contentBase: &quot;./dist&quot;, //服务的文件夹 inline: true //是否实时监听 &#125;&#125; 因为我们是使用局部环境，所以直接敲”webpack-dev-server”无法启动服务器，要配置一下脚本 123456//package.json配置 &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot; &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】组件开发","slug":"【Vue】组件开发","date":"2020-11-21T04:04:25.000Z","updated":"2020-11-29T12:45:24.496Z","comments":true,"path":"2020/11/21/【Vue】组件开发/","link":"","permalink":"https://letere-gzj.github.io/2020/11/21/%E3%80%90Vue%E3%80%91%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/","excerpt":"Vue组件开发使用","text":"Vue组件开发使用 一、组件化的基本认识1.1 Vue组件化思想 组件化是Vue.js中的重要思想 它提供了一种抽象，让我们可以开发出一个个独立可用的小组件来构造我们的应用 任何的应用都会被抽象成一棵组件树 1.2 注册组件的基本步骤 （1）创建组件构造器 调用Vue.extend()方法 （2）注册组件 调用Vue.component()方法 （3）使用组件 在Vue实例的作用域内使用组件 二、组件化的基本使用12345678910111213141516171819202122232425262728&lt;div id=&quot;app&quot;&gt; &lt;!--3、使用组件--&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //ES6语法：``能够定义字符串，并且可以换行定义 //1、创建组件构造器对象 const cpnConstructor = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h1&gt;这是1号标题&lt;/h1&gt; &lt;h2&gt;这是2号标题&lt;/h2&gt; &lt;h3&gt;这是3号标题&lt;/h3&gt; &lt;/div&gt; ` //添加模板 &#125;); //2、注册主键 //component(&#x27;组件标签名&#x27;, 组件构造器) Vue.component(&#x27;cpn&#x27;, cpnConstructor); const app = new Vue(&#123; el: &#x27;#app&#x27;, &#125;);&lt;/script&gt; 三、全局组件和局部组件3.1 全局组件12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!--被成功执行--&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!--被成功执行--&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1、创建组件构造器 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h3&gt;我是标题&lt;/h3&gt; &lt;P&gt;我是内容&lt;/P&gt; &lt;/div&gt; ` &#125;); //2、注册组件（全局注册） const component = Vue.component(&quot;cpn&quot;, cpnC); const app = new Vue(&#123; el: &#x27;#app&#x27; &#125;); const app2 = new Vue(&#123; el: &quot;#app2&quot; &#125;)&lt;/script&gt; 3.2 局部组件1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!--没有被使用到--&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1、创建组件构造器 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h3&gt;我是标题&lt;/h3&gt; &lt;P&gt;我是内容&lt;/P&gt; &lt;/div&gt; ` &#125;); const app = new Vue(&#123; el: &#x27;#app&#x27;, //2、注册组件（局部注册） components: &#123; cpn: cpnC &#125; &#125;); const app2 = new Vue(&#123; el: &quot;#app2&quot; &#125;)&lt;/script&gt; 四、父子组件的区别12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; &lt;cpn2&gt;&lt;/cpn2&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1、创建第一个组件构造器(子组件) const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;标题1&lt;/h2&gt; &lt;p&gt;内容1&lt;/p&gt; &lt;/div&gt; ` &#125;); //2、创建第二个组件构造器(父组件) const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;p&gt;内容2&lt;/p&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;!--调用子组件--&gt; &lt;/div&gt; `, //注册子组件 components: &#123; cpn1: cpnC1 &#125; &#125;); //最顶部(根:root)组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, //3、组件注册 components: &#123; cpn2: cpnC2 &#125; &#125;);&lt;/script&gt; 十、通信案例利用父子组件通信的形式，实现父子组件双向绑定 10.1 方式一父组件通过props传值给子组件，子组件通过自定义事件来传值给父组件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--案例：实现父子组件双向绑定通信--&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn :numb=&quot;num&quot; @valuechange=&quot;numbchange&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;props：&#123;&#123;numb&#125;&#125;&lt;/h2&gt; &lt;h2&gt;data：&#123;&#123;dnumb&#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;dnumb&quot; @input=&quot;$emit(&#x27;valuechange&#x27;, dnumb)&quot;&gt; &lt;!--监听输入事件，输入时向父组件发送修改的数据--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; num: 1 &#125;, methods: &#123; numbchange(value)&#123; //默认传递的数据为String类型，要进行转换 this.num = parseInt(value) &#125; &#125;, components: &#123; cpn: &#123; template: &quot;#cpn&quot;, props: &#123; numb: Number &#125;, data()&#123; //用v-model实现双向绑定，建议绑定data中的数据，不要之间绑定props中的数据 return &#123; dnumb: this.numb &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 10.2 方法二利用watch属性，watch监听属性值的改变，大量代码和上面重复，会适当用’…’来省略 1234567891011121314151617181920212223242526272829...&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; ... &lt;input type=&quot;text&quot; v-model=&quot;dnumb&quot;&gt; &lt;!--将事件监听变为用watch监听属性值的改变--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; ... components: &#123; cpn: &#123; ... /* watch：监听属性值的改变，一旦改变，就调用方法 属性值.(newValue) 属性值.(newValue, oldValue) */ watch: &#123; dnumb(newValue)&#123; this.$emit(&quot;valuechange&quot;, newValue); &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 十一、父子组件访问11.1 父访问子 （1）$children $children会返回html中使用的所有子组件对象，用数组保存，实际开发中不怎么常用 1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!--子组件对象1--&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!---子组件对象2--&gt; &lt;button @click=&quot;btnClick1()&quot;&gt;按钮($children)&lt;/button&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是子组件&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods:&#123; btnClick1()&#123; //$children会返回html中使用的所有子组件对象，用数组保存 this.$children[0].showMessage(); this.$children[1].showMessage(); &#125; &#125;, components: &#123; cpn: &#123; template: &quot;#cpn&quot;, methods: &#123; showMessage()&#123; alert(&quot;成功调用子组件方法哦！&quot;) &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; $refs $refs.ref名 获取指定子组件对象 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;cpn ref=&quot;cpn3&quot;&gt;&lt;/cpn&gt; &lt;!--子组件3--&gt; &lt;!--若要用$refs来获取子组件对象，要在组件使用添加ref属性--&gt; &lt;button @click=&quot;btnClick2()&quot;&gt;按钮($refs)&lt;/button&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是子组件&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods:&#123; btnClick2()&#123; //$refs.ref名 获取指定子组件对象 this.$refs.cpn3.showMessage(); &#125; &#125;, components: &#123; cpn: &#123; template: &quot;#cpn&quot;, methods: &#123; showMessage()&#123; alert(&quot;成功调用子组件方法哦！&quot;) &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 11.2 子访问父1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;我是父/根组件&lt;/h2&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;|--我是子组件1&lt;/h2&gt; &lt;button @click=&quot;btnClick1()&quot;&gt;子组件1：$parent&lt;/button&gt; &lt;button @click=&quot;btnClick2()&quot;&gt;子组件1：$root&lt;/button&gt; &lt;cpn2&gt;&lt;/cpn2&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;cpn2&quot;&gt; &lt;div&gt; &lt;h2&gt;|----我是子组件1-1&lt;/h2&gt; &lt;button @click=&quot;btnClick1_1()&quot;&gt;子组件1-1：$parent&lt;/button&gt; &lt;button @click=&quot;btnClick2_1()&quot;&gt;子组件1-1：$root&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; showMessage()&#123; alert(&quot;成功调用父组件方法！&quot;) &#125; &#125;, components: &#123; cpn: &#123; template: &quot;#cpn&quot;, methods: &#123; btnClick1() &#123; this.$parent.showMessage(); //调用父组件的方法 &#125;, btnClick2()&#123; this.$root.showMessage(); //访问根组件的方法 &#125; &#125;, //子组件中再定义子组件 components: &#123; cpn2: &#123; template: &quot;#cpn2&quot;, methods: &#123; btnClick1_1() &#123; this.$parent.btnClick1(); //调用父组件方法 &#125;, btnClick2_1() &#123; this.$root.showMessage(); //访问根组件的方法 &#125; &#125; &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 十二、slot插槽12.1 基本使用 组件插槽的目的是让组件具有更强的扩展性 插槽使用思想：抽取共性，保留不同 123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!--没有填写内容，插槽使用默认值--&gt; &lt;cpn&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;!--在组件标签下填写内容，内容会自动替换掉组件中&lt;slot&gt;标签 --&gt; &lt;/cpn&gt; &lt;cpn&gt; &lt;img src=&quot;林克.jpg&quot; width=&quot;150&quot; height=&quot;170&quot;&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是组件&lt;/h2&gt; &lt;slot&gt; &lt;!--定义插槽--&gt; &lt;h3&gt;这里是默认值哦！&lt;/h3&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; cpn: &#123; template: &quot;#cpn&quot; &#125; &#125; &#125;);&lt;/script&gt; 12.2 具名插槽使用 给插槽起别名，用来区分具体使用哪个插槽 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;button slot=&quot;left&quot;&gt;返回&lt;/button&gt; &lt;!--利用slot属性，使用具体的插槽--&gt; &lt;input slot=&quot;center&quot; type=&quot;text&quot; placeholder=&quot;搜索&quot;&gt; &lt;button slot=&quot;right&quot;&gt;登录&lt;/button&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;slot name=&quot;left&quot;&gt; &lt;!--用name属性，给插槽起别名，方便具体使用--&gt; &lt;span&gt;左边&lt;/span&gt; &lt;/slot&gt; &lt;slot name=&quot;center&quot;&gt; &lt;span&gt;中间&lt;/span&gt; &lt;/slot&gt; &lt;slot name=&quot;right&quot;&gt; &lt;span&gt;右边&lt;/span&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; cpn: &#123; template: &quot;#cpn&quot; &#125; &#125; &#125;);&lt;/script&gt; 12.3 编译的作用域123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;cpn v-show=&quot;isShow&quot;&gt;&lt;/cpn&gt; &lt;!--正常显示，使用的是父组件的isShow--&gt;&lt;/div&gt; &lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;这是组件&lt;/h2&gt; &lt;button v-show=&quot;isShow&quot;&gt;按钮&lt;/button&gt; &lt;!--没有显示，使用的时子组件的isShow--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isShow: true &#125;, components: &#123; cpn: &#123; template: &quot;#cpn&quot;, data() &#123; return &#123; isShow: false &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 总结：变量的作用域是看模板，在app模板下的所有变量都是查看app根组件中的数据，在cpn模板下的变量是查看cpn组件的数据 12.4 作用域插槽 作用域插槽：父组件替换插槽的标签，但是内容由子组件来提供 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!--按照上面的编译作用域，app模板的数据都是从app对象中获取，如果要获取子组件中的数据进行修改插槽内容，使用作用域插槽--&gt; &lt;cpn&gt; &lt;!--Vue 2.5.x版本以下要求使用template标签， 新版没有要求--&gt; &lt;template v-slot=&quot;slot&quot;&gt; &lt;!--引入插槽对象，&#x27;slot&#x27;为别名，随意起--&gt; &lt;ol&gt; &lt;li v-for=&quot;game in slot.data&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt; &lt;!--调用插槽中绑定的数据--&gt; &lt;/ol&gt; &lt;/template&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div style=&quot;float: left&quot;&gt; &lt;slot :data=&quot;games&quot;&gt;&lt;!--绑定数据, &#x27;data&#x27;为别名，随意取--&gt; &lt;ul&gt; &lt;li v-for=&quot;game in games&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; cpn: &#123; template: &quot;#cpn&quot;, data()&#123; return &#123; games: [&quot;怪物猎人&quot;, &quot;口袋妖怪&quot;, &quot;塞尔达无双&quot;] &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】课堂练习","slug":"【Vue】课堂练习","date":"2020-11-21T03:39:03.000Z","updated":"2020-11-21T03:58:43.598Z","comments":true,"path":"2020/11/21/【Vue】课堂练习/","link":"","permalink":"https://letere-gzj.github.io/2020/11/21/%E3%80%90Vue%E3%80%91%E8%AF%BE%E5%A0%82%E7%BB%83%E4%B9%A0/","excerpt":"学习Vue时的课堂练习小案例","text":"学习Vue时的课堂练习小案例 一、作业1 需求：遍历数组，数组第一个元素文字颜色为红色，其余元素点击谁，谁变红 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .active &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--需求： 遍历数组，数组第一个文字颜色为红色，其余点击谁，谁变红 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(game, index) in games&quot; :class=&quot;&#123;active: currentIndex === index&#125;&quot; &lt;!--class属性对象绑定，true使用样式--&gt; @click=&quot;changeIndex(index)&quot;&gt; &#123;&#123;game&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; games: [&quot;怪物猎人&quot;, &quot;口袋妖怪&quot;, &quot;异度之刃&quot;, &quot;最终幻想&quot;], currentIndex: 0 //用于表示文字样式状态，默认数组0号位使用样式 &#125;, methods: &#123; changeIndex(index)&#123; //点击修改样式状态值 this.currentIndex = index; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果 二、图书购物系统 style.css 1234567891011121314151617table &#123; border: 1px solid #e9e9e9; border-collapse: collapse; border-spacing: 0;&#125;th, td&#123; padding: 8px 16px; border: 1px solid #e9e9e9; text-align: left;&#125;th &#123; background-color: #f7f7f7; color: #5c6b77; font-weight: 600;&#125; main.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const vue = new Vue(&#123; el: &quot;#app&quot;, data: &#123; books: [ //数据 &#123; id: 1, name: &quot;《算法导论》&quot;, date: &quot;2006-9&quot;, price: 85.00, count: 1 &#125;, &#123; id: 2, name: &quot;《UNIX编程艺术》&quot;, date: &quot;2006-2&quot;, price: 59.00, count: 1 &#125;, &#123; id: 3, name: &quot;《编程珠玑》&quot;, date: &quot;2008-10&quot;, price: 39.00, count: 1 &#125;, &#123; id: 4, name: &quot;《代码大全》&quot;, date: &quot;2006-3&quot;, price: 128.00, count: 1 &#125; ] &#125;, //过滤器 使用格式：&#123;&#123;过滤对象 | 过滤器&#125;&#125; filters: &#123; showPrice(price) &#123; return &quot;￥&quot; + parseFloat(price).toFixed(2); //toFixed(number)：保留小数点后几位 &#125; &#125;, methods: &#123; increment(index) &#123; //数量增加 this.books[index].count ++; &#125;, decrement(index) &#123; //数量减少 this.books[index].count --; &#125;, remove(index)&#123; //移除购物车 this.books.splice(index, 1); &#125; &#125;, computed: &#123; totalPrice() &#123; //计算总价格 let result = 0; for (let i=0; i&lt;this.books.length; i++)&#123; result += this.books[i].count * this.books[i].price; &#125; return result; &#125; &#125;&#125;); 购物车.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&quot;&gt; &lt;!--引入CSS样式--&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;books.length&quot;&gt; &lt;!--v-if , v-else实现购物车为空时页面切换--&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;书籍名称&lt;/th&gt; &lt;th&gt;出版日期&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;购买数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(book, index) in books&quot;&gt; &lt;td&gt;&#123;&#123;book.id&#125;&#125;&lt;/td&gt; &lt;!--为了方便具体表格添加元素，建议手动遍历--&gt; &lt;td&gt;&#123;&#123;book.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;book.date&#125;&#125;&lt;/td&gt; &lt;!--使用过滤器保留两位小数--&gt; &lt;td&gt;&#123;&#123;book.price | showPrice&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button @click=&quot;decrement(index)&quot; :disabled=&quot;book.count &lt; 2&quot;&gt;-&lt;/button&gt; &lt;!--绑定disabled，实现书籍减到1时，无法继续点击--&gt; &#123;&#123;book.count&#125;&#125; &lt;button @click=&quot;increment(index)&quot;&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt; &lt;button @click=&quot;remove(index)&quot;&gt;移除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h2&gt;总价格为：&#123;&#123;totalPrice | showPrice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;h2 v-else&gt;购物车为空&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;!--引入JavaScript代码--&gt;&lt;script src=&quot;./js/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】Vue基本语法","slug":"【Vue】Vue基本语法","date":"2020-11-19T13:05:14.000Z","updated":"2020-11-21T03:41:20.873Z","comments":true,"path":"2020/11/19/【Vue】Vue基本语法/","link":"","permalink":"https://letere-gzj.github.io/2020/11/19/%E3%80%90Vue%E3%80%91Vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"介绍Vue的基本语法","text":"介绍Vue的基本语法 一、Vue的template1.1 代码规范代码规范：缩进使用2个空格 在IDEA中设置： 1.2 设置IDEA模板123456789101112&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot; &#125; &#125;);&lt;/script&gt; 二、插值操作2.1 mustache语法 mustache：插值操作，即&#123;&#123; &#125;&#125; 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--mustache语法支持简单的表达式--&gt; &lt;h2&gt;&#123;&#123;firstName + lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;firstName + &#x27;·&#x27; + lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;number * 2&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, firstName: &quot;莱特&quot;, lastName: &quot;雷&quot;, number: 10 &#125; &#125;);&lt;/script&gt; 2.2 其他的插值操作 （1）v-once 1234&lt;div id=&quot;app&quot;&gt; &lt;!--不会随着数据改变而页面显示也发生改变--&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; (2)v-html 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;!--以html的形式展示url属性--&gt; &lt;h2 v-html=&quot;url&quot;&gt;&lt;/h2&gt; &lt;!--结果：B站--&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, url: &quot;&lt;a href=&#x27;http://bilibili.com&#x27;&gt;B站&lt;/a&gt;&quot; &#125; &#125;);&lt;/script&gt; （3）v-text 1234&lt;div id=&quot;app&quot;&gt; &lt;!--展示文本，与mustache语法相似，但不灵活，一般不使用--&gt; &lt;h2 v-text=&quot;message&quot;&gt;&lt;/h2&gt;&lt;/div&gt; （4）v-pre 1234&lt;div id=&quot;app&quot;&gt; &lt;!--将文本原封不动的进行显示--&gt; &lt;h2 v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--结果：&#123;&#123;message&#125;&#125;--&gt;&lt;/div&gt; （5）v-cloak 案例：解决html中vue加载出现卡顿，导致信息没有及时更改 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; /*拥有v-clock属性的标签不显示内容*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--cloak在被vue解析前存在 在vue解析后会消失 --&gt; &lt;div id=&quot;app&quot; v-cloak&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; setTimeout(function () &#123; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot; &#125; &#125;); &#125;, 1000) &lt;/script&gt;&lt;/body&gt; 二、属性绑定标签中的属性无法使用mustache语法来进行绑定，则需要v-bind来进行绑定 2.1 v-bind基本使用1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;!--标签中属性的取值绑定，不能使用mustache语法--&gt; &lt;!-- 使用v-bind来绑定--&gt; &lt;img v-bind:src=&quot;imgUrl&quot; width=&quot;130&quot; height=&quot;200&quot;/&gt; &lt;!-- v-bind的语法糖 &#x27;:&#x27;--&gt; &lt;a :href=&quot;aUrl&quot;&gt;B站&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, imgUrl: &quot;../../img/刻晴.jpg&quot;, aUrl: &quot;https://www.bilibili.com&quot; &#125; &#125;);&lt;/script&gt; 2.2 动态绑定class （1）对象语法 把对象作为class的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .active&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--原始方法--&gt; &lt;h2 class=&quot;active&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--v-bind绑定--&gt; &lt;h2 :class=&quot;type&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--开发需求：已经点击过的链接颜色发生改变--&gt; &lt;!-- v-bind:class=&quot;&#123;key1: value1, key2: value2 ...&#125;&quot; class绑定可以绑定一个对象 v-bind:class=&quot;&#123;类名1: true, 类名2: false&#125;&quot; boolean值为true，则绑定该类名，false不绑定 --&gt; &lt;h2 :class=&quot;&#123;active: isActive, line: isLine&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--可以在动态绑定class之后，一样可以定义普通class，会自动合并--&gt; &lt;button v-on:click=&quot;change()&quot;&gt;改变&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, type: &quot;active&quot;, isActive: true, isLine: true &#125;, methods: &#123; change : function () &#123; this.isActive = !this.isActive; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; （2）数组语法 一般不会使用，不灵活 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .active&#123; color: red; &#125; .line&#123; font-size: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--数组绑定 注意：数组带&#x27;&#x27;为字符串，不带&#x27;&#x27;为变量，会从vue中寻找 --&gt; &lt;h2 :class=&quot;[&#x27;active&#x27;, &#x27;line&#x27;]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--和普通class可以共存--&gt; &lt;h2 :class=&quot;[type1, type2]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--可以将数组绑定封装在方法中调用--&gt; &lt;h2 :class=&quot;getClass()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, type1: &quot;active&quot;, type2: &quot;line&quot; &#125;, methods: &#123; getClass : function () &#123; return [this.type1, this.type2]; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 2.3、动态绑定style （1）对象语法 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;!--对象绑定 &#123;key1: value1, key2: value2 ...&#125; &#123;属性名: 属性值&#125; 注意：属性名要使用驼峰命名 font-size ==&gt; fontSize，属性值要用&#x27;&#x27;括住，否则被当做变量 --&gt; &lt;h2 :style=&quot;&#123;fontSize: &#x27;50px&#x27;&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 :style=&quot;&#123;fontSize: size + &#x27;px&#x27;&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, size: 50 //可以动态改变字体大小 &#125; &#125;);&lt;/script&gt; （2）数组语法 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;!--数组语法 在数组中传递对象 --&gt; &lt;h2 :style=&quot;[style1, style2]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, //创建数组参数对象 style1: &#123;fontSize: &#x27;50px&#x27;, color: &#x27;white&#x27;&#125;, style2: &#123;backgroundColor: &#x27;red&#x27;&#125; &#125; &#125;);&lt;/script&gt; 四、计算属性计算属性为在展示数据时，先进行数据处理再展示 4.1 计算属性基本使用1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;!--旧方法实现字符拼接--&gt; &lt;h2&gt;&#123;&#123;firstName + &#x27;·&#x27; + lastName&#125;&#125;&lt;/h2&gt; &lt;!--使用方法解决--&gt; &lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt; &lt;!--计算属性：跟方法类似--&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &quot;莱特&quot;, lastName: &quot;雷&quot; &#125;, methods: &#123; getFullName: function () &#123; return this.firstName + &#x27;·&#x27; + this.lastName; &#125; &#125;, //计算属性 computed: &#123; fullName: function () &#123; //看似函数，实则属性 return this.firstName + &#x27;·&#x27; + this.lastName; &#125; &#125; &#125;);&lt;/script&gt; 4.2 计算属性复杂操作1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;总价格为：&#123;&#123;totalPrice&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; games: [ &#123;id: 101, name: &#x27;怪物猎人&#x27;, price: 200&#125;, &#123;id: 102, name: &#x27;塞尔达传说&#x27;, price: 330&#125;, &#123;id: 103, name: &#x27;古剑三&#x27;, price: 98&#125; ] &#125;, //computed执行一次后会有缓存，函数每调用一次就会执行一次，效率比函数好 computed:&#123; totalPrice: function () &#123; let result = 0; for (let i=0; i&lt; this.games.length; i++)&#123; result += this.games[i].price; &#125; return result; /* 其余for循环 */ for (let i in this.games)&#123; //获取下标 result += this.games[i].price; &#125; for (let game of games)&#123; //获取对象 result += game.price; &#125; &#125; &#125; &#125;);&lt;/script&gt; 4.3 计算属性getter和setter 计算属性本质是一个类，里面包含一个get、set方法，所有调用计算属性的时候不用函数的形式调用，直接使用属性名 12345678910111213141516171819202122232425262728&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &quot;莱特&quot;, lastName: &quot;雷&quot; &#125;, computed: &#123; // 计算属性的简写方法 // fullName: function () &#123; // return this.firstName + &#x27;·&#x27; + this.lastName; // &#125; //计算属性详细写法 //一般计算属性只要实现get方法就可以 fullName: &#123; set: function (newValue) &#123; const names = newValue.split(&#x27; &#x27;); this.firstName = names[0]; this.lastName = names[1]; &#125;, get : function () &#123; return this.firstName + &#x27;·&#x27; + this.lastName; &#125; &#125; &#125; &#125;);&lt;/script&gt; 4.4 计算属性和methods的区别 计算属性使用后会有缓存，效率要比method效率高 五、ES6语法5.1 块级作用域 var可以看作为JavaScript的语言设计上的错误，且不能修复和移除，因为要向后兼容。因此设计出let来替代var。let拥有块级作用域，var没有 1234567&lt;script&gt; &#123; var name = &quot;莱特雷&quot;; console.log(name); &#125; console.log(name); //var没有块级作用域，&#x27;&#123;&#125;&#x27;里面外面都能用&lt;/script&gt; 在es5之前，因为if和for都没有块级作用域的概念，所有在很多时候，我们都必须借助function作用域来解决引用外面变量的问题 es6加入了let，let拥有了if和for的的作用域 5.2 const关键字 const：将某个变量变成常量，不可再次赋值 const使用注意： 1.不能重新赋值 2.在创建的时候一定要赋值 3.常量指向的对象不能修改，但是对象内的属性可以修改 5.3 对象字面量增强写法 字面量：const Obj = {} ，中’{}’内的内容为字面量 （1）属性增强写法 123456789ES5写法 const name = &quot;莱特雷&quot;; const age = 18; const person = &#123; name: name, age: age &#125; console.log(person); 123456789ES6写法 const name = &quot;莱特雷&quot;; const age = 18; const person2 = &#123; name, age, &#125; console.log(person2) （2）函数定义增强写法 1234567ES5写法 const func = &#123; run: function () &#123; console.log(&quot;跑步&quot;) &#125; &#125;; func.run(); 1234567ES6写法 const func2 = &#123; run() &#123; console.log(&quot;跑步&quot;) &#125; &#125;; func2.run(); 六、事件监听 Vue使用v-on来监听事件 6.1 v-on介绍 作用：绑定事件监听器 语法糖：@ 预期：Function|Inline Statement|Object 参数：event 6.2 v-on参数传递 （1）无参函数 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;!--无参，括号可省略--&gt; &lt;button @click=&quot;btn1Click&quot;&gt;按钮1&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; btn1Click() &#123; console.log(&quot;btn1被按下&quot;); &#125; &#125; &#125;);&lt;/script&gt; （2）带参函数 1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;!--1、有参，正常使用--&gt; &lt;button @click=&quot;btn2Click(&#x27;按钮2&#x27;)&quot;&gt;按钮2-1&lt;/button&gt; &lt;!--2、有参，传递空参 会传递undifine属性给函数 --&gt; &lt;button @click=&quot;btn2Click()&quot;&gt;按钮2-2&lt;/button&gt; &lt;!--undefined被按下--&gt; &lt;!--3、有参，省略括号调用 换传递浏览器自动生成的event事件对象 --&gt; &lt;button @click=&quot;btn2Click&quot;&gt;按钮2-3&lt;/button&gt; &lt;!--[object MouseEvent]被按下--&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; btn2Click(name)&#123; console.log(name + &quot;被按下&quot;); &#125; &#125; &#125;);&lt;/script&gt; （3）传参并传事件 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;!--同时获取普通参数，以及浏览器事件，可以使用$event手动获取浏览器事件--&gt; &lt;button @click=&quot;btn3Click(&#x27;按钮3&#x27;, $event)&quot;&gt;按钮3&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; btn3Click(name, event)&#123; console.log(&quot;按钮：&quot; + name + &quot;, &quot; + &quot;事件：&quot; + event); &#125; &#125; &#125;);&lt;/script&gt; 6.3 v-on修饰符 （1）stop修饰符 阻止事件冒泡：触发按钮事件的同时，不触发div事件 1234567891011121314151617&lt;!-- 1、stop修饰符 --&gt;&lt;div id=&quot;app&quot; @click=&quot;divClick&quot;&gt; 这是div文本 &lt;button @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt; &lt;!--阻止事件冒泡--&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; btnClick() &#123; console.log(&quot;btnClick&quot;); &#125; &#125; &#125;);&lt;/script&gt; （2）prevent修饰符 阻止自动执行的事件（网页跳转，表单提交） 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;!--2、阻止页面自动跳转--&gt; &lt;a href=&quot;https://www.bilibili.com&quot; v-on:click.prevent=&quot;alert()&quot;&gt;bilibili&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; alert()&#123; alert(&quot;正要跳转bilibili!&quot;); &#125; &#125; &#125;);&lt;/script&gt; （3）{keyCode}修饰符 指定监听键盘特定按键 12345678910111213141516171819&lt;div id=&quot;app&quot; @click=&quot;divClick&quot;&gt; &lt;!-- 3、监听键盘某个按键的点击 案例：监听Enter键的按下 --&gt; &lt;input type=&quot;text&quot; @keyup.enter=&quot;keyUp&quot; /&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, // el: &quot;#div2&quot;, methods: &#123; keyUp() &#123; console.log(&quot;正在使用键盘按钮&quot;) &#125; &#125; &#125;);&lt;/script&gt; （4）native 用于组件的修饰符，暂时不讲 （5）once修饰符 事件只触发一次 123456789101112131415161718&lt;!-- 1、stop修饰符 --&gt;&lt;div id=&quot;app&quot;&gt; &lt;!--事件只触发一次--&gt; &lt;button @click.once=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; btnClick() &#123; console.log(&quot;btnClick&quot;); &#125; &#125; &#125;);&lt;/script&gt; 七、条件判断7.1 v-if1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;isShow&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;change()&quot;&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, isShow: true &#125;, methods: &#123; change() &#123; this.isShow = !this.isShow; &#125; &#125; &#125;);&lt;/script&gt; 7.2 v-if和v-else123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;isShow&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 v-else&gt;isShow为false时显示我&lt;/h2&gt; &lt;button @click=&quot;change()&quot;&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot;, isShow: true &#125;, methods: &#123; change() &#123; this.isShow = !this.isShow; &#125; &#125; &#125;);&lt;/script&gt; 7.3 v-if和v-else-if和v-else12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/p&gt; &lt;p v-else-if=&quot;score&gt;=80&quot;&gt;良好&lt;/p&gt; &lt;p v-else-if=&quot;score&gt;=60&quot;&gt;及格&lt;/p&gt; &lt;p v-else&gt;不及格&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; score: 55 &#125; &#125;);&lt;/script&gt; 7.4 v-if小案例 用户登录可以选择登录的方式 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;isUser&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户账号&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;请输入用户账号&quot;/&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for=&quot;email&quot;&gt;用户邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;请输入用户邮箱&quot;/&gt; &lt;/span&gt; &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换登录&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isUser: true &#125; &#125;);&lt;/script&gt; 问题：input输入框在切换登录形式时没有清空，仍然保留前面的信息 原因：Vue内部使用虚拟Dom，会出于性能考虑，尽量使用重复的元素，而不是新建元素 解决方法：在input标签中添加key属性，作为唯一标识，vue会识别key属性是否相同，不相同就不会复用 12345...&lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;请输入用户账号&quot; key=&quot;username&quot;/&gt;...&lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;请输入用户邮箱&quot; key=&quot;email&quot;/&gt;... 7.5 v-show使用1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;!-- 条件元素为false： v-if ：包含的元素不会存在Dom中 v-show：只是个元素添加行内样式&#x27;display: none&#x27;，来隐藏，仍然存在Dom中 --&gt; &lt;h2 v-if=&quot;isShow&quot; id=&quot;if&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 v-show=&quot;isShow&quot; if=&quot;show&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊&quot;, isShow: true &#125; &#125;);&lt;/script&gt; 八、循环遍历8.1 遍历数组12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;!--遍历数组 一个取值时，获取的是数组元素 两个取值时，参数1时数组元素，参数2是数组下标 --&gt; &lt;ul&gt; &lt;li v-for=&quot;name in names&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;(name, index) in names&quot;&gt;&#123;&#123;index+1&#125;&#125;、&#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; names: [&quot;莱特雷&quot;, &quot;C酱&quot;, &quot;咕料&quot;, &quot;定春&quot;] &#125; &#125;);&lt;/script&gt; 8.2 遍历对象1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;!--遍历对象中的属性 在遍历对象中，如何只获取一个值，获取的是value 获取两个值时，参数1为value，参数2为key 获取三个值时，参数1为value，参数2为key，参数3为index --&gt; &lt;ul&gt; &lt;li v-for=&quot;value in person&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in person&quot;&gt;&#123;&#123;key + &quot;: &quot; + value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key, index) in person&quot;&gt;&#123;&#123;index+1 + &quot;、&quot; + key + &quot;: &quot; + value&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; person: &#123; name: &quot;C酱&quot;, age: 18, hair: &quot;没有&quot; &#125; &#125; &#125;);&lt;/script&gt; 8.3 v-for绑定key 在v-for使用中，可以绑定一个key，key的值要唯一，建议之间绑定数组元素。 绑定key，在数组插入元素时，会直接才插入的位置，创建新的元素，不需要进行额外操作 未绑定key，会在尾部创建一个元素，然后逐步从插入的位置进行替换 8.4 数组响应式 数据的响应式，即数据发生修改，页面内容自动更新 数组中具有响应式的方法： （1）push()：在数据尾部添加数据 （2）pop()：从尾部开始删除数据 （3）shift()：从头部开始删除数据 （4）unshift()：在数据头部添加元素 （5）splice(起始位置, 删除元素个数, 插入参数) （6）sort()：排序 （7）reverse()：反转 （8）Vue.set(要修改的对象, 索引值, 修改值)：Vue自带的方法 数组中不具有响应式的方法 （1）通过数组下标修改数组 九、JavaScript高阶函数9.1 正常写法123456789101112131415161718192021222324252627282930313233343536&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; numbs: [1, 8, 24, 50, 99, 100 ,152, 365, 777] &#125;, methods: &#123; /* 编程范式：命令式编程/声明式编程 编程范式：面向对象编程（第一公民：对象）/函数式编程（第一公民：函数） */ getNumbers() &#123; //需求1：将所有小于100的数提取出来 let newNums = []; for (let num of this.numbs) &#123; if (num &lt; 100) &#123; newNums.push(num); &#125; &#125; //需求2：将上面数据x2 for (let i in newNums) &#123; newNums[i] = 2 * newNums[i]; &#125; //需求3：将该数组相加求和 let totalNum = 0; for (let num of newNums) &#123; totalNum += num; &#125; return totalNum; &#125; &#125; &#125;&lt;/script&gt; 9.2 高阶函数使用123456789101112131415161718getNumbers2 () &#123; //1、filter中的回调函数，必须返回boolean值。 //返回true时，会自动将遍历的元素，加入到新的数组中 let newNums = this.numbs.filter(function (n) &#123; return n &lt; 100; &#125;); //2、map函数，遍历所有元素，返回对元素操作后的数据，加入到新数组中 let newNum2 = newNums.map(function (n) &#123; return n*2; &#125;); //3、reduce：对数据中所有内容进行汇总 let totalNum = newNum2.reduce(function (preValue, n) &#123; return preValue + n; &#125;, 0); //0为初始值，即第一次遍历的perValue值 return totalNum;&#125; 9.3 链式编程123456789101112//链式编程getNumbers3() &#123; let total = this.numbs.filter(function (n) &#123; return n &lt; 100; &#125;).map(function (n) &#123; return n*2; &#125;).reduce(function (preValue, n) &#123; return preValue + n; &#125;, 0) return total;&#125; 9.4 箭头函数（Lambda表达式）12345//箭头函数（Lambda表达式）getNumbers4()&#123; let total = this.numbs.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2).reduce((preValue, n) =&gt; preValue + n, 0); return total;&#125; 十、表单绑定10.1 v-model基本使用 v-model实现表单元素和数据的双向绑定 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;!--双向绑定数据：前端数据改变，后端数据也跟着改变--&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot; &#125; &#125;);&lt;/script&gt; 10.2 v-model实现原理123456789101112131415161718192021222324&lt;!--用已有的知识实现v-model--&gt;&lt;div id=&quot;app&quot;&gt; &lt;!--方式一--&gt; &lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;varChange&quot;&gt; &lt;!--方式二--&gt; &lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot;&gt; &lt;br/&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot; &#125;, methods :&#123; varChange(event)&#123; this.message = event.target.value; &#125; &#125; &#125;);&lt;/script&gt; 总结：v-model可以看做是v-bind和v-on组合使用的一个实例 10.3 v-model结合radio使用（单选）12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;label form=&quot;male&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;male&quot; name=&quot;sex&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男 &lt;!--v-model绑定同一个属性时，可以省略name，来实现单选的互斥--&gt; &lt;/label&gt; &lt;label form=&quot;female&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;female&quot; name=&quot;sex&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女 &lt;/label&gt; &lt;h3&gt;选择的性别是：&#123;&#123;sex&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; sex: &#x27;男&#x27; //直接设置默认值，不用添加标签参数checked &#125; &#125;);&lt;/script&gt; 10.4 v-model结合checkbox使用 （1）单选框 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;!--checkbox单选框--&gt; &lt;label for=&quot;license&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;license&quot; v-model=&quot;isAgree&quot;&gt;同一协议 &lt;h3&gt;你的选择是：&#123;&#123;isAgree&#125;&#125;&lt;/h3&gt; &lt;button :disabled=&quot;!isAgree&quot;&gt;下一步&lt;/button&gt; &lt;/label&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isAgree: false //单选框对应boolean类型 &#125; &#125;);&lt;/script&gt; （2）多选框 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;!--checkbox多选框--&gt; &lt;input type=&quot;checkbox&quot; value=&quot;怪物猎人&quot; v-model=&quot;games&quot;&gt;怪物猎人 &lt;input type=&quot;checkbox&quot; value=&quot;蜘蛛侠&quot; v-model=&quot;games&quot;&gt;蜘蛛侠 &lt;input type=&quot;checkbox&quot; value=&quot;最终幻想&quot; v-model=&quot;games&quot;&gt;最终幻想 &lt;input type=&quot;checkbox&quot; value=&quot;塞尔达传说&quot; v-model=&quot;games&quot;&gt;塞尔达传说 &lt;h3&gt;你喜欢的游戏是：&#123;&#123;games&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; games: [] //多选框对应数组类型 &#125; &#125;);&lt;/script&gt; 10.5 v-model结合select使用 （1）选择一个 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;!--选择一个--&gt; &lt;select name=&quot;game&quot; v-model=&quot;game&quot;&gt; &lt;option value=&quot;怪物猎人&quot;&gt;怪物猎人&lt;/option&gt; &lt;option value=&quot;漫威蜘蛛侠&quot;&gt;漫威蜘蛛侠&lt;/option&gt; &lt;option value=&quot;塞尔达传说&quot;&gt;塞尔达传说&lt;/option&gt; &lt;option value=&quot;刺客信条&quot;&gt;刺客信条&lt;/option&gt; &lt;/select&gt; &lt;h3&gt;选择的游戏的是：&#123;&#123;game&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; game: &#x27;怪物猎人&#x27; &#125; &#125;);&lt;/script&gt; （2）选择多个 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;!--选择多个--&gt; &lt;select name=&quot;game&quot; v-model=&quot;games&quot; multiple&gt; &lt;option value=&quot;怪物猎人&quot;&gt;怪物猎人&lt;/option&gt; &lt;option value=&quot;漫威蜘蛛侠&quot;&gt;漫威蜘蛛侠&lt;/option&gt; &lt;option value=&quot;塞尔达传说&quot;&gt;塞尔达传说&lt;/option&gt; &lt;option value=&quot;刺客信条&quot;&gt;刺客信条&lt;/option&gt; &lt;/select&gt; &lt;h3&gt;选择的游戏的是：&#123;&#123;games&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; games: [] &#125; &#125;);&lt;/script&gt; 10.6 v-model的修饰符 （1）lazy修饰符 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;!--1、lazy：取消实时更新，当用户按Enter或失去焦点时才更新数据--&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;你好啊！&quot; &#125; &#125;);&lt;/script&gt; （2）number修饰符 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;!--2、number：绑定的值为number类型，v-model默认绑定的时String类型，若要后台读取的是number类型，需要添加此修饰符--&gt; &lt;input type=&quot;number&quot; v-model.number=&quot;num&quot;&gt; &lt;h3&gt;&#123;&#123;num&#125;&#125; + &#123;&#123;typeof num&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; num: 0 &#125; &#125;);&lt;/script&gt; （3）trim修饰符 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;!--3、trim：去除两边的空格--&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;../../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; text: &#x27;去除空格&#x27; &#125; &#125;);&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【Vue】认识Vue","slug":"【Vue】认识Vue","date":"2020-11-17T12:27:44.000Z","updated":"2020-11-19T13:03:57.544Z","comments":true,"path":"2020/11/17/【Vue】认识Vue/","link":"","permalink":"https://letere-gzj.github.io/2020/11/17/%E3%80%90Vue%E3%80%91%E8%AE%A4%E8%AF%86Vue/","excerpt":"Vue的简单认识","text":"Vue的简单认识 一、认识VuejsVue是一个渐进式的框架 渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验 Vue特点和功能： 解耦视图和数据 可复用的组件 前端路由技术 状态管理 虚拟DOM 学习Vue需要基础： HTML CSS JavaScript 官网：https://cn.vuejs.org/ 二、Vue.js安装2.1 CDN引入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!--开发环境版本，包含了有帮助的命令行警告--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!--生成环境版本，又花了尺寸和速度--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;````#### 2.2 下载和引入（ctrl + s 保存）&lt;br/&gt;开发环境：https://vuejs.org/js/vue.js &lt;br/&gt;生成环境：https://vuejs.org/js/vue.min.js#### 2.3 npm安装后面课程使用再讲---### 三、Hello Vuejs#### 3.1 Vue简单使用```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;!--div交给vue管理，会识别&#123;&#123;&#125;&#125;语法--&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;!--没有交给vue管理，无法识别&#123;&#123;&#125;&#125;--&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;!--引入vuejs--&gt; &lt;script&gt; /* let(es6中定义变量) const(es6定义常量) 在vue中一般不使用var，因为没有作用域，会有一定的局限性 */ //编程范式：声明式编程 //好处：数据和界面完全分离 const vue = new Vue(&#123; el: &#x27;#app&#x27;, //管理div标签 data: &#123; //定义数据 message: &#x27;Hello, Vuejs!&#x27; &#125; &#125;); /*原生js做法（编程范式：命令式编程） 1.创建div元素，设置id属性 2.定义一个变量为message 3.将message变量放在前面的div元素中显示 */ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.2 Vue列表展示1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;game in games&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt; &lt;!-- v-for 是 vue用来遍历数据元素的方法--&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vue = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; games: [&#x27;怪物猎人&#x27;, &#x27;刺客信条&#x27;, &#x27;塞尔达传说&#x27;] &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.3 (案例)计数器1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;当前计数：&#123;&#123;counter&#125;&#125;&lt;/h3&gt; &lt;!--方式一：--&gt; &lt;!-- &lt;button v-on:click=&quot;counter++&quot;&gt;+&lt;/button&gt;--&gt; &lt;!-- &lt;button @click=&quot;counter&amp;#45;&amp;#45;&quot;&gt;-&lt;/button&gt;--&gt; &lt;!--方式二：--&gt; &lt;button v-on:click=&quot;add()&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;sub()&quot;&gt;-&lt;/button&gt; &lt;!--&#x27;@&#x27; 是 &#x27;v-on:&#x27; 的语法糖(简写)--&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vue = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0 &#125;, methods: &#123; //定义方法 add: function () &#123; this.counter++; &#125;, sub: function () &#123; this.counter--; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 四、Vue的MVVNMVVM(Model View ViewModel) 五、Vue的Options选项 官网查看：https://cn.vuejs.org/v2/api 目前掌握选项： el： 类型：String | HTMLElement 作用：决定之后Vue实例会管理哪一个DOM data： 类型：Object | Function（组件当中data必须存的是函数） 作用：Vue实例对应的数据对象 methods： 类型：([key:String]:Function) 作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用 六、Vue的生命周期6.1 new Vue()源码查看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Vue (options) &#123; if (!(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;); &#125; this._init(options); //初始化&#125;function initMixin (Vue) &#123; //初始化函数 Vue.prototype._init = function (options) &#123; var vm = this; // a uid vm._uid = uid$3++; var startTag, endTag; /* istanbul ignore if */ if (config.performance &amp;&amp; mark) &#123; startTag = &quot;vue-perf-start:&quot; + (vm._uid); endTag = &quot;vue-perf-end:&quot; + (vm._uid); mark(startTag); &#125; // a flag to avoid this being observed vm._isVue = true; // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; /* istanbul ignore else */ &#123; initProxy(vm); &#125; // expose real self 内部调用其他的初始化函数 vm._self = vm; initLifecycle(vm); initEvents(vm); initRender(vm); //钩子函数 callHook(vm, &#x27;beforeCreate&#x27;); initInjections(vm); // resolve injections before data/props initState(vm); initProvide(vm); // resolve provide after data/props callHook(vm, &#x27;created&#x27;); /* istanbul ignore if */ if (config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false); mark(endTag); measure((&quot;vue &quot; + (vm._name) + &quot; init&quot;), startTag, endTag); &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125; &#125;;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"}],"tags":[]},{"title":"【JavaWeb】JavaScript使用","slug":"【JavaWeb】JavaScript使用","date":"2020-11-16T13:39:02.000Z","updated":"2020-11-17T12:23:12.042Z","comments":true,"path":"2020/11/16/【JavaWeb】JavaScript使用/","link":"","permalink":"https://letere-gzj.github.io/2020/11/16/%E3%80%90JavaWeb%E3%80%91JavaScript%E4%BD%BF%E7%94%A8/","excerpt":"JavaScript的使用笔记","text":"JavaScript的使用笔记 一、JavaScript介绍JavaScript语言主要是完成页面的数据验证，因此它运行在客户端，运行浏览器来解析执行JavaScript代码。JS是弱类型语言，类型可变Java是强类型语言，类型已确定，并且不可变 特点： （1）交互性：可以实现信息的动态交互 （2）安全性：不允许直接访问本地硬盘 （3）跨平台性：只要是可以解释JS的浏览器都可以执行，与平台无关 二、JavaScript和html代码结合2.1 方式一在head标签中，或者body标签中，使用script标签来书写JavaScript代码 12345678&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //alert是JavaScript的一个警告框函数 alert(&quot;这里是警告框&quot;); &lt;/script&gt;&lt;/head&gt; 2.2 方式二跟css类，将JavaScript写入一个单独的文件，通过script标签来引入，实现代码复用 123456&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--通过src来进行引入--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/hello.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 注意： 一个标签内，两种方法只能使用一个，若需要使用另一种方法，请重新创建script标签 三、变量JavaScript变量类型： 数值类型：number 字符串类型：string 对象类型：object 布尔类型：boolean 函数类型：function JavaScript里特殊的值： undefined：未定义，所有js变量未赋予初始值的时候，默认值为undefined null：空值 NaN：(Not a Number)非数字，非数值 JS中定义变量的格式： var 变量名; var 变量名 = 值; 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var i; //值为undefined console.log(i); //控制台输出 i = 1; console.log(typeof(i)); //typeof返回变量的类型 i = &quot;abc&quot;; console.log(typeof i); //JS为弱类型，变量定义了仍然可以发生改变 i = 12 * &quot;abc&quot;; //虽然语法没错，但最后结果为NaN(Not a Number) console.log(i);&lt;/script&gt; 四、运算符4.1 关系运算符大部分与Java一样，就不仔细讲，只讲特殊的 等于：== 简单的字面值比较 全等于：=== 除了做字面值的比较外，还会比较两个变量的数据类型 123456789测试等于和全等于 &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var a = &quot;12&quot;; var b = 12; console.log(a == b); //只是简单的比较字面值 console.log(a === b); //不仅比较字面值，还比较变量类型 &lt;/script&gt; 4.2 逻辑运算符且运算：&amp;&amp; 情况一：当表达式全为真时，返回最后一个表达式的值 情况二：当表达式中，有一个假时，返回第一个假的表达式的值 或运算：|| 情况一：当表达式全为假时，但会最后一个表达式的值 情况二：只要有一个表达式为真，就返回第一个为真的表达式的值 取反运算：! 在JavaScript中，所有的变量都可以作为一个boolean类型去使用 0、null、undifined、””（空串）、NaN都是认为false，其余都是true 12345678910111213141516171819202122232425262728293031323334353637变量boolean值测试 &lt;script type=&quot;text/javascript&quot;&gt; var a = 0; if (a)&#123; console.log(&quot;0为真&quot;); &#125;else &#123; console.log(&quot;0为假&quot;); &#125; var b = null; if (b)&#123; console.log(&quot;null为真&quot;); &#125;else &#123; console.log(&quot;null为假&quot;); &#125; var c; if (c)&#123; console.log(&quot;undefined为真&quot;); &#125;else &#123; console.log(&quot;undefined为假&quot;); &#125; var d = &quot;&quot;; if (d)&#123; console.log(&quot;空串为真&quot;); &#125;else &#123; console.log(&quot;空串为假&quot;); &#125; var e = 1 * &quot;a&quot;; if (e)&#123; console.log(&quot;NaN为真&quot;); &#125;else &#123; console.log(&quot;NaN为假&quot;); &#125; &lt;/script&gt; 12345678910测试关系运算符 &lt;script type=&quot;text/javascript&quot;&gt; console.log(1 &amp;&amp; true); //全真返回最后一个真值 true console.log(1 &amp;&amp; null); //出现假，返回第一个假值 null console.log(0 &amp;&amp; null); //返回第一个假值 0 console.log(1 || true); //出现一个真，返回第一个真值 1 console.log(false || 1); // 1 console.log(null || false); //都为假，返回最后一个假值 false &lt;/script&gt; 五、数组JS中数组定义方式： 12var 数组名 = []; //空数组var 数组名 = [1, &#x27;abc&#x27;, true]; //定义数组时并赋值 JS的数组定义不会限制长度，可以通过下标向数组添加元素，会自动进行扩容。并且可以存储不同类型的元素。 JS数组的遍历与Java一样 12345678&lt;script type=&quot;text/javascript&quot;&gt; var a = [1, &quot;abc&quot;, null, NaN]; a[5] = true; //数组会自动扩容，并前面没有赋值的会定义为undefined for (var b = 0; b &lt; a.length; b++)&#123; console.log(a[b]); &#125;&lt;/script&gt; 六、函数6.1 使用方式一使用function关键字来定义函数 123function 函数名(形参列表)&#123; 函数体&#125;; 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; //无参函数 function fun() &#123; console.log(&quot;无参函数执行了！&quot;); &#125; fun(); //函数调用 //带参函数 function sum(a, b) &#123; console.log(a + b); &#125; sum(1, 2); //带返回值函数 function minus(a, b) &#123; return a - b; &#125; console.log(minus(10, 1));&lt;/script&gt; 6.2 使用方式二1var 函数名 = function(形参列表)&#123;函数体&#125; 123456&lt;script type=&quot;text/javascript&quot;&gt; var sum = function (a, b) &#123; return a + b; &#125; console.log(sum(1, 1));&lt;/script&gt; 注意： JS中不允许函数重载 6.3 隐形参数在function中不需要定义，但却可以直接用来获取所有参数的变量，称为隐形参数。 JS隐形参数类似于Java的可变长度参数public void fun(Object arguments...)，所以操作方式也和Java一样，使用数组的方式读取参数，存放在名为arguments的数组中 123456789&lt;script type=&quot;text/javascript&quot;&gt; function f() &#123; for (var i = 0; i &lt;arguments.length; i++)&#123; console.log(arguments[i]); &#125; &#125; f(&quot;这&quot;, &quot;是&quot;, &quot;隐&quot;, &quot;形&quot;, &quot;参&quot;, &quot;数&quot;);&lt;/script&gt; 七、自定义对象7.1 方式一Object形式自定义对象 123var 变量名 = new Object(); //空对象变量名.属性 = 值; //定义对象的属性变量名.函数名 = function()&#123;&#125;; //定义对象中的函数(方法) 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var human = new Object(); human.name = &quot;莱特雷&quot;; human.age = 21; human.sex = &quot;男&quot; human.print =function () &#123; console.log(human.name + human.age + human.sex); &#125; console.log(human); //打印对象 human.print(); //函数调用&lt;/script&gt; 7.2 方式二使用&#123;&#125;的形式自定义对象 12345var 变量名 = &#123; 属性名: 值, //用逗号隔开 属性名: 值, 函数名: function()&#123;&#125;&#125; 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; var game = &#123; name: &quot;怪物猎人&quot;, price: 400, company: &quot;卡普空&quot;, buy: function () &#123; console.log(&quot;成功购买！&quot;) &#125; &#125; console.log(game);&lt;/script&gt; 八、事件事件是电脑输入设备与页面进行交互的响应。 常用事件： onload：加载完毕事件 onclick：单击事件 conblur：失去焦点事件—常用于输入框失去焦点后，验证其输入的内容是否合法 onchange：内容发生改变事件—常用语下拉列表和输入框内容发生改变后操作 onsumbit：表单提交事件—在表单提交前，验证表单数据是否合法 8.1 事件注册事件注册（绑定）：告诉浏览器，当事件响应后要执行的哪些操作代码 （1）静态事件注册 通过html标签的事件属性直接赋予事件响应后的代码 （2）动态事件注册 指先通过js代码得到标签的dom对象，然后再通过dom对象.事件名 = function(){}这种形式赋予事件响应后的代码 8.2 onload事件使用（1）静态注册 123&lt;!--方式一--&gt;&lt;body onload=&quot;alert(&#x27;静态注册onload事件&#x27;)&quot;&gt;&lt;/body&gt; 12345678910111213&lt;!--方式二--&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function funcOnload() &#123; alert(&quot;静态注册onload事件&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;funcOnload()&quot;&gt; &lt;!--函数调用--&gt;&lt;/body&gt; （2）动态注册 1234567891011&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; alert(&quot;动态注册onload事件&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 8.3 单击事件使用（1）静态注册 1&lt;button onclick=&quot;alert(&#x27;静态注册onclick&#x27;)&quot;&gt;按钮&lt;/button&gt; 123456789101112&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function funcOnclick() &#123; alert(&quot;静态注册onclick&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;funcOnclick()&quot;&gt;按钮&lt;/button&gt;&lt;/body&gt; （2）动态注册 123456789101112131415161718192021222324&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //动态注册 window.onload = function () &#123; //1.获取标签对象 /* document是JavaScript语言提供的一个对象 document标识整个页面的所有内容 getElementById：获取元素(标签)，通过ID属性 */ var btnObject = document.getElementById(&quot;btn&quot;); //[object HTMLButtonElement] //2.通过标签对象.事件名 = function()&#123;&#125; btnObject.onclick = function () &#123; alert(&quot;动态注册onclikc&quot;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;/body&gt; 8.4 失去焦点事件使用（1）静态注册 123456789101112&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function funcOnblur() &#123; console.log(&quot;静态注册onblur事件&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; onblur=&quot;funcOnblur()&quot;/&gt;&lt;/body&gt; （2）动态注册 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var username = document.getElementById(&quot;username&quot;); username.onblur = function () &#123; console.log(&quot;动态注册onblur事件&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input id=&quot;username&quot; type=&quot;text&quot;/&gt;&lt;br/&gt;&lt;/body&gt; 8.5 内容发生改变事件使用（1）静态注册 123456789101112131415161718&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function funcOnchange() &#123; alert(&quot;选了也不给你玩！&quot;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 选择游戏：&lt;br/&gt; &lt;select onchange=&quot;funcOnchange()&quot;&gt; &lt;option&gt;-请选择-&lt;/option&gt; &lt;option&gt;怪物猎人&lt;/option&gt; &lt;option&gt;刺客信条&lt;/option&gt; &lt;option&gt;看门狗&lt;/option&gt; &lt;/select&gt;&lt;/body&gt; （2）动态注册 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var SG = document.getElementById(&quot;selectGame&quot;); SG.onchange = function () &#123; alert(&quot;选了也不给你玩！&quot;); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 选择游戏：&lt;br/&gt; &lt;select id=&quot;selectGame&quot;&gt; &lt;option&gt;-请选择-&lt;/option&gt; &lt;option&gt;怪物猎人&lt;/option&gt; &lt;option&gt;刺客信条&lt;/option&gt; &lt;option&gt;看门狗&lt;/option&gt; &lt;/select&gt;&lt;/body&gt; 8.6 表单提交事件使用静态注册 1234567891011121314&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function funcOnsubmit() &#123; alert(&quot;静态注册onsubmit!&quot;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form onsubmit=&quot;funcOnsubmit()&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt; 动态注册 1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var FS = document.getElementById(&quot;FS&quot;); FS.onsubmit = function () &#123; alert(&quot;动态注册onsubmit&quot;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;FS&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/body&gt; 九、DOM模型DOM（Document Object Model）文档对象模型 即：把文档中的标签，属性，文本，转换成对象来管理 9.1 document对象理解： （1）Document它管理了所有的html文档的内容 （2）document它是一种树结构的文档，有层级关系 （3）它让我们把所有标签都对象化 （4）我们可以通过document访问所有的标签对象 9.2 document中的方法(1)document.getElementById(elementId) 通过标签的id属性来获取该标签的dom对象 (2)document.getElementByName(elementName) 通过标签的name属性来获取该标签的dom对象 (3)document.getElementByTagName(tagname) 通过标签名来获取标签的dom对象 (4)document.createElement(tagname) 通过标签名来创建一个标签对象 9.3 getElementById测试12345678910111213141516171819202122232425262728293031323334353637&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 需求：当用户点击校验按钮，获取输入框中的内容，然后验证是否合法 验证规则：由字母，数字，下划线组成，长度为5-12 */ window.onload = function () &#123; var check = document.getElementById(&quot;check&quot;); check.onclick = function () &#123; var username = document.getElementById(&quot;username&quot;); //DOM.属性，可以获取该标签内的属性 var text = username.value; //获取输入框内容 //验证字符串是否符合某个规则，需要使用到正则表达式 //学习地址：https://www.runoob.com/js/js-regexp.html var patt = /^\\w(5,12)$/; //字母，数字，下划线组成，长度为5-12 var error = document.getElementById(&quot;error&quot;); //正则对象.test来测试是否匹配 if (patt.test(text))&#123; alert(&quot;用户名合法！&quot;) &#125;else &#123; alert(&quot;用户名不合法！&quot;) &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt; &lt;br/&gt; &lt;button id=&quot;check&quot;&gt;校验&lt;/button&gt;&lt;/body&gt; 优化判断用户名对错方法 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var check = document.getElementById(&quot;check&quot;); check.onclick = function () &#123; var username = document.getElementById(&quot;username&quot;); var text = username.value; var patt = /^\\w(5,12)$/; if (!patt.test(text))&#123; //innerHTML表示标签中的内容，可读，可写 document.getElementById(&quot;error&quot;).innerHTML = &quot;用户名不合法&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt; &lt;!--添加显示错误文本的信息标签--&gt; &lt;span style=&quot;color: red&quot; id=&quot;error&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;button id=&quot;check&quot;&gt;校验&lt;/button&gt;&lt;/body&gt; 进一步优化判断用户名对错 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var check = document.getElementById(&quot;check&quot;); check.onclick = function () &#123; var username = document.getElementById(&quot;username&quot;); var text = username.value; var patt = /^\\w(5,12)$/; var png = document.getElementById(&quot;png&quot;); if (patt.test(text))&#123; png.src=&quot;../img/green.png&quot;; &#125;else &#123; png.src=&quot;../img/error.png&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt; &lt;img id=&quot;png&quot; src=&quot;&quot; /&gt; &lt;br/&gt; &lt;button id=&quot;check&quot;&gt;校验&lt;/button&gt;&lt;/body&gt; 素材下载： right.png error.png 9.4 getElementsByName测试1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var hobbies = document.getElementsByName(&quot;hobby&quot;); //返回一个集合，每个元素为一个DOM对象 function selectAll() &#123; for (var i=0; i &lt; hobbies.length; i++)&#123; hobbies[i].checked = true; &#125; &#125; function selectNotAll() &#123; for (var i = 0; i &lt; hobbies.length; i++)&#123; hobbies[i].checked = false; &#125; &#125; function selectAlter() &#123; for (var i = 0; i &lt; hobbies.length; i++)&#123; hobbies[i].checked = !hobbies[i].checked; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 兴趣爱好： &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;cpp&quot;&gt;C++ &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;java&quot;&gt;Java &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;js&quot;&gt;JavaScript &lt;br/&gt; &lt;button onclick=&quot;selectAll()&quot;&gt;全选&lt;/button&gt; &lt;button onclick=&quot;selectNotAll()&quot;&gt;全不选&lt;/button&gt; &lt;button onclick=&quot;selectAlter()&quot;&gt;反选&lt;/button&gt;&lt;/body&gt; 9.4 getElementsByTagName测试123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var input = document.getElementsByTagName(&quot;input&quot;); //按照标签名返回一个集合 function selectAll() &#123; for (var i=0; i&lt;input.length; i++)&#123; input[i].checked = true; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;兴趣爱好：&lt;input type=&quot;checkbox&quot; value=&quot;cpp&quot;&gt;C++&lt;input type=&quot;checkbox&quot; value=&quot;java&quot;&gt;Java&lt;input type=&quot;checkbox&quot; value=&quot;js&quot;&gt;JavaScript&lt;br/&gt;&lt;button onclick=&quot;selectAll()&quot;&gt;全选&lt;/button&gt;&lt;/body&gt; 9.5 节点常用属性和方法节点：标签对象 方法： getElementsByTagName()：获取当前节点的指定标签名的子节点 appendChild( childNode)：添加子节点 属性： childNodes：获取当前节点的所有子节点 firstChild：获取当前节点的第一个子节点 lastChild：获取当前节点的最后一个子节点 parentNode：获取当前节点的父节点 nextSibling：获取当前节点的下一个节点 previousSibling：获取当前节点的上一个节点 className：用于获取或设置标签的class属性值 innerHTML：获取/设置起始标签和结束标签的内容 innerText：表示获取/设置起始标签和结束标签的文本 十、补充说明123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //页面加载完后调用函数 window.onload = function () &#123; var divObj = document.createElement(&quot;div&quot;); //创建div标签对象 类似&lt;div&gt;&lt;/div&gt; divObj.innerText = &quot;用createElement创建标签对象&quot;; //添加文本内容： &lt;div&gt;用createElement创建标签对象&lt;/div&gt; document.body.appendChild(divObj); //在body标签中添加子标签，实现div从内存中写入到网页中 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【JavaWeb】html和css","slug":"【JavaWeb】html和css","date":"2020-11-16T12:57:44.000Z","updated":"2020-11-16T13:32:46.984Z","comments":true,"path":"2020/11/16/【JavaWeb】html和css/","link":"","permalink":"https://letere-gzj.github.io/2020/11/16/%E3%80%90JavaWeb%E3%80%91html%E5%92%8Ccss/","excerpt":"html 和 css 的简单介绍","text":"html 和 css 的简单介绍 一、html1.1 html介绍12345678910&lt;!DOCTYPE html&gt; &lt;!--声明--&gt;&lt;html lang=&quot;en&quot;&gt; &lt;!--html标签：标识html的开启， lang：标识语言--&gt;&lt;head&gt; &lt;!--头部信息，主要有三部分（title标签， css样式, js代码）--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--页面使用的编码字符--&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body onclick=&quot;alert(&#x27;这里是警告框哦！&#x27;)&quot;&gt; &lt;!--html标签显示的主体内容--&gt; 内容：hello world!&lt;/body&gt;&lt;/html&gt; html学习网站：https://www.w3school.com.cn/ 1.2 font标签在html5中，font标签已经被摒弃，建议用CSS来决定字体样式 1&lt;font color=&quot;red&quot; face=&quot;宋体&quot; size=&quot;5&quot;&gt;我是字体标签&lt;/font&gt; &lt;!--html5摒弃此标签，建议使用css来修改样式--&gt; 1.3 特殊字符特殊字符查询：https://www.w3school.com.cn/tags/html_ref_entities.html 1234567&lt;!-- 常用特殊字符 &lt; ---- &amp;lt; &gt; ---- &amp;gt; 空格 ---- &amp;nbsp;--&gt;我是&amp;lt;br&amp;gt;标签 1.4 标题标签123456789101112&lt;!-- 标题标签：h1 ---- h6 h1最大，h6最小 标签属性： align: left(左对齐) / center(居中) / right(右对齐)--&gt;&lt;h1 align=&quot;left&quot;&gt;标题1&lt;/h1&gt;&lt;h2 align=&quot;center&quot;&gt;标题2&lt;/h2&gt;&lt;h3 align=&quot;right&quot;&gt;标题3&lt;/h3&gt;&lt;h4&gt;标题4&lt;/h4&gt;&lt;h5&gt;标题5&lt;/h5&gt;&lt;h6&gt;标题6&lt;/h6&gt; 1.5 超链接1234567891011&lt;!--超链接 &lt;a&gt;标签：页面跳转 属性 href=&quot;&quot; :跳转地址 target=&quot;&quot;：设置跳转的属性 _self：当前页面进行跳转（默认） _blank：打开新窗口进行跳转--&gt;&lt;a href=&quot;http://www.bilibili.com&quot;&gt;B站&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.bilibili.com&quot; target=&quot;_self&quot;&gt;B站self&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.bilibili.com&quot; target=&quot;_blank&quot;&gt;B站blank&lt;/a&gt; 1.6 列表标签12345678910111213141516171819&lt;!--列表标签 无序列表 &lt;ul&gt; : unOrder list &lt;li&gt; :list iterm列表内容 有序列表 &lt;ol&gt; : order list 定义列表--&gt;&lt;ul&gt; &lt;li&gt;塞尔达&lt;/li&gt; &lt;li&gt;马里奥&lt;/li&gt; &lt;li&gt;宝可梦&lt;/li&gt; &lt;li&gt;牧场物语&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt; &lt;li&gt;塞尔达&lt;/li&gt; &lt;li&gt;马里奥&lt;/li&gt; &lt;li&gt;宝可梦&lt;/li&gt; &lt;li&gt;牧场物语&lt;/li&gt;&lt;/ol&gt; 1.7 图片标签123456789101112131415&lt;!-- 图片标签 &lt;img&gt; src：设置图片路径 相对路径： . 当前目录 .. 上一级目录 文件名 绝对路径： http://ip:port/工程名/资源路径 width：宽 high：高 border：边框大小 alt：设置当前路径文件找不到时，提示的文本内容--&gt;&lt;img src=&quot;../img/芭芭拉.jpg&quot; width=&quot;200&quot; height=&quot;300&quot; border=&quot;1&quot; alt=&quot;图片找不到&quot;/&gt; 1.8 表格标签1234567891011121314151617181920212223242526272829303132&lt;!--表格标签 例子：做一个带表头，三行，散列的表格，并显示边框 例子2：修改表格的宽度，高度，表格的对齐方式，单元格间距 &lt;table&gt; 表格标签 border 边框大小 width 表格宽度 heigth 表格高度 align 设置表格对于页面的对齐方式 cellspacing 单元格间距 &lt;tr&gt; 行 &lt;th&gt; 表头（自带加粗以及居中） &lt;td&gt; 列--&gt;&lt;table border=&quot;1&quot; width=&quot;200&quot; height=&quot;200&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;1.1&lt;/th&gt; &lt;th&gt;1.2&lt;/th&gt; &lt;th&gt;1.3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.1&lt;/td&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--表格跨行跨列 例子：新建一个五行，五列的表格， 第一行，第一列的单元格要跨两行， 第二行第一列的单元格跨两行， 第四行第四列的单元格跨两行两列 colspan 单元格跨列 rowspan 单元格跨行--&gt;&lt;table border=&quot;1&quot; width=&quot;200&quot; height=&quot;200&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;1.1&lt;/td&gt; &lt;td&gt;1.3&lt;/td&gt; &lt;td&gt;1.4&lt;/td&gt; &lt;td&gt;1.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;td&gt;2.3&lt;/td&gt; &lt;td&gt;2.4&lt;/td&gt; &lt;td&gt;2.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3.2&lt;/td&gt; &lt;td&gt;3.3&lt;/td&gt; &lt;td&gt;3.4&lt;/td&gt; &lt;td&gt;3.5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4.1&lt;/td&gt; &lt;td&gt;4.2&lt;/td&gt; &lt;td&gt;4.3&lt;/td&gt; &lt;td rowspan=&quot;2&quot; colspan=&quot;2&quot;&gt;4.4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;5.1&lt;/td&gt; &lt;td&gt;5.2&lt;/td&gt; &lt;td&gt;5.3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 1.9 iframe标签123456789101112&lt;!-- iftame标签 ： 可以在一个html页面上，打开一个小窗口，去加载一个单独的页面 &lt;iframe&gt; src 显示页面的路径 width 窗口宽度 heigth 窗口高度 注意：iframe标签与a标签组合使用 iframe标签使用name来给该标签起别名 然在a标签的target属性，设置为iframe标签的别名--&gt;&lt;iframe src=&quot;iframe页面.html&quot; name=&quot;iframeTest&quot;&gt;&lt;/iframe&gt;&lt;br/&gt;&lt;a href=&quot;../../hello.html&quot; target=&quot;iframeTest&quot;&gt;iframe进行跳转跳转&lt;/a&gt; 1.10 表单标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- 表单标签：用来收集用户信息的所有元素集合，然后把这些信息发送给服务器 &lt;form&gt; &lt;input&gt; 输入框 type=&quot;text&quot; 类型为文本框 type=&quot;passowrd&quot; 类型为密码框 value 默认值 type=&quot;radio&quot; 类型为单选框 checked=&quot;checked&quot; 默认选择 type=&quot;checkbox&quot; 类型为多选框 type=&quot;reset&quot; 重置按钮，恢复默认值 value 修改按钮文本 type=&quot;submit&quot; 提交按钮，将数据发送给服务器 value 修改按钮文本 type=&quot;file&quot; 选择要上传的文件 type=&quot;hidden&quot; 隐藏域 &lt;select&gt; 下拉选择框 &lt;option&gt; 下拉列表框的选项 selected=&quot;selected&quot; 默认选择 &lt;textarea&gt; 多行文本框 rows 行数 cols 列数--&gt;&lt;form&gt; 用户名：&lt;input type=&quot;text&quot; value=&quot;莱特雷&quot;/&gt; &lt;br/&gt; 密码:&lt;input type=&quot;password&quot;/&gt; &lt;br/&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;checked&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 &lt;br/&gt; 兴趣：&lt;input type=&quot;checkbox&quot;/&gt;Java &lt;input type=&quot;checkbox&quot;/&gt;C语言 &lt;input type=&quot;checkbox&quot;&gt; Python &lt;br/&gt; 国籍：&lt;select&gt; &lt;option selected=&quot;selected&quot;&gt;中国&lt;/option&gt; &lt;option&gt;美国&lt;/option&gt; &lt;option&gt;日本&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 自我评价：&lt;textarea rows=&quot;10&quot;, cols=&quot;20&quot;&gt;这里是默认值&lt;/textarea&gt; &lt;input type=&quot;reset&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;file&quot; /&gt; &lt;br/&gt; &lt;input type=&quot;hidden&quot; /&gt;&lt;/form&gt; 1234567891011121314151617181920212223&lt;!--表单提交 &lt;form&gt; action: 提交服务器的地址 method：提交的方式GET/POST http://localhost:8080/ 服务器地址 ? 分隔符 name=&quot;莱特雷&quot;&amp;sex=&quot;男&quot; 请求参数 若要表达发送数据给服务器，需要设置参数name 对于单选，多选，下拉列表要发送服务器属性，需要添加value参数 GET请求特点： 1.浏览器地址栏中的地址是aciton属性[+?请求参数] 2.请求参数的格式key1=value1&amp;key2=value2&amp;... 3.不安全 4.有数据长度的限制，100字符内 POST请求特点： 1.浏览器地址栏中油action属性值 2.安全 3.理论上没有数据长度限制--&gt; 1.11 其他标签123456789101112&lt;!--其他标签 &lt;div&gt; 默认独占一行 &lt;span&gt; 长度为封装数据的长度 &lt;p&gt; 段落标签，默认在段落的上方下方空出一行--&gt;&lt;div&gt;div标签1&lt;/div&gt;&lt;div&gt;div标签2&lt;/div&gt;&lt;span&gt;span标签1&lt;/span&gt;&lt;span&gt;span标签2&lt;/span&gt;&lt;p&gt;p标签1&lt;/p&gt;&lt;p&gt;p标签2&lt;/p&gt; 二、CSS技术 CSS是层叠样式表单，是用于（增强）控制网页样式并允许将样式信息与网页内容分离的一种标记性语言 2.1 CSS语法格式123p&#123; (选择器)&#123; font-size: 80px; (属性): (值); &#125; &#125; 多个声明：要用分号隔开，虽然最后一个不用分号，为了统一，建议加上（一般一行写一个语句） 2.2 CSS与html结合使用 方式一：在标签的style属性上设置 1&lt;div style=&quot;border: 1px solid red &quot;&gt;div标签1&lt;/div&gt; 缺点： （1）样式过多，代码量巨大 （2）可读性差 （3）代码冗余，没有复用 方式二：在head标签中，使用style标签来定义各种需要的css样式 12345678910111213&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* 将所有div标签都改成以下样式 */ div&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签&lt;/div&gt;&lt;/body&gt; 缺点： 仅仅能够在一个页面上进行复用，不能多个页面进行复用 方式三：把css样式写成一个单独的css文件，再通过link标签进行引入 123456789&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--引入css文件--&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div标签&lt;/div&gt;&lt;/body&gt; 2.3 CSS选择器 （1）标签名选择器 123标签名&#123; 属性: 值&#125; 标签名选择器，可以决定哪些标签可以 （2）id选择器 123#id属性值&#123; 属性: 值;&#125; id选择器，可以选择性的去使用样式 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*id选择器：名字一定要为id + 属性名*/ #id1001&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;id1001&quot;&gt;div1001标签&lt;/div&gt;&lt;/body&gt; （3）class(类)选择器 123.class属性值&#123; 属性: 值&#125; class类型选择器，可以通过class属性有效的选择性去使用这个样式 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*class选择器*/ .class01&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;class01&quot;&gt;class选择器&lt;/div&gt;&lt;/body&gt; 与id选择器的区别，class选择器能够复用，id选择器不能 （4）组合选择器 123选择器1, 选择器2, 选择器3, ... 选择器n&#123; 属性: 值;&#125; 组合选择器可以让多个选择器共用一个css代码 1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*组合选择器*/ #id1002, .class02&#123; color: blue; font-size: 30px; border: 1px solid yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;id1002&quot;&gt;div1001标签&lt;/div&gt; &lt;div class=&quot;class02&quot;&gt;class选择器&lt;/div&gt;&lt;/body&gt; 2.4 CSS常用样式 修改颜色：color: red; 修改宽度：width: 200px; 修改高度：height: 200px; 修改背景颜色：backgroud-color: green; 修改字体大小：font-size: 10px; DIV居中：margin-left: auto; margin-right: auto; 文本居中：text-align: center; 超链接去下划线：text-decoration: none; 表格细线(将边框合并)：border-collapse: collapse; 去掉无序列表前面的标识：list-style: none;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"}],"tags":[]},{"title":"【拓展】树形结构数据","slug":"【拓展】树形结构数据","date":"2020-11-15T07:06:52.000Z","updated":"2020-11-15T07:14:23.363Z","comments":true,"path":"2020/11/15/【拓展】树形结构数据/","link":"","permalink":"https://letere-gzj.github.io/2020/11/15/%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE/","excerpt":"关于数据库树形结构数据的读取以及使用","text":"关于数据库树形结构数据的读取以及使用 一、创建数据库数据库主要3个字段：id, pid, nameid为：编号pid为：父节点编号name：节点名称 二、打印树形结构数据在控制台中打印出树形结构 2.1 创建Bean类123456789//导入了lombok进行快速创建@Data@AllArgsConstructor@NoArgsConstructorpublic class Tree &#123; private String id; private String pid; private String name;&#125; 2.2 整合Mybatis使用数据库具体使用方法不多介绍，大致说一下步骤（本人使用SpringBoot项目） （1）application.yaml配置文件连接数据库，并配置Mapper映射文件的位置 12345678910spring: datasource: username: root password: 123 url: jdbc:mysql://localhost:3306/treenode?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver#Mybatis配置mybatis: mapper-locations: classpath:mapper/*.xml （2）创建dao层接口 12345@Mapper@Repositorypublic interface TreeMapper &#123; public List&lt;Tree&gt; queryAllTreeNode();&#125; （3）创建Mapper映射文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.dao.TreeMapper&quot;&gt; &lt;select id=&quot;queryAllTreeNode&quot; resultType=&quot;com.letere.pojo.Tree&quot;&gt; select * from `tree` &lt;/select&gt;&lt;/mapper&gt; 2.3 创建工具类打印树形结构1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PrintTreeUtil &#123; //寻找父节点 private static List&lt;Tree&gt; findFather(List&lt;Tree&gt; trees)&#123; List&lt;Tree&gt; father = new ArrayList&lt;&gt;(); for (Tree tree : trees)&#123; if (tree.getPid() == null)&#123; father.add(tree); &#125; &#125; return father; &#125; //寻找父节点的子节点 private static List&lt;Tree&gt; findChild(Tree tree, List&lt;Tree&gt; trees)&#123; List&lt;Tree&gt; child = new ArrayList&lt;&gt;(); for (Tree t : trees)&#123; if (tree.getId().equals(t.getPid()))&#123; child.add(t); &#125; &#125; return child; &#125; //递归打印一个节点下的所有子节点 private static void printTree(Tree tree, List&lt;Tree&gt; trees, String priex)&#123; //priex：前缀 List&lt;Tree&gt; child = findChild(tree, trees); if (child != null)&#123;//存在子节点 for (Tree c : child)&#123; System.out.println(priex + &quot;|--&quot; + c.getName()); printTree(c, trees, priex + &quot; &quot;); //递归 &#125; &#125; &#125; //打印树形结构 public static void printTreePlus(List&lt;Tree&gt; trees)&#123; List&lt;Tree&gt; father = findFather(trees); for (Tree f : father)&#123; System.out.println(f.getName()); //打印父节点 printTree(f, trees, &quot; &quot;); //打印该父节点下的所有子节点 &#125; &#125;&#125; 2.4 方法测试及结果12345@Testvoid test()&#123; List&lt;Tree&gt; trees = treeMapper.queryAllTreeNode(); //获取数据库所有节点 PrintTreeUtil.printTreePlus(trees); //按树形结构打印&#125; 三、关联树形结构数据3.1 创建JavaBean要创建一个父子节点有关联的Bean 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class Tree2 &#123; private String id; private String name; private List&lt;Tree2&gt; child; //关联子节点数据&#125; 3.2 Service实现关联实现思路和上面的打印树形结构思路基本一致，只是从打印变成赋值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Servicepublic class TreeService implements TreeMapper &#123; @Autowired TreeMapper treeMapper; @Override public List&lt;Tree&gt; queryAllTreeNode() &#123; return treeMapper.queryAllTreeNode(); &#125; //寻找父节点 private List&lt;Tree&gt; findFather(List&lt;Tree&gt; trees)&#123; List&lt;Tree&gt; father = new ArrayList&lt;&gt;(); for (Tree tree : trees)&#123; if (tree.getPid() == null)&#123; father.add(tree); &#125; &#125; return father; &#125; //寻找该父节点的子节点 private List&lt;Tree&gt; findChild(Tree tree, List&lt;Tree&gt; trees)&#123; List&lt;Tree&gt; child = new ArrayList&lt;&gt;(); for (Tree t : trees)&#123; if (tree.getId().equals(t.getPid()))&#123; child.add(t); &#125; &#125; return child; &#125; //递归关联一个父节点下的所有子节点 private List&lt;Tree2&gt; addTree(Tree tree, List&lt;Tree&gt; trees)&#123; List&lt;Tree&gt; childs = findChild(tree, trees); List&lt;Tree2&gt; nodes = new ArrayList&lt;&gt;(); if (childs != null)&#123;//子节点存在 for (Tree c : childs)&#123; if (c.getPid().equals(tree.getId()))&#123; Tree2 node = new Tree2(c.getId(), c.getName(), addTree(c, trees)); //将Tree类型数据转变为Tree2类型，并递归寻找自己的子节点 nodes.add(node); //将Tree2类型数据添加到列表中 &#125; &#125; &#125; return nodes; &#125; //递归关联父节点与子节点 public List&lt;Tree2&gt; treeNodes()&#123; List&lt;Tree&gt; trees = queryAllTreeNode(); List&lt;Tree&gt; father = findFather(trees); List&lt;Tree2&gt; nodes = new ArrayList&lt;&gt;(); for (Tree f : father)&#123; Tree2 node = new Tree2(f.getId(), f.getName(), addTree(f, trees)); //递归寻找自己的子节点，并变成Tree2类型数据 nodes.add(node); &#125; return nodes; &#125;&#125; 3.3 方法测试及结果12345678@AutowiredTreeService treeService;@Testvoid test3()&#123; List&lt;Tree2&gt; nodes = treeService.treeNodes(); System.out.println(nodes);&#125;","categories":[{"name":"拓展","slug":"拓展","permalink":"https://letere-gzj.github.io/categories/%E6%8B%93%E5%B1%95/"}],"tags":[]},{"title":"【SpringBoot】Dubbo","slug":"【SpringBoot】Dubbo","date":"2020-11-09T12:22:49.000Z","updated":"2020-11-09T13:12:03.145Z","comments":true,"path":"2020/11/09/【SpringBoot】Dubbo/","link":"","permalink":"https://letere-gzj.github.io/2020/11/09/%E3%80%90SpringBoot%E3%80%91Dubbo/","excerpt":"关于分布式系统，以及Dubbo的介绍和举例","text":"关于分布式系统，以及Dubbo的介绍和举例 一、分布式系统 分布式系统是若干个独立计算机的集合，这些计算机对于用户来说就像是单个相关系统 分布式系统是由一组通过网络进行通信，为了完成共同的任务而协调工作的的计算机节点组成的系统 只有单个硬件处理能力无法满足日益增长的计算，存储任务时，才考虑使用分布式系统 二、RPC2.1 RPC介绍 PRC：【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，它是一种技术的思想，而不是规范 它允许程序调用另一个地址空间中的过程或函数，而不用程序员显示编码这个远程调用的细节 2.2 RPC的两个核心 通信：两个主机之间的交流 序列化：数据传输需要转换，方便数据传输 三、Dubbo及Zookeeper安装3.1 Dubbo介绍 Dubbo 是一款高性能，轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现 Dubbo官网：http://dubbo.apache.org/zh-cn/ Dubbo快速上手：http://dubbo.apache.org/zh-cn/docs/2.7/user/quick-start/ 3.2 搭建Dubbo环境 注册中心：官方推荐Multicast，Zookeeper，Redis，Simple，下面主要介绍Zookeeper Zookeeper官网：https://zookeeper.apache.org/ Zookeeper下载地址：https://zookeeper.apache.org/releases.html#download 下载后解压即可 3.3 环境测试 （1）去解压后的bin目录下apache-zookeeper-3.6.2-bin\\bin，以管理员身份运行zkServer.cmd，会返现服务器闪退 （2）编辑cmd，添加暂停pause，查看错误 （3）重新运行zkServer.cmd，查看错误 （4）复制conf文件夹下的zoo_sample.cfg，改名为zoo.cfg （5）先启动zkServer.cmd服务器，在打开zkCli.cmd客户端，连接成功则环境配置成功 四、SpringBoot整合Dubbo4.1 导入依赖12345678910111213141516171819202122232425262728293031323334353637&lt;!--Dubbo启动器依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt;&lt;/dependency&gt;&lt;!--Zookeeper客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--Zookeeper服务端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;!--解决日志冲突--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt;&lt;/dependency&gt; 4.2 创建服务端 （1）创建一个SprigBoot项目，创建Service层接口，以及实现方法 123456接口public interface TicketService &#123; public String getTicket();&#125; 123456789接口实现类@DubboService //在项目启动中就自动注册到注册中心，旧注解为@Service，容易与Spring的注解冲突@Component //使用Dubbo后尽量不要使用Service注解public class TicketServiceImpl implements TicketService &#123; @Override public String getTicket() &#123; return &quot;《优惠券》&quot;; &#125;&#125; （2）配置文件中配置服务端的信息 1234567server.port=8081#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181#服务应用名字dubbo.application.name=provider#哪些服务被扫描dubbo.scan.base-packages=com.letere.service 4.3 创建客户端 再重新创建一个SpringBoot项目 创建Service层方法，为了实现分布式系统，远程调用方法，使用的“定义路径相同的接口名”方法，将服务端的Service接口，赋值到客户端的Service接口，在自己的Service类中注入并调用 1234567891011@Service //交给Springpublic class UserService &#123; //调用provider提供的方法 @DubboReference//引用 和Autowird一样 （1）引用pom坐标 （2）可以定义路径相同的接口名 TicketService ticketService; public void buyTicket() &#123; String ticket = ticketService.getTicket(); System.out.println(&quot;在注册中心中拿到一张票，为：&quot; + ticket); &#125;&#125; 创建一个测试方法，来调用 123456789101112@SpringBootTestclass DemoApplicationTests &#123; @Autowired UserService userService; @Test void contextLoads() &#123; userService.buyTicket(); &#125;&#125; 4.3 Dubbo测试 （1）回到Zookeeper的bin目录下，将注册中心服务器zkServer.cmd开启 （2）先启动SpringBoot服务端，在启动SpringBoot的客户端查看方法调用是否成功","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】任务","slug":"【SpringBoot】任务","date":"2020-11-09T12:12:30.000Z","updated":"2020-11-09T12:14:03.111Z","comments":true,"path":"2020/11/09/【SpringBoot】任务/","link":"","permalink":"https://letere-gzj.github.io/2020/11/09/%E3%80%90SpringBoot%E3%80%91%E4%BB%BB%E5%8A%A1/","excerpt":"关于SpringBoot实现一些特定任务的方法","text":"关于SpringBoot实现一些特定任务的方法 一、异步任务1.1 使用环境使用异步任务场景：Controller调用Service层方法，等Service方法结束后，才跳转页面。一旦业务处理时间过长，页面加载半天，导致用户体验差 123456789101112131415Service层方法@Servicepublic class AsynService &#123; public void waiting() &#123; System.out.println(&quot;数据处理中&quot;); try &#123; Thread.sleep(3000); //让程序暂停3秒，延迟程序运行时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415Controller@Controllerpublic class AsynController &#123; @Autowired AsynService service; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; service.waiting(); return &quot;OK!&quot;; &#125;&#125; 访问该页面，返现加载3秒之后页面才显示出来，十分的慢 1.2 异步的使用 （1）在需要开启异步的方法waiting()中添加注解@Async （2）在SpringBoot主程序Application.java中开启异步@EnableAsync 这时再访问该页面，发现页面秒打开，这就是开启异步后的现象 二、邮件任务邮件任务即通过java程序来发送邮件 2.1 导入相关依赖12345&lt;!--javax:mail--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 配置文件设置12345678spring: mail: username: 190649799@qq.com #邮件发送邮箱 password: jsdjxhpszzrfcehh #密码，通过邮箱手机令牌生成的 host: smtp.qq.com #开启加密验证 properties: mail.smtl.ssl.enable: true 2.3 发送一个简单的邮件创建一个信息类，通过JavaMailSenderImpl.send(信息类)来发送邮件 1234567891011121314151617@AutowiredJavaMailSenderImpl mailSender; //自动注入JavaMailSenderImpl@Testvoid contextLoads() &#123; //发送一个简单的邮件 SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); //创建一个简单的信息类 simpleMailMessage.setSubject(&quot;邮件主题&quot;); simpleMailMessage.setText(&quot;邮件内容&quot;); simpleMailMessage.setTo(&quot;1906497996@qq.com&quot;);//发送目标 simpleMailMessage.setFrom(&quot;1906497996@qq.com&quot;);//发送来源 mailSender.send(simpleMailMessage);&#125; 2.4 发送一个复杂的邮件123456789101112131415161718192021222324@AutowiredJavaMailSenderImpl mailSender;@Testvoid test() throws MessagingException &#123; //发送一个复杂的邮件 MimeMessage message = mailSender.createMimeMessage(); //组装 MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setSubject(&quot;主题&quot;); helper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;这是邮件的内容&lt;/p&gt;&quot;, true); //附件 helper.addAttachment(&quot;色图.jpg&quot;, new File(&quot;文件路径&quot;)); helper.setTo(&quot;1906497996@qq.com&quot;); helper.setFrom(&quot;1906497996@qq.com&quot;); mailSender.send(message);&#125; 三、定时任务3.1 两个注解 @EnableScheduling ：开启定时功能的注解，在主程序Application.java中添加此注解 @Scheduled : 方法执行的时间，在要定时执行的方法上添加此注解，注解参数为Cron表达式 3.2 Cron表达式 Cron表达式介绍：https://www.jianshu.com/p/e9ce1a7e1ed1 Cron在线生成工具：https://cron.qqe2.com 3.3 实例12345678910@Servicepublic class ScheduledService &#123; //填写Cron表达式 //秒 分 时 日 月 星期 @Scheduled(cron = &quot;0 * * * * 0-7&quot;) //每天任何时间的0秒执行此操作 public void Hello() &#123; System.out.println(&quot;Hello! 你被执行了！&quot;); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】Swagger使用","slug":"【SpringBoot】Swagger使用","date":"2020-11-08T07:48:32.000Z","updated":"2021-06-25T06:07:30.626Z","comments":true,"path":"2020/11/08/【SpringBoot】Swagger使用/","link":"","permalink":"https://letere-gzj.github.io/2020/11/08/%E3%80%90SpringBoot%E3%80%91Swagger%E4%BD%BF%E7%94%A8/","excerpt":"了解Swagger，以及如何在SpringBoot中使用Swagger","text":"了解Swagger，以及如何在SpringBoot中使用Swagger 一、Swagger的介绍和集成1.1 Swagger介绍 号称世界上最流行的API框架 ResutFul API文档在线自动生成工具 ==&gt; API文档与API定义同步更新 直接运行，可以在线测试API接口 支持多种语言：Java… 官网：https://swagger.io 1.2 集成Swagger （1）导入相应的依赖 1234567891011121314151617181920&lt;!--Swagger API接口--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--Swagger UI界面--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--若Swagger为3.0，还需要导入此依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; （2）简单创建一个Hello跳转 （3）测试 3.0以下版本访问：http://localhost:8080/swagger-ui.html3.0版本访问：http://localhost:8080/swagger-ui/index.html 会出现以下页面 二、Swagger基础配置2.1 创建Swagger配置类12345@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123;&#125; 2.2 注入Docket类Docket类为配置Swagger中主要配置内容 （1）源码分析 123456789101112131415161718192021222324252627Docket构造器public Docket(DocumentationType documentationType) &#123; this.apiInfo = ApiInfo.DEFAULT; this.groupName = &quot;default&quot;; this.enabled = true; this.genericsNamingStrategy = new DefaultGenericTypeNamingStrategy(); this.applyDefaultResponseMessages = true; this.host = &quot;&quot;; this.pathMapping = Optional.empty(); this.apiSelector = ApiSelector.DEFAULT; this.enableUrlTemplating = false; this.vendorExtensions = new ArrayList(); this.globalRequestParameters = new ArrayList(); this.documentationType = documentationType;&#125; //创建此类要传入一个DocumentationType的参数 || 查看Documentation类 public class DocumentationType extends SimplePluginMetadata &#123; public static final DocumentationType SWAGGER_12 = new DocumentationType(&quot;swagger&quot;, &quot;1.2&quot;); public static final DocumentationType SWAGGER_2 = new DocumentationType(&quot;swagger&quot;, &quot;2.0&quot;); public static final DocumentationType OAS_30 = new DocumentationType(&quot;openApi&quot;, &quot;3.0&quot;); /** @deprecated */ @Deprecated //方法过时 public static final DocumentationType SPRING_WEB = new DocumentationType(&quot;spring-web&quot;, &quot;5.2&quot;); ......&#125; //Documentation对象，可以直接调用其定义的常量来创建，选择SWAGGER_2 （2）修改SwaggerConfig配置类 123456789101112@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; @Bean public Docket getDokcet(Environment environment)&#123; Docket docket = new Docket(DocumentationType.SWAGGER_2); //----------------------配置信息------------------------- //----------------------------------------------------------- return docket; &#125; 2.3 修改Swagger信息调用Docket类中的apiInfo方法 （1）源码分析 1234567891011121314151617181920212223242526272829303132333435363738apiInfo方法public Docket apiInfo(ApiInfo apiInfo) &#123; this.apiInfo = (ApiInfo)BuilderDefaults.defaultIfAbsent(apiInfo, this.apiInfo); return this;&#125; //需要传入一个ApiInfo类 || 查看ApiInfo类public class ApiInfo &#123; public static final Contact DEFAULT_CONTACT = new Contact(&quot;&quot;, &quot;&quot;, &quot;&quot;); //构造器 public ApiInfo(String title, String description, String version, String termsOfServiceUrl, Contact contact, String license, String licenseUrl, Collection&lt;VendorExtension&gt; vendorExtensions) &#123; this.title = title; this.description = description; this.version = version; this.termsOfServiceUrl = termsOfServiceUrl; this.contact = contact; this.license = license; this.licenseUrl = licenseUrl; this.vendorExtensions = new ArrayList(vendorExtensions); &#125; //官方静态构造方法 static &#123; DEFAULT = new ApiInfo(&quot;Api Documentation&quot;, &quot;Api Documentation&quot;, &quot;1.0&quot;, &quot;urn:tos&quot;, DEFAULT_CONTACT, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;&#125; //按照官方文档静态代码，参考来设置自定义Swagger信息Contact类（传参需要的参数之一）public class Contact &#123; //构造器 public Contact(String name, String url, String email) &#123; this.name = name; this.url = url; this.email = email; &#125;&#125; （2）修改SwaggerConfig配置类 123456789101112131415161718192021222324252627282930@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; @Bean public Docket getDokcet(Environment environment)&#123; Docket docket = new Docket(DocumentationType.SWAGGER_2); //----------------------配置信息------------------------- //配置Swagger信息 docket.apiInfo(getApiInfo()); //----------------------------------------------------------- return docket; &#125; //创建一个获取ApiInfo对象的方法 private ApiInfo getApiInfo()&#123; //作者信息(姓名，地址，邮箱) Contact contact = new Contact(&quot;莱特雷&quot;, &quot;http://letere.gitee.io/blog&quot;, &quot;Xxxx@qq.com&quot;); return new ApiInfo(&quot;letere&quot;, //标题 &quot;修改的是Swagger信息&quot;, //描述 &quot;1.0&quot;, //版本 &quot;urn:tos&quot;, contact, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;;&#125; 效果如下： 三、配置扫描接口使用Docket.select()方法类配置 3.1 修改SwaggerConfig配置类123456789101112131415161718192021222324252627282930@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; @Bean public Docket getDokcet(Environment environment)&#123; Docket docket = new Docket(DocumentationType.SWAGGER_2); //----------------------配置信息------------------------- //配置Swagger信息 docket.apiInfo(getApiInfo()); //配置扫描接口 /* apis()：要扫描的接口 RequestHandlerSelectors：配置接口扫描的方式 basePackage：扫描的路径（常用） any：扫描全部 none：不扫描 withClassAnnotation：扫描类上的注解，参数为一个注解的反射对象 withMethodAnnotation：扫描方法上的注解 paths()：过滤扫描接口 PathSelectors：过滤扫描接口的方式 ant：设置路径 */ docket.select().apis(RequestHandlerSelectors.basePackage(&quot;com.letere.controller&quot;)).build(); //扫描此包下的接口 //----------------------------------------------------------- return docket; &#125;&#125; 四、配置开关实现多环境时，判断是否使用Swagger一般在开发环境中会使用Swagger，生产环境会关闭Swagger 4.1 方式一：通过Application.yaml设置在application.yaml中有以下设置来控制Swagger是否开启可以在不同的环境，选择是否开启 1234springfox: documentation: swagger-ui: enabled: true #开发环境启动swaggger 4.2 方式二：在Docket中设置可以调用Docket.enable()方法，可以选择开启/关闭Swagger，重点在与如何获取当前的环境，来进行判断 1234567891011121314151617181920212223242526@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; @Bean public Docket getDokcet(Environment environment)&#123; Docket docket = new Docket(DocumentationType.SWAGGER_2); //----------------------配置信息------------------------- //配置Swagger信息 docket.apiInfo(getApiInfo()); //配置扫描接口 docket.select().apis(RequestHandlerSelectors.basePackage(&quot;com.letere.controller&quot;)).build(); //设置要使用Swagger的环境 Profiles profiles = Profiles.of(&quot;dev&quot;); //可以多参数 //判断当前环境，是否是要使用Swagger的环境 boolean b = environment.acceptsProfiles(profiles); if (!b)&#123; //如果不是，就关闭Swagger docket.enable(false); &#125; //----------------------------------------------------------- return docket; &#125;&#125; 五、添加分组和注释注解5.1 添加分组Docket类中使用Docket.group()方法，可以给组起名字如果需要创建多个分组，只能创建多个Docket类 1234567891011121314151617181920212223242526272829@Configuration@EnableSwagger2 //开启Swagger2public class SwaggerConfig &#123; @Bean public Docket getDokcet(Environment environment)&#123; Docket docket = new Docket(DocumentationType.SWAGGER_2); //----------------------配置信息------------------------- //配置Swagger信息 docket.apiInfo(getApiInfo()); //配置扫描接口 docket.select().apis(RequestHandlerSelectors.basePackage(&quot;com.letere.controller&quot;)).build(); //设置要使用Swagger的环境 Profiles profiles = Profiles.of(&quot;dev&quot;); //可以多参数 //判断当前环境，是否是要使用Swagger的环境 boolean b = environment.acceptsProfiles(profiles); if (!b)&#123; docket.enable(false); &#125; //配置分组 docket.groupName(&quot;莱特雷&quot;); //----------------------------------------------------------- return docket; &#125;&#125; 5.2 注释注解Swagger可以添加注释注解，来给类的方法，属性…添加注释，方便Swagger后台查看 12345@ApiModel(&quot;用户&quot;) //给类添加注释public class User &#123; @ApiModelProperty(&quot;用户名&quot;) //给类中属性添加注释 @ApiModelProperty(&quot;密码&quot;) private String password; 123456789@RestControllerpublic class HelloController &#123; @ApiOperation(&quot;返回用户&quot;) //给Controller方法添加注释 @GetMapping(&quot;/user&quot;) public User user()&#123; return new User(); &#125;&#125; 5.3 常用注解 （1）ApiOperation 12//对接口方法进行解释@ApiOperation(&quot;获取博客文章&quot;) （2）ApiImplicitParam 和 ApiImplicitParams ApiImplicitParam对接口的参数进行解释说明 而ApiImplicitParams用于包裹多个ApiImplicitParam 1234567891011121314//ApiImplicitParams使用方法@ApiImplicitParams(&#123; @ApiImplicitParam(), @ApiImplicitParam()&#125;)//ApiImplicitParam使用@ApiImplicitParam(name = &quot;id&quot;, value = &quot;博客文章id&quot;, dataType = &quot;int&quot;, allowMultiple = true, required = true)// name：参数名// value: 参数解释说明// dataType：参数的数据类型：常用有(int, Integer) = int, (String) = string, (Date) = date 【大致上都是数据类型的小写】// allowMultiple: 是否多个参数，如果参数是数组或集合，需要开启// requried: 是否必传 （3）ApiParam 使用效果和ApiImplicitParam一致，使用的位置直接在参数上 因此可以省略“name”参数名和”dataType”参数数据类型的属性 参数类型为文件（MultipartFile）的只能使用此注解 1public void test(@ApiParam(value = &quot;文件&quot;, required = true) MultipartFile file) &#123;&#125; （4）RequestPart swagger3.x版本，若参数为文件，则需要此注解（2.x版本不需要） 1public void test(@ApiParam(value = &quot;文件&quot;, required = true) @RequestPart MultipartFile file) &#123;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】Shiro安全框架","slug":"【SpringBoot】Shiro安全框架","date":"2020-11-05T12:38:41.000Z","updated":"2021-05-06T07:51:35.800Z","comments":true,"path":"2020/11/05/【SpringBoot】Shiro安全框架/","link":"","permalink":"https://letere-gzj.github.io/2020/11/05/%E3%80%90SpringBoot%E3%80%91Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/","excerpt":"Shiro安全框架的简单介绍，以及与SpringBoot的整合","text":"Shiro安全框架的简单介绍，以及与SpringBoot的整合 一、Shiro快速开始1.1 Shiro介绍 Apache Shiro是一个Java的安全框架 Shiro可以非常容易开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境中 Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等 官网快速上手教程：http://shiro.apache.org/10-minute-tutorial.html 下载地址：http://shiro.apache.org/download.html 1.2 快速入门 下载后，按照官方文档，将sample/quickstart下的maven项目复制到IDEA中，进行测试 由于Maven文件中继承了父maven，依赖没有版本号，所以要手动导入依赖 1234567891011121314151617181920212223242526&lt;!--shiro安全框架--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- configure logging 配置日志--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 运行Quickstart，显示以下结果，证明运行成功 二、Shiro分析 源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Quickstart &#123; private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) &#123;// Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);// SecurityManager securityManager = factory.getInstance(); //上面方法过时，新版方法如下 IniRealm iniRealm = new IniRealm(&quot;classpath:shiro.ini&quot;); //根据ini文件创建一个IniRealm对象 DefaultSecurityManager securityManager = new DefaultSecurityManager(); //创建安全管理器 securityManager.setRealm(iniRealm); //将IniRealm注入到SecurityManager SecurityUtils.setSecurityManager(securityManager); //将SecerityManager注入到安全工具类SecurityUtils //获取当前用户对象Subject Subject currentUser = SecurityUtils.getSubject(); //通过当前用户获取Session Session session = currentUser.getSession(); //告诉如何使用Session存值，取值 session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;); String value = (String) session.getAttribute(&quot;someKey&quot;); if (value.equals(&quot;aValue&quot;)) &#123; log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;); &#125; //SpringSecurity一样，判断当前用户是否已认证 if (!currentUser.isAuthenticated()) &#123; UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);//生成令牌，用户、密码作为参数 token.setRememberMe(true); //未登陆就生产一个令牌，并且记住此令牌 try &#123; currentUser.login(token); //执行登陆操作 从ini文件中读取用户令牌信息 lonestarr = vespa, goodguy, schwartz 用户名 = 密码, 角色（权限）... &#125; catch (UnknownAccountException uae) &#123; log.info(&quot;There is no user with username of &quot; + token.getPrincipal()); //用户名错误异常 &#125; catch (IncorrectCredentialsException ice) &#123; log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;); //密码错误异常 &#125; catch (LockedAccountException lae) &#123; log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked. &quot; + //账号被锁异常 &quot;Please contact your administrator to unlock it.&quot;); &#125; // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) &#123; //意外未知异常 //unexpected condition? error? &#125; &#125; log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;); //currentUser.getPrincipal()：获取用户名 if (currentUser.hasRole(&quot;schwartz&quot;)) &#123; //currentUser.hasRole(&quot;schwartz&quot;)：判断拥有的角色 log.info(&quot;May the Schwartz be with you!&quot;); &#125; else &#123; log.info(&quot;Hello, mere mortal.&quot;); &#125; if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123; //currentUser.isPermitted(&quot;lightsaber:wield&quot;)：判断拥有的权限 log.info(&quot;You may use a lightsaber ring. Use it wisely.&quot;); &#125; else &#123; log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;); &#125; if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123; log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;. &quot; + &quot;Here are the keys - have fun!&quot;); &#125; else &#123; log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;); &#125; currentUser.logout();//注销 System.exit(0); &#125;&#125; 三、SpringBoot整合Shiro创建SpringBoot项目 3.1 导入相关依赖123456789101112131415161718&lt;!--web支持--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!--thymeleaf模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!--shiro安全框架--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt;&lt;/dependency&gt; 3.2 创建自定义Realm Realm用于设置用户认证和授权 12345678910111213141516//自定义Realmpublic class UserRealm extends AuthorizingRealm &#123; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; System.out.println(&quot;执行 ==&gt; 授权doGetAuthorizationInfo&quot;); return null; &#125; //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;执行 ==&gt; 认证doGetAuthenticationInfo&quot;); return null; &#125;&#125; 3.3 创建Shiro配置类 注入Realm类 注入DefaultWebSecurityManager类，Realm类作为参数传递 注入ShiroFilterFactoryBean类，DefaultWebSecurityManage类作为参数传递 123456789101112131415161718192021222324252627@Configurationpublic class ShiroConfig &#123; //创建Realm对象 @Bean //交给Spring来托管 public UserRealm getRealm()&#123; return new UserRealm(); &#125; //DefaultWebSecurityManager（对应Shiro的SecurityManager） @Bean public DefaultWebSecurityManager getSecurityManager(UserRealm realm)&#123; return new DefaultWebSecurityManager(realm); &#125; //ShiroFilterFactoryBean（对应Shiro的subject） @Bean(name = &quot;shiroFilterFactoryBean&quot;) //要起别名为&quot;shiroFilterFactoryBean&quot;，否则报错 public ShiroFilterFactoryBean getFilterFactoryBean(DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean filterFactoryBean = new ShiroFilterFactoryBean(); filterFactoryBean.setSecurityManager(securityManager); //---------------------里面配置相关设置--------------------------- //------------------------------------------------------------------------ return filterFactoryBean; &#125;&#125; 3.4 简单的环境配置12345678910111213141516index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;!--添加跳转--&gt; &lt;a th:href=&quot;@&#123;/user/toAdd&#125;&quot;&gt;增加用户&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/toUpdate&#125;&quot;&gt;修改用户&lt;/a&gt; &lt;a th:href=&quot;@&#123;/user/toDelete&#125;&quot;&gt;删除用户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011add.html 和 update.html 和 delete.html都类似，改一下h1内容&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;增加用户&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324Controller接口层@Controllerpublic class RouteController &#123; //对应的跳转 @RequestMapping(&#123;&quot;/&quot;, &quot;index.thml&quot;&#125;) public String toIndex()&#123; return &quot;index&quot;; &#125; @RequestMapping(&quot;/user/toAdd&quot;) public String toAdd()&#123; return &quot;/user/add&quot;; &#125; @RequestMapping(&quot;/user/toUpdate&quot;) public String toUpdate()&#123; return &quot;/user/update&quot;; &#125; @RequestMapping(&quot;/user/toDelete&quot;) public String toDelete()&#123; return &quot;/user/delete&quot;; &#125;&#125; 以上是最基本的Shrio框架的搭建，举例功能下面实现 四、Shiro实现拦截登录4.1 设置要拦截的请求 “/user/toAdd”：无需认证，可以直接访问 “/user/toUpdate”：需要认证，才能访问 “/user/toDelete”：用户需要”admin”权限才能访问 123456789101112131415161718192021@Bean(name = &quot;shiroFilterFactoryBean&quot;) //要起别名为&quot;shiroFilterFactoryBean&quot;，否则报错public ShiroFilterFactoryBean getFilterFactoryBean(DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean filterFactoryBean = new ShiroFilterFactoryBean(); filterFactoryBean.setSecurityManager(securityManager); //---------------------里面配置相关设置--------------------------- //添加shiro内容过滤器 /* anon：无需认证就可以访问 authc：必须认证了才能访问 user：必须拥有“Remenber me”功能才能访问 perms：拥有对某个资源的权限才能访问 role：拥有某个角色权限才能访问 */ Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/toAdd&quot;, &quot;anon&quot;); filterMap.put(&quot;/user/toUpdate&quot;, &quot;authc&quot;); //支持通配符/user/* filterMap.put(&quot;/user/toDelete&quot;, &quot;perms[admin]&quot;); filterFactoryBean.setFilterChainDefinitionMap(filterMap); //将上面Map设置到过滤器中 //------------------------------------------------------------------------ return filterFactoryBean;&#125; 4.2 设置拦截跳转 Shrio成功拦截请求，但没有进行登录页面跳转，不想SpringSecurity自带登录页面，需要手动设置 123456789101112131415161718192021222324login.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录&lt;/h1&gt; &lt;form action=&quot;&quot;&gt; &lt;p&gt; 用户名： &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; 密码: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 12345Controller跳转Login页面 @RequestMapping(&quot;/toLogin&quot;) public String toLogin()&#123; return &quot;login&quot;; &#125; 1234567891011121314151617Shiro配置类设置登录页面 @Bean(name = &quot;shiroFilterFactoryBean&quot;) public ShiroFilterFactoryBean getFilterFactoryBean(DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean filterFactoryBean = new ShiroFilterFactoryBean(); filterFactoryBean.setSecurityManager(securityManager); //---------------------里面配置相关设置--------------------------- Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/toAdd&quot;, &quot;anon&quot;); filterMap.put(&quot;/user/toUpdate&quot;, &quot;authc&quot;); filterMap.put(&quot;/user/toDelete&quot;, &quot;perms[admin]&quot;); filterFactoryBean.setFilterChainDefinitionMap(filterMap); //需要认证，但是没有认证，会进入登录页面（需要手动配置，SpringSecurity有自带登录页面） filterFactoryBean.setLoginUrl(&quot;/toLogin&quot;); //------------------------------------------------------------------------ return filterFactoryBean; &#125; 五、Shiro实现用户认证5.1 Controller层登录业务 在login.html 添加aciton=”/login”进行Controller业务跳转 Controller接受登录页面发送的账号、密码，执行登录操作 123456789101112131415161718@RequestMapping(&quot;/login&quot;)public String login(String username, String password, Model model)&#123; //从登录表单中接受数据 //获取当前用户 Subject subject = SecurityUtils.getSubject(); //封装用户登录的数据 UsernamePasswordToken token = new UsernamePasswordToken(username, password); //进行登录，并且进行异常捕获 try &#123; subject.login(token); &#125; catch (UnknownAccountException e) &#123; model.addAttribute(&quot;msg&quot;, &quot;用户名错误&quot;); return &quot;login&quot;; //出错返回登录页面 &#125; catch (IncorrectCredentialsException e)&#123; model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;); return &quot;login&quot;; &#125; return &quot;index&quot;; //登录成功返回首页&#125; 5.2 Realm类实现认证判断 subject.login()方法会去执行Realm中的认证方法 123456789101112131415161718 //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;执行 ==&gt; 认证doGetAuthenticationInfo&quot;); //登录会执行认证方法 //设置登录需要的用户名 密码 //（1）内存中设置 String name = &quot;莱特雷&quot;; String password = &quot;123&quot;; UsernamePasswordToken userToken = (UsernamePasswordToken)token;//用户认证 if (!name.equals(userToken.getUsername()))&#123; return null; //会抛出异常 UnknownAccountException（用户名错误） &#125; //密码认证，Shiro会自己判断 return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);//参数一：用户对象（没有就不设置），参数二：密码，参数三：密码加密方式 &#125; 六、Shiro整合MybatisShiro整合Mybatis，实现从数据库获取用户、密码，实现数据库认证 6.1 导入相关依赖123456789101112&lt;!--MySQL数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--SpringBoot Mybatis整合--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 6.2 配置文件1234567891011#连接数据库信息spring: datasource: username: root password: 123 url: jdbc:mysql://localhost:3306/jdbctest?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver#Mybatis基础配置mybatis: mapper-locations: classpath:mapper/*.xml #Mybatis mapper文件路径 6.3 创建相应的Bean，Mapper，Service1234567891011121314151617181920212223242526272829303132333435363738394041424344Beanpublic class Person &#123; private String name; private Integer age; private String password; private String perms; public Person() &#123; &#125; public Person(String name, Integer age, String password) &#123; this.name = name; this.age = age; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 123456Mapper接口@Mapper //注意要添加Mapper注解，否则要创建配置类，开启组件扫描@Repositorypublic interface PersonMapper &#123; public Person queryPersonByName(String name); //通过用户名查询该人的信息&#125; 12345678910111213Mapper.xml中SQL&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.bean.PersonMapper&quot;&gt; &lt;select id=&quot;queryPersonByName&quot; resultType=&quot;com.letere.bean.Person&quot;&gt; select * from `person` where name = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; 1234567891011Service调用Dao层@Servicepublic class PersonService implements PersonMapper &#123; @Autowired PersonMapper personMapper; @Override public Person queryPersonByName(String name) &#123; return personMapper.queryPersonByName(name); &#125;&#125; 6.4 修改Relam中的认证方法123456789101112131415//认证@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println(&quot;执行 ==&gt; 认证doGetAuthenticationInfo&quot;); //（2）实现数据库认证 UsernamePasswordToken userToken = (UsernamePasswordToken)token; Person person = personService.queryPersonByName(userToken.getUsername()); //通过用户名查询对象 if (person == null)&#123; //对象为空，即查询失败，不存在此用户名 return null; &#125; //密码认证Shiro会自动执行 return new SimpleAuthenticationInfo(person, person.getPassword(), &quot;&quot;); //参数1传bean对象&#125; 七、授权方法实现授予用户特定的权限去访问特定的页面 7.1 添加需要权限访问的页面在ShiroConfig的配置类中的拦截中，添加需要权限才能访问的页面并且可以设置权限不够时，自动跳转的页面 1234567891011121314151617181920 @Bean(name = &quot;shiroFilterFactoryBean&quot;) //要起别名为&quot;shiroFilterFactoryBean&quot;，否则报错 public ShiroFilterFactoryBean getFilterFactoryBean(DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean filterFactoryBean = new ShiroFilterFactoryBean(); filterFactoryBean.setSecurityManager(securityManager); //---------------------里面配置相关设置--------------------------- //添加shiro内容过滤器 Map&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;(); filterMap.put(&quot;/user/toAdd&quot;, &quot;anon&quot;); filterMap.put(&quot;/user/toUpdate&quot;, &quot;authc&quot;); filterMap.put(&quot;/user/toDelete&quot;, &quot;perms[admin]&quot;); //需要admin权限才能访问 filterFactoryBean.setFilterChainDefinitionMap(filterMap); filterFactoryBean.setLoginUrl(&quot;/toLogin&quot;);//未授权请求，自动跳转到相应的页面 filterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;); //------------------------------------------------------------------------ return filterFactoryBean; &#125; 7.2 整合数据库实现 （1）数据库添加新字段 在数据库中添加新的字段perms，来表示该用户拥有的权限 12alter table `person`add perms varchar(20) （2）修改对应的Bean类 （3）修改Relam类中的授权方法 1234567891011121314//授权@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; System.out.println(&quot;执行 ==&gt; 授权doGetAuthorizationInfo&quot;); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); //获取验认证通过后的用户 Person person = (Person)principals.getPrimaryPrincipal(); //设置用户权限 authorizationInfo.addStringPermission(person.getPerms()); return authorizationInfo;&#125; 八、Shiro整合thymeleaf整合thymeleaf，实现根据用户的权限，来显示其能够访问的页面 8.1 导入相关依赖123456&lt;!--shiro与thymeleaf整合--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 8.2 修改ShiroConfig类在Shiro配置类中，住一个ShiroDialect类的Bean 12345//ShiroDialect：整合shiro和thymeleaf@Beanpublic ShiroDialect getShiroDialect()&#123; return new ShiroDialect();&#125; 8.3 修改前端代码 9 修改过滤器（拦截器）9.1 介绍 shiro对需要验证的请求authc，进行拦截，并进行判断是否已登录等操作或其他操作 这些操作都在shiro的默认过滤器中处理 我们可以自定义一个过滤器，来替换shiro默认的过滤器，来实现我们自己想要的业务 9.2 实现 （1）创建过滤器123456789101112//继承org.apache.shiro.web.filter.authc.FormAuthenticationFilter类public class MyShiroFilter extends FormAuthenticationFilter &#123; //重写onAcessDeniend方法 @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException &#123; //业务逻辑代码 return true; //放行 return false; //拦截 &#125;&#125; （2）替换过滤器123456789101112131415161718@Configurationpublic class ShiroConfig extends ShiroWebFilterConfiguration &#123; //...... @Override @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean() &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = super.shiroFilterFactoryBean(); //使用自定义过滤器，来替换authc自带的过滤器 Map&lt;String, Filter&gt; filters = new HashMap&lt;&gt;(); filters.put(&quot;authc&quot;, new MyShiroFilter()); shiroFilterFactoryBean.setFilters(filters); return shiroFilterFactoryBean; &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】整合数据库","slug":"【SpringBoot】整合数据库","date":"2020-11-04T13:50:54.000Z","updated":"2020-11-05T12:33:11.284Z","comments":true,"path":"2020/11/04/【SpringBoot】整合数据库/","link":"","permalink":"https://letere-gzj.github.io/2020/11/04/%E3%80%90SpringBoot%E3%80%91%E6%95%B4%E5%90%88%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"SpringBoot如何整合数据库，实现CURD操作","text":"SpringBoot如何整合数据库，实现CURD操作 一、整合原生JDBC1.1 导入相关依赖1234567891011&lt;!--SpringBoot JDBC启动器依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--MySQL驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 配置文件连接数据库123456spring: datasource: #基础JDBC连接 username: root password: 123 url: jdbc:mysql://localhost:3306/jdbctest?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver 1.3 CURD测试在Controller层实现相关业务，数据库操作方法全部封装在jdbcTemplate类中 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Controllerpublic class JDBCController &#123; @Autowired JdbcTemplate jdbcTemplate; //查询 @RequestMapping(&quot;/select&quot;) @ResponseBody public List&lt;Map&lt;String, Object&gt;&gt; selectPerson()&#123; String sql = &quot;select * from person&quot;; List&lt;Map&lt;String, Object&gt;&gt; mapList = jdbcTemplate.queryForList(sql); return mapList; &#125; //增加 @RequestMapping(&quot;/update&quot;) @ResponseBody public String addPerson()&#123; String sql = &quot;insert into person value(&#x27;盐取&#x27;, 80, 45787)&quot;;// jdbcTemplate.execute(sql); 都可以 jdbcTemplate.update(sql); return &quot;add-ok&quot;; &#125; //删除 @RequestMapping(&quot;/delete/&#123;name&#125;&quot;) @ResponseBody public String deletePerson(@PathVariable(&quot;name&quot;) String name)&#123; //预编译SQL（占位符） String sql = &quot;delete from person where name = ?&quot;; jdbcTemplate.update(sql, name); return &quot;delete OK!&quot;; &#125; //修改 @RequestMapping(&quot;/add/&#123;name&#125;/&#123;age&#125;/&#123;passowrd&#125;&quot;) @ResponseBody public String addPerson(@PathVariable(&quot;name&quot;) String name, @PathVariable(&quot;age&quot;) Integer age, @PathVariable(&quot;password&quot;) String password)&#123; String sql = &quot;update `person` value(?, ?, ?)&quot;; jdbcTemplate.update(sql, name, age, password); return &quot;update-ok&quot;; &#125; //使用方式是原生JDBC的方法封装好了，直接使用&#125; 二、整合Mybatis2.1 导入相关依赖123456789101112&lt;!--Mybatis和SpringBoot整合包(非springboot官方)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; &lt;!--MySQL驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 配置文件连接数据库12345678910111213spring: datasource: username: root password: 123 url: jdbc:mysql://localhost:3306/jdbctest?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver#整合Mybatis全局配置文件，直接在此设置mybatis: configuration: map-underscore-to-camel-case: true #开启驼峰命名 mapper-locations: classpath:mybatis/mapper/*.xml #Mapper文件路径 2.3 Mybatis基础操作 其他操作和使用Mybtias差异不大，只是Mapper.xml文件，放进resources/mapper目录下 123456789JavaBean@Data@AllArgsConstructor@NoArgsConstructorpublic class Person &#123; private String name; private Integer age; private String password;&#125; 12345678910111213141516Mapper接口//此注解标识：此类为Mybatis的Mapper类@Mapper@Repositorypublic interface PersonMapper &#123; List&lt;Person&gt; queryPersons(); Person queryPersonByName(String name); int addPerson(Person person); int deletePersonByName(String name); int updatePerson(Person person);&#125; 12345678910111213141516171819202122232425262728293031323334Mapper.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.mapper.PersonMapper&quot;&gt; &lt;!--绑定接口文件--&gt; &lt;select id=&quot;queryPersons&quot; resultType=&quot;com.letere.bean.Person&quot;&gt; select * from `person` &lt;/select&gt; &lt;select id=&quot;queryPersonByName&quot; resultType=&quot;com.letere.bean.Person&quot;&gt; select * from `person` where name like #&#123;name&#125; &lt;/select&gt; &lt;insert id=&quot;addPerson&quot;&gt; insert into `person` value (#&#123;name&#125;, #&#123;age&#125;, #&#123;password&#125;) &lt;/insert&gt; &lt;delete id=&quot;deletePersonByName&quot;&gt; delet from `person` where name = #&#123;name&#125; &lt;/delete&gt; &lt;update id=&quot;updatePerson&quot;&gt; update `person` set age = #&#123;age&#125;, password = #&#123;password&#125; where name = #&#123;name&#125; &lt;/update&gt;&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233Service层实现类@Servicepublic class PersonService implements PersonMapper &#123; @Autowired private PersonMapper mapper; @Override public List&lt;Person&gt; queryPersons() &#123; return mapper.queryPersons(); &#125; @Override public Person queryPersonByName(String name) &#123; name = &#x27;%&#x27; + name + &#x27;%&#x27;; return mapper.queryPersonByName(name); &#125; @Override public int addPerson(Person person) &#123; return mapper.addPerson(person); &#125; @Override public int deletePersonByName(String name) &#123; return mapper.deletePersonByName(name); &#125; @Override public int updatePerson(Person person) &#123; return mapper.updatePerson(person); &#125;&#125; 12345678910111213141516171819Controller层调用Service层@RestControllerpublic class PersonController &#123; @Autowired private PersonService server; @RequestMapping(&quot;/person/queryAll&quot;) public List&lt;Person&gt; queryAll(Model model)&#123; List&lt;Person&gt; persons = server.queryPersons(); return persons; &#125; @RequestMapping(&quot;/person/queryByName/&#123;name&#125;&quot;) public Person queryByName(@PathVariable(&quot;name&quot;) String name)&#123; Person person = server.queryPersonByName(name); return person; &#125;&#125; 三、整合druid数据连接池3.1 导入相关依赖12345678910111213&lt;!--druid数据源--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt; &lt;!--log4j日志记录--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 3.2 配置文件设置12345678910111213141516171819202122232425spring: datasource: username: root password: 123 url: jdbc:mysql://localhost:3306/jdbctest?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #切换druid数据源 druid: #druid数据源特有设置 #配置监控统计拦截filters：stat(监控统计)、log4j(日志记录)、wall(防止sql注入) filters: stat,wall,log4j max-pool-prepared-statement-per-connection-size: 20 use-global-data-source-stat: true connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillus=500 #基础设置 #初始化连接数大小 initial-size: 3 #最小连接数 min-idle: 3 #最大连接数 max-active: 10 #连接超时时间 max-wait: 60000 3.3 配置druid后台监控 创建一个druid的配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//druid配置类@Configurationpublic class DruidConfig &#123; //绑定配置文件的数据源 @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; //后台监控功能 注册Servlet 类似web.xml //因为SpringBoot内置了servlet容器，所有没有web.xml，替代方法ServletRegistrationBean @Bean public ServletRegistrationBean servletRegistrationBean()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);//后台监控地址 //后台需要有人登陆，账号密码配置 HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;(); //-----------------后台监控设置--------------------- //增加配置（参数名为固定的，不能修改） initParameters.put(&quot;loginUsername&quot;, &quot;莱特雷&quot;); initParameters.put(&quot;loginPassword&quot;, &quot;123&quot;); //允许谁可以访问 initParameters.put(&quot;allow&quot;, &quot;&quot;); //值为空，所有人都可以访问 //禁止谁可以访问 initParameters.put(&quot;用户名&quot;, &quot;ip地址&quot;); //里面参数自定义 //---------------------------------------------------------- bean.setInitParameters(initParameters);//设置初始化参数 return bean; &#125; //注册过滤器 @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean&lt;Filter&gt; filterBean = new FilterRegistrationBean&lt;&gt;(); //配置过滤器 filterBean.setFilter(new WebStatFilter());//druid过滤器 //过滤请求 HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;(); //不过滤的内容 initParameters.put(&quot;exclusions&quot;, &quot;*.js, *.css, /druid/*&quot;); filterBean.setInitParameters(initParameters); return filterBean; &#125;&#125; 网页输入：”http://localhost:8080/druid&quot; 会进入登录页面，填写配置的账号，密码进入后台","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】项目实例：员工管理系统","slug":"【SpringBoot】项目实例：员工管理系统","date":"2020-11-02T13:11:41.000Z","updated":"2020-11-04T13:49:44.004Z","comments":true,"path":"2020/11/02/【SpringBoot】项目实例：员工管理系统/","link":"","permalink":"https://letere-gzj.github.io/2020/11/02/%E3%80%90SpringBoot%E3%80%91%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"简单用个实例来加深SpringBoot的使用","text":"简单用个实例来加深SpringBoot的使用 一、基础准备1.1 创建JavaBean （1）导入lombok依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 在SpringBoot中导入lombok依赖不能使用，还要进行插件安装“Settings” –&gt; “Plugins” –&gt; 搜索”lomnok” –&gt; 安装 （2）Department类 123456@Data@AllArgsConstructor@NoArgsConstructorpublic class Department &#123; private Integer id; private String departmentName; （3）Employee类 1234567891011@Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123; private Integer id; private String lastName; private String email; private Integer gender; private Department department; private Date date;&#125; 1.2 创建对应的DAO类为了方便，就暂时不整合Mybatis，就将数据存放在Java类中，并直接实现其方法 （1）DepartmentDao类 12345678910111213141516171819202122232425public class DepartmentDao &#123; //模拟数据库的数据 private static Map&lt;Integer, Department&gt; departmentMap = null; static &#123; departmentMap = new HashMap&lt;&gt;(); departmentMap.put(101, new Department(101, &quot;教学部&quot;)); departmentMap.put(102, new Department(102, &quot;市场部&quot;)); departmentMap.put(103, new Department(103, &quot;教研部&quot;)); departmentMap.put(104, new Department(104, &quot;运营部&quot;)); departmentMap.put(105, new Department(105, &quot;后勤部&quot;)); &#125; //查询所有部门 public static Collection&lt;Department&gt; getDepartMents()&#123; return departmentMap.values(); &#125; //通过ID查找部门 public static Department getDepartmentById(Integer id)&#123; return departmentMap.get(id); &#125;&#125; （2）EmployeeDao类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class EmployeeDao &#123; //模拟数据库的数据 private static Map&lt;Integer, Employee&gt; employees; static&#123; employees = new HashMap&lt;&gt;(); employees.put(101, new Employee(101, &quot;C酱&quot;, &quot;CC.com&quot;, 1, DepartmentDao.getDepartmentById(101))); employees.put(102, new Employee(102, &quot;咕料&quot;, &quot;gu.com&quot;, 0, DepartmentDao.getDepartmentById(102))); employees.put(103, new Employee(103, &quot;定春&quot;, &quot;sadaharu.com&quot;, 0, DepartmentDao.getDepartmentById(103))); employees.put(104, new Employee(104, &quot;YJJ&quot;, &quot;yjj.com&quot;, 0, DepartmentDao.getDepartmentById(104))); employees.put(105, new Employee(105, &quot;盐取&quot;, &quot;tukubi.com&quot;, 0, DepartmentDao.getDepartmentById(105))); &#125; //主键自增模拟 private static Integer initId = 106; //添加员工 public static void addEmployee(Employee employee, Integer id)&#123; if (employee.getId() == null)&#123; employee.setId(initId++); &#125; if (employee.getDepartment() == null)&#123; employee.setDepartment(DepartmentDao.getDepartmentById(id)); &#125; employees.put(employee.getId(), employee); &#125; //查询所有员工 public static Collection&lt;Employee&gt; getEmployees()&#123; return employees.values(); &#125; //通过ID查询员工 public static Employee getEmployeeById(Integer id)&#123; return employees.get(id); &#125; //删除员工 public static void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 1.3 拓展WebMvc配置类1234@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;&#125; 1.4 实例需要的静态资源下载 百度网盘 提取码：vi6a asserts放在静态资源文件夹 其他html放在templates文件夹下 二、设置主页虽然将index.html直接放在静态资源文件夹就可以自动设置主页，但真正的开发中一般将网页和静态资源区分，所以会将页面放在templates文件夹中 因此需要导入模板引擎thymeleaf启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 2.1 通过Controller跳转12345678910@Controllerpublic class IndexController &#123; //跳转首页 @RequestMapping(&#123;&quot;/&quot;, &quot;/index.html&quot;&#125;) public String getIndex()&#123; return &quot;index&quot;; &#125;&#125; 2.2 通过拓展WebMvc配置类跳转12345678910@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; //视图控制器：控制网页跳转 @Override public void addViewControllers(ViewControllerRegistry registry)&#123; //跳转到首页 registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); &#125; 2.3 解决CSS样式丢失问题CSS样式丢失原因为thymeleaf模板引擎取值的方式不同 修改方法如下 也顺便把其他页面的本地资源位置重新按照thymeleaf方式修改 三、国际化设置所谓国际化，就是支持页面语言的切换 3.1 创建配置文件 （1）在resources文件夹下创建名为i18n的文件夹（国际化 –&gt; Internationalization –&gt; 首字母i 和 尾字母之间隔了18个字母） （2）并在i18n文件夹下创建login.properties（名字随意）【默认语言】，login_zh_CN.properties【中文】，login_en_US.propertirs【英文】，会自动合并为login （3）添加网页中需要语言的参数，IDEA中有便捷方式快速添加 3.2 配置信息 （1）源码分析 123456789101112131415161718192021222324252627282930313233343536public class MessageSourceAutoConfiguration &#123; private static final Resource[] NO_RESOURCES = &#123;&#125;; @Bean @ConfigurationProperties(prefix = &quot;spring.messages&quot;) //配置前缀 public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties(); &#125; @Bean //从MessageSourceProperties中获取信息源 public MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; messageSource.setBasenames(StringUtils .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; &#125; ||能配置的内容 public class MessageSourceProperties &#123; private String basename = &quot;messages&quot;; //信息名 private Charset encoding = StandardCharsets.UTF_8; //编码集 &#125; 总结：在配置文件中填写配置信息的位置spring.messages.basename=”” （2）在配置文件设置信息的位置 123spring: messages: basename: i18n.login #信息位置 3.3 修改主页提取信息 3.4 语言切换设置 （1）源码分析 123456789101112131415161718192021222324252627282930313233WebMvcAutoConfiguration.java @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;) public LocaleResolver localeResolver() &#123; if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); //如果用户配置了地区分解器，就使用用户 &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); //没有配置则新建一个 localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125; ||跳转 public class AcceptHeaderLocaleResolver implements LocaleResolver &#123; //自定义地区分解器，实现localeResolver接口 @Override public Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = getDefaultLocale(); if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123; return defaultLocale; &#125; Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = getSupportedLocales(); if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123; return requestLocale; &#125; Locale supportedLocale = findSupportedLocale(request, supportedLocales); if (supportedLocale != null) &#123; return supportedLocale; &#125; return (defaultLocale != null ? defaultLocale : requestLocale); &#125; &#125; 总结：新建一个自定义的地区分解器，将次注入的WebMvc配置类中 （2）修改主页 添加链接重新跳转会主页，并传递地区参数信息 （3）自定义localeResolver（地区分解器） 123456789101112131415161718192021222324public class MyLocaleResolver implements LocaleResolver &#123; //解析请求 @Override public Locale resolveLocale(HttpServletRequest request) &#123; //获取请求的参数 String language = request.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault();//如果没有就使用默认的 if (language != null)&#123; //举例：zh_CN String[] split = language.split(&quot;_&quot;); //按“_”进行分割 //locale: 国家，地区 locale = new Locale(split[0], split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; （4）将localeResolver注入WebMvc配置类中 1234567891011121314151617@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; //视图控制器：控制网页跳转 @Override public void addViewControllers(ViewControllerRegistry registry)&#123; //跳转到首页 registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); &#125; //注入地区分解器 @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 四、编写登录后的页面4.1 编写主页 4.2 编写Controller跳转12345678910111213@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/login&quot;) public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Model model)&#123; //具体的业务逻辑判端，瞎写 if (&quot;莱特雷&quot;.equals(username) &amp;&amp; &quot;123&quot;.equals(password))&#123; return &quot;dashboard&quot;; &#125; model.addAttribute(&quot;msg&quot;, &quot;用户名或密码出现错误&quot;); //登录失败，向前端发送消息 return &quot;index&quot;; &#125;&#125; 4.3 隐藏账号密码 （1）模拟登录出现问题 （2）解决问题 在网页跳转在套一层跳转 用Controller跳转 / 拓展WebMvc配置类编写 12345678910Controller修改 @RequestMapping(&quot;/login&quot;) public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Model modeln)&#123; //具体的业务逻辑判端，瞎写 if (&quot;莱特雷&quot;.equals(username) &amp;&amp; &quot;123&quot;.equals(password))&#123; return &quot;redirect:/main.html&quot;; //将页面跳转到/main.html（作为一个中间跳转） &#125; model.addAttribute(&quot;msg&quot;, &quot;用户名或密码出现错误&quot;); //登录失败，向前端发送消息 return &quot;index&quot;; &#125; 123456789101112WebMvc配置页面跳转@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; //视图控制器：控制网页跳转 @Override public void addViewControllers(ViewControllerRegistry registry)&#123; //跳转到首页 registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;);//隐藏登录后的用户密码 &#125; 五、添加拦截器添加中间跳转隐藏密码出现新的问题：直接页面输入localhost:8080/main.html会绕过登录界面，此时需要配置拦截器来拦截下来 5.1 创建自定义的拦截器 类实现HandlerInterceptor接口，重写方法 12345678910111213public class MyInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //登录成功后：应该有用户的Session Object login = request.getSession().getAttribute(&quot;UserLogin&quot;); if (login == null)&#123; request.setAttribute(&quot;msg&quot;, &quot;没有权限，请先登录&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);//跳转回index页面 return false; &#125; return true; //true：放行，进行跳转；false：不放行 &#125;&#125; 5.2 修改Controller跳转 为了用户登录后返回一个Session，方便拦截器拦截 12345678910@RequestMapping(&quot;/login&quot;)public String login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, Model model, HttpSession session)&#123; //具体的业务逻辑判端，瞎写 if (&quot;莱特雷&quot;.equals(username) &amp;&amp; &quot;123&quot;.equals(password))&#123; session.setAttribute(&quot;UserLogin&quot;, username); return &quot;redirect:/main.html&quot;; &#125; model.addAttribute(&quot;msg&quot;, &quot;用户名或密码出现错误&quot;); //登录失败，向前端发送消息 return &quot;index&quot;;&#125; 5.3 注册拦截器 在WebMvc配置类中，注入拦截器（方法重写） 12345678910111213141516171819202122232425@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; //视图控制器：控制网页跳转 @Override public void addViewControllers(ViewControllerRegistry registry)&#123; //跳转到首页 registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;);//隐藏登录后的用户密码 &#125; //注入地区分解器 @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;, &quot;/index.html&quot;, &quot;/login&quot;, &quot;/asserts/**&quot;); //拦截所有请求，但不拦截主页，登录页，以及静态资源 &#125;&#125; 六、员工管理页面为了方便管理，将展示员工list的页面放在”emp”文件夹下 6.1 编写Controller跳转1234567891011@Controllerpublic class EmployeeController &#123; //查询所有员工信息，封装到Model，并返回前端 @RequestMapping(&quot;/emp/getEmps&quot;) public String getEmps(Model model)&#123; Collection&lt;Employee&gt; employees = EmployeeDao.getEmployees(); model.addAttribute(&quot;emps&quot;, employees); return &quot;emp/list&quot;; &#125;&#125; 6.2 修改页面（1）代码复用 由于dashboard.html 和 list.html 有大量的重复代码（顶部导航栏、侧边栏） 为了方便修改，将重复代码提取，进行统一修改 （2）修改复用代码 6.3 解决高亮问题点击页面时，总是首先那个按钮会发亮，点击员工管理没发亮 （1）lsit页面，main页面修改 \\ （2）复用代码设置高亮 6.4 员工表单修改list.html页面，将后端的数据提取出来，并放在一个表单中 七、添加员工功能7.1 添加按钮修改list.html页面，增加一个“添加员工”按钮，并跳转Contoller进行业务处理 7.2 添加员工页面复制list.html进行修改，变成add.html页面，把表内容删除，变成表单 12345678910111213141516171819202122232425262728293031323334353637&lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt; &lt;!--表单--&gt; &lt;form th:action=&quot;@&#123;/emp/addEmp&#125;&quot; method=&quot;post&quot;&gt; &lt;!--页面跳转--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;lastName&quot; class=&quot;form-control&quot; placeholder=&quot;莱特雷&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;letere.com&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Department&lt;/label&gt; &lt;select class=&quot;form-group&quot; name=&quot;department.id&quot;&gt; &lt;!--遍历departments集合，并添加value参数，来保证传递会后端的是部门ID--&gt; &lt;option th:each=&quot;dpet:$&#123;departments&#125;&quot; th:text=&quot;$&#123;dpet.getDepartmentName()&#125;&quot; th:value=&quot;$&#123;dpet.getId()&#125;&quot;&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Date&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;date&quot; class=&quot;form-control&quot; placeholder=&quot;2020-12-01&quot;&gt; &lt;!--注意日期格式为SpringBoot配置文件中设置，若没有设置，默认为yy/MM/dd --&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-sm btn-primary&quot;&gt;添加&lt;/button&gt; &lt;/form&gt;&lt;/main&gt; 7.3 Controller创建相应的业务123456789101112131415161718@Controllerpublic class EmployeeController &#123; //跳转到添加员工页面 @GetMapping(&quot;/emp&quot;) public String toAddEmp(Model model)&#123; Collection&lt;Department&gt; departments = DepartmentDao.getDepartMents(); model.addAttribute(&quot;departments&quot;, departments); //向前端传递部门名称 return &quot;emp/add&quot;; &#125; //后端接收数据，添加员工，并返回员工列表主页 @RequestMapping(&quot;/emp/addEmp&quot;) public String addEmp(Employee employee)&#123; EmployeeDao.addEmployee(employee, employee.getDepartment().getId()); return &quot;redirect:/emp/getEmps&quot;; &#125;&#125; 效果图 八、修改员工功能8.1 修改按钮修改list.html，添加一个修改员工按钮 效果图 8.2 创建修改页面复制add.html进行修改 8.3 Controller创建相应业务123456789101112131415161718192021@Controllerpublic class EmployeeController &#123; //跳转到修改员工页面 @RequestMapping(&quot;/emp/&#123;id&#125;&quot;) public String toUpdateEmp(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; //接受前端传来的员工id Employee employee = EmployeeDao.getEmployeeById(id); Collection&lt;Department&gt; departments = DepartmentDao.getDepartMents(); model.addAttribute(&quot;emp&quot;, employee); model.addAttribute(&quot;departments&quot;, departments); //向前端传递员工信息作为默认值 return &quot;emp/update&quot;; &#125; //后端接受数据，修改员工，并返回员工列表主页 @RequestMapping(&quot;/emp/updateEmp&quot;) public String updateEmp(Employee employee)&#123; EmployeeDao.addEmployee(employee, employee.getDepartment().getId()); return &quot;redirect:/emp/getEmps&quot;; &#125;&#125; 效果图 九、删除员工功能和收尾9.1 Controller添加删除员工业务1234567891011@Controllerpublic class EmployeeController &#123; //删除员工并跳转回员工列表主页 @RequestMapping(&quot;/delemp/&#123;id&#125;&quot;) public String deleteEmp(@PathVariable(&quot;id&quot;) Integer id)&#123; EmployeeDao.delete(id); return &quot;redirect:/emp/getEmps&quot;; &#125; &#125; 9.2 添加错误页面 在templates文件夹下创建”error”文件夹，将对应的错误页面改名为错误代码，放进”error”文件夹，thymeleaf会自动跳转，不用填写相应跳转 9.3 添加注销功能 （1）修改commen.html页面 （2）Controller添加相应业务 1234567891011@Controllerpublic class LoginController &#123; //注销登录 @RequestMapping(&quot;/logout&quot;) public String logout(HttpSession session)&#123; session.invalidate();//销毁Session return &quot;redirect:index.html&quot;; &#125; &#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】SpringBootWeb开发","slug":"【SpringBoot】SpringBootWeb开发","date":"2020-10-31T08:05:17.000Z","updated":"2020-11-01T03:59:08.404Z","comments":true,"path":"2020/10/31/【SpringBoot】SpringBootWeb开发/","link":"","permalink":"https://letere-gzj.github.io/2020/10/31/%E3%80%90SpringBoot%E3%80%91SpringBootWeb%E5%BC%80%E5%8F%91/","excerpt":"如何利用SpringBoot写一个Web项目","text":"如何利用SpringBoot写一个Web项目 一、访问静态资源1.1 源码分析1234567891011121314151617181920@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; //如果有手动配置访问路径，默认静态资源位置失效 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;//访问/webjars/**，就会从/META-INF/resources/webjars/下寻找对应的资源 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; // private String staticPathPattern = &quot;/**&quot; ，访问链接为此时，都会被this.resourceProperties.getStaticLocations()识别&#125; 123456789public String[] getStaticLocations() &#123; return this.staticLocations; &#125; //跳转&quot;staticLocations&quot;private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; //跳转&quot;CLASSPATH_RESOURCE_LOCATIONS&quot;private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;// &quot;/**&quot;进行静态资源访问，则会从以下目录寻找资源 1.2 利用webjars webjars网址：https://www.webjars.org/ 导入依赖，通过网页访问webjars/*，来进行访问静态资源 但此方法局限性比较高，基本不会使用 1.3 使用默认静态资源位置 源码分析，静态资源可以存放在一下位置 （1）classpath:/META-INF/resources/ （2）classpath:/resources/ （3）classpath:/static/ （4）classpath:/public/ 资源访问的优先级：resources &gt; static &gt; public 二、定制首页2.1 源码分析123456789 //获取首页private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());//静态资源目录获取首页 return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();&#125;private Resource getIndexHtml(String location) &#123; return this.resourceLoader.getResource(location + &quot;index.html&quot;);//寻找静态资源里名字为index.html的页面&#125; 总结：首页名字为”index.html”，并将此文件放在静态资源文件夹中 2.2 实例 创建一个index.html文件，放在默认静态资源文件夹 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 2.3 彩蛋：定制图标 将favicon.ico图标放在静态资源文件夹内 三、thymeleaf模板引擎3.1 介绍 模板引擎：将后端数据和前端页面结合，渲染成一个网页 thymeleaf是其中一个模板引擎 thymeleaf官网：https://www.thymeleaf.org/ 3.2 使用方法 （1）源码分析 123456789thymeleaf自动配置类：ThymeleafProperties public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; //字符集编码 public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; //前缀 public static final String DEFAULT_SUFFIX = &quot;.html&quot;; //后缀 &#125; 总结：thymeleaf作用于视图解析器一样，都是对字符串进行拼接跳转，跳转到”/templates/Xxxx.html”文件 （2）导入启动器依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; （3）编写Controller接口以及对应的跳转页面 12345678910111213Controller接口@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/thymeleaf&quot;) public String thymeleaf(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;Message&quot;); model.addAttribute(&quot;msg2&quot;,&quot;&lt;h1&gt;Message2&lt;h1&gt;&quot;); model.addAttribute(&quot;list&quot;, Arrays.asList(&quot;咕料&quot;, &quot;C酱&quot;)); return &quot;hello&quot;; &#125;&#125; 12345678910111213141516171819202122跳转页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello thymeleaf!&lt;/h1&gt; &lt;!--所有html元素都可以被thymeleaf替换接管：th:元素名--&gt; &lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt; &lt;!--取值--&gt; &lt;div th:utext=&quot;$&#123;msg2&#125;&quot;&gt;&lt;/div&gt;&lt;!--不转义取值--&gt; &lt;div th:each=&quot;name:$&#123;list&#125;&quot; th:text=&quot;$&#123;name&#125;&quot;/&gt;&lt;!--遍历元素：两种方法都可以--&gt; &lt;div th:each=&quot;name:$&#123;list&#125;&quot;&gt; [[ $&#123;name&#125; ]] &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; thymeleaf模板引擎取值和jsp页面取值方法不一样，可自行百度了解或参考官方文档 https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence 四、拓展配置MVC4.1 拓展方法 官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-developing-web-applications 总结： 添加@Configuration注解到类型为WebMvcConfigurer的类中，不要添加@EnableWebMvc注解 举例： 1234@Configuration //配置类public class MyMvcConfig implements WebMvcConfigurer &#123; //实现WebMVCConfigurer接口 //跟Spring全注解开发的配置类使用类似&#125; 4.2 添加@EnableWebMVC注解 （1）源码分析 1234567891011121314151617181920212223242526源码分析： @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Import(DelegatingWebMvcConfiguration.class) //此注解导入一个DelegatingWebMvcConfiguration public @interface EnableWebMvc &#123; &#125; ||跳转 @Configuration(proxyBeanMethods = false) public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; //此类继承于WebMvcConfigurationSupport //省略 &#125; -------------------------------------------------- 回到WebMvc自动配置类WebMvcAutoConfiguration中 @Configuration(proxyBeanMethods = false) @ConditionalOnWebApplication(type = Type.SERVLET) @ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;) @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) //如果不存在WebMvcConfigurationSupport.class才会自动装配 @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) @AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;) public class WebMvcAutoConfiguration &#123; //省略 &#125; （2）总结： 一旦我们添加@EnableWebMvc，SpringBoot不再加载自动配置类，我们自定义的配置类全面接管了WebMvc的配置","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】SpringBoot配置","slug":"【SpringBoot】SpringBoot配置","date":"2020-10-31T06:24:04.000Z","updated":"2020-10-31T07:59:02.532Z","comments":true,"path":"2020/10/31/【SpringBoot】SpringBoot配置/","link":"","permalink":"https://letere-gzj.github.io/2020/10/31/%E3%80%90SpringBoot%E3%80%91SpringBoot%E9%85%8D%E7%BD%AE/","excerpt":"关于SpringBoot的配置文件使用","text":"关于SpringBoot的配置文件使用 一、配置文件 SpringBoot的配置文件有三种，properties、yml、yaml三种 1.1 正常配置修改 （1）properties文件 12配置端口号： server.port=8081 （2）yaml文件 123配置端口号： server: prot: 8081 注意：在”:”后面要空一个，再接参数 1.2 给对象赋值创建一个JavaBean对象 12345678910@Componentpublic class Person &#123; private String name; private int age; private boolean isMan; private Date birthday; private Map&lt;String,Object&gt; maps; private List&lt;String&gt; lists; private Dog dog;&#125; （1）properties文件 123配置文件 name=小白 age=1 1234567891011121314@Component@PropertySource(value = &quot;classpath:test.properties&quot;)//加载指定的配置文件public class Person &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; @Value(&quot;$&#123;age&#125;&quot;) private int age; private boolean isMan; private Date birthday; private Map&lt;String,Object&gt; maps; private List&lt;String&gt; lists; private Dog dog; &#125; （2）yaml文件 yaml文件不仅可以进行简单的赋值 还可以赋值其他参数，集合、对象、数组… 1234567891011配置文件person: name: 莱特雷 age: 22 boolean: true birthday: 2019/12/12 maps: &#123;key1: value1,key2: value2&#125; lists: [代码, 音乐, 看小电影] dog: name: 小白 age: 1 1234567891011@Component@ConfigurationProperties(prefix = &quot;person&quot;) //绑定yaml的personpublic class Person &#123; private String name; private int age; private boolean isMan; private Date birthday; private Map&lt;String,Object&gt; maps; private List&lt;String&gt; lists; private Dog dog; 总结：properties的作用非常有限，所以一般都推荐使用yaml作为配置文件 1.3 yaml文件特有方法 （1）松散绑定 即驼峰命名，配置文件中last-name和类中lastName是可以识别，并复制 但要保证类中get set方法不出错 （2）JSR303数据校验 在字段增加一层过滤器，可以保证数据的合法性 12345添加启动器依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 123456789101112131415在JavaBean进行配置@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Validated //JSR303数据校验public class Person &#123; @Email//规定填写数据为邮箱格式 private String name; private int age; private boolean isMan; private Date birthday; private Map&lt;String,Object&gt; maps; private List&lt;String&gt; lists; private Dog dog;&#125; 具体可设置的参数 注解 说明 @Null 被注释的元素必须为null @NotNull 被注释的元素必须不为null @AssertTrue 被注释的元素必须为true @AssertFalse 被注释元素必须为fasle @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值，小数存在精度 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值，小数存在精度 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=) 被注释的元素必须符合指定的正则表达式 @Valid 被注释的元素需要递归验证 注解 说明 @Email 被注释的元素必须是电子邮箱地址 @Length(min=下限, max=上限) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的元素的必须非空并且size大于0 @NotBlank 被注释的元素必须不为空且不能全部为’ ‘(空字符串) @Range(min=最小值, max=最大值) 被注释的元素必须在合适的范围内 二、配置文件的位置 三、多环境配置 （1）properties配置 一个环境创建一个配置文件 文件形式为： application-环境名.properties 在默认配置文件application.properties中 使用：spring.profiles.active=环境名，来进行环境切换 （2）yaml配置 12345678910111213141516171819202122232425#最上面为默认环境 server: port: 8081 #选择激活的环境 spring: profiles: active: dev --- server: port: 8082 #起环境名 spring: profiles: dev --- server: port: 8083 #起环境名 spring: profiles: test#用&quot;---&quot;来分割环境 四、可以配置的参数由于SpringBoot可以配置的参数过于多，所以不会一一列出来，而是教利用源码查找方法 （1）IDEA双击”shift”来进行搜索 （2）来ServerProperties来进行举例 总结 ：可以通过搜索properties寻找可以配置的属性","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】了解SpringBoot","slug":"【SpringBoot】了解SpringBoot","date":"2020-10-29T13:35:26.000Z","updated":"2020-10-31T06:20:36.151Z","comments":true,"path":"2020/10/29/【SpringBoot】了解SpringBoot/","link":"","permalink":"https://letere-gzj.github.io/2020/10/29/%E3%80%90SpringBoot%E3%80%91%E4%BA%86%E8%A7%A3SpringBoot/","excerpt":"通过稍微查看源码，对SpringBoot进行了解","text":"通过稍微查看源码，对SpringBoot进行了解 一、pom.xml文件 pom.xml有个父项目为spring-boot-starter-parent spring-boot-starter-parent也有一个父项目spring-boot-dependencies 1.1 pom.xml 里面配置启动器依赖：spring-boot-starter-XXXX，也就是SpringBoot的启动场景 举例：spring-boot-starter-web，他会帮我们自动导入web环境所有的依赖 springboot将所有的功能场景，都变成一个个启动器。需要相应的功能，则需要使用相应的启动器 官方文档（启动器类型）：https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter 1.2 spring-boot-starter-parent 里面配置了资源插件，来过滤文件内容 12345678910111213141516171819&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/application*.yml&lt;/include&gt; &lt;include&gt;**/application*.yaml&lt;/include&gt; &lt;include&gt;**/application*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/application*.yml&lt;/exclude&gt; &lt;exclude&gt;**/application*.yaml&lt;/exclude&gt; &lt;exclude&gt;**/application*.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt;&lt;/resources&gt; 里面也配置了一大堆插件 1.3 spring-boot-dependencieslim 里面是管理SpringBoot的核心依赖，存放着各种各样的版本 称此为版本仓库，因为此版本仓库，所以我们引入依赖时不需要指定版本 二、主程序XxxxApplication2.1 主程序123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 主程序需要关注的有： 注解@SpringBootApplication SpringApplication类 2.2 @SpringBootApplication注解 （1）点进@SpringBootApplication 12345678SpringBootApplication注解 //省略了元注解 @SpringBootConfiguration //SpringBoot的配置类 @EnableAutoConfiguration //自动配置 @ComponentScan(excludeFilters = &#123;@Filter(type = FilterType.CUSTOM,classes = &#123;TypeExcludeFilter.class&#125;), //组件扫描 @Filter(type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;) &#125; )//组件扫描 （2）点进@SpringBootConfiguration（springboot配置类） 123SpringBootConfiguration注解 //省略了元注解 @Configuration //Spring配置类 总结：@SpringBootConfiguration只是一个简单配置类 （3）点进@EnableAutoConfiguration 1234EnableAutoConfiguration注解 //省略了元注解 @AutoConfigurationPackage //自动配置包 @Import(AutoConfigurationImportSelector.class) //自动配置选择器导入 （4）点进@AutoConfigurationPackage 12AutoConfigurationPackage注解 @Import(AutoConfigurationPackages.Registrar.class) //自动配置`包注册` （5）点进AutoConfigurationImportSelector.class 1234567891011121314protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //获取候选的配置 configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);&#125; 123456789101112131415点进获取候选配置方法getCandidateConfigurations() protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), //getSpringFactoriesLoaderFactoryClass()获得加载类 getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; //如果配置为空，找不到META-INF/spring.factories，此为自动配置的核心文件 + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; &#125; protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class; //标记为@EnableAutoConfiguration的类启动资源 &#125; //@SpringBootApplication注解上，标记了@EnableAutoConfiguration，所以被SpringBootApplication标记的类的所有资源会导入 12345678910111213141516171819202122232425262728293031323334353637383940public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123; String factoryTypeName = factoryType.getName(); return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());&#125;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) &#123; return result; &#125; else &#123; try &#123; //获取类所有资源 //获取所有系统资源 Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);//获取资源放在urls里 LinkedMultiValueMap result = new LinkedMultiValueMap(); while(urls.hasMoreElements()) &#123; //判断是否含有更多元素，循环遍历资源，并保存着Properties类中 URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); //有，更多元素就封装到properties类里面 Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryTypeName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) &#123; String factoryImplementationName = var9[var11]; result.add(factoryTypeName, factoryImplementationName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException var13) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13); &#125; &#125;&#125; 总结：这里所有的资源加载，都来自于”META-INF/spring.factories”，是SpringBoot的核心文件 2.3 查看spring.factories 文件所在位置：org\\springframework\\boot\\spring-boot-autoconfigure\\2.3.4.RELEASE\\spring-boot-autoconfigure-2.3.4.RELEASE.jar!\\META-INF\\spring.factories spring.factories里面全是SpringBoot为我们配置的配置类，名字为xxxxAutoConfiguration 分析其中的一个自动配置类 12345678910@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123;&#125; @ConditionalOnXxxx注解进行判断，如果过条件符合才会加载此自动类，通过pom.xml导入相关的启动器依赖，来满足条件，进行自动装配 2.4 main方法 （1）表面形式： SpringApplication.run(Application.class, args)，调用SpringApplication的静态方法run，利用反射进行运行 （2）内部形式 1、推断应用的类型是普通的项目还是web项目 2、查找并加载所有可用的初始化器，设置到initalizer属性中 3、找出所有的应用程序监听器，设置到listeners 4、推断并设置mian方法的定义类，找到运行的主类","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【SpringBoot】SpringBoot入门","slug":"【SpringBoot】SpringBoot入门","date":"2020-10-29T13:01:03.000Z","updated":"2020-10-31T05:46:24.434Z","comments":true,"path":"2020/10/29/【SpringBoot】SpringBoot入门/","link":"","permalink":"https://letere-gzj.github.io/2020/10/29/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%85%A5%E9%97%A8/","excerpt":"SpringBoot的简单了解","text":"SpringBoot的简单了解 一、SpringBoot介绍 Spring：为了解决企业级应用开发的复杂性而创建的，简化开发 SpringBoot基于Spring开发，是一个JavaWeb的开发框架，和SpringMVC类似 SpringBoot主要优点： （1）为了所有Spring开发者更快入门 （2）开箱即用，提供各种默认设置来简化项目的配置 （3）内嵌式容器简化Web项目 （4）没有冗余代码生成和XML配置的要求 二、微服务 框架发展背景：http://dubbo.apache.org/zh-cn/docs/user/preface/background.html 2.1 单体应用架构 单体应用架构(all in on)，将一个应用中的所有应用服务都封装在一个应用中 好处 （1）易于开发和测试 （2）方便部署 （3）功能拓展 缺点：修改任意地方都要停掉整个服务，重新打包，部署应用war包 2.2 微服务架构 打破all in one的架构方式，把独立出来的功能元素的动态组合，需要的功能元素才去组合。 好处 （1）节省了调用资源 （2）每个功能元素的服务都是一个可替换的，可独立升级的软件代码 2.3 学习方向 构建一个个功能独立的微服务应用单元，使用springBoot，可以帮我们快速构建一个应用 大型分布式网络服务的调用，这部分由SpringCloud来完成，实现分布式 在分步式中间，进行流式数据计算、批处理，用spring cloud data flow Spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案 三、搭建SpringBoot项目3.1 通过官网 官网：https://start.spring.io/ 下载，解压，导入，删除除了pom.xml和src的多余文件，就是一个标准的SpringBoot项目 3.2 通过IDEA 使用IDEA创建SpringBoot项目，集成了Spring官网，本质上是利用官网创建 删除除了pom.xml和src的多余文件，就是一个标准的SpringBoot项目 3.3 使用SpringBoot （1）目录介绍 （2）在主程序同级目录下进行建包 （3）直接在Controller包中创建一个Controller接口 123456789@Controllerpublic class DemoController &#123; @RequestMapping(&quot;/demo&quot;) @ResponseBody//返回字符串，不经视图解析器 public String demo()&#123; return &quot;SpringBoot Demo&quot;; &#125;&#125; （4）运行主程序 3.4 总结 SpringBoot无需玩家进行任何配置，可以直接使用，体现了SpringBoot的自动装配特性 SpringBoot还具有微服务的特性 通过Maven打包，变成一个jar包，这个jar包就是一个单独的可执行程序 可以通过命令行 java -jar ./jar包名字（含后缀名）来运行 3.5 彩蛋 修改banner：即命令行输出”Spring”的图像 banner样式参考地址：https://www.bootschool.net/ascii 然后在SpringBoot同级目录，新建一个banner.txt，将要设置的样式放进去，重新运行就可以看到","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"}],"tags":[]},{"title":"【Spring】声明式事务","slug":"【Spring】声明式事务","date":"2020-10-28T13:00:58.000Z","updated":"2020-10-28T14:24:21.919Z","comments":true,"path":"2020/10/28/【Spring】声明式事务/","link":"","permalink":"https://letere-gzj.github.io/2020/10/28/%E3%80%90Spring%E3%80%91%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","excerpt":"通过Spring配置事物管理","text":"通过Spring配置事物管理 一、引出事务错误1.1 运行环境 此例子是以Spring 和 Mybatis整合的方式进行举例 Maven依赖导入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;transaction&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.22&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring操作数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring AOP--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--注解实现JavaBean--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis 与 Spring 整合适配包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--运行环境--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!--Maven打包Java项目下的xml文件--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;!--资源所在目录--&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!--扫描的内容：xx.properties和xx.xml文件--&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt;&lt;!--扫描properties文件--&gt; &lt;include&gt;**/*.xml&lt;/include&gt;&lt;!--扫描xml文件--&gt; &lt;/includes&gt; &lt;!--是否启动过滤器：选定扫描的内容已经达到了过滤效果--&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 1.2 各包内容 com.letere.bean包 12345678910JavaBean：通过引入Lombok包进行快速创建@Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123; private Integer id; private String lastName; private char gender; private String email;&#125; com.letere.dao包 12345678910接口public interface EmployeeMapper &#123; //增 int addEmp(Employee employee); //删 int deleteEmpById(Integer id); //方法整合 int transationTest();&#125; 1234567891011121314151617映射文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.dao.EmployeeMapper&quot;&gt; &lt;insert id=&quot;addEmp&quot;&gt; insert into tbl_employee(id, last_name, gender, email) values (#&#123;id&#125;, #&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteEmpById&quot;&gt; delete from tbl_employee where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; con.letere.service包 1234567891011121314151617181920212223Service层实现类public class EmployeeService extends SqlSessionDaoSupport implements EmployeeMapper &#123; @Override public int addEmp(Employee employee) &#123; return getSqlSession().getMapper(EmployeeMapper.class).addEmp(employee); &#125; @Override public int deleteEmpById(Integer id) &#123; return getSqlSession().getMapper(EmployeeMapper.class).deleteEmpById(id); &#125; @Override public int transationTest() &#123; addEmp(new Employee(null, &quot;虾米&quot;, &#x27;1&#x27;, &quot;routui.com&quot;));//增加员工 int a = 10/0; //故意填写错误，使其抛出异常 deleteEmpById(8);//删除员工 return 0; &#125;&#125; 1.3 配置文件12345JDBC连接配置文件 jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 jdbc.username=root jdbc.password=123 12345678910111213Mybatis全局配置文件（可选）&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!--启用驼峰命名--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 12345678910111213141516171819202122232425262728Spring-dao配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入数据库连接配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc-config.properties&quot; /&gt; &lt;!--数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory 省去了Mybatis中需要去new sqlSessionFactory().build(inpuyStream)步骤，通过Spring进行属性注入 --&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sqlSessionFactory&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--关联数据源--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!--绑定配置文件--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:com/letere/dao/*.xml&quot;/&gt; &lt;!--指定sql映射文件的位置，默认为借口所在位置--&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314Spring整合配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;!--属性注入Service层实现类--&gt; &lt;bean class=&quot;com.letere.service.EmployeeService&quot; id=&quot;employeeService&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4 测试方法123456789101112测试方法 //故意制造事务错误 @Test public void transationTest()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); EmployeeMapper mapper = context.getBean(&quot;employeeService&quot;, EmployeeMapper.class); mapper.transationTest(); //在执行完插入操作后出现异常，但是插入仍然成功，这是事务所不想看到的 &#125; 二、xml配置文件实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Spring整合配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--导入spring-dao配置文件，进行进行管理--&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;bean class=&quot;com.letere.service.EmployeeService&quot; id=&quot;employeeService&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--1、创建事务管理器--&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; id=&quot;transactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--2、配置通知：切入的方法--&gt; &lt;tx:advice transaction-manager=&quot;transactionManager&quot; id=&quot;txAdvice&quot;&gt; &lt;!--给方法配置事务 name：方法名字，可以直接用*表示所有方法 propagation：传播特性，默认:REQUIRED REQUIRED ： 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 SUPPORTS ： 支持当前事务，如果当前没有事务，就以非事务方式执行。 MANDATORY ： 支持当前事务，如果当前没有事务，就抛出异常。 REQUIRES_NEW ： 新建事务，如果当前存在事务，把当前事务挂起。 SUPPORTED ： 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 NEVER ： 以非事务方式执行，如果当前存在事务，则抛出异常。 NESTED ： 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;&lt;!--所有方法--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--3、事务切入--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.letere.service.*.*(..))&quot;/&gt;&lt;!--Service层下所有类所有方法--&gt; &lt;!--切入--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; Spring配置事物利用了AOP层的原理，所有配置切入点以及切面 配置完后再执行测试方法，会发现插入不成功了，实现了声明式事务 三、注解实现 由于xml配置过于繁琐，开发中一般使用注解实现声明式事务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Spring整合配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--导入spring-dao配置文件，进行进行管理--&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;bean class=&quot;com.letere.service.EmployeeService&quot; id=&quot;employeeService&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--1、创建事务管理器--&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; id=&quot;transactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--2、开启事务注解：让Spring能够识别事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;!--3、在Service类上面 或 在Service类中方法上添加事务注解 @Transactionnal 注解添加到类中：类中所有方法具有事务 注解添加到方法上：只有该方法上具有事务 --&gt; &lt;!--4、可选：在@Transactionnal中添加参数 propagation：传播行为 参数为Propagation.xxx，是一个枚举类 isolation：事务隔离级别 参数为Isolation.xxx，是一个枚举类 timeout：超时时间 默认值为-1，不超时，设置超时时间以秒为单位 readOnly：是否只读 默认false，true/fasle rollbackFor：回滚 设置出现哪些异常会进行事务回滚 noRollbackFor：不回滚 设置出现哪些异常不会进行事务回滚 --&gt;&lt;/beans&gt; 123456789101112131415161718192021222324将事务注解声明在类上@Transactionnalpublic class EmployeeService extends SqlSessionDaoSupport implements EmployeeMapper &#123; @Override public int addEmp(Employee employee) &#123; return getSqlSession().getMapper(EmployeeMapper.class).addEmp(employee); &#125; @Override public int deleteEmpById(Integer id) &#123; return getSqlSession().getMapper(EmployeeMapper.class).deleteEmpById(id); &#125; @Override public int transationTest() &#123; addEmp(new Employee(null, &quot;虾米&quot;, &#x27;1&#x27;, &quot;routui.com&quot;));//增加员工 int a = 10/0; //故意填写错误，使其抛出异常 deleteEmpById(8);//删除员工 return 0; &#125;&#125; 三、纯注解开发 纯注解是在注解开发上的拓展 演示只配置与声明式事务有关的配置，不是全部xml文件都转为配置类 12345678910111213141516171819202122232425配置类@Configuration//配置类@ComponentScan(basePackages = &quot;com.letere.service&quot;)//组建扫描@EnableTransactionManagement//开启事务public class TxConfig &#123; //创建数据源 @Bean public DriverManagerDataSource getDataSource()&#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123&quot;); return dataSource; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager getTransactionManager(DataSource datasource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(datasource); return transactionManager; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://letere-gzj.github.io/categories/Spring/"}],"tags":[]},{"title":"【Mybatis】逆向工程","slug":"【Mybatis】逆向工程","date":"2020-10-28T12:06:10.000Z","updated":"2020-10-28T12:43:25.254Z","comments":true,"path":"2020/10/28/【Mybatis】逆向工程/","link":"","permalink":"https://letere-gzj.github.io/2020/10/28/%E3%80%90Mybatis%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","excerpt":"关于Mybatis的代码生成器使用","text":"关于Mybatis的代码生成器使用 一、介绍 逆向工程：也被称作Mybatis Generator（代码生成器） 简称：MBG 代码生成器可以通过数据库表，来自动生成JavaBean、接口、映射文件，不用自己配置 代码生成器，要下载相应的jar包：mybatis-generator-core 下载地址：https://github.com/mybatis/generator/releases 123456Maven： &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; 方便学习，可以参考官方使用文档：https://www.mybatis.org/generator 二、使用方法2.1 创建配置文件 参考官方文档配置文件信息：http://mybatis.org/generator/configreference/xmlconfig.html 复制基本的模板进行修改，具体各个参数，可细看官方文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--数据库驱动位置--&gt; &lt;classPathEntry location=&quot;D:\\DataBase\\mysql-connector-java-8.0.21\\mysql-connector-java-8.0.21.jar&quot;/&gt; &lt;!--代码生成器运行环境：参数看官方 MyBatis3Simple：创建简单的增删改查方法 MyBatis3：能创建动态sql语句 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--jdbcConnection：数据库连接--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&quot; userId=&quot;root&quot; password=&quot;123&quot;&gt; &lt;/jdbcConnection&gt; &lt;!--javaTypeResolver：Java类型解析器 使用默认即可 --&gt; &lt;javaTypeResolver &gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!--指定JavaBean的生成策略：生成JavaBean targetPackage=&quot;test.model1&quot;：目标包 targetProject=&quot;\\MGBTestProjecr\\src&quot;：目标工程（在IDEA中蓝色的文件夹） 属性内容可看官方文档 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.letere.bean&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt;&lt;!--当前工程src包下--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!--sqlMapGenerator：sql映射文件生成策略（Mapper文件）--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.letere.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt;&lt;!--当前工程resources目录下--&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!--javaClientGenerator：生成mapper接口所在位置与方法--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.letere.dao&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!--table：关联数据库表，通过数据库表来逆向生成前面所有东西 tableName：表名 domainObject：生成JavaBean的名字 --&gt; &lt;table tableName=&quot;tbl_employee&quot; domainObjectName=&quot;Employee&quot; /&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 目录结构 2.2 使用代码生成器 代码生成器运行的方式有很多种，可看官方文档：http://mybatis.org/generator/running/running.html 下面是以Java运行xml文件的形式来举例 复制官方基本代码进行修改：http://mybatis.org/generator/running/runningWithJava.html 注意代码导包会出现重复包，应选择导入以下包： java.io.File; org.mybatis.generator.config.xml.ConfigurationParser; 123456789101112测试方法：只需修改配置文件路径即可 @Test public void runningXmlByJava() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;src\\\\main\\\\resources\\\\mbg-config.xml&quot;);//xml配置文件位置 ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; 代码运行，会发现在每个包下会自动相应的JavaBean、接口、配置文件","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://letere-gzj.github.io/categories/Mybatis/"}],"tags":[]},{"title":"【SSM整合】Spring+SpringMVC+Mybatis框架整合","slug":"【SSM整合】Spring-SpringMVC-Mybatis框架整合","date":"2020-10-26T13:35:33.000Z","updated":"2020-10-27T13:34:59.367Z","comments":true,"path":"2020/10/26/【SSM整合】Spring-SpringMVC-Mybatis框架整合/","link":"","permalink":"https://letere-gzj.github.io/2020/10/26/%E3%80%90SSM%E6%95%B4%E5%90%88%E3%80%91Spring-SpringMVC-Mybatis%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/","excerpt":"将三大框架整合在一起的方法","text":"将三大框架整合在一起的方法 一、前期准备 导包（Maven设置） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;SpringMVC框架&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;整合ssm&lt;/artifactId&gt; &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--Junit：单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mysql8数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.22&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库连接池(c3p0, dbcp)--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet jsp--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--静态资源导出--&gt; &lt;build&gt; &lt;resources&gt; &lt;!--maven资源打包，java目录下默认值打包java程序，不打包配置文件，通过设置也让其打包--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/project&gt; 二、整合Mybatis层2.1 数据库创建12345678910111213141516create database `ssmbuild`;use `ssmbuild`;create table `book`( `bookID` int(10) not null auto_increment, `bookName` varchar(100) not null, `bookCounts` int(11) not null, `detail` varchar(200) not null, key `bookID` (`bookID`))engine=innodb default charset=utf8insert into `book` (`bookID`, `bookName`, `bookCounts`, `detail`)values (1, &#x27;java&#x27;, 1, &#x27;从入门到放弃&#x27;), (2, &#x27;MySQL&#x27;, 10, &#x27;从删库到跑路&#x27;), (3, &#x27;Linux&#x27;, 5, &#x27;从进门到进牢&#x27;) 2.2 创建相应的包 controller、dao(mapper)、pojo(bean)、service 2.3 创建数据库对应的bean/pojo 为了偷懒，可以导入一个第三方jar包lombok 1234567Maven依赖导入 &lt;!--lombok：通过注解，快速创建Bean对象--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; 12345678910Bean/Pojo@Data //自动产生get set toString方法@AllArgsConstructor //创建所有有参构造器@NoArgsConstructor //创建无参构造器public class Books &#123; private Integer bookID; private String bookName; private Integer bookCounts; private String detail;&#125; 2.3 创建接口 在dao包中创建映射接口 1234567891011121314public interface BookMapper &#123; //增 int addBook(Book book); //删 int deleteBookById(Integer id); //改 int updateBook(Book book); //查 Book queryBookById(Integer id); List&lt;Books&gt; queryAllBook();&#125; 2.4 创建接口的Mybatis的映射文件 在dao包中创建和接口同名的映射文件 在映射文件中添加方法执行的sql语句 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.letere.dao.BookMapper&quot;&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;com.letere.pojo.Books&quot;&gt; insert into book(bookName, bookCounts, detail) values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;Integer&quot;&gt; delete from book where bookID=#&#123;bookID&#125; &lt;/delete&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;com.letere.pojo.Books&quot;&gt; &lt;!--Books在全局配置文件起了别名--&gt; update book set bookName=#&#123;bookName&#125;, bookCounts=#&#123;bookCounts&#125;, detail=#&#123;detail&#125; where bookID=#&#123;bookID&#125; &lt;/update&gt; &lt;select id=&quot;queryBookById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.letere.pojo.Books&quot;&gt; select * from book where bookID=#&#123;bookID&#125; &lt;/select&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;com.letere.pojo.Books&quot;&gt; select * from book &lt;/select&gt;&lt;/mapper&gt; 2.5 创建Mybatis全局映射文件 在全局配置文件中注册Mapper映射文件 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--配置数据源：读取配置文件（交给Spring去做）--&gt; &lt;!--起别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.letere.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!--将写好的sql映射文件注册到全局配置文件中--&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=&quot;.\\\\com\\\\letere\\\\dao\\\\BookMapper.xml&quot; /&gt;--&gt; &lt;mapper class=&quot;com.letere.dao.BookMapper&quot; /&gt; &lt;!--接口 和 映射文件 名称一样，可以直接用class来定位--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.6 创建Service层的实现类 在Service包创建BookMapper的实现类，用于Controller层调用 1234567891011121314151617181920212223242526272829303132@Servicepublic class BookService implements BookMapper&#123; @Autowired private BookMapper bookMapper;//创建BookMapper对象，来调用其接口 @Override public int addBook(Book book) &#123; return bookMapper.addBook(book); &#125; @Override public int deleteBookById(Integer id) &#123; return bookMapper.deleteBookById(id); &#125; @Override public int updateBook(Book book) &#123; return bookMapper.updateBook(book); &#125; @Override public Book queryBookById(Integer id) &#123; return bookMapper.queryBookById(id); &#125; @Override public List&lt;Books&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125;&#125; 2.7 创建好数据库连接配置文件 在resources文件下创建一个database.properties1234mysql.dirver=com.mysql.cj.jdbc.Drivermysql.url=jdbc:mysql://localhost:3306/ssmbuild?serverTimezone=GMT%2B8&amp;useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8mysql.username=rootmysql.password=123 2.8 创建配置整合文件 将mybatis+spring+springmvc三个框架都整合在一个文件中 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--将其他配置文件进行关联--&gt;&lt;/beans&gt; 三、整合Spring层3.1 关于DAO层的Spring配置文件 创建一个spring-dao.xml的配置文件，里面填写配置内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mybatis-spring=&quot;http://mybatis.org/schema/mybatis-spring&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt; &lt;!--1.关联数据库配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!--2.数据源 dbcp：半自动化，不能自动连接 c3p0：自动化操作（自动化加载配置文件，并可以自动设置到对象中） druid：hikari --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;mysql.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;mysql.url&#125;&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;mysql.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;mysql.password&#125;&quot; /&gt; &lt;!--c3p0连接池的私有属性--&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot; /&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot; /&gt; &lt;!--关闭连接后不自动commit--&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!--获取连接超时时间--&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot; /&gt; &lt;!--当获取连接失败重试次数--&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot; /&gt; &lt;/bean&gt; &lt;!--3.sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--绑定数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定Mybatis的全局配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--4.配置dao接口扫描包，动态的实现类Dao接口可以注入到Spring容器中--&gt; &lt;mybatis-spring:scan base-package=&quot;com.letere.dao&quot;/&gt; &lt;!-- 旧方法 --&gt;&lt;!-- &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;--&gt;&lt;!-- &lt;property name=&quot;basePackage&quot; value=&quot;com.letere.dao&quot;/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;/beans&gt; 3.2 关于Service层的Spring配置文件 创建一个Spring-service.xml 文件，里面填写配置信息 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1.扫描serviec层下的包--&gt; &lt;context:component-scan base-package=&quot;com.letere.service&quot;/&gt; &lt;!--2.声明事务配置--&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; id=&quot;dataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--3.aop事务支持--&gt;&lt;/beans&gt; 3.3 在关联Spring文件导入dao和service的配置文件 在applicationContext.xml中导入spring-dao.xml 和 spring-service.xml配置文件 12345678910applicationContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--将其他配置文件进行关联--&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;&lt;/beans&gt; 四、整合SpringMVC层4.1 添加web支持 右键模块 –&gt; Add FrameWork Support –&gt; JavaSE –&gt; Web Application –&gt; 勾选后选择4.0版本 防止项目发布出现缺少依赖，要手动将依赖引入到发布项目中 4.2 创建springmvc的配置文件 创建spring-mvc.xml配置文件，里面填写配置信息 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--扫描contorller包--&gt; &lt;context:component-scan base-package=&quot;com.letere.controller&quot;/&gt; &lt;!--注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 4.3 将SpringMVC配置导入到Spring关联文件 将spring-mvc.xml导入到applicationContext.xml中 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--Spring核心配置文件--&gt; &lt;!--将其他配置文件进行关联--&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;&lt;/beans&gt; 4.4 配置Web.xml文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--SpringMVC自带servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;!--框架整合中，不仅需要springmvc的配置文件，还需要其他的，所以直接用整合的配置文件--&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--过滤器，解决乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt;&lt;!--private String encoding;因为可以为空，所以代码不提示--&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session超时时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 以上是框架整合最基本的的内容了 后面就是Controller 和 JSP页面之间的使用，在SpringMVC中有所讲解，就不展开了","categories":[{"name":"SSM整合","slug":"SSM整合","permalink":"https://letere-gzj.github.io/categories/SSM%E6%95%B4%E5%90%88/"}],"tags":[]},{"title":"【SpringMVC】JSON讲解","slug":"【SpringMVC】JSON讲解","date":"2020-10-26T12:15:47.000Z","updated":"2020-10-26T13:26:41.682Z","comments":true,"path":"2020/10/26/【SpringMVC】JSON讲解/","link":"","permalink":"https://letere-gzj.github.io/2020/10/26/%E3%80%90SpringMVC%E3%80%91JSON%E8%AE%B2%E8%A7%A3/","excerpt":"前端、后端如何使用JSON进行交互","text":"前端、后端如何使用JSON进行交互 一、认识JSON1.1 JSON介绍 JSON为一个字符串，是前后端分离的重要工具 前后端都可以正确解析JSON，所有前后端交流可以通过JSON来实现 1.2 前端对JSON的操作 解析JSON：JSON.parse(JSON json)方法 封装JSON：JSON.stringify(Object object)方法 创建一个html来演示 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //1、编写一个JavaScript对象 ES6 var user = &#123; name : &quot;莱特雷&quot;, age : 3, sex : &quot;男&quot; &#125; console.log(user); //输出user对象 console.log(&quot;============================&quot;); //2、将js对象转换成json对象 var json = JSON.stringify(user); console.log(json); //输出json字符串 console.log(&quot;============================&quot;); //3、将JSON对象转化为javascript对象 var object = JSON.parse(json); console.log(object); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 控制台打印结果 二、Jackson使用2.1 导入第三方jar包 jackson-databind-xx.xx.xx.jar 下载地址：https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind 选择对应的版本，进入页面在上面表格寻找|File| bundle(x.xMB)|，点击bundle即可下载 maven:12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt;&lt;/dependency&gt; 2.2 后端发送JSON步骤 （1）在controller接口实现类，在请求映射方法添加新注解@ResponseBody，让方法不会被视图解析器识别 （2）或者直接在来上添加@RestController来使类中所有方法都不会被视图解析器识别 （3）方法中创建一个ObjectMapper对象，通过writeValueAsString()方法转变成JSON字符串 （4）return JSON字符串来对前端发送数据 12345678910111213@RequestMapping(&quot;/j2&quot;)@ResponseBody //此注解，让此方法不会走视图解析器，会直接返回一个字符串public String json2() throws JsonProcessingException &#123; User user = new User(&quot;莱特雷&quot;, 21, &quot;男&quot;); //使用Jackson，编程JSON字符串 ObjectMapper mapper = new ObjectMapper(); String str = mapper.writeValueAsString(user);//把user变成一个字符串 return str; //页面结果：&#123;&quot;name&quot;:&quot;???&quot;,&quot;age&quot;:21,&quot;sex&quot;:&quot;?&quot;&#125;， 出现乱码&#125; 2.3 乱码解决 （1）原生态解决方法 在请求映射注解添加额外参数produce 1234567891011@RequestMapping(value = &quot;/j3&quot;, produces = &quot;application/json;charset=utf-8&quot;)@ResponseBody public String json3() throws JsonProcessingException &#123; User user = new User(&quot;莱特雷&quot;, 21, &quot;男&quot;); ObjectMapper mapper = new ObjectMapper(); String str = mapper.writeValueAsString(user); return str;&#125; （2）在spring配置文件中进行设置 123456789101112131415&lt;!--解决后端向前端传递数据乱码问题--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;&lt;!--注意：是json.Mappxxxxxx，不是cbor.Mappxxxxxxx，别导错包--&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 2.4 返回多个对象的JSON 方法没变，Jackson的writeValueAsString()支持集合 12345678910111213141516171819202122//返回多个对象的JSON@RequestMapping(&quot;/j4&quot;)@ResponseBody //此注解，让此方法不会走视图解析器，会直接返回一个字符串public String json4() throws JsonProcessingException &#123; User user1 = new User(&quot;莱特雷&quot;, 21, &quot;男&quot;); User user2 = new User(&quot;C酱&quot;, 18, &quot;女&quot;); User user3 = new User(&quot;咕料&quot;, 30, &quot;男&quot;); User user4 = new User(&quot;YJJ&quot;, 25, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); ObjectMapper mapper = new ObjectMapper(); String str = mapper.writeValueAsString(list); return str; //页面结果：[&#123;&quot;name&quot;:&quot;莱特雷&quot;,&quot;age&quot;:21,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;C酱&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;女&quot;&#125;,&#123;&quot;name&quot;:&quot;咕料&quot;,&quot;age&quot;:30,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;YJJ&quot;,&quot;age&quot;:25,&quot;sex&quot;:&quot;男&quot;&#125;]&#125; 2.5 返回时间 （1）使用SimpleDateFormat来对时间戳进行格式化 12345678910111213141516@RequestMapping(&quot;/j5&quot;)@ResponseBody //此注解，让此方法不会走视图解析器，会直接返回一个字符串public String json5() throws JsonProcessingException &#123; Date date = new Date();//时间戳 //格式化时间 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:MM:ss&quot;); String format = sdf.format(date); ObjectMapper mapper = new ObjectMapper(); String str = mapper.writeValueAsString(format); return str; //页面结果：&quot;2020-10-25 04:10:11&quot;&#125; （2）利用ObjectMapper来格式化时间 1234567891011121314151617181920@RequestMapping(&quot;/j6&quot;)@ResponseBodypublic String json6() throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间戳 ObjectMapper configure = mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期的格式 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:MM:ss&quot;); mapper.setDateFormat(sdf);//设置获取时间的格式 //按格式获取时间（不再获取时间戳） Date date = new Date(); String str = mapper.writeValueAsString(date); return str; //页面结果：&quot;2020-10-25 16:10:08&quot;&#125; 三、FastJson使用 fastjson是阿里开发的一款专门用于Java开发的包 3.1 导入第三方jar包 fastjson-xx.xx.xx.jar 下载地址：https://mvnrepository.com/artifact/com.alibaba/fastjson 选择相应的版，进入页面，在上面的表格的Files中，点击jar进行下载 Maven 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt; 3.2 fastjson三个主要类 （1）JSONObject：代表Json对象 （2）JSONArray：代表json对象数组 （3）JSON：JSONObject和JSONArray转化 3.3 常用方法（静态方法） （1）Java对象 转变成 JSON字符串 JSON.toJSONString(Object object) （2）JSON字符串 转变成 Java对象 JSON.parseObject(String json) （3）Java对象 转变成 JSON对象 JSON.toJSON(Object object) （4）JSON对象 转变成 Java对象 JSON.toJavaObject(JSON json, Class&lt;T&gt; clazz) 参数一：JSON对象，参数二：要转化成的Java对象","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://letere-gzj.github.io/categories/SpringMVC/"}],"tags":[]},{"title":"【SpringMVC】细节整理","slug":"【SpringMVC】细节整理","date":"2020-10-25T03:45:07.000Z","updated":"2020-10-25T07:08:10.137Z","comments":true,"path":"2020/10/25/【SpringMVC】细节整理/","link":"","permalink":"https://letere-gzj.github.io/2020/10/25/%E3%80%90SpringMVC%E3%80%91%E7%BB%86%E8%8A%82%E6%95%B4%E7%90%86/","excerpt":"关于SpringMVC框架的细节介绍","text":"关于SpringMVC框架的细节介绍 一、Controller配置总结1.1 Controller介绍 Controller：控制器 控制器提供访问应用程序的行为，可以通过实现接口/注解的形式来实现 控制器负责解析用户的请求，并转变成一个模型model 1.2 实现方法 （1）实现接口的方式 实现方法和之前一样，但是把配置的处理器 和 适配器删掉也能够正常运行，正常开发是不需要配置这两样东西的，为了将原理才使用 缺点：一个实现Controller接口的类，只能实现一个方法，导致需要创建大量的类 实现Controller接口方法比较旧，已经不推荐使用了 123456789101112public class ControllerTest1 implements Controller &#123; //函数式接口，只有一个方法，就是返回一个ModelAndView类的对象 @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;, &quot;Test1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; （2）以添加@Controller注解方式实现 学Spring也讲过其他注解@Component @Service @Repositort，功能都一样，就是为了区分而已 12345678910111213141516@Controller //代表这个类会被Spring进行接管，这个注解的类中所有方法，如果返回值是String，且有具体的页面可以跳转，就可以被视图解析器解析。public class ControllerTest2 &#123; //请求映射访问 @RequestMapping(&quot;/t2&quot;) public String test1(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;); return &quot;test&quot;; &#125; @RequestMapping(&quot;/t3&quot;) public String test3(Model model)&#123; model.addAttribute(&quot;msg&quot;, &quot;ControllerTest3&quot;); return &quot;test&quot;; &#125;&#125; 二、结果跳转方式2.1 原生的ServletAPI 通过设置ServletAPI，不需要视图解析器 （1）通过HttpServeltResponse进行输出 （2）通过HttpServletResponse实现重定向 （3）通过HttpServletResponse实现转发 2.2 通过ModelAndView 通过setViewName(&quot;&quot;)方法来设置View名称，通过视图解析器跳转到指定页面 页面：{视图解析器前缀} + viewName + {视图解析器后缀} 2.3 SpringMVC 创建String的返回方法 （1）无需视图解析器 return &quot;/index.jsp&quot; jsp页面的全类名 转发：return &quot;forward:/index.jsp&quot; 重定向：return &quot;redirect:index.jsp&quot; （2）视图解析器 return &quot;具体的jsp名称&quot; 重定向：return &quot;redirect:index.jsp&quot; 重定向仍然要写全类名 三、ResutFul风格3.1 介绍 普通风格访问页面：localhost:8080/mehtod?add=1&amp;... RestFul风格：localhost:8080/mehtod/add/1/2/... ResutFul是一个资源定位操作风格，软件可以更简洁，更有层次，更易于实现缓存机制 3.2 资源操作方式 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作 分别对应：添加，删除，修改，查询 传统方式操作资源：通过不同的参数来实现不同的效果，每个链接都不相同 http://xxx.xxx.com/item/queryItem.aciton?id=1 查询：GET http://xxx.xxx.com/item/saveItem.aciton 新增：POST http://xxx.xxx.com/item/updateItem.aciton 更新：POST http://xxx.xxx.com/item/deleteItem.aciton?id=1 删除：GET/POST resutFul操作资源：通过不同的请求方式来实现不同效果（链接接一样，功能不同） http://xxx.xxx.com/item/1 查询：GET http://xxx.xxx.com/item 新增：POST http://xxx.xxx.com/item 更新：PUT http://xxx.xxx.com/item/1 删除：DELETE 3.3 实现方法 （1）基本实现：使用@PathVariable，让参数的值绑定到URM模板上 1234567891011/*resultFul风格： 在Spring MVC中可以使用@PathVariable注解，让方法参数的值对应绑定到一个URM模板变量上 网页输入：http://localhost/add2/1/2 */@RequestMapping(&quot;/add2/&#123;a&#125;/&#123;b&#125;&quot;)public String test2(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;, &quot;结果为：&quot;+res); return &quot;test&quot;;&#125; （2）实现同一链接，不同功能 设置参数method，传入参数为RequestMethod对象，是个枚举类 12345678910111213141516171819/* 限制发送请求的方式 public enum RequestMethod &#123; GET, //GET请求 HEAD, POST, //POST请求 PUT, //PUT请求 PATCH, DELETE, //DELETE请求 OPTIONS, TRACE; 来限定访问的方法 */@RequestMapping(value=&quot;/add3/&#123;a&#125;/&#123;b&#125;&quot;, method = RequestMethod.GET)public String test3(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;, &quot;结果为：&quot;+res); return &quot;test&quot;;&#125; （3）通过注解实现同一链接，不同方法 通过一下注解来取代@RequestMappng() 12345678910111213141516171819202122/*上面方式的简化版通过请求映射访问注解 @GetMapping @DeleteMapping @PostMapping @PutMapping @PatchMapping */@GetMapping(&quot;/add4/&#123;a&#125;/&#123;b&#125;&quot;) //GET请求public String test4(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;, &quot;GET结果为：&quot;+res); return &quot;test&quot;;&#125;@PostMapping(&quot;/add4/&#123;a&#125;/&#123;b&#125;&quot;) //POST请求public String test5(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;, &quot;POST结果为：&quot;+res); return &quot;test&quot;;&#125; 四、数据处理4.1 处理提交数据 （1）正常方法 ?参数名=参数值 123456789101112// http://localhost:8080/user/t1?name=莱特雷@GetMapping(&quot;/user/t1&quot;)public String test1(String name, Model model)&#123; //1.接受前端数据 System.out.println(name); //2.将返回的结果传递给前端（通过Model） model.addAttribute(&quot;msg&quot;, name); //3.视图跳转 return &quot;test&quot;;&#125; （2）起别名 用@RequestParam(&quot;&quot;)起个别名，再用上面方法传参 12345678910111213// http://localhost:8080/user/t2?username=莱特雷// 前端需要用到的参数，无论名字相不相同，都起个别名@GetMapping(&quot;/user/t2&quot;)public String test2(@RequestParam(&quot;username&quot;) String name, Model model)&#123; //1.接受前端数据 System.out.println(name); //2.将返回的结果传递给前端（通过Model） model.addAttribute(&quot;msg&quot;, name); //3.视图跳转 return &quot;test&quot;;&#125; （3）前端接受是一个对象时 把创建对象所需要的值进行传递，?参数=值&amp;?参数=值?参数=值... 12345678910111213141516171819202122232425262728293031323334353637383940public class User &#123; private int id; private String name; private int age; public User()&#123;&#125; public User(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718//前端接受的是一个对象：id, name, age// http://localhost:8080/user/t3?id=0&amp;name=莱特雷&amp;age=21/*内部执行流程 （1）接受前段用户传递的参数。判断参数的名字，假设名字直接在方法上，可以直接使用。 （2）假设传递的是对象，则会对象中的字段名，名字一样则传递成功 */@GetMapping(&quot;/user/t3&quot;)public String test3(User user, Model model)&#123; //1.接受前端数据 System.out.println(user); //2.将返回的结果传递给前端（通过Model） model.addAttribute(&quot;msg&quot;, user); //3.视图跳转 return &quot;test&quot;;&#125; 4.2 将后台的数据显示到前端 （1）ModelAndView 通过public ModelAndView addObject(String attributeName, @Nullable Object attributeValue)来封装数据给前端 （2）Model 通过 Model addAttribute(String var1, @Nullable Object var2)来封装数据给前端 （3）ModelMap ModelMap：继承与LinkHashMap，所以他拥有LinkedHashMap的全部功能 （4）对比 Model： 只有几个方法只适合用于存储数据，简化了新手对于Model对象的操作和理解（推荐使用） ModelMap：继承了LinkMap，处理时限了自身的一些方法，同样继承LinkMap的方法和特性 ModelAndView：可以穿出数据的同时，可以进行设置返回的逻辑视图，进行跳转 五、解决乱码问题5.1 乱码出现 （1）控制器创建一个请求方式为POST的方法 123456789101112@Controllerpublic class EncodingController &#123; //post方法提交中文，会出现乱码 //通过过滤器解决 @PostMapping(&quot;/encode/t1&quot;) public String test1(String name, Model model)&#123; System.out.println(name); model.addAttribute(&quot;msg&quot;, name); return &quot;test&quot;; &#125;&#125; （2）创建一个表单jsp，跳转到该控制器，使用post方法 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/encode/t1&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; （3）目录结构如下 （4）网页输入：http://localhost:8080/form.jsp ，填写数据再提交，出现乱码 5.2 乱码解决 由于post方法提交数据，会导致数据变成乱码，解决方法可以将post方法换成get 如果仍然用post方法提交，则需要使用到过滤器了 （1）使用自定义过滤器 类实现Filter接口，重写doFilter方法 在web.xml中注册自定义过滤器 1234567891011121314151617181920过滤器public class EncodingFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;);//将编码调回utf-8 servletResponse.setCharacterEncoding(&quot;utf-8&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 1234567891011web.xml文件 &lt;!--1.自定义过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;com.letere.filter.EncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!--过滤所有的请求--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--因为我们是直接通过form.jsp访问，所以使用/*拦截jsp页面--&gt; &lt;/filter-mapping&gt; （2）使用SpringMVC自带的过滤器 直接在web.xml注册自带的过滤器CharacterEncodingFilter 1234567891011121314151617web.xml文件 &lt;!--2.使用Spring自带的过滤器 缺点，会对GET方法不友好 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!--设置编码集为utf-8--&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--因为我们是直接通过form.jsp访问，所以使用/*拦截jsp页面--&gt; &lt;/filter-mapping&gt;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://letere-gzj.github.io/categories/SpringMVC/"}],"tags":[]},{"title":"【SpringMVC】SpringMVC框架入门","slug":"【SpringMVC】SpringMVC框架入门","date":"2020-10-24T07:29:23.000Z","updated":"2021-11-12T05:11:30.662Z","comments":true,"path":"2020/10/24/【SpringMVC】SpringMVC框架入门/","link":"","permalink":"https://letere-gzj.github.io/2020/10/24/%E3%80%90SpringMVC%E3%80%91SpringMVC%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/","excerpt":"SpringMVC的简单介绍","text":"SpringMVC的简单介绍 一、SpringMVC介绍1.1 简介 SpringMVC是Spring框架的一部分，是基于Java实现MVC轻量级Web框架 （SpringMVC底层还是Servlet） 1.2 特点 （1）轻量级，简单易学 （2）高效，基于请求响应的MVC框架（处理请求，返回视图） （3）与Spring兼容性好，无缝结合 （4）约定优于配置 （5）功能强大：RESTful、数据验证、格式化、本地化、主题等 （6）简介灵活 1.3 实例演示：配置文件实现 SpringWeb框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器。 SpringMVC框架，和其他MVC框架一样，一请求为驱动，围绕一个中心Servlet分派请求级提供其他功能，DispatcherServlet是一个世纪的Servlet 本框架全部是基于Maven来实现导包，不再手动导包 （1）创建Maven空白项目 （2）右键项目名称，添加web项目支持 （3）Maven的pom.xml设置导包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SpringMVC框架&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;/project&gt; （4）创建JSP页面 在/WEB-INF/jsp，下创建一个hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; （5）建包，并创造类实现Controller接口 创建一个包，并创建一个HelloController.java的类 123456789101112131415public class HelloCotroller implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //模块和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中 mv.addObject(&quot;msg&quot;, &quot;HelloSpringMVC&quot;); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;);//自动拼接为：&quot;/WEB-InF/jsp/&quot; + &quot;hello&quot; + &quot;.jsp&quot; = /WEB-InF/jsp/hello.jsp return mv; &#125;&#125; （6）在Resources包下创建SpringMVC的配置文件 在src/main/resources下创建一个Spring配置文件，名字为springmvc-servlet.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--添加处理器映射器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt; &lt;!--添加处理器适配器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;&lt;/bean&gt; &lt;!--添加视图解析器 1.获取ModelAndView的数据 2.解析ModelAndeView的视图名字 3.拼接视图的名字，找到对应的视图 4.将数据渲染到视图上 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--handler：处理器--&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.letere.controller.HelloCotroller&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; （7）在web.xml注册Servlet 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件：【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--Servlet映射器--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;!-- /拦截非.jsp页面的所有请求--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; （8）整体目录结构 （9）配置Tomcat服务器 （10）点击启动按，启动tomcat （11）网页输入：http://localhost:8080/hello 二、SpringMVC执行原理2.1 各文件功能 （1）web.xml 注册SpringMVC自带的Servlet 页面跳转经过此Servlet进行处理 12345678910111213141516171819202122&lt;!--配置DispatcherServlet：前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--DispatcherServlet要绑定springmvc的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--级别：跟服务器一起启动--&gt;&lt;/servlet&gt;&lt;!-- SpringMVC中：&#x27;/&#x27;和&#x27;/*&#x27;是有区别的 / ：只匹配所有的请求，不会去匹配jsp /*：匹配所有的请求，包括jsp页面--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; （2）SpringMVC配置文件 开启映射器，适配器，视图解析器，配置关联的类 视图解析器：解析要跳转的页面 视图解析器，映射器，适配器都为SpringMVC自带的类，不用自己写 1234567891011121314&lt;!--处理器映射器：此处理器会根据Bean来寻找--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!--处理器适配器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!--视图解析器：模板引擎Thymeleaf，freemarker--&gt;&lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;!--用于拼接：拼接为/WEB-INF/jsp/xxx.jsp--&gt;&lt;/bean&gt;&lt;!--Servlet分发跳转为/test，去执行HelloController类--&gt;&lt;bean id=&quot;/test&quot; class=&quot;com.letere.controller.HelloController&quot;/&gt; （3）Controller实现类 类实现接口，重写方法，并返回一个ModelAndView类的对象 1234567891011121314public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); //业务代码 String result = &quot;HelloSpringMVC&quot;; mv.addObject(&quot;msg&quot;, result); //视图跳转 mv.setViewName(&quot;test&quot;); //跳转jsp页面的名称 return mv; &#125;&#125; 2.2 执行流程 （1）DispatcherServlet：表示前段控制器，是整个SpringMVC的控制中心，用户发送请求，DispatcherServlet接受请求并拦截请求 （2）HandlerMapping：处理器映射，由DispatcherServlet自行调用，HandlerMappping根据请求的url查找handler （3）HandlerExecution：具体的Handler，根据url查找控制器controller，并将解析后的信息传递给DispatcherServlet（如：解析控制器映射） （4）HandlerAdapter：处理器适配器，按特定的规则去执行Handler （5）Handler让具体的Controller执行 （6）Controller将具体的执行信息返回HandlerAdapter，如MoudleAndView类 （7）HandlerAdapter将MoudleAndView传递给DispatcherServlet （8）DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的ModelAndView （9）视图解析器将解析的逻辑视图名传递给DispatcherServlet （10）DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图 （11）最终将视图呈现给用户 三、基于注解实现3.1 操作实例 （1）web.xml注册Servlet 配置方法和前面一样，就不添加注解解释了 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--SpringMVC配置文件名称--&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; （2）创建SpringMVC的配置文件 开启注解扫描（Spring里学过） 加载mvc注解驱动 添加视图解析器 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--1.创建context名称空间--&gt; &lt;!--2.开始注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.letere.controller&quot;&gt;&lt;/context:component-scan&gt; &lt;!--3.创建mvc名称空间--&gt; &lt;!--4.让Spring MVC不处理静态资源 .css .js. html .mp3 .mp4--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--5.开启mvc注解驱动 不用再配置handler(处理器) 和 adapter（适配器） --&gt; &lt;mvc:annotation-driven /&gt; &lt;!--6.视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; （3）创建类，添加Controller注解 类添加Controller注解 类方法使用返回值为String的 如果需要先前端返回数据，使用Model对象进行返回 类方法添加RequestMapping，表示访问此方式时的网址路径 1234567891011@Controllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String Hello(Model model)&#123; //封装数据 model.addAttribute(&quot;msg&quot;, &quot;Hello, SpringMVCAnnotation!&quot;); return &quot;hello&quot;; //会被视图解析器处理，进行拼接跳转 &#125;&#125; （4）其他步骤和xml配置一样 创建jsp页面 启动tomcat 输入：http://localhost:8080/hello","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://letere-gzj.github.io/categories/SpringMVC/"}],"tags":[]},{"title":"【Maven】Maven常用操作","slug":"【Maven】Maven常用操作","date":"2020-10-24T07:01:16.000Z","updated":"2020-10-24T07:21:12.855Z","comments":true,"path":"2020/10/24/【Maven】Maven常用操作/","link":"","permalink":"https://letere-gzj.github.io/2020/10/24/%E3%80%90Maven%E3%80%91Maven%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"关于Maven一些常用的操作","text":"关于Maven一些常用的操作 一、Maven属性设置 Maven的属性设置都在&lt;properties&gt;的标签下进行设置 Maven常用设置有：字符编码格式，Java编译版本，Java执行版本 12345678&lt;properties&gt; &lt;!--字符节编码--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!--JDK编译代码版本--&gt; &lt;maven.compiler.source&gt;15&lt;/maven.compiler.source&gt; &lt;!--JDK执行代码版本--&gt; &lt;maven.compiler.target&gt;15&lt;/maven.compiler.target&gt;&lt;/properties&gt; 二、Maven全局变量 自定义属性： （1）在&lt;properties&gt;标签自定义标签来声明变量 （2）在pom.xml文件中的其他位置，使用${标签名}使用变量值 自定义全局变量，一般定义依赖的崩崩好，当你的项目要使用多个相同的版本号，先使用全局变量定义，再使用${变量名}比较好 1234567891011121314151617181920212223242526272829303132pom.xml文件 &lt;properties&gt; &lt;!--自定义标签，标识版本号--&gt; &lt;spring-version&gt;5.2.9.RELEASE&lt;/spring-version&gt;&lt;!--spring版本号--&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;!--使用自定义变量（标签）--&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 三、资源插件 （1）默认没有使用资源插件时，maven执行编译代码，会把src/main/resources目录中的文件拷贝到target/classes目录中 （2）对于src/main/java目录下的非java文件不处理，不拷贝到target/classes目录中 （3）程序需要把一些配置文件放在src/main/java目录中，当执行java程序时，需要用到src/main/java目录的文件。则需要maven把该目录下的文件进行拷贝，此时就需要在&lt;build&gt;创建资源插件 123456789101112131415&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;!--资源所在目录--&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!--扫描的内容：xx.properties和xx.xml文件--&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt;&lt;!--扫描properties文件--&gt; &lt;include&gt;**/*.xml&lt;/include&gt;&lt;!--扫描xml文件--&gt; &lt;/includes&gt; &lt;!--是否启动过滤器：选定扫描的内容已经达到了过滤效果--&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;","categories":[{"name":"Maven","slug":"Maven","permalink":"https://letere-gzj.github.io/categories/Maven/"}],"tags":[]},{"title":"【Maven】IDEA中使用Maven","slug":"【Maven】IDEA中使用Maven","date":"2020-10-21T13:34:04.000Z","updated":"2020-10-21T14:12:00.296Z","comments":true,"path":"2020/10/21/【Maven】IDEA中使用Maven/","link":"","permalink":"https://letere-gzj.github.io/2020/10/21/%E3%80%90Maven%E3%80%91IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Maven/","excerpt":"如何在IDEA中使用Maven学习笔记","text":"如何在IDEA中使用Maven学习笔记 一、IDEA设置 在IDEA中内置了Maven，但一般不使用内置Maven，因为内置Maven修改不方便 在IDEA中设置自己安装的maven （1）settings –&gt; Bulid, Execution, Deployment –&gt; Maven （2）settings –&gt; Bulid, Execution, Deployment –&gt; Maven –&gt; Runner （3）在File –&gt; New Project Settings –&gt; Setting For New Projects上重新执行上面步骤 二、IDEA创建Maven项目 （1）new Project 选择Maven项目 可以使用模板来创建，或者直接空白都可以 （2）下一步 （3）下一步 三、Maven项目介绍 例子：我使用了Java程序模板进行创建 发现与约定目录结构有点区别，可以进行补全，并可以对文件夹进行修改 右面的”maven”打开，可以发现生命周期，双击帮你执行操作，不需要敲命令行","categories":[{"name":"Maven","slug":"Maven","permalink":"https://letere-gzj.github.io/categories/Maven/"}],"tags":[]},{"title":"【Maven】Maven的核心概念","slug":"【Maven】Maven的核心概念","date":"2020-10-21T12:07:35.000Z","updated":"2020-10-21T13:32:59.009Z","comments":true,"path":"2020/10/21/【Maven】Maven的核心概念/","link":"","permalink":"https://letere-gzj.github.io/2020/10/21/%E3%80%90Maven%E3%80%91Maven%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"开始深入了解Maven，学习笔记","text":"开始深入了解Maven，学习笔记 一、Maven工程预定目录结构project（项目）| —- src（源代码）| —- —- main（主程序）| —- —- —- java（主程序java源码）| —- —- —- resources（java程序中要使用的配置文件）| —- —- test（测试程序）| —- —- —- java| —- —- —- resources| —- pom.xml （Maven核心文件） 二、Maven使用 Maven第一次使用会下载文件 下载的是Maven工具执行需要的插件 下载位置为：C:\\Users\\”用户名”.m2\\repository（本地仓库） 修改本地仓库位置 （1）在修改文件之前，先将文件进行备份，方便复原 （2）找到Maven安装目录下的conf\\settings.xml （3）修改localRepository来指定你的目录，非中文目录 三、仓库 存放maven使用的插件，项目使用的jar（第三方工具包） 分类： 本地仓库：个人计算机上的文件夹，存放各种jar 远程仓库：在互联网上，使用网络才能使用的仓库 中央仓库：最权威的，所有开发人员都共享的一个集中仓库 中央仓库镜像：中央仓库的备份，在各大洲，重要的城市都有镜像 私服：在公司内部，在局域网中使用，不对外使用 仓库使用：不需要人为参与，maven自己使用 四、POM Project Object Model ，项目对象模型，特指pom.xml文件 4.1 pom文件标签 标签 说明 modelVersion Maven版本，通常4.0.0 groupId 组织id，一般是公司域名的倒写 artifactId 项目名称，也是模块名称 version 项目版本号；如果带有-SNAPSHOT，表示不稳定版本 packaging 项目打包的类型：jar、war…；默认jar 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Maven入门&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/project&gt; 其中groupId、artifactId、version组成坐标；用来唯一表示一个jar文件 标签 说明 dependencies 管理jar包 dependency 管理具体的jar包，里面填写坐标 properties 设置配置属性 build 与构建相关的配置 parent 继承父工程pom的设置 modules 子模块 12345678910设置依赖（导入jar包） &lt;dependencies&gt; &lt;dependency&gt; &lt;!--配置单元测试--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 如果要导入相关jar包，可以通过maven配置依赖的形式进行导入 maven中央仓库搜索网：https://mvnrepository.com/ 可以在此查看相关jar包Maven的依赖编写，或直接下载jar包 搜索条件为：groupId，或artifactId 4.2 依赖管理 在上面依赖举例中，出现了&lt;scope&gt;标签，此标签标示依赖作用的范围 有三个参数：compile、test、provided，没有此标签默认为compile compile：在生命周期编译、测试、打包、部署都起作用 test：只在测试阶段起作用 provided：在编译、测试阶段起作用 compile test provided 编译 是 否 是 测试 是 是 是 打包 是 否 否 部署 是 否 否 五、Maven生命周期及代码 Maven生命周期，就是构建项目的过程 清理，编译，测试，报告，打包，安装，部署 mvn clean：清理 mvn compile：编译主程序 mvn test-compile：编译测试程序 mvn test：测试（会生成一个surefire-reports，保存测试结果） mvn package：打包主程序（封装为jar包） mvn install：安装主程序（将jar包复制到本地仓库） mvn deploy：部署主程序 注意 ： 以上命令都在pom.xml所在目录执行 六、插件 Maven执行上述的命令，都是使用到插件来进行 插件可以通过在pom.xml，进行信息配置修改 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;build&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean插件：执行clean操作--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt;&lt;!-- resources插件：把项目需要的配置文件拷贝到指定 --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt;&lt;!-- compile插件：执行编译操作 --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt;&lt;!--package打包插件：执行打包操作--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt;&lt;!--install插件：执行安装操作--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt;&lt;!--deploy插件：执行部署操作--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt;&lt;!--reports插件：执行报告操作--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt;","categories":[{"name":"Maven","slug":"Maven","permalink":"https://letere-gzj.github.io/categories/Maven/"}],"tags":[]},{"title":"【Maven】Maven入门","slug":"【Maven】Maven入门","date":"2020-10-20T14:23:32.000Z","updated":"2020-10-20T14:48:48.606Z","comments":true,"path":"2020/10/20/【Maven】Maven入门/","link":"","permalink":"https://letere-gzj.github.io/2020/10/20/%E3%80%90Maven%E3%80%91Maven%E5%85%A5%E9%97%A8/","excerpt":"Maven的简单介绍","text":"Maven的简单介绍 一、传统开发和Maven开发1.1 传统开发 （1）很多模块，模块之间有关系，手工管理关系，比较繁琐 （2）需要很多第三方面的功能，需要很多jar包，要手动从网络上下载 （3）需要管理jar包版本 （4）管理文件之间的依赖 1.2 Maven开发 （1）maven可以管理jar包 （2）自动下载jar和他的文档，源代码 （3）管理jar之间的依赖，自动下载依赖的jar包 （4）管理你需要的jar版本 （5）帮你编译程序，把java编译为class （6）帮你测试代码是否正确 （7）帮你打包文件，形成jar文件或war文件 （8）帮你部署项目 二、项目构建 构建是面向过程的，通过一定的步骤，完成项目代码的编译，测试，运行，打包 支持的构建操作有： （1）清理：把之前编译的东西删除，为新的编译代码做准备 （2）编译：把程序源代码编译为执行代码，把java编程class文件 （3）测试：maven可以执行测试程序代码，验证你的功能是否正确 （4）报告：生成测试结果文件，测试通过没有 （5）打包：把你的项目中所有的class文件，配置文件的哪个所有资源放在一个压缩文件中。这个压缩文件就是项目的结果文件，java文件为jar扩展名 （6）安装：把5中生成的jar文件，安装在本地仓库 （7）把程序安装好可以执行 开发中：一般使用前6步，第7步用maven变得更复杂 三、Maven核心概念 （1）POM：一个文件 名称是pom.xml，pom（project object model）项目对象模型 maven把一个项目当作一个模型使用。控制maven构建项目的过程，来管理jar包 （2）约定的目录结构：maven项目的目录和文件位置是有规定的 （3）坐标：是一个唯一的字符串，用来表示资源的 （4）依赖管理：用来管理你的项目可以使用的jar文件 （5）仓库管理（了解）：你的资源存放的位置 （6）生命周期（了解）：maven工具构建项目的过程 （7）插件和目标（了解）：执行maven构建的使用用的工具是插件 （8）继承 （9）聚合 四、maven安装和配置 （1）maven下载 下载地址：http://maven.apache.org/download.cgi 下载相应的zip包即可 建议使用3.3.9版本，是比较广泛使用版本。跟JDK1.8类似 3.3.9版本下载地址：https://downloads.apache.org/maven/maven-3/3.3.9/binaries/ （2）解压安装包，目录介绍 bin：执行程序，主要是mvn.cmd conf：maven工具本身的配置文件settings.xml （3）配置环境变量 步骤跟配置JDK一样 （4）测试是否安装成功 命令行敲打mvn -v，出现下面结果表示安装成功","categories":[{"name":"Maven","slug":"Maven","permalink":"https://letere-gzj.github.io/categories/Maven/"}],"tags":[]},{"title":"【Mybatis】缓存机制","slug":"【Mybatis】缓存机制","date":"2020-10-20T11:49:10.000Z","updated":"2020-10-20T13:41:39.676Z","comments":true,"path":"2020/10/20/【Mybatis】缓存机制/","link":"","permalink":"https://letere-gzj.github.io/2020/10/20/%E3%80%90Mybatis%E3%80%91%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"Mybatis缓存机制学习笔记","text":"Mybatis缓存机制学习笔记 一、介绍 Mybatis包含一个非常强大的查询缓存机制，它可以非常方便地配置和定制，缓存可以极大提升查询效率 Mybatis默认包含两级缓存 一级缓存（本地缓存）和二级缓存（全局缓存） 1、默认情况下，只有一级缓存开启 2、二级缓存需要手动开启和配置 3、为了提高拓展性。Mybatis定义了缓存接口Cache，我们可以通过实现Cache接口来定义二级缓存 二、一级缓存2.1 介绍 一级缓存（本地缓存），也被称为sqlSession级别的缓存，一级缓存是一致开启的无法关闭。 在与数据库同一次会话期间，查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，会支架从缓存中拿，没必要再去查询数据库 2.2 演示实例 前期准备： 为了能够更好展现缓存的效果，要导入Mybatis下的log4j-1.2.17.jar日志包 并把日志包的配置文件log4j.xml放在src目录下 1234567891011121314151617181920212223日志包配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 测试： 123456789101112131415161718192021测试方法 @Test public void test() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;./Dao/MybatisConfig.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is); SqlSession ss = ssf.openSession(); EmployeeMapper mapper = ss.getMapper(EmployeeMapper.class); //第一次查询sql，向数据库发送了sql语句 Employee emp01 = mapper.getEmpById(1); System.out.println(emp01); //第二次查询，并没有向数据库发送sql语句 Employee emp02 = mapper.getEmpById(1); System.out.println(emp02); ss.close(); &#125; 测试结果分析： 在测试方法类，共执行了两次sql语句，但是想数据库发送语句只出现了一次 而第二次查询并没有发送sql语句 证明了是直接使用缓存，发现缓存有此数据，于是直接拿来使用 2.3 不能使用一级缓存情况 （1）sqlSession改变了，不是同一个sqlSession （2）sqlSession一样，但查询条件不一样 （3）sqlSession一样，但在两次查询期间，执行了增删改的操作 （4）sqlSession一样，被手动清除掉缓存，执行openSession.clearCache();方法 三、二级缓存3.1 介绍 二级缓存（全局缓存）：基于namespqce级别的缓存 一个名称空间对应一个二级缓存 工作机制： （1）一个会话，查询一条数据。这条数据就会放在当前会话的以及缓存中，即在一级缓存 （2）如果会话关闭；一级缓存中的数据会被保存在二级缓存中；新的会话查询信息，就可以查找二级缓存信息 不同namespace（映射文件）查询的数据会在放在自己对应的缓存中(map中) 2.2 开启步骤 开启二级缓存步骤 （1）在全局配置文件中设置 &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;：开启二级缓存 1234567全局配置文件 &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;!--开启驼峰命名--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;!--开启所有关联对象都会延迟加载--&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;!--关闭所有对象全部加载--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;!--开启二级缓存--&gt; &lt;/settings&gt; （2）去每个mapper.xml（映射文件）中配置使用二级缓存 在&lt;mapper&gt;标签下使用&lt;cache&gt;&lt;/cache&gt;开启 123456789101112131415161718192021222324252627282930313233映射文件&lt;mapper namespace=&quot;Dao.EmployeeMapper&quot;&gt; &lt;!-- 配置二级缓存 &lt;cache eviction=&quot;&quot; flushInterval=&quot;&quot; readOnly=&quot;&quot; size=&quot;&quot; type=&quot;&quot;&gt;&lt;/cache&gt; eviction：缓存回收策略 LRU - 最近最少使用：移除最长时间不被使用的对象 FIFO - 先进先出：按对象进入缓存的顺序来移除 SOFT - 软引用：移除基于垃圾回收器状态和软引用规则的对象 WEAK - 弱引用：更加积极地移除基于垃圾收集器状态和弱引用状态的对象 默认使用：LRU flushInterval：缓存刷新间隔 缓存多长时间清空一次 默认不清空 readOnly：是否只读 true：只读，mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据 mybatis会加快获取速度，直接将数据在缓存中的引用交给用户 false：非只读，mybatis觉得获取的数据可能会被修改， mybatis会利用序列化/反序列化的技术克隆一份新的数据给你。安全，速度。 默认：false size：缓存存放多少元素 type：指定自定义缓存的全类名 自定义缓存：实现Cache接口 --&gt; &lt;!--使用二级缓存--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;Dao.Employee&quot; useCache=&quot;true&quot;&gt; select id, last_name lastName, gender, email from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; （3）查询封装的JavaBean实现序列化/反序列化接口 public class Xxxx implements Serializable 1234JavaBeanpublic class Employee implements Serializable &#123; 类中内容省略&#125; 3.3 演示实例123456789101112131415161718192021测试方法 @Test public void test() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;./Dao/MybatisConfig.xml&quot;); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(is); //开启第一个sqlSession SqlSession ss1 = ssf.openSession(); EmployeeMapper mapper1 = ss1.getMapper(EmployeeMapper.class); Employee emp1 = mapper1.getEmpById(1); System.out.println(emp1); //将sqlSession关闭，一级缓存内容转移到二级缓存 ss1.close(); //开启第二个sqlSession，与第一个sqlSession执行同一sql语句 SqlSession ss2 = ssf.openSession(); EmployeeMapper mapper2 = ss2.getMapper(EmployeeMapper.class); Employee emp2 = mapper2.getEmpById(1); System.out.println(emp2); ss2.close(); &#125; 结果分析 和一级缓存分析一样，只是向数据库发送了一次sql语句 3.4 和缓存有关的设置 （1）全局配置文件：cacheEnabled=&quot;true&quot;/&quot;false&quot;，开启/关闭二级缓存 （2）映射文件select标签：useCache=&quot;true&quot;/&quot;fasle&quot;，使用/不使用二级缓存，默认true （3）每个增删改标签都有：flushCache=&quot;true&quot;/&quot;false&quot;，是否清除缓存，一二级都会被清空，默认true 查询标签也有，默认为fasle，清空缓存对于查询没有意义，一般不修改 （4）openSession.clearCache(); 手动清除缓存，只会清掉一级缓存，不影响二级缓存 （5）全局配置文件：localCacheScope=&quot;SESSION&quot;/&quot;STATEMENT&quot;本地缓存作用域（一级缓存作用域） SESSION：缓存保存在当前会话 STATEMENT：可以禁用一级缓存 四、整合Ehcache缓存框架4.1 自定义缓存介绍 Mybatis支持自定义缓存 实现cache接口的类就可以作为自定义缓存 在&lt;cache type=&quot;自定义缓存全类名&quot;&gt;&lt;/cache&gt;设置 但一般我们不会自定义缓存类，而是使用现有的缓存类，也是下面所说的ehcache EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点 4.2 整合步骤 （1）需要导入相关Jar包 ehcache-core-2.6.8.jar http://www.java2s.com/example/jar/e/ehcache-core-index.html slf4j-api-1.7.30.jar slf4j-log4j12-1.7.30.jar 上面两个在Mybatis的框架下有 mybatis-ehcache-1.0.3.jar https://github.com/mybatis/ehcache-cache/releases （2）在映射文件中使用ehcache自定义缓存类 （3）在src目录下，放置ehcache的配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=&quot;D:\\FrameWork\\Ehcache\\overData&quot; /&gt; &lt;defaultCache maxElementsInMemory=&quot;1&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; &lt;!-- 属性说明：l diskStore：指定数据在磁盘中的存储位置。l defaultCache：当借助CacheManager.add(&quot;demoCache&quot;)创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略 以下属性是必须的：l maxElementsInMemory - 在内存中缓存的element的最大数目 l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 以下属性是可选的：l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; （4）若其他Mapper文件也要配置该缓存空间 可以&lt;cache-ref namespace=&quot;&quot;&gt;&lt;/cache-ref&gt;来进行配置 引用名称空间，可以使用别人的名称空间，共用缓存 4.3 演示结果分析 重新执行二级缓存的测试方法 结果分析 ehcahe将二级缓存文件保存在本地，可以去本地查看","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://letere-gzj.github.io/categories/Mybatis/"}],"tags":[]},{"title":"【Mybatis】动态sql","slug":"【Mybatis】动态sql","date":"2020-10-19T12:46:53.000Z","updated":"2020-10-19T13:53:00.666Z","comments":true,"path":"2020/10/19/【Mybatis】动态sql/","link":"","permalink":"https://letere-gzj.github.io/2020/10/19/%E3%80%90Mybatis%E3%80%91%E5%8A%A8%E6%80%81sql/","excerpt":"关于Mybatis的动态sql学习笔记","text":"关于Mybatis的动态sql学习笔记 一、基础标签1.1 if标签 if：判断 &lt;if test=&quot;&quot;&gt; sql语句 &lt;/if&gt; test：判断表达式(OGNL) 从参数中取值进行判断 如果遇到特殊符号，要使用转义字符 举例：查询员工，要求：携带哪个字段时，查询条件就带上这个字段的值 12接口 public List&lt;Employee&gt; getEmpByConditionIf(Employee employee); 123456789101112131415161718映射文件 &lt;select id=&quot;getEmpByConditionIf&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee where &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;if test=&quot;gender==&#x27;0&#x27; or gender==&#x27;1&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/select&gt; 存在问题： 当id不存在时，sql语句就变成 where and Xxxx，会报错 解决方法一： 给where后面先弄一个1=1，后面条件拼接都用and Xxx拼接 12345678910111213141516SQL语句 select * from tbl_employee where 1=1 &lt;if test=&quot;id!=null&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;if test=&quot;gender==&#x27;0&#x27; or gender==&#x27;1&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt; 解决方法二：使用where标签 1.2 where标签 where 用来替代sql语句中where内的查询条件 好处：会去掉凭借字符串第一个多出的and / or，解决拼接错误 举例：上述例子修改 12接口 public List&lt;Employee&gt; getEmpByConditionIf2(Employee employee); 12345678910111213141516171819映射文件 &lt;select id=&quot;getEmpByConditionIf2&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee &lt;where&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; and last_name=#&#123;lastName&#125; &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;if test=&quot;gender==&#x27;0&#x27; or gender==&#x27;1&#x27;&quot;&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 注意：where只能解决”and Xxxx”在前面拼接的，而”Xxx and”在后面拼接的无法解决，拼接要规范 如果要使用”Xxxx and”的方式拼接，可以使用trim标签 1.3 trim标签 trim标签 trim标签用于字符串的截取 &lt;trim prefix=&quot;&quot; prefixOverrides=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;&quot;&gt;&lt;/trim&gt; prefix：前缀，给拼串后的字符串写一个前缀 prefixOverrides：前缀覆盖，去掉整个字符串前面多余的字符 suffix：后缀，给拼串后的字符串写一个后缀 suffixOverides：后缀覆盖，去掉整个字符串后面多余的字符 举例：修改上述例子，利用trim来实现and在后拼接 12接口 public List&lt;Employee&gt; getEmpByConditionTrim(Employee employee); 12345678910111213141516171819202122映射文件 &lt;select id=&quot;getEmpByConditionTrim&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee &lt;!--where标签无法解决and/or后拼接问题，使用trim标签解决 下面字符串，前面缺少一个where，后面可能会多余一个and --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; and &lt;/if&gt; &lt;if test=&quot;lastName!=null and lastName!=&#x27;&#x27;&quot;&gt; last_name=#&#123;lastName&#125; and &lt;/if&gt; &lt;if test=&quot;email!=null and email.trim()!=&#x27;&#x27;&quot;&gt; email=#&#123;email&#125; and &lt;/if&gt; &lt;if test=&quot;gender==&#x27;0&#x27; or gender==&#x27;1&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; 1.4 choose标签 choose标签 分支选择，使用方法与Java的分支选择差不多 choose — switch when — case otherwise — default 举例：如果对象带id就用id查，如果对象有lastName就用lastName查，二者选其一；如果都没有，就查找女性信息 12接口 public List&lt;Employee&gt; getEmpByConditionChoose(Employee employee); 123456789101112131415161718映射文件 &lt;select id=&quot;getEmpByConditionChoose&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;id!=null&quot;&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test=&quot;lastName!=null&quot;&gt; last_name=#&#123;lastName&#125; &lt;/when&gt; &lt;otherwise&gt; gender=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 1.5 set标签 set标签 用来取代修改的set，用if实现动态sql时，会出现字符串拼接错误 举例：实现动态修改数据 12接口 public void updateEmp(Employee emmployee); 12345678910111213141516映射文件 &lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee &lt;set&gt; &lt;if test=&quot;lastName!=null&quot;&gt; last_name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125; &lt;/update&gt; 跟where一样，如果字符串出现拼接错误，可以使用trim解决 12接口 public void updateEmp2(Employee emmployee); 1234567891011121314151617映射文件 &lt;update id=&quot;updateEmp2&quot;&gt; update tbl_employee &lt;!--字符串前缀缺少set，后缀可能会多出&#x27;,&#x27;--&gt; &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;lastName!=null&quot;&gt; last_name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test=&quot;email!=null&quot;&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test=&quot;gender!=null and gender!=&#x27;&#x27;&quot;&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; 1.6 foreach标签 foreach标签 用来遍历集合/数据，使用方法和增强for循环类似 &lt;foreach collection=&quot;&quot; item=&quot;&quot; separator=&quot;&quot; open=&quot;&quot; close=&quot;&quot; index=&quot;&quot;&gt; collection：指定要遍历的集合 (mybatis会自动将list封装为Map集合[list, list集合名称]，所以要填写list；set, array同理) (可以在接口的参数用@param(“”)起别名，来直接调用用别名) (手动将List集合转变成Map集合) item：将当前遍历的元素赋值给指定的变量 separator：元素之间分割符号 open：遍历完拼接的字符串的前缀 close：遍历完拼接的字符串的后缀 index：索引 遍历list的时候，index是索引值，item是当前值 遍历map的时候，idnex是map的Key，item是map的Value 举例：实现以下sql语句 select * from tbl_employee where id in (1, 2, 3, 4) 12接口 public List&lt;Employee&gt; getEmpByConditionForeach(List&lt;Integer&gt; id); 12345678910映射文件 &lt;select id=&quot;getEmpByConditionForeach&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee where id in &lt;!--由于接口没定义别名，所以collection参数为list--&gt; &lt;foreach collection=&quot;list&quot; item=&quot;item_id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;item_id&#125; &lt;/foreach&gt; &lt;/select&gt; 二、批量插入 利用foreach标签实现动态插入2.1 MySQL处理 方法一：实现以下sql语句 insert into tbl_employee(last_name, gender, email) value(x, x, x, x), (x, x, x, x) mysql支持value(),.(), ()的方式进行批量插入 12接口 public void addEmps(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); 123456789映射文件 &lt;insert id=&quot;addEmps&quot;&gt; insert into tbl_employee(last_name, gender, email, dept_id) value &lt;!--由于接口参数定义别名，collection直接使用别名--&gt; &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (#&#123;emp.lastName&#125;, #&#123;emp.gender&#125;, #&#123;emp.email&#125;, #&#123;emp.dept.id&#125;) &lt;/foreach&gt; &lt;/insert&gt; 方法二：执行多条sql语句 在mysql的url添加属性：allowMultiQueries=true 然后使用foreach实现重复多条sql语句，分隔符为’;’ 2.2 Oracle处理 使用以下sql语句格式： 用begin end包括多条sql语句，多条sql语句使用foreach来实现，分隔符为’;’ 123begin 多条sql语句;end; 三、默认参数 在Mybatis中，除了方法中我们传入的参数，还额外自带两个默认的参数 _parameter：代表整个参数 单个参数：_parameter就是传递的参数 多个参数：参数会封装在一个map，_parameter就是这个map _databaseId：如果配置了databaseIdProvider标签，_databaseId就是代表当前数据库的别名 123456全局配置文件 &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlServer&quot;/&gt; &lt;/databaseIdProvider&gt; 12接口 public List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee); 12345678910映射文件 &lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;Dao.Employee&quot;&gt; &lt;if test=&quot;_databaseId==&#x27;mysql&#x27;&quot;&gt; select * from tbl_employee &lt;if test=&quot;_parameter!=null&quot;&gt; where gender=#&#123;_parameter.gender&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt; 四、进阶标签4.1 bind标签 是CURD标签的子标签，可以将OGNL表达式绑定在一个变量中，方便后来引用这个变量的值 &lt;bind name=&quot;&quot; value=&quot;&quot; /&gt; name：变量名 value：参数进行处理后的值 例：&lt;bind name=&quot;_lastName&quot; value=&quot;&#39;%&#39;+lastName+&#39;%&#39;&quot;/&gt; 4.2 sql、include标签 sql标签 抽取可重用的sql片段，方便后面引用，类似Java的方法封装 123&lt;sql id=&quot;&quot;&gt; sql语句&lt;/sql&gt; include标签 引用外部的定义的sql标签 &lt;include refid=&quot;&quot;&gt;&lt;/include&gt; refid：引用的sql标签id","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://letere-gzj.github.io/categories/Mybatis/"}],"tags":[]},{"title":"【Mybatis】映射文件","slug":"【Mybatis】映射文件","date":"2020-10-18T03:40:08.000Z","updated":"2020-10-18T09:07:29.879Z","comments":true,"path":"2020/10/18/【Mybatis】映射文件/","link":"","permalink":"https://letere-gzj.github.io/2020/10/18/%E3%80%90Mybatis%E3%80%91%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/","excerpt":"关于Mybatis映射文件的学习笔记","text":"关于Mybatis映射文件的学习笔记 一、基本的增删改查1.1 操作实例 （1）定义接口方法 12345678910111213public interface EmployeeMapper &#123; //增 public abstract void addEmp(Employee emp); //删 public abstract void deleteEmpById(Integer id); //改 public abstract void updateEmp(Employee emp); //查 public abstract Employee getEmpById(int id);&#125; （2）在映射文件中，填写相应的sql语句 增的标签为：&lt;insert&gt; 删的标签为：&lt;delete&gt; 改的标签为：&lt;update&gt; 查的标签为：&lt;select&gt; 查的标签要额外添加resultType来确定返回值的类型 传入的参数是个对象时，仍然可以直接使用#{}来获取对象属性 1234567891011121314151617181920212223&lt;mapper namespace=&quot;Dao.EmployeeMapper&quot;&gt; &lt;insert id=&quot;addEmp&quot; parameterType=&quot;Dao.Employee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into tbl_employee(last_name, email, gender) values(#&#123;lastName&#125;, #&#123;email&#125;, #&#123;gender&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteEmpById&quot;&gt; delete from tbl_employee where id=#&#123;id&#125; &lt;/delete&gt; &lt;update id=&quot;updateEmp&quot;&gt; update tbl_employee set last_name=#&#123;lastName&#125;, email=#&#123;email&#125;, gender=#&#123;gender&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;Dao.Employee&quot;&gt; select id, last_name lastName, gender, email from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; （3）Java程序调用方法 1234567891011121314151617181920212223242526272829@Testpublic void test1() throws IOException &#123; String resource = &quot;./Dao/mybatisConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(inputStream); //不会自动提交数据 SqlSession ss = ssf.openSession();//参数true/false，true自动提交数据，flase需要手动提交数据，默认false EmployeeMapper mapper = ss.getMapper(EmployeeMapper.class); //增 Employee employee = new Employee(null, &quot;yjj&quot;,&#x27;0&#x27;, &quot;yyy.com&quot;); mapper.addEmp(employee); //改 mapper.updateEmp(new Employee(3, &quot;yjj&quot;, &#x27;0&#x27;, &quot;丫丁丁.com&quot;)); //查 Employee emp = mapper.getEmpById(3); System.out.println(emp); //删 mapper.deleteEmpById(3); //手动提交数据 ss.commit();&#125; 1.2 拓展：获取自增主键的值 在插入时，mysql支持自增主键，自增主键的获取，mybatis底层是利用了JDBC的**statement.getGenreatedKeys()**的方法 使用方法： 在&lt;insert&gt;标签添加额外的属性 useGenerateKeys=&quot;true&quot;：开启获取自增主键 keyProperty=&quot;&quot;：将获取的信息封装到JavaBean的哪个属性 举例 123451、修改映射文件中的&lt;insert&gt;标签 &lt;insert id=&quot;addEmp&quot; parameterType=&quot;Dao.Employee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into tbl_employee(last_name, email, gender) values(#&#123;lastName&#125;, #&#123;email&#125;, #&#123;gender&#125;) &lt;/insert&gt; 1234562、修改Java程序的增方法进行测试 Employee employee = new Employee(null, &quot;yjj&quot;,&#x27;0&#x27;, &quot;yyy.com&quot;); mapper.addEmp(employee); //上面创建employee并没有对id进行赋值，但是employee.getId()返回的并不是null //因为获取了自增值，并将该值封装到JavaBean的id属性中 System.out.println(employee.getId()); 1.3 拓展：获取非自增主键的值 在&lt;insert&gt;中添加字标签&lt;selectKey&gt; keyProperty：sql查询出来的数据，封装给JavaBean的那个属性 order：执行顺序”BEFORE/AFTER”，在sql语句之前/之后执行 resultType：返回结果类型 举例： 12345678910111213以获取非自增主键的方式，来实现获取自增主键 &lt;insert id=&quot;addEmp&quot; parameterType=&quot;Dao.Employee&quot;&gt; insert into tbl_employee(last_name, email, gender) values(#&#123;lastName&#125;, #&#123;email&#125;, #&#123;gender&#125;) &lt;!--在插入后执行，获取最后一条数据的id，将此id封装到JavaBean中--&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;Integer&quot;&gt; select id from tbl_employee order by id desc limit 1; &lt;/selectKey&gt; &lt;/insert&gt; 二、参数传递2.1 单个参数 对于单个参数，Mybatis不会做任何处理，参数名字可以随便起 使用方法：#&#123;参数名&#125; 2.2 多个参数 对于过个参数。MyBatis对进行特殊处理，会将参数封装到为一个Map集合中 若全局配置文件useActualParamName=&quot;true&quot;，则该Map存储格式为： Key：param1, param2….paramN 或者 arg0, arg1 …. argN value：按顺序传入的参数 若全局配置文件useActualParamName=&quot;false&quot;，则该Map存储格式为： Key：param1, param2….paramN 或者 0, 1 …. N value：按顺序传入的参数 Mybaits版本不同，默认值可能发生变化 12接口public abstract Employee getEmpByIdAndLastName(Integer id, String lastName); 123456映射文件 &lt;select id=&quot;getEmpByIdAndLastName&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee where id=#&#123;arg0&#125; and last_name=#&#123;arg1&#125; &lt;/select&gt; 2.3 命名参数 由于参数一多，上面的方法就十分不便利，由此引出命名参数 命名参数：【明确指定封装的参数时map的Key】 在接口传参时使用格式：Xxxx(@Param(“id”)int id, @Param(“name”)String name) Map存储格式为： Key：使用@Param注解指定的值 value：按顺序传入的参数 12接口方法 public abstract Employee getEmpByIdAndLastName(@Param(&quot;id&quot;) Integer id, @Param(&quot;lastName&quot;) String lastName); 123456映射文件 &lt;select id=&quot;getEmpByIdAndLastName&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125; &lt;/select&gt; 2.4 Map集合 为了方便，我们也可以传入map 直接#{Key}：来取出对象的值 12接口方法： public abstract Employee getEmpByMap(Map&lt;String, Object&gt; map); 123456映射文件 &lt;select id=&quot;getEmpByMap&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125; &lt;/select&gt; 1234567891011121314151617181920方法测试 @Test public void test2() throws IOException &#123; String resource = &quot;./Dao/mybatisConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(inputStream); SqlSession ss = ssf.openSession(); EmployeeMapper mapper = ss.getMapper(EmployeeMapper.class); //创建Map集合 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;, 2); map.put(&quot;lastName&quot;, &quot;C酱&quot;); Employee emp = mapper.getEmpByMap(map); System.out.println(emp); &#125; 2.5 集合/数组 Mybatis也会对集合、数组封装为Map Collection： Key：collection[0], collection[1] … collection[N] 使用方法：#{Key} List： Key：list[0], list[1] … list[N] 使用方法：#{Key} Set： Key：set[0], set[1] … set[N] 使用方法：#{Key} Array： Key：array[0], array[1] … array[2] 使用方法：#{Key} 举例：以List集合为例 12接口方法 public abstract Employee getEmpByList(List&lt;Object&gt; list); 123456映射文件 &lt;select id=&quot;getEmpByList&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee where id=#&#123;list[0]&#125; and last_name=#&#123;list[1]&#125; &lt;/select&gt; 1234567891011121314151617181920方法测试 @Test public void test3() throws IOException &#123; String resource = &quot;./Dao/mybatisConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(inputStream); SqlSession ss = ssf.openSession(); EmployeeMapper mapper = ss.getMapper(EmployeeMapper.class); //创建list集合 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(&quot;C酱&quot;); Employee emp = mapper.getEmpByList(list); System.out.println(emp); &#125; 2.6 补充 （1）若接口定义返回类型为：集合 映射文件，resultType填写集合属性的类型 （2）若接口定义返回类型为：Map 映射文件中resultTyoe填写map 2.7 获取参数 #{}：可以获取map中的值或pojo对象属性的值 ${}：可以获取map中的值或pojo对象属性的值 #{} 和 ${} 的区别 #{}是以预编译的形式，将参数设置到sql语句中；类似PreparedStatement ${}取出的值直接拼装在sql中，进行sql拼接；类似Statement 使用场景 大多情况下，使用#{} 在原生JDBC不支持占位符的地方（表名），可以用${}进行取值 2.8 参数处理 #{}，在取出参数时，可以进行一些规则 支持的属性：javaType、jdbcType、mode、numericScale、resultMap、typeHandler、jdbcTypeName、expression javaType：在Java中的属性 jdbcType：在数据库中的属性 mode：存储过程（后面讲） numericScale：保留几位小数 resultMap：规定封装的结果集 typeHandler：类型处理器 jdbcTypeName：和jdbcType一样 expression：表达式（未来支持的功能） 上述属性中，就jdbcType可能需要进行设置 在我们数据为null时，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle(报错) 解决方法： 因为mybatis对所有的null都映射为jdbc OTHER 解决方法（1）：设置jdbcType=NULL 解决方法（2）：全局配置文件&lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;&gt; 三、resultMap的使用3.1 基础介绍 resultMap和resultType类，来确定返回的类型，但resultMap可以进行自定义 resultMap和resultType不能同时使用 reslutMap &lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;&lt;/resultMap&gt; id：resultMap的唯一标识 type：自定义规则的JavaBean 子标签&lt;id&gt; &lt;id&gt;是用来定义主键 &lt;id column=&quot;&quot; property=&quot;&quot;/&gt; column：数据库中列的字段名 property：JavaBean的属性名 将查询对象的字段名，封装到对应JavaBean的属性 子标签&lt;result&gt; &lt;result&gt;用来定义非主键 &lt;result column=&quot;&quot; property=&quot;&quot;/&gt; column：数据库中列的字段名 property：JavaBean的属性名 其他不指定的类会自动封装；但是一旦使用resultMap的话，建议全部指定 举例： 12345678910111213映射文件 &lt;resultMap id=&quot;MyEmp&quot; type=&quot;Dao.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmpById&quot; resultMap=&quot;MyEmp&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; 3.2 前期准备 （1）为Employee类添加多一个属性为Department （2）创建相应的类(JavaBean)，接口，映射文件，并将映射文件注册到全局配置文件中 123456789101112131415161718192021222324252627282930313233类 public class Department &#123; private Integer id; private String departmentName; private List&lt;String&gt; emps; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getDepartmentName() &#123; return departmentName; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; public List&lt;String&gt; getEmps() &#123; return emps; &#125; public void setEmps(List&lt;String&gt; emps) &#123; this.emps = emps; &#125; @Override public String toString() &#123; return &quot;Department&#123;&quot; + &quot;id=&quot; + id + &quot;, departmentName=&#x27;&quot; + departmentName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; 1234接口 public interface DepartmentMapper &#123; public Department getDeptById(Integer id); &#125; 12345678910111213映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;Dao.DepartmentMapper&quot;&gt; &lt;select id=&quot;getDeptById&quot; resultType=&quot;Dao.Department&quot;&gt; select id, dept_name as departmentName from tbl_department where id = #&#123;id&#125; &lt;/select&gt; &lt;mapper&gt; （3）在数据库中创建相应的表部门表 12345创建部门表 create table tbl_department( id int(11) primary key auto_increment, dept_name varchar(255) ) （4）在数据库为员工表添加额外字段，并和部门表进行联系 123添加字段 alter table tbl_employee add column dept_id int(11) 12345联系两表 alter table tbl_employee add constraint fk_emp_dept foreign key(dept_id) references tbl_department(id) 3.3 联合查询 （1）级联属性封装结果集 举例：在查询员工表时，根据员工表的部门号，把相应的部门查询出来 在resultMap中的result，通过对象.属性进行对部门类赋值 12345678910111213141516映射文件 &lt;resultMap id=&quot;EmpDept&quot; type=&quot;Dao.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;!--级联赋值方式--&gt; &lt;result column=&quot;dept_id&quot; property=&quot;dept.id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;dept.departmentName&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;EmpDept&quot;&gt; select A.id, last_name, gender, email, B.id as dept_id, B.dept_name from tbl_employee as A, tbl_department as B where A.dept_id = B.id And A.id = #&#123;id&#125; &lt;/select&gt; （2）利用association对象实现 子标签&lt;association property=&quot;&quot; javaType=&quot;&quot;&gt;&lt;/association&gt; &lt;assovaition&gt;：指定联合的JavaBean对象 property：指定哪个属性是联合对象 javaType：联合的类的全类名 1234567891011121314151617映射文件 &lt;resultMap id=&quot;EmpDept2&quot; type=&quot;Dao.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dao.Department&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;EmpDept2&quot;&gt; select A.id, last_name, gender, email, B.id as dept_id, B.dept_name from tbl_employee as A, tbl_department as B where A.dept_id = B.id And A.id = #&#123;id&#125; &lt;/select&gt; （3）关联的对象时集合时 关联的对象时多个值时使用 举例：一个部门有多个员工，在查询一个部门时，把该部门的员工查询出来 123456789101112131415映射文件 &lt;!--利用Collection实现集合关联--&gt; &lt;resultMap id=&quot;MyDept&quot; type=&quot;Dao.Department&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;!--collection定义集合类型的属性的封装规则 ofType：集合里面数据的类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Dao.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 3.4 分步查询 利用assocation来实现 分布查询的好处：以已有的方法，完成复杂的sql操作，不用额外写sql语句 1234567891011121314151617181920Employee映射文件 &lt;resultMap id=&quot;EmpByStep&quot; type=&quot;Dao.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;!--association：定义关联对象的封装规则 select：查询的方法。关联对象的属性通过哪个sql语句来获取 column：指定哪个值传递给sql语句来进行查询 --&gt; &lt;association property=&quot;dept&quot; select=&quot;Dao.DepartmentMapper.getDeptById&quot; column=&quot;dept_id&quot;&gt; &lt;!--不填写，默认封装--&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmpByIdStep&quot; resultMap=&quot;DSM&quot; &gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt; 123456Department映射文件 &lt;select id=&quot;getDeptById&quot; resultType=&quot;Dao.Department&quot;&gt; select id, dept_name as departmentName from tbl_department where id = #&#123;id&#125; &lt;/select&gt; 拓展：分步查询传递多个数据 可以将多个值封装到Map中进行传递 &lt;association property=&quot;&quot; select=&quot;&quot; column=&quot;&#123;key1=column1, key2=column2...&#125;&quot;&gt; Collection实现分步查询 关联的对象时多个值时使用 举例：一个部门有多个员工，在查询一个部门时，把该部门的员工查询出来 12345678910映射文件 &lt;!--Collection实现分步查询--&gt; &lt;resultMap id=&quot;MyDeptStep&quot; type=&quot;Dao.Department&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;departmentName&quot;/&gt; &lt;!--collection分步查询使用方法和association类似--&gt; &lt;collection property=&quot;emps&quot; select=&quot;resultMap.EmployeeMapperPlus.getEmpByDid&quot; column=&quot;id&quot;&gt; &lt;!--默认封装--&gt; &lt;/collection&gt; &lt;/resultMap&gt; 3.5 延迟加载 我们每次查询Employee对象的时候，都将Department一起查询出来 为了提升效率，希望部门信息在我们使用的时候再去查询，也就是延迟加载 在分布查询的基础上，在全局配置文件加上两个配置即可实现延迟加载 &lt;setting name=&quot;lazyLoadingEnable&quot; value=&quot;true&quot;/&gt;：开启所有关联对象都会延迟加载 &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;：关闭所有对象全部加载 可以不在全局配置文件中开启lazyLoadingEnable 在association中添加fetchType=&quot;lazy/enger来开启延迟加载 3.6 鉴别器 mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为 举例：封装Employee 如果是男生，把last_name这一列的值赋值给email 如果查询的时女生，则把部门信息查询出来 1234567891011121314151617181920212223映射文件 &lt;resultMap id=&quot;DSM&quot; type=&quot;Dao.Employee&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;last_name&quot; property=&quot;lastName&quot; /&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt; &lt;!--鉴别器： column：指定判断的列名 javaType：列值对应的java类型 --&gt; &lt;discriminator javaType=&quot;String&quot; column=&quot;gender&quot;&gt; &lt;!-- 男生 --&gt; &lt;case value=&quot;0&quot; resultType=&quot;Dao.Employee&quot;&gt; &lt;result column=&quot;last_name&quot; property=&quot;email&quot; /&gt; &lt;/case&gt; &lt;!--女生 --&gt; &lt;case value=&quot;1&quot; resultType=&quot;Dao.Employee&quot;&gt; &lt;association property=&quot;dept&quot; select=&quot;Dao.DepartmentMapper.getDeptById&quot; column=&quot;dept_id&quot;&gt; &lt;!--默认封装--&gt; &lt;/association&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt;","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://letere-gzj.github.io/categories/Mybatis/"}],"tags":[]},{"title":"【Mybatis】全局配置文件","slug":"【Mybatis】全局配置文件","date":"2020-10-17T12:40:13.000Z","updated":"2020-10-19T12:42:33.255Z","comments":true,"path":"2020/10/17/【Mybatis】全局配置文件/","link":"","permalink":"https://letere-gzj.github.io/2020/10/17/%E3%80%90Mybatis%E3%80%91%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"Mybatis全局配置文件学习笔记","text":"Mybatis全局配置文件学习笔记 一、properties（属性） （1）properties标签：可以引入外部properties配置文件内容，可以读取连接数据库的基本配置文件 （2）Mybatis与Spring进行整合时，读取配置文件的工作，一般交给Spring处理，此标签了解即可 （3）resource：引入类路径下的资源；url：网络路径或磁盘路径的内容 （4）使用实例： 12345配置文件jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=123 12345678910111213141516全局配置文件 &lt;!--properties，引入配置文件信息--&gt; &lt;properties resource=&quot;./properties/jdbcConfig.properties&quot;&gt;&lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--读取配置文件信息，使用$&#123;属性名&#125;来读取--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 二、settings（设定） （1）settting：包含很多重要设定项 （2）setting：用来设定某一个设定项 name：设定项名 value：设定项取值 （3）setting的设定项名（查看官方文档）： https://mybatis.org/mybatis-3/zh/configuration.html#settings （4）使用实例 1234 &lt;settings&gt;&lt;!--启用驼峰命名--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 三、typeAliases（类型别名） （1）typeAliases：为Java某个类型起别名 type：起别名类的全类名 alias：别名。若不添加此字段，默认为类名小写 （2）单个起别名实例： 别名启用前 12345678映射文件&lt;mapper namespace=&quot;properties.EmployeeMapper&quot;&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;Dao.Employee&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 别名启用后 1234全局配置文件--配置别名 &lt;typeAliases&gt; &lt;typeAlias type=&quot;properties.Employee&quot; alias=&quot;employee&quot;&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; 123456789映射文件--引用别名&lt;mapper namespace=&quot;properties.EmployeeMapper&quot;&gt; &lt;!--resultType：引用类型别名--&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;employee&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; （3）批量起别名 typeAliases标签下的字标签 package：为指定包下的所有类起别名 name：指定包名（为当前包，以及下面所有的后带包的每一个类都起一个默认别名） 在批量起别名的情况下，防止包与子包出现重名，可以在某个类使用@Alias(“别名”)，自定义别名 1234全局配置文件--批量起别名 &lt;typeAliases&gt; &lt;package name=&quot;properties&quot;/&gt; &lt;/typeAliases&gt; 1234567类--自定义批量别名@Alias(&quot;OtherName&quot;)public class Empioyee&#123; xxxxxxxx xxxxxxxx xxxxxxxx&#125; 四、typeHandlers（类型处理器） （1）Java类型与数据库类型映射的桥梁 以后细说 五、objectFactory（对象工厂） （1）一般都不会修改此配置属性，都是使用默认方法 不细说 六、plugin（插件） （1）plugin对语句执行的偶一点进行拦截调用 拦截方法： Executor：执行器 ParameterHandler：参数处理器 ResultSetHandler：结果集处理器，拿出结果集并封装成JavaBean对象 StatementHandler：sql语句处理器 以后细说 七、envrionments（环境） （1）标签介绍 environments：存放多个环境 default：指定某个环境，来进行环境切换 environment：配置一个具体的环境信息，必须有两个标签 id：当前环境的唯一标识 transactionManager：事务管理器 type：事务管理器类型（JDBC、MANAGED） 自定义事务管理器：类实现TransactionFactory接口，type指定为全类名 事务管理：一般交给Spring来进行 dataSource：数据源 type：数据源类型（UNPOOLED、POOLED、JNDI） 自定义连接池：类实现DataSoutceFactory接口，type是该类的全类名 （2）使用实例 创建两个数据库环境，”mysql”和”Oracle” 1234567891011121314151617181920212223全局配置文件--环境配置&lt;environments default=&quot;mysql&quot;&gt; &lt;!--mysql数据库环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;mysql.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;mysql.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;mysql.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;mysql.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--Oracle数据库环境--&gt; &lt;environment id=&quot;oracle&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;oracle.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;oracle.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;oracle.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;oracle.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 八、databaseIdProvider（数据库厂商标识） （1）标签介绍 databaseIdProvider：设置数据库厂商标识，来指定某条sql语句是指定数据来执行的 type=”DB_VENDOR”：得到数据库厂商标识（驱动自带），mybatis就能根据数据库厂商标识来执行 举例驱动：MYSQL、Oracle、SQL Server 也可以使用子标签property来为驱动起别名 （2）使用实例 1234567全局配置文件--数据库厂商标识 &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;!--为不同厂商起别名--&gt; &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlServer&quot;/&gt; &lt;/databaseIdProvider&gt; 123456789映射文件--设定sql语句执行的数据库&lt;mapper namespace=&quot;properties.EmployeeMapper&quot;&gt; &lt;!--databaseId：设置语句执行使用的数据库类型--&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;employee&quot; databaseId=&quot;mysql&quot;&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 九、mappers（映射器） （1）标签介绍 mappers：存放一组映射文件注册 mapper：注册一个sql映射 resource：引用类路径下的sql映射文件 url：引用网络路径/磁盘路径下的sql映射文件 开发中：一般将mapper映射文件，存放在mybatis.mapper的包中 （2）利用接口注册 情况一：有sql映射文件 创建一个接口，接口名与sql映射文件名一样，且放在同一目录下 用mapper的class：类的全类名 情况二：没有sql映射文件 创建一个接口，在接口方法上添加相应的注解： 增：@Insert(“sql语句”) 删：@Delete(“sql语句”) 改：@Update(“sql语句”) 查：@Select(“sql语句”) 用mapper的class：类的全类名 使用推荐 ：比较重要的Dao接口，sql写在xml配置文件中；不重要的，简单Dao接口为了快速开发，使用注解 情况二演示 12345接口public interface EmployeeMapperAnnotation &#123; @Select(&quot;select * from tbl_employee where id=#&#123;id&#125;&quot;) public Employee getEmpById(Integer id);&#125; 1234全局配置文件--注册接口&lt;mappers&gt; &lt;mapper class=&quot;mapper.EmployeeMapperAnnotation&quot;&gt;&lt;/mapper&gt;&lt;mappers&gt; （3）批量注册 要求和接口注册一样 利用package标签 name：接口和映射文件所在的包名","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://letere-gzj.github.io/categories/Mybatis/"}],"tags":[]},{"title":"【Mybatis】Mybatis入门","slug":"【Mybatis】Mybatis入门","date":"2020-10-14T11:33:32.000Z","updated":"2020-10-18T03:33:47.833Z","comments":true,"path":"2020/10/14/【Mybatis】Mybatis入门/","link":"","permalink":"https://letere-gzj.github.io/2020/10/14/%E3%80%90Mybatis%E3%80%91Mybatis%E5%85%A5%E9%97%A8/","excerpt":"mybatis初步入门","text":"mybatis初步入门 一、mybatis认识 二、mybatis下载 mybatis下载地址：https://github.com/mybatis/mybatis-3/releases 下载最新版的zip包即可 mybatis官方文档：https://mybatis.org/mybatis-3/zh/index.html 三、利用mybatis进行查询3.1 旧方法操作步骤 （1）导入相关依赖jar包 mybatis 数据库连接驱动，mysql举例：mysql-connection-java （2）数据创建表，Java创建对应的类 123456表创建语句create table tbl_employee(id int(11) primary key auto_increment,last_name varchar(255),gender char(1),email varchar(255)) 1234567891011121314151617181920//类public class Employee &#123; private Integer id; private String lastName; private char gender; private String email; //省略相应的get、set方法 @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, lastName=&#x27;&quot; + lastName + &#x27;\\&#x27;&#x27; + &quot;, gender=&quot; + gender + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; （3）创建sql映射文件 配置文件信息可在官方文档进行复制 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace：名称空间（随意，不重名即可） id：sql唯一标识（随意，不重名即可） resultType：返回值类型 #&#123;id&#125;：从传递过来的参数中，取出id值 **若sql字段名和类的属性不一致，使用sql语句的别名方式解决**--&gt;&lt;!--&lt;mapper namespace=&quot;xxxx&quot;&gt;--&gt;&lt;mapper namespace=&quot;Interface.EmployeeMapper&quot;&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;JavaBean.Employee&quot;&gt; select id, last_name lastName, gender, email from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; （4）创建全局配置文件，并与映射文件关联 配置文件信息可以复制官方文档 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--驱动--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;!--连接数据库信息--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--将写好的sql映射文件注册到全局配置文件中--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;.\\\\config\\\\EmployeeMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; （5）编写执行sql语句代码 （1）创建全局配置文件的输入流：InputStream inputStream = Resources.getResourceAsStream(“文件路径”); （2）创建SqlSessionFactory对象：SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(inputStream); （3）根据SqlSessionFactory获取SqlSession对象：SqlSession sqlSession = ssf.openSession(); （4）SqlSession对象调用方法，执行增删改查操作，若是查操作，会自动将查询结果封装到类中 （5）资源关闭 12345678910111213141516@Testpublic void test1() throws IOException &#123; //1、根据xml配置文件（全局配置文件），创建一个sqlSessionFactory对象 String resource = &quot;.\\\\config\\\\mybatisConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(inputStream); //2.获取sqlSession实例，能直接执行已经映射的sql语句 SqlSession sqlSession = ssf.openSession(); //参数一：sql的唯一标识，参数二：执行sql需要的参数 Employee o = sqlSession.selectOne(&quot;mybatis.EmployeeMapper.getEmpById&quot;, 1); System.out.println(o); //3.关闭资源 sqlSession.close();&#125; 3.2 新方法操作步骤 （1）在旧方法上进行修改 （2）创建一个接口 1234//接口public interface EmployeeMapper &#123; public abstract Employee getEmpById(int i);&#125; （3）修改sql映射文件 namespace：使用接口的全类名 id：接口方法 1234567&lt;mapper namespace=&quot;Interface.EmployeeMapper&quot;&gt; &lt;select id=&quot;getEmpById&quot; resultType=&quot;JavaBean.Employee&quot;&gt; select id, last_name lastName, gender, email from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; （4）修改执行sql的代码 获取sqlSession对象之后 通过getMapper方法，获取接口实现类对象 调用接口方法执行sql语句 123456789101112131415161718 @Testpublic void test2() throws Exception&#123; //1.获取sqlSessionFactory对象，将方法封装到方法中 SqlSessionFactory ssf = MybatisUtils.getSqlSessionFactory(); //2,获取sqlSession对象 SqlSession ss = ssf.openSession(); //3.获取接口实现类对象 //一旦接口和sql映射文件进行映射，会自动创建一个代理对象，代理对象会执行增删改查操作 EmployeeMapper mapper = ss.getMapper(EmployeeMapper.class); Employee empById = mapper.getEmpById(2); System.out.println(empById); //4.资源关闭 ss.close();&#125; 四、总结 （1）接口式编程 原生 Dao ====&gt; DaoImpl Mtbatis Mapper ====&gt; xxMapper.xml （2）sqlSession代表和数据库的一次会话；用完必须关闭。 （3）sqlSession和Connection一样，都是非线程安全。每次使用都应该去获取新的对象 （4）mapper接口灭有实现类，但mybatis会为这个接口生成一个代理对象 （5）两个重要配置文件： mybatis全局配置文件，包含数据库连接池信息，事务管理器信息等…系统运行环境 sql映射文件，保存了每一个sql语句的映射信息","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://letere-gzj.github.io/categories/Mybatis/"}],"tags":[]},{"title":"【Spring】AOP","slug":"【Spring】AOP","date":"2020-10-12T13:33:20.000Z","updated":"2020-10-14T11:37:40.788Z","comments":true,"path":"2020/10/12/【Spring】AOP/","link":"","permalink":"https://letere-gzj.github.io/2020/10/12/%E3%80%90Spring%E3%80%91AOP/","excerpt":"Spring的AOP学习笔记","text":"Spring的AOP学习笔记 一、AOP概述 AOP： （1）面向切面（方面）编程 （2）通俗描述：不通过修改源码的方式，在主干功能里面添加新功能 举例： 拿登录作为例子 二、AOP底层原理2.1 动态代理 AOP底层使用到了动态代理 有两种情况的动态代理 有接口：使用JDK动态代理 无接口：使用CGLIB动态代理 有接口： 无接口 2.2 JDK动态代理实例 （1）使用JDK动态代理，使用Proxy类里面的方法创建代理对象 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 参数1：ClassLoader(类加载器) 参数2：interfaces(接口) 参数3：InvocationHandler(一个接口，其实现类填写增强的方法) （2）JDK动态代理代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class JDK &#123; public static void main(String[] args) &#123; Class[] interfaces = &#123;UserDao.class&#125;; UserDaoImpl userDao = new UserDaoImpl(); //创建代理类，等同于创建userDao类 UserDao proxyInstance = (UserDao)Proxy.newProxyInstance(JDK.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); proxyInstance.add(1, 2); &#125;&#125;//（1）创建接口，定义方法interface UserDao&#123; public abstract int add(int a, int b); public abstract String update(String id);&#125;//（2）创建借口实现类，实现方法class UserDaoImpl implements UserDao &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public String update(String id) &#123; return id; &#125;&#125;//(3)创建代理对象的代码class UserDaoProxy implements InvocationHandler &#123; //把要代理的对象，传递进代理类 private Object obj; //有参构造器进行传递 public UserDaoProxy(Object obj)&#123; this.obj = obj; &#125;; //自动执行此方法，填写增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前的处理： System.out.println(&quot;方法之前执行：&quot; + method.getName()); System.out.println(&quot;传递的参数&quot; + Arrays.toString(args)); //执行方法： Object res = method.invoke(obj, args); //方法之后的处理： System.out.println(&quot;方法之后执行：&quot; + res); return res; &#125;&#125; 三、AOP框架3.1 aop术语 （1）连接点：类中可以被增强的方法，被称为连接点 （2）切入点：实际被真正增强的方法，被称为切入点 （3）通知（增强）：实际增强的逻辑部分 通知的种类： 前置通知（Before） 后置通知（AfterReturning） 环绕通知（Around） 异常通知（AfterThrowing） 最终通知（After） 3.2 aop使用了解 （1）Spring框架一般都是基于AspectJ实现AOP操作 AspectJ：AspectJ不是Spring的组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作 （2）基于AspectJ实现AOP操作 基于xml配置文件实现 基于注解方式实现（推荐使用） （3）在项目工程中引入相关依赖 首先是IOC的相关Jar包：beans、context、core、expression、logging、aop外 还需要Spring自带的：aspects 以及额外的：cglib、aopalliance、weaver （4）切入点表达式 切入点表达式作用：知道哪个类是对哪个类进行增强 语法结构： execution([权限修饰符][返回类型][类全路径][方法名称]([参数列表])) 举例一：对com.letere.dao.BookDao类里面的add进行增强 `execution(* com.letere.dao.BookDao.add(..)) 举例二：对com.letere.dao.BookDao类里面的所有方法进行增强 execution(* com.letere.dao.BookDao.*(..)) 举例三：对com.letere.dao包内所有类里面的所有方法进行增强 execution(* com.letere.dao.*.*(..)) 四、基于注解实现AOP操作4.1 操作步骤 （1）创建一个类（被增强类），在类里面定义方法 （2）创建一个增强类（里面填写增强的逻辑） （3）进行通知配置 在Spring配置文件中，开启组件扫描 使用注解创建User和UserProxy对象 在增强类中添加注解@Aspect 在Spring配置文件中开启生成的代理对象 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--生成context名称空间、生成aop名称空间--&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;annotationAspectJ&quot;&gt;&lt;/context:component-scan&gt; &lt;!--开启AspectJ生成代理对象--&gt; &lt;!--一旦搜到@AspectJ注解，就将此类生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 123456@Componentclass User&#123; public void add()&#123; System.out.println(&quot;add...&quot;); &#125;&#125; 1234567@Component@Aspectclass UserProxy&#123; public void before()&#123; System.out.println(&quot;before...&quot;); &#125;&#125; （4）配置不同类型的通知 在增强类里面，在作为通知方法上面添加通知类型 @Before(value = &quot;execution()&quot;) @After(value = &quot;execution()&quot;) @AfterReturning(value = &quot;execution()&quot;) @AfterThrowing(value = &quot;execution()&quot;) @Around(value = &quot;execution()&quot;) 1234567891011121314151617181920212223242526272829303132333435363738394041@Component@Aspectclass UserProxy&#123; //前置通知 @Before(value = &quot;execution(* annotationAspectJ.User.add(..))&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; //最终通知，在方法执行后执行，出现异常也一样执行 @After(value = &quot;execution(* annotationAspectJ.User.add(..))&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125; //后置（返回）通知，在返回值之前执行 @AfterReturning(value = &quot;execution(* annotationAspectJ.User.add(..))&quot;) public void afterReturning()&#123; System.out.println(&quot;afterReturning...&quot;); &#125; //异常通知，出现异常时执行 @AfterThrowing(value = &quot;execution(* annotationAspectJ.User.add(..))&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing...&quot;); &#125; //环绕通知，可在方法之前/之后执行 @Around(value = &quot;execution(* annotationAspectJ.User.add(..))&quot;) public void around(ProceedingJoinPoint pjp)&#123; System.out.println(&quot;beforeAround...&quot;); try &#123; pjp.proceed();//执行方法，类似代理模式下的代理对象 &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; System.out.println(&quot;afterAround...&quot;); &#125;&#125; （5）公共切入点抽取 重用切入点:@pointCut(value = “execution()”) 12345678910111213@Component@Aspectclass UserProxy&#123; //切入点 @Pointcut(value = &quot;execution(* annotationAspectJ.User.add(..))&quot;) public void pointCut()&#123;&#125; //前置通知 @Before(value = &quot;pointCut()&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125;&#125; （6）一个方法有多个增强类，可以设置优先级 在增强类上面添加注解@Order(数字类型值)，数字类型值越小，优先级越高 4.2 纯注解开发形式 配置类 12345@Configuration@ComponentScan(basePackages = &#123;&quot;annotationAspectJ&quot;&#125;)//注解扫描位置@EnableAspectJAutoProxy(proxyTargetClass = true)//识别@Aspect，生成代理类public class classConfig &#123;&#125; 五、基于xml配置文件实现AOP操作5.1 操作步骤 （1）创建两个类，增强类和被增强类，创建方法 （2）在Spring配置文件中创建两个类的对象 （3）在Spring配置文件中配置切入点 12345class Book&#123; public void buy()&#123; System.out.println(&quot;buy...&quot;); &#125;&#125; 12345class BookProxy&#123; public void before()&#123; System.out.println(&quot;before buy...&quot;); &#125;&#125; 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--创建aop名称空间--&gt; &lt;!--创建对象--&gt; &lt;bean id=&quot;book&quot; class=&quot;xmlAspectJ.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bookProxy&quot; class=&quot;xmlAspectJ.BookProxy&quot;&gt;&lt;/bean&gt; &lt;!--配置aop增强--&gt; &lt;aop:config&gt; &lt;!--切入点pointCut--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* xmlAspectJ.Book.buy(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;bookProxy&quot;&gt; &lt;!--增强作用在具体的哪个方法上--&gt; &lt;!--将before方法配置到p的bug方法上--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://letere-gzj.github.io/categories/Spring/"}],"tags":[]},{"title":"【Spring】IOC容器","slug":"【Spring】IOC容器","date":"2020-10-12T12:57:40.000Z","updated":"2020-10-26T12:14:31.954Z","comments":true,"path":"2020/10/12/【Spring】IOC容器/","link":"","permalink":"https://letere-gzj.github.io/2020/10/12/%E3%80%90Spring%E3%80%91IOC%E5%AE%B9%E5%99%A8/","excerpt":"Spring的IOC容器学习笔记","text":"Spring的IOC容器学习笔记 一、IOC容器概述1.1 IOC介绍 IOC：控制反转，减低计算机代码之间的耦合度 把对象的创建和对象之间的调用过程，交给Spring进行管理 1.2 底层原理 底层使用xml解析，工厂设计模式，反射 1.3 IOC接口 Spring提供IOC容器实现的两种方式（两个接口）： （1）BeanFactory： IOC容器最基本的实现方式，是Spring内部使用的接口，不提供开发人员进行使用 加载配置文件时候不会创建（懒汉式），使用时再创建对象 （2）ApplicationContext： BeanFactory接口的子接口，提供更多更强大的功能，一般有开发人员进行使用 加载配置文件时，就会创建配置文件对象（饿汉式） 把耗时耗资源的操作，交给启动服务器时使用更好 ApplicationContext的实现类 ClassPathXmlApplicationContext FileSystemXmlApplicationContext 二、xml配置文件实现bean管理2.1 属性注入 （1）通过set方法 在类中创建set方法 12345678910111213&lt;!--xml配置文件--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--通过xml配置文件set方法进行属性注入--&gt; &lt;bean id=&quot;book&quot; class=&quot;ClassPack.Book&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt; &lt;property name=&quot;author&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; （2）通过带参构造器 在类中创建一个带参构造器 12345&lt;!--省略了beans配置内容--&gt; &lt;bean id=&quot;order&quot; class=&quot;ClassPack.Order&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;abc&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;中国&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; （3）p名称空间—简化了set方法 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &lt;!--添加名称为p的空间--&gt; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--简化set方法属性注入--&gt; &lt;!--p名称空间注入--&gt; &lt;bean id=&quot;book1&quot; class=&quot;ClassPack.Book&quot; p:name=&quot;呐喊&quot; p:author=&quot;鲁迅&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; （4）外部bean注入 举例： 1.创建两个类service类和dao类 2.在service类中调用dao里面的方法 3.在Spring配置文件中进行配置 利用property中ref属性，来进行对象赋值 123456789101112&lt;!--省略beans配置内容&gt; &lt;!--1.将Service和UserDao类的对象进行创建--&gt; &lt;bean id=&quot;userService&quot; class=&quot;service.UserService&quot;&gt; &lt;!--2.在Service中注入userDao对象 name属性：类里面属性名称 red属性：创建userDao对象bean标签的id名称 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; （5）内部bean注入 跟外部bean类似，只是另外一个对象bean不再外面创建，而在一个bean里面创建 在&lt;property&gt;标签中，添加&lt;bean&gt;标签进行内部创建 123456789101112131415&lt;!--省略beans配置内容&gt; &lt;!--内部Bean操作--&gt; &lt;bean id=&quot;employee&quot; class=&quot;ClassPack.Employee&quot;&gt; &lt;!--设置前两个基本属性--&gt; &lt;property name=&quot;name&quot; value=&quot;咕料&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--内部bean形式注入对象--&gt; &lt;property name=&quot;department&quot;&gt; &lt;bean id=&quot;department&quot; class=&quot;ClassPack.Department&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;人事部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; （6）级联赋值 方法一：跟外部bean操作一样，就是在创建外部bean的同时，用&lt;property&gt;标签进行赋值 方法二：跟外部bean操作类似，但不在外部bean创建时进行赋值 1234567891011121314151617&lt;!--省略beans配置内容&gt; &lt;!--级联赋值--&gt; &lt;!--方法二：在方法一的基础上改进 注意需要在类中添加get方法 --&gt; &lt;bean id=&quot;employee&quot; class=&quot;ClassPack.Employee&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;咕料&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;department&quot; ref=&quot;department&quot;&gt;&lt;/property&gt; &lt;property name=&quot;department.name&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;department&quot; class=&quot;ClassPack.Department&quot;&gt;&lt;/bean&gt; （7）集合属性注入 在&lt;property&gt;标签内，添加对应的集合标签；数组用&lt;array&gt;，List集合用&lt;List&gt;，Set集合用&lt;Set&gt;，Map使用&lt;Map&gt; Map集合在对应的&lt;Map&gt;下，还要添加&lt;entry&gt;标签才可以 集合注入的内容是对象时，需要添加&lt;ref&gt;标签进行赋值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!--省略beans配置内容&gt; &lt;!--集合类型属性注入--&gt; &lt;bean id=&quot;student&quot; class=&quot;ClassPack.Student&quot;&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=&quot;arr&quot;&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小学&lt;/value&gt; &lt;value&gt;中学&lt;/value&gt; &lt;value&gt;大学&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map类型属性进行注入--&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;C酱&quot; value=&quot;女&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;咕料&quot; value=&quot;男&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--注入List集合，值为对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--外部bean创建对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;ClassPack.Course&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Java基础&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;ClassPack.Course&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring5&quot;&gt;&lt;/property&gt; &lt;/bean&gt; （8）把集合注入部分提取出来 1.在Spring配置文件中引入名称空间util 2.使用util标签完成list集合注入提取 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &lt;!--引入util名称空间--&gt; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; &lt;!--在下面空间添加内容--&gt; &lt;!--可以将原本内容复制，再将里面的beans改成util--&gt; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;!--1.提取list集合类型属性注入--&gt; &lt;util:list id=&quot;gameList&quot;&gt; &lt;value&gt;塞尔达传说&lt;/value&gt; &lt;value&gt;守望先锋&lt;/value&gt; &lt;value&gt;赛博朋克2077&lt;/value&gt; &lt;!--如果是属性值是对象，就用ref--&gt; &lt;/util:list&gt; &lt;!--2.使用提取出来的List集合--&gt; &lt;bean id=&quot;game&quot; class=&quot;ClassPack.Game&quot;&gt; &lt;property name=&quot;name&quot; ref=&quot;gameList&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.2 工厂bean（FactoryBean） （1）Spring有两种类型的bean，一种是普通bean，另外一种是工厂bean(Factory Bean) （2）普通Bean特点： 在配置文件中定义bean类型就是返回类型 （3）工厂Bean特点： 在配置文件中定义Bean类型可以和返回类型不一样 （4）使用工厂Bean： 创建一个类，让其实现接口FactoryBean，作为工厂Bean 实现接口里面的方法，在实现方法中定义返回的Bean类型 1234567891011121314151617181920212223//类实现FactoryBean接口，泛型填想要实现的另外一个类型public class MyFactoryBean implements FactoryBean&lt;Course&gt; &#123; //定义返回Bean的对象 //MyFactoryBean类返回的对象是Course类 @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setName(&quot;Java基础&quot;); return course; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125; 12&lt;!--跟普通创建bean方法一样--&gt; &lt;bean id=&quot;myFactoryBean&quot; class=&quot;ClassPack.MyFactoryBean&quot;&gt;&lt;/bean&gt; 1234567//实现代码 @Test public void test1()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;factoryBean.xml&quot;); Course myFactoryBean = context.getBean(&quot;myFactoryBean&quot;, Course.class); System.out.println(myFactoryBean); &#125; 2.3 bean的作用域 （1）在Spring里面，设置创建Bean实例是单实例还是多实例 （2）在Spring情况下，默认情况下是单实例对象 （3）如何设置单实例还是多实例 在Spring配置文件bean标签里面，有属性(scope)设置用于单实例还是多实例 scope属性值： singleton：表示单实例对象，是默认值 prototype，表示多实例对象 singleton和prototype区别： singleton单实例，protptype是多实例 设置scope值是singleton时候，加载spring配置文件时候就会创建单实例对象 设置scope值是prototype时候，不是在加载spring配置文件时候创建对象，在调用getBean()时候才创建多实例对象 12345&lt;!--省略beans配置内容--&gt; &lt;bean id=&quot;book&quot; class=&quot;ClassPack.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;book1&quot; class=&quot;ClassPack.Book&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; 123456789101112131415161718192021//单实例演示@Testpublic void singleTest()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;actionScope.xml&quot;); Book book1 = context.getBean(&quot;book&quot;, Book.class); Book book2 = context.getBean(&quot;book&quot;, Book.class); System.out.println(book1.equals(book2));//true //单例对象是指每次创建的对象，都是同一个对象&#125;//多实例演示@Testpublic void prototypeTest()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;actionScope.xml&quot;); Book book1 = context.getBean(&quot;book1&quot;, Book.class); Book book2 = context.getBean(&quot;book1&quot;, Book.class); System.out.println(book1.equals(book2));//false //多实例对象是指每次创建的对象，都是不同的对象&#125; （4）还有其他不常用值：requesy、session 2.4 bean生命周期 （1）生命周期：从对象的创建到对象的销毁的过程 （2）bean的生命周期 通过构造器创建Bean实例（无参数构造器） 通过构造器创建Bean实例（无参数构造器） 通过构造器创建Bean实例（无参数构造器） bean可以使用（对象获取到了）、 当容器关闭时，调用bean的销毁的方法（需要进行配置销毁的方法） （3）演示Bean的生命周期 第一步，执行无参构造器创建Bean实例 第二步，调用set方法设置属性值 第三步，执行初始化方法 第四步，获取创建Bean实例对象 ClassPack.LifeCycleBean@34123d65 第五步，执行销毁的方法 1234567891011121314151617181920212223//类public class LifeCycleBean &#123; private String name; public LifeCycleBean()&#123; System.out.println(&quot;第一步，执行无参构造器创建Bean实例&quot;); &#125; public void setName(String name) &#123; this.name = name; System.out.println(&quot;第二步，调用set方法设置属性值&quot;); &#125; //创建执行的初始化方法 public void initMethod()&#123; System.out.println(&quot;第三步，执行初始化方法&quot;); &#125; //创建执行销毁的方法 public void destroyMethod()&#123; System.out.println(&quot;第五步，执行销毁的方法&quot;); &#125;&#125; 12345&lt;!--省略了beans配置内容--&gt; &lt;!--init-method配置执行初始化方法，destory-method配置销毁方法--&gt; &lt;bean id=&quot;lifeCycleBean&quot; class=&quot;ClassPack.LifeCycleBean&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;生命周期&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 1234567891011//执行代码 @Test public void test()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;lifeCycle.xml&quot;); LifeCycleBean lifeCycleBean = context.getBean(&quot;lifeCycleBean&quot;, LifeCycleBean.class); System.out.println(&quot;第四步，获取创建Bean实例对象&quot;); System.out.println(lifeCycleBean); //手动让bean实例销毁 context.close(); &#125; （4）Bean的后置处理器，bean的生命周期变成7步 第一步，执行无参构造器创建Bean实例 第二步，调用set方法设置属性值 把bean实例传递给bean后置处理器的方法：postProcessBeforeInitialization 第三步，执行初始化方法 把bean实例传递给bean后置处理器的方法：postProcessAfterInitialization 第四步，获取创建Bean实例对象 ClassPack.LifeCycleBean@34123d65 第五步，执行销毁的方法 （5）实现方法： 在上面的基础上，新建一个类，实现BeanPostProcessor接口，作为后置处理器 在xml配置文件中配置 1234567891011121314//后置处理器类public class LifeCycleBean2 implements BeanPostProcessor&#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); return null; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return null; &#125;&#125; 12&lt;!--配置后置处理器--&gt;&lt;bean id=&quot;lifeCycleBean2&quot; class=&quot;ClassPack.LifeCycleBean2&quot;&gt;&lt;/bean&gt; 2.5 自动装配 自动装配：根据指定的装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入 12345678910111213141516&lt;!--省略beans配置内容--&gt; &lt;!--手动装配--&gt; &lt;bean id=&quot;emp&quot; class=&quot;beanManager.Emp&quot;&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;beanManager.Dept&quot;&gt;&lt;/bean&gt; &lt;!--自动装配 autowire：自动装配 参数： byName(根据属性名称注入)，注入值bean的id值和类属性名称一样 byType(根据属性类型注入)，相同类型的bean必须只有一个 --&gt; &lt;bean id=&quot;emp2&quot; class=&quot;beanManager.Emp&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;emp3&quot; class=&quot;beanManager.Emp&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt; 2.6 引入外部属性文件 一般将属性值比较固定的，通过文件进行保存，通过读取文件来获取属性内容（例如：连接数据库的内容） 举例：连接 数据库连接池 （1）直接配置数据库信息 引入德鲁伊连接池依赖的jar包 在xml文件中配置信息 12345678&lt;!--直接配置--&gt;&lt;!--1.创建连接池对象--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/jdbctest?serverTimezone=GMT%2B8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123&quot;&gt;&lt;/property&gt;&lt;/bean&gt; （2）通过引入外部属性文件配置数据库连接池 创建properties文件信息 创建context名称空间（和之前的util一致） 在配置文件使用标签引入外部属性文件 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--创建连接对象--&gt; &lt;bean id=&quot;dataSource1&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClassName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.user&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建对象的方式没有改变的就不演示了 三、注解形式实现bean管理3.1 注解介绍 注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…) 注解可以作用在类，属性，方法上 简化xml配置 3.2 利用注解创建对象 创建对象的四个注解： （1）@Component （2）@Service （3）@Controller （4）@Repository 四个注解功能是一样的，但一般为了区分，会在不同的地方使用不同注解 创建方法： （1）引入以来jar包：aop （2）xml配置文件开启组件扫描，需要引入context名称空间 （3）类添加创建注解，创建方法和xml配置方法一致 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1.引入context名称空间--&gt; &lt;!--2.开始组建扫描--&gt; &lt;context:component-scan base-package=&quot;ClassPack&quot;&gt;&lt;/context:component-scan&gt; &lt;!--如果需要扫描多个包，可以用&#x27;,&#x27;来添加其他路径--&gt; &lt;/beans&gt; 123456789//创建带注解的类//value类似于&lt;bean&gt;的id；若不添加value，则value默认值为，类名首字母小写@Component(value = &quot;annotationClass&quot;) public class AnnotationClass &#123; public void show()&#123; System.out.println(&quot;注解创建类...&quot;); &#125;&#125; 补充： 组件扫描可以开启更细致的扫描 1234567&lt;!--use-default-filters：是否扫描全部类--&gt;&lt;!--iinclude-filter：只扫描特定内容--&gt; &lt;context:component-scan base-package=&quot;ClassPack&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--自己添加过滤器：只扫描包中有注解，且注解为Component的类--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Component&quot;/&gt; &lt;/context:component-scan&gt; 123456&lt;!--exclude-filter：不扫描指定内容--&gt; &lt;context:component-scan base-package=&quot;ClassPack&quot;&gt; &lt;!--自己添加过滤器：不扫描包中有注解，且注解为Component的类--&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Component&quot;/&gt; &lt;/context:component-scan&gt; 3.3 属性注入 属性注入的注解： （1）@AutoWired： 自动装填，根据属性类型进行注入 （2）@Qualifier： 根据属性的名称进行注入，此注解要和@AutoWired一起使用 （3）@Resource： 可以根据类型注入，可以根据名称注入 此注解为javax.annotation.Resource当中，新版本JDK摒弃了此API，官方推荐用上面两注解来实现 新版本JDK没有@Resource解决方法：https://blog.csdn.net/qq_44518192/article/details/107644905 （4）@Value： 注入普通类型属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//类：//四种属性注入演示：@Component()public class Attribute1 &#123; //不需要添加set方法 @Autowired private Attribute2 a2; //Attriubute接口实现类有两个，通过指定id名称（默认转配：类名小写）来创建对象 @Autowired @Qualifier(value = &quot;attribute3&quot;) private Attribute a3; //类似于：Attrribute a3 = new Attriable3(); //跟@AutoWired方法一样 @Resource private Attribute2 a4; //跟@Qualifier(value = &quot;&quot;)一样 @Resource(name = &quot;attribute3&quot;) private Attribute a5; @Value(value = &quot;C酱&quot;) private String name; public void show()&#123; a2.show(); a3.show(); a4.show(); a5.show(); System.out.println(name); &#125;&#125;interface Attribute&#123; public void show();&#125;@Repository()class Attribute2 implements Attribute&#123; @Override public void show()&#123; System.out.println(&quot;这里是Attribute2！&quot;); &#125;&#125;@Component()class Attribute3 implements Attribute&#123; @Override public void show()&#123; System.out.println(&quot;这里是Attribute3！&quot;); &#125;&#125; 12345678public class attributeInjection &#123; @Test public void test()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;.\\\\annotationXml\\\\create.xml&quot;); Attribute1 bean = context.getBean(&quot;attribute1&quot;, Attribute1.class); bean.show(); &#125;&#125; 3.4 纯注解开发 （1）创建配置类，替代xml配置文件 @Configuration：作为配置类，替代xml配置文件 @ComponentScan(basePackages = &#123;&quot;ClassPack&quot;&#125;) ：扫描注解路径，跟xml的开启组件扫描一样 （2）public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) ：加载配置类 123456//配置类@Configuration //作为配置类，替代xml配置文件@ComponentScan(basePackages = &#123;&quot;ClassPack&quot;&#125;)public class SpringConfig &#123;&#125; 12345678910//创建对象public class pureAnnotationDevelopment &#123; @Test public void test()&#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);//加载配置类 Attribute1 bean = context.getBean(&quot;attribute1&quot;, Attribute1.class); bean.show(); &#125;&#125; 此纯注解开发，一般是SpringBoot才使用到","categories":[{"name":"Spring","slug":"Spring","permalink":"https://letere-gzj.github.io/categories/Spring/"}],"tags":[]},{"title":"【Spring】Spring概念","slug":"【Spring】Spring概念","date":"2020-10-11T03:29:14.000Z","updated":"2020-10-11T05:44:02.618Z","comments":true,"path":"2020/10/11/【Spring】Spring概念/","link":"","permalink":"https://letere-gzj.github.io/2020/10/11/%E3%80%90Spring%E3%80%91Spring%E6%A6%82%E5%BF%B5/","excerpt":"关于Spring的基本了解","text":"关于Spring的基本了解 一、Spring概念1.Spring框架的概述 （1）Spring是轻量级的开源JavaEE的框架 （2）Spring可以解决企业应用开发的复杂性 （3）Spring有两个核心部分：IOC和Aop IOC：控制反转，把创建对象过程交给Spring进行管理，不再自己new Aop：面向切面，不修改源代码进行功能增强 （4）Spring特点： 1.方便解耦，简化开发 2.Aop编程支持 3.方便程序测试（整合了JUnit4） 4.方便和其他框架进行整合 5.方便进行事物操作 6.降低API开发难度 2.Spring下载 Spring官网地址：https://spring.io/projects/spring-framework#learn 查看最新的GA版本，GA是稳定开发版 下载地址：https://repo.spring.io/release/org/springframework/spring 下载xxx-dist.zip文件 3.入门案例演示 （1）创建一个Java项目 （2）导入Spring基本包：bean、context、epression、core 还有一个日志包：commons-logging-1.1.1.jar （3）举例用Spring来创建对象 （4）创建配置文件（IDEA操作）： new – xml configuration file – Spring （5）自定义个对象（需要空参构造器） 12345public class User &#123; public void add()&#123; System.out.println(&quot;add...&quot;); &#125;&#125; （6）修改Spring配置文件 在&lt;beans&gt;标签下添加&lt;bean&gt;标签来创建对象 格式：&lt;bean id=&quot;user&quot; class=&quot;ClassPack.User&quot;&gt;&lt;/bean&gt; 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--配置User对象创建--&gt; &lt;bean id=&quot;user&quot; class=&quot;ClassPack.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; （7）Java文件操作 12345678910111213141516@Testpublic void test()&#123; //1.加载Spring的配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);//src下使用 ApplicationContext context1 = new FileSystemXmlApplicationContext(&quot;src\\\\bean1.xml&quot;);//相对路径 //2.获取配置创建的对象 User user = context.getBean(&quot;user&quot;, User.class); User user1 = context1.getBean(&quot;user&quot;, User.class); System.out.println(user); user.add(); System.out.println(user1); user1.add();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://letere-gzj.github.io/categories/Spring/"}],"tags":[]},{"title":"【JDBC】数据库事务","slug":"【JDBC】数据库事务","date":"2020-10-08T13:21:35.000Z","updated":"2020-10-08T14:00:27.291Z","comments":true,"path":"2020/10/08/【JDBC】数据库事务/","link":"","permalink":"https://letere-gzj.github.io/2020/10/08/%E3%80%90JDBC%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/","excerpt":"Java实现数据库事务学习笔记","text":"Java实现数据库事务学习笔记 一、介绍1.1 事务 （1）事物：一组逻辑操作单元，使数据从一种状态变换到另一种状态 一组逻辑操作单元：一行或多行的DML操作 1.2 事务处理 （1）事物处理：保证所有书屋作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。 （2）一个事物执行多个操作时，要么所有事物都被提交（commit）；要么放弃修改，事物回滚（rollback）最初状态 （3）数据一旦提交，就不可以回滚 1.3 数据自动提交情况 （1）DDL操作，一旦执行，都会自动提交 （2）DML操作，默认情况下，一旦执行，就会自动提交 可以通过set autocommit = false的方式取消自动提交 （3）默认在关闭连接时，会自动提交数据 二、操作方法 Java实现事务，主要避免出现数据自动提交，以免数据出错无法进行回滚 例子：转账 （1）重载JDBCUtils的update方法，不让其关闭连接，避免数据提交 12345678910111213141516171819202122public static int Update(Connection conn, String sql, Object ...args)&#123; PreparedStatement ps = null; try &#123; //1.sql语句预编译 ps = conn.prepareStatement(sql); //2.填充占位符 for (int i = 0; i &lt; args.length; i++)&#123; ps.setObject(i+1, args[i]); &#125; //3.执行sql语句 return ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭，不关闭连接 JDBCUtils.close(null, ps); &#125; //6.try-catch-finally处理异常 return 0;&#125; （2）设置数据执行sql不自动提交，等事务全部成功执行完再提交，报错就回滚 void setAutoCommit(boolean autoCommit) throws SQLException：设置数据是否自动提交 void commit() throws SQLException：手动提交数据 void rollback() throws SQLException：数据回滚 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void test2() &#123; Connection conn = null; try &#123; //1.连接数据库 conn = JDBCUtils.getConnection(); //2.取消数据自动提交 conn.setAutoCommit(false); //3.执行增删改操作 String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;; JDBCUtils.Update(conn, sql1, &quot;AA&quot;); String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;; JDBCUtils.Update(conn, sql2, &quot;BB&quot;); //4.手动提交数据 conn.commit(); &#125; catch (Exception e) &#123; System.out.println(&quot;事物出现错误，数据回滚！&quot;); //5.出现异常时，数据回滚 try &#123; conn.rollback(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; finally &#123; //6.恢复为默认值自动提交数据，用于数据库连接池操作 try &#123; conn.setAutoCommit(true); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; //7.关闭连接 if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; //8.try-catch-finally处理异常&#125; 三、事物ACID属性 （1）原子性（Automicity） 原子性是指事物是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 （2）一致性（Consistency） 事物必须使数据库从一致状态变换到另外一个一致性状态 （3）隔离性（isolation） 事物的隔离性是指一个事物的执行不能被其他事物干扰，即一个事物内部的操作及使用的数据对并发的其他事务是隔离带，并发执行的各个事务之间不能互相干扰 （4）持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其他有人哈影响 四、事务隔离4.1 事务并发出现的问题 （1）脏读：事务T1读取事务T2更新了，但未提交的数据 （2）不可重复读：T1读取了某个字段，T2操作更新了该字段，T1再进行读取时发现两次读取不一致 （3）幻读：T1读取某个字段，T2对该字段所在表插入新的字段，如果T1再进行读取该表，会发现多出几行 4.2 四种隔离级别（隔离级别越高，性能越差） （1）READ UNCOMMITTED（读未提交数据）：什么问题都没解决 （2）READ COMMITTED（读已提交数据）：解决了脏读的问题 （3）REPEATABLE READ（课重复读）：解决脏读、不可重复读问题 （4）SERIALIZABLE（串行化）：三个问题都解决了 补充： oracle支持2种事务隔离，READ COMMITTED和SERIALIZABLE，默认为READ COMMITTED mysql支持4重事务隔离，默认为REPEATABLE READ 4.3 mysql8.0设置隔离等级 （1）查看当前隔离级别： select @@transaction_isolation; （2）设置当前mysql连接的隔离级别 set transaction isolation level read committed; （3）设置数据库系统的全局的隔离级别： set global transaction isolaction level read committed 4.4 java控制数据库设置隔离等级 void setTransactionIsolation(int level) throws SQLException：设置隔离等级 1234567891011121314151617181920@Testpublic void queryTest() throws Exception &#123; //1.连接数据库 Connection conn = JDBCUtils.getConnection(); //获取当前隔离级别 System.out.println(conn.getTransactionIsolation()); //设置数据库的隔离级别 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); //取消自动提交数据 conn.setAutoCommit(false); //2.查询数据 String sql = &quot;select user, password, balance from user_table where user = ?&quot;; User cc = JDBCUtils.query(conn, User.class, sql, &quot;CC&quot;); System.out.println(cc);&#125;","categories":[{"name":"JDBC技术","slug":"JDBC技术","permalink":"https://letere-gzj.github.io/categories/JDBC%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【JDBC】批量插入","slug":"【JDBC】批量插入","date":"2020-10-08T05:57:19.000Z","updated":"2020-10-08T07:01:51.584Z","comments":true,"path":"2020/10/08/【JDBC】批量插入/","link":"","permalink":"https://letere-gzj.github.io/2020/10/08/%E3%80%90JDBC%E3%80%91%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/","excerpt":"Java实现数据库批量插入操作","text":"Java实现数据库批量插入操作 一、介绍 （1）update、delete本身就具有批量操作的效果 （2）所以批量操作一般就指批量插入 二、实例 下面出现的几个方法，一逐步优化，所以最终推荐使用最后一个方法 代码演示的是插入1000条数据的速度 演示使用表的格式 1.方式一123456789101112131415161718192021@Testpublic void test() throws Exception &#123; //1.连接数据库 Connection conn = JDBCUtils.getConnection(); //2.创建Preparedstatement对象 String sql = &quot;insert into goods(name) values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); //3.循环填充占位符，并执行；并记录循环开始，结束时间 long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) &#123; ps.setObject(1, &quot;name&quot; + (i+1)); ps.execute(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费时间为：&quot; + (end-start));//80903（本人花费时间） //4.关闭连接 JDBCUtils.close(conn, ps);&#125; 2.方式二 使用addBatch()、executeBatch()、clearBatch()进行批量插入，类似创建一个缓冲区，存够一定数据才在执行 mysql服务器默认关闭批量处理，需要在url后面添加?rewriteBatchedSatements=true,mysql8.0不需要此操作 123456789101112131415161718192021222324252627@Testpublic void test2() throws Exception &#123; //1.连接数据库 Connection conn = JDBCUtils.getConnection(); //2.创建PreparedStatement对象 String sql = &quot;insert into goods(name) values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); //3.填充占位符，循环执行，并记录开始，结束时间 long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) &#123; ps.setObject(1, &quot;name&quot; + i); //（1）攒sql语句 ps.addBatch(); //（2）攒够一定数量，开始一次性执行 if (i % 500 == 0)&#123; ps.executeBatch(); ps.clearBatch(); &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;花费时间为：&quot; + (end-start));//38537（本人花费时间） //4.关闭连接 JDBCUtils.close(conn, ps);&#125; 3.方式三 没执行一次sql语句都会提交一次数据，于是关闭自动提交数据，等全部数据执行完才一次性提交 123456789101112131415161718192021222324252627282930313233@Testpublic void test3() throws Exception &#123; //1.连接数据库 Connection conn = JDBCUtils.getConnection(); //2.创建PreparedStatement String sql = &quot;insert into goods(name) values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); //3.设置不允许自动提交数据 conn.setAutoCommit(false); ///4.填充占位符，循环执行，并记录开始，结束时间 long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) &#123; ps.setObject(1, &quot;name&quot; + i); //（1）攒sql语句 ps.addBatch(); //（2）攒够一定数量，开始一次性执行 if (i % 500 == 0)&#123; ps.executeBatch(); ps.clearBatch(); &#125; &#125; //5.手动提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(&quot;花费时间为：&quot; + (end-start));//409（本人花费时间） //6.关闭连接 JDBCUtils.close(conn, ps);&#125;","categories":[{"name":"JDBC技术","slug":"JDBC技术","permalink":"https://letere-gzj.github.io/categories/JDBC%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【JDBC】操作BLOB类型字段","slug":"【JDBC】操作BLOB类型字段","date":"2020-10-08T05:56:57.000Z","updated":"2020-10-08T06:30:15.686Z","comments":true,"path":"2020/10/08/【JDBC】操作BLOB类型字段/","link":"","permalink":"https://letere-gzj.github.io/2020/10/08/%E3%80%90JDBC%E3%80%91%E6%93%8D%E4%BD%9CBLOB%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5/","excerpt":"使用java在数据库中存储BLOB类型字段","text":"使用java在数据库中存储BLOB类型字段 一、介绍 （1）BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，可以容纳不容大小的数据 （2）BLOB数据必须使用PreparedStatement来操作 （3）BLOB的不同类型 类型 大小（单位：字节） TinyBlob 最大255 Blob 最大65K MediumBlob 最大16M LongBlob 最大4G （4）注意：存储数据过大，数据库性能会下降 （5）如果修改了数据类型，仍然出现数据过大，需要寻找my.ini配置文件，添加参数max_alllowed_paket=16M，并重启mysql服务器 二、操作方法1.存入BLOB数据 （1）创建一个文件输入流 （2）利用PreparedStatement对象的void setBlob(int parameterIndex, InputStream inputStream)填充占位符 （3）执行sql语句 JDBCUtils是自定义类，具体封装的方法，请看“【JDBC】使用PreparedStatement实现CRUD操作” 123456789101112131415161718192021222324252627@Testpublic void addTest() throws Exception &#123; //1.连接数据库 Connection conn = JDBCUtils.getConnection(); //2.创建PreparedStatement对象 String sql = &quot;insert into customers(name, email, birth, photo) values(?, ?, ?, ?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); //3.填充占位符&#x27;?&#x27; ps.setObject(1, &quot;艾米莉亚&quot;); ps.setObject(2,&quot;emi@qq.com&quot;); ps.setObject(3,&quot;1999-09-09&quot;); //4.BLOB数据填充占位符 FileInputStream fis = new FileInputStream(&quot;.\\\\src\\\\艾米莉亚.jpg&quot;); ps.setBlob(4, fis); //5.执行sql语句 ps.execute(); //6.资源关闭，连接关闭 fis.close(); JDBCUtils.close(conn, ps); //7.try-catch处理异常（省略）&#125; 2.取出BLOB数据 利用Blob getBlob(String columnLabel)读取BOLB数据 BLOB对象使用java.io.InputStream getBinaryStream ()来获取输入流 利用IO流操作，保存到本地 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Testpublic void queryTest() throws Exception &#123; //1.连接数据库 Connection conn = JDBCUtils.getConnection(); //2.创建PreparedStatement对象 String sql = &quot;select * from customers where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); //3.填充占位符 ps.setObject(1, 23); //4.执行查询语句 ResultSet rs = ps.executeQuery(); //5.读取查询结果，保存到类中，BLOB数据保存到本地 InputStream is = null; FileOutputStream fos = null; if (rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); Customer emi = new Customer(id, name, email, birth); System.out.println(emi); //（1）获取blob数据 Blob photo = rs.getBlob(&quot;photo&quot;); //（2）获取该数据的输入流 is = photo.getBinaryStream(); //（3）创建输出流 fos = new FileOutputStream(&quot;.\\\\src\\\\emi.jpg&quot;); //（4）读取二进制数据，保存到本地 byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1)&#123; fos.write(buffer, 0, len); &#125; &#125; //6.资源关闭 fos.close(); is.close(); JDBCUtils.close(conn, ps, rs); //7try-catch处理异常（省略）&#125;","categories":[{"name":"JDBC技术","slug":"JDBC技术","permalink":"https://letere-gzj.github.io/categories/JDBC%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【JDBC】使用PreparedStatement实现CRUD操作","slug":"【JDBC】使用PreparedStatement实现CRUD操作","date":"2020-09-28T15:18:13.000Z","updated":"2020-10-06T06:15:41.153Z","comments":true,"path":"2020/09/28/【JDBC】使用PreparedStatement实现CRUD操作/","link":"","permalink":"https://letere-gzj.github.io/2020/09/28/%E3%80%90JDBC%E3%80%91%E4%BD%BF%E7%94%A8PreparedStatement%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C/","excerpt":"JDBC实现增删改查学习笔记","text":"JDBC实现增删改查学习笔记 一、Statement简介 在java.sql包中3个接口分别定义了对数据库的调用的不同方式： （1）Statement：用于执行静态SQL语句并返回它所生成的结果的对象 （2）PrepareStatement：SQL语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句 （3）CallableStatement：用于执行SQL存储过程 注意： Satement是对SQL语句进行拼接，容易被钻漏洞（SQL注入）。所以一般会用PreparedStatement来代替Statement PreparedStatement是Statement的子接口，是预编译的的Statement 二、实现增删改操作 四种对数据库的操作，可以分为两类：增删改、查 增删改：不需要返回值 查：需要处理返回值 2.1实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Testpublic void test() throws Exception&#123; FileInputStream fis = null; Connection conn = null; PreparedStatement ps = null; try &#123; //1.创建输入流 fis = new FileInputStream(&quot;src\\\\jdbc.properties&quot;); Properties pro = new Properties(); pro.load(fis); //2.获取数据 String user = pro.getProperty(&quot;user&quot;); String password = pro.getProperty(&quot;password&quot;); String url = pro.getProperty(&quot;url&quot;); String driverClass = pro.getProperty(&quot;DriverClass&quot;); //3.反射加载驱动 Class.forName(driverClass); //4.连接数据库 conn = DriverManager.getConnection(url, user, password); //------------------------------------------------------------------------ //5.预编译sql语句，返回PreparedStatement对象 String sql = &quot;insert into `customers`(name, email, birth) values(?, ?, ?)&quot;;//? 为 占位符 ps = conn.prepareStatement(sql); //6.填充占位符 ps.setString(1,&quot;C酱&quot;);//第一参数为占位符位置，从1开始算 ps.setString(2,&quot;CC@gmail.com&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = sdf.parse(&quot;2002-08-14&quot;); ps.setDate(3, new java.sql.Date(date.getTime())); //7.执行操作 ps.execute(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //8.资源关闭 if (ps != null)&#123; try &#123; ps.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //9.try-catch-finally处理异常&#125; 2.2 封装方法修改实例 （1）新建一个JDBCUtils类，来封装数据库连接，资源关闭操作 123456789101112131415161718192021222324/** * 连接数据，返回一个Connection对象 * @return Connection * @throws Exception */public static Connection getConncetion() throws Exception&#123; //1.创建输入流 FileInputStream fis = new FileInputStream(&quot;src\\\\jdbc.properties&quot;); Properties pro = new Properties(); pro.load(fis); //2.获取数据 String user = pro.getProperty(&quot;user&quot;); String password = pro.getProperty(&quot;password&quot;); String url = pro.getProperty(&quot;url&quot;); String driverClass = pro.getProperty(&quot;DriverClass&quot;); //3.反射加载驱动 Class.forName(driverClass); //4.连接数据库 Connection conn = DriverManager.getConnection(url, user, password); return conn;&#125; 123456789101112131415161718192021/** * 关闭资源 * @param conn * @param ps */public static void close(Connection conn, PreparedStatement ps)&#123; if (ps != null)&#123; try &#123; ps.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125;&#125; （2）重新修改实例 123456789101112131415161718192021222324252627282930@Testpublic void test2()&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.连接数据库 conn = JDBCUtils.getConncetion(); //2.预编译sql语句，返回PreparedStatement对象 String sql = &quot;insert into `customers`(name, email, birth) values(?, ?, ?)&quot;;//? 为 占位符 ps = conn.prepareStatement(sql); //3.填充占位符 ps.setString(1,&quot;C酱&quot;);//第一参数为占位符位置，从1开始算 ps.setString(2,&quot;CC@gmail.com&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = sdf.parse(&quot;2002-08-14&quot;); ps.setDate(3, new java.sql.Date(date.getTime())); //4.执行操作 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //5.资源关闭 JDBCUtils.close(conn, ps); &#125; //6.try-catch-finally处理异常&#125; 2.3 封装通用的增删改方法123456789101112131415161718192021222324252627282930/** * 通用的sql增删改操作，传入的sql语句是带占位符的 * @param sql * @param args */public static void Update(String sql, Object ...args) throws Exception &#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1.获取数据库连接 conn = JDBCUtils.getConncetion(); //2.sql语句预编译 ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++)&#123; ps.setObject(i+1, args[i]); &#125; //4.执行sql语句 ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //5.资源关闭 JDBCUtils.close(conn, ps); &#125; //6.try-catch-finally处理异常&#125; 123456789@Testpublic void test3() &#123; try &#123; String sql = &quot;delete from `customers` where name = ?&quot;; JDBCUtils.Update(sql, &quot;C酱&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 三、实现查找操作3.1 概述 查找操作对比其他操作，多了个对返回的数据进行接受、处理。 对返回的数据，一般会创造一个类来进行接受，属于ORM编程思想，也是“万事万物皆对象”的体现 3.2 实现方法 （1）查询语句的执行方法是ResultSet executeQuery()，会返回一个结果集resultSet方法 （2）通过resultSet.next()方法来判断是否存在一行数据，有就返回true并指针下移，用于条件判断 （3）通过resultSet.getXxxx(index)来获取数据，因为要封装通用方法，一般使用getObject(index) 注意：index是从1开始算，并不是0开始 （4）创建相应的对象，将获取的数据赋值到该对象中，一般使用反射方法 注意： 步骤3需要知道一行数据到底有多少列数据；步骤4需要获取到列名，才能利用反射进行数据赋值（注意类的属性名，与查询的列名一致，不一致可以用sql语句别名的方式） 解决方法： （a）用resultSet.getMetaData()的方法来获取数据的原数据 （b）resultMetaData.getColumnCount()来获取列数，解决步骤3 （c）resultMetaData.getColumnLabel(index)，获取列名，index从1开始，解决步骤4 3.3 实例 （1）查询特定表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static UserTable queryForUserTable(String sql, Object ...args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1.连接数据库 conn = JDBCUtils.getConnection(); //2.预编译sql ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i+1, args[i]); &#125; //4.执行并返回结果集 rs = ps.executeQuery(); //5.处理结果集 ResultSetMetaData rsmd = rs.getMetaData();//获取结果集的元数据 int column = rsmd.getColumnCount();//获取列数 //6.处理一行结果集 if (rs.next())&#123; UserTable u = new UserTable();//创建一个空参对象 for (int i = 0; i &lt; column; i++)&#123; //（1）获取列数据 Object columnValue = rs.getObject(i + 1); //（2）获取列名 String columnLabel = rsmd.getColumnLabel(i + 1); //（3）通过反射进行赋值赋值 Class clazz = u.getClass(); Field filed = clazz.getDeclaredField(columnLabel); filed.setAccessible(true); filed.set(u, columnValue); &#125; return u; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //7.资源关闭 JDBCUtils.close(conn, ps, rs); &#125; return null;&#125; （2）通过泛型，来实现查询任意表数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static &lt;T&gt; List&lt;T&gt; queryAll(Class&lt;T&gt; clazz, String sql, Object ...args)&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1.连接数据库 conn = JDBCUtils.getConnection(); //2.预编译sql ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) &#123; ps.setObject(i+1, args[i]); &#125; //4.执行并返回结果集 rs = ps.executeQuery(); //5.处理结果集 ResultSetMetaData rsmd = rs.getMetaData();//获取结果集的元数据 int column = rsmd.getColumnCount();//获取列数 //6.处理多行结果集 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();//创建一个List集合 while (rs.next())&#123; T t = clazz.getDeclaredConstructor().newInstance();//反射创建一个空参对象 for (int i = 0; i &lt; column; i++)&#123; //（1）获取列数据 Object columnValue = rs.getObject(i + 1); //（2）获取列名 String columnLabel = rsmd.getColumnLabel(i + 1); //（3）通过反射进行赋值 Field filed = clazz.getDeclaredField(columnLabel); filed.setAccessible(true); filed.set(t, columnValue); &#125; list.add(t);//添加对象 &#125; return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //7.资源关闭 JDBCUtils.close(conn, ps, rs); &#125; return null;&#125;","categories":[{"name":"JDBC技术","slug":"JDBC技术","permalink":"https://letere-gzj.github.io/categories/JDBC%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【JDBC】获取数据库连接","slug":"【JDBC】获取数据库连接","date":"2020-09-27T12:02:34.000Z","updated":"2020-09-28T15:38:47.345Z","comments":true,"path":"2020/09/27/【JDBC】获取数据库连接/","link":"","permalink":"https://letere-gzj.github.io/2020/09/27/%E3%80%90JDBC%E3%80%91%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/","excerpt":"通过Java获取数据库连接，学习笔记","text":"通过Java获取数据库连接，学习笔记 一、导入驱动jar包 注意：本文使用的是IDEA集成编辑软件，mysql8.0数据库 （1）”File” —&gt; “Project Structure” （2）”Model” —&gt; “Dependeincies” —&gt; “+” —&gt; “JARs or directories” （3）选择jar包所在路径，然后”OK”即可 二、获取数据库连接 以下会列出5种数据库连接方法，但每个方法是上一个方法的迭代，第五个版本是最终版，也是最推荐连接的方法 2.1 连接方式一123456789101112131415@Testpublic void testConnection() throws SQLException &#123; //1.提供连接数据的基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&quot;;//数据库的位置 Properties info = new Properties();//配置文件 info.setProperty(&quot;user&quot;, &quot;root&quot;);//用户 info.setProperty(&quot;password&quot;, &quot;123&quot;);//密码 //2.获取Driver实现类对象 Driver driver = new com.mysql.cj.jdbc.Driver(); //3.调用connect方法连接数据库 Connection conn = driver.connect(url, info);//连接数据库 System.out.println(conn);//com.mysql.cj.jdbc.ConnectionImpl@4a668b6e&#125; 说明： （1）连接数据的方法：Connection connect(String url, java.util.Properties info) （2）url格式：jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8 jdbc:mysql – 协议 localhost – ip地址 3306 – 端口号 test – test数据库 ?serverTimezone=GMT%2B8 – 解决时区问题 2.2 连接方式二 方式二是对方式一的优化，因为方式一出现了第三方的API Driver driver = new com.mysql.cj.jdbc.Driver(); （上面代码出现了com.sql.cj.jdbc.Driver() 第三方API） 可以通过反射来加载类，来创建对象 12345678910111213141516@Testpublic void test() throws Exception &#123; //1.提供连接数据库的基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&quot;; Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;123&quot;); //2.获取Driver实现类对象 Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); //3.创建Connection对象，连接数据库 Connection connect = driver.connect(url, info); System.out.println(connect);&#125; 2.3 连接方式三 使用DriverManager来代替Driver来获取连接 DriverManger连接数据库的方式，要比Driver简单，且方式多 使用DriverManager要先进行注册驱动，才能获取连接 注册驱动： public static void registerDriver(java.sql.Driver driver) 连接数据库： public static Connection getConnection(String url) public static Connection getConnection(String url, java.util.Properties info) public static Connection getConnection(String url, String user, String password) 常用第三种方法连接数据库 123456789101112131415161718@Testpublic void test() throws Exception&#123; //1.提供连接数据库的基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&quot;; String user = &quot;root&quot;; String password = &quot;123&quot;; //2.获取Driver实现类对象 Class clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);&#125; 2.4 连接方式四 是方式三的优化，省略了方式三的一些不必要的操作 反射获取驱动类会自动进行DriverManager的驱动注册，可以进行省略 1234567891011121314@Testpublic void test() throws Exception&#123; //1.提供另外三个基本信息 String url = &quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&quot;; String user = &quot;root&quot;; String password = &quot;123&quot;; //2.反射会自动进行驱动注册，可以省略步骤 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);&#125; 2.5 连接方式五（最终版） 使用配置文件来读取连接数据库所需要的信息 程序进行封装之后，可以直接修改配置文件而改变要读取的内容，而不用重新打开编辑器进行修改 123456789101112131415161718192021@Testpublic void test() throws Exception&#123; //1.创建输入流 FileInputStream fis = new FileInputStream(&quot;src\\\\jdbc.properties&quot;); Properties pro = new Properties(); pro.load(fis); //2.获取数据 String user = pro.getProperty(&quot;user&quot;); String password = pro.getProperty(&quot;password&quot;); String url = pro.getProperty(&quot;url&quot;); String driverClass = pro.getProperty(&quot;DriverClass&quot;); //3.反射加载驱动 Class.forName(driverClass); //4.连接数据库 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(connection);&#125;","categories":[{"name":"JDBC技术","slug":"JDBC技术","permalink":"https://letere-gzj.github.io/categories/JDBC%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【JDBC】JDBC概述","slug":"【JDBC】JDBC概述","date":"2020-09-27T08:05:59.000Z","updated":"2020-09-27T08:14:41.565Z","comments":true,"path":"2020/09/27/【JDBC】JDBC概述/","link":"","permalink":"https://letere-gzj.github.io/2020/09/27/%E3%80%90JDBC%E3%80%91JDBC%E6%A6%82%E8%BF%B0/","excerpt":"JDBC的简单介绍","text":"JDBC的简单介绍 一、数据的持久化 把数据保存在课掉电式存储设备中以供之后使用 数据持久化意味着将内存中的数据保存在硬盘上 持久化应用是将内存找那个的数据存储在关系型数据库中，当然也可以存储在磁盘文件、xml数据文件中 二、Java中的数据存储技术 （1）JDBC直接访问数据库 （2）JDO(Java Data Object)技术 （3）第三方O/R工具，如Hibernate, Mybatis等 注意： JDBC是Java访问数据库的基石，JDO，Hibernate，Mybatis等实时更好封装了JDBC 三、JDBC体系结构 简略图 详细图 四、JDBC编写过程","categories":[{"name":"JDBC技术","slug":"JDBC技术","permalink":"https://letere-gzj.github.io/categories/JDBC%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"【Java基础】Java8的其他新特性","slug":"【Java基础】Java8的其他新特性","date":"2020-09-25T03:12:12.000Z","updated":"2020-09-27T03:14:38.757Z","comments":true,"path":"2020/09/25/【Java基础】Java8的其他新特性/","link":"","permalink":"https://letere-gzj.github.io/2020/09/25/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91Java8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"Java基础学习收尾，了解JDK版本的新特性","text":"Java基础学习收尾，了解JDK版本的新特性 一、Lambda表达式1.1 使用举例1234567891011121314151617181920212223242526272829303132333435@Testpublic void test()&#123; //匿名实现类对象 Runnable r1 = new Runnable()&#123; @Override public void run() &#123; System.out.println(&quot;我爱广州！&quot;); &#125; &#125;; r1.run(); //lambda方法 Runnable r2 = () -&gt; System.out.println(&quot;我爱广州！&quot;); r2.run();&#125;@Testpublic void test2()&#123; //匿名实现类对象 Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1, o2); &#125; &#125;; System.out.println(com1.compare(12, 21)); //lambda表达式 Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2); System.out.println(com2.compare(31, 12)); //方法引用 Comparator&lt;Integer&gt; com3 = Integer :: compare; System.out.println(com3.compare(31, 12));&#125; 1.2 Lambda表达式使用 1.Lambda格式： Lambda形参列表 -&gt; Lambda体 “-&gt;”：lambda操作符 或 箭头操作符 -&gt;的左边：Lamdba形参列表（泛型可省略数据类型）（接口中的抽象方法的形参列表） -&gt;的右边：Lambda体（重写的抽象方法的方法体） 2.Lambda表达式的本质： 作为函数式接口的实例 函数式接口：只声明了一个抽象方法，此接口就称为函数式接口 3.Lambda表达式使用： （1）无参，无返回值：123Runnable r1 = () -&gt; &#123; System.out.println(&quot;无参，无返回值写法&quot;);&#125;; （2）有参，无返回值 123Consumer&lt;String&gt; con = (String str) -&gt; &#123; System.out.println(str);&#125;; （3）参数有泛型可省略数据类型；参数只有一个可省略&quot;()&quot;；执行表达式只有一个可省略&quot;&#123;&#125;&quot;1Runnable r1 = () -&gt; System.out.println(&quot;我爱广州！&quot;); （4）有参，有多条执行语句，且有返回值：12345Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2);&#125;; （5）执行语句只有一个，且是return语句，可把&quot;&#123;&#125;&quot;和&quot;return&quot;省略1Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; o1.compareTo(o2); 二、函数式接口2.1 定义和种类 函数式接口：只声明了一个抽象方法的接口 函数式接口 参数类型 返回类型 用途 Consumer&lt;T&gt; T void 对类型为T的对象应用操作，包含的方法：void accept(T t) Suppiler&lt;T&gt; 无 T 返回类型为T的对象，包含方法为：T get() Fuction&lt;T, R&gt; T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t) Predicate&lt;T&gt; T boolean 确定类型为T的对象是否满足某约束，并返回boolean值，包含方法：boolean test(T t) BiFunction&lt;T, U, R&gt; T, U R 对类型为T, U参数应用操作，返回R类型的结果。包含方法为：R apply(T t, U u) 2.2 使用举例1234567891011121314151617181920212223242526272829303132333435363738@Testpublic void test1()&#123; List&lt;String&gt; list = Arrays.asList(&quot;北京&quot;, &quot;南京&quot;, &quot;天津&quot;, &quot;东京&quot;, &quot;西京&quot;, &quot;普京&quot;); //匿名实现类方法 List&lt;String&gt; list1 = filterString(list, new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) &#123; return s.contains(&quot;京&quot;); &#125; &#125;); for (String s : list1)&#123; System.out.println(s); &#125; //函数式接口 + Lambda表达式 List&lt;String&gt; list2 = filterString(list, s -&gt; s.contains(&quot;京&quot;)); for (String s : list2)&#123; System.out.println(s); &#125;&#125;//根据给定的规则，过滤集合中的字符串。此规则有Predicate的方法决定public List&lt;String&gt; filterString(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; ArrayList&lt;String&gt; filterList = new ArrayList(); for (String s : list)&#123; if (pre.test(s))&#123; filterList.add(s); &#125; &#125; return filterList;&#125; 三、引用3.1 方法引用 1.当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！ 2.方法引用可以看做是Lambda表达式深层次的表达。 3.使用格式：类(对象) :: 方法名 4.使用情况： （1）对象 :: 非静态方法1234567891011121314//情况一： 对象 :: 实例方法//Consumer中的void accpect(T t)//PrintStream中的void println(T t)@Testpublic void test1()&#123; //Lamvda表达式 Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str); con1.accept(&quot;Lambda表达式&quot;); //方法引用 PrintStream ps = System.out; Consumer&lt;String&gt; con2 = ps :: println; con2.accept(&quot;方法引用&quot;);&#125; （2）类 :: 静态方法12345678910111213//情况二：类 :: 静态方法//Comparator中的int compare(T t1, T t2)//Integer中的int compare(T t1, T t2)@Testpublic void test2()&#123; //Lambda表达式 Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2); System.out.println(com1.compare(12, 43)); //方法引用 Comparator&lt;Integer&gt; com2 = Integer :: compare; System.out.println(com2.compare(23, 21));&#125; （3）类 :: 非静态方法1234567891011121314//情况三：类 :: 实例方法（有难度）//Comparator的int compare(T t1, T t2);//String中的int t1.compare(t2);@Testpublic void test3()&#123; //Lambda表达式 Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2); System.out.println(com1.compare(&quot;abc&quot;, &quot;abd&quot;)); //方法引用 Comparator&lt;String&gt; com2 = String :: compareTo; System.out.println(com1.compare(&quot;abc&quot;, &quot;abd&quot;)); //第一个方法的参数，作为第二方法对象的进行调用&#125; 5.方法引用使用的要求：要求接口中的 抽象方法的形参列表和返回值类型 与 方法引用的形参列表和返回值类型相同 3.2 构造器引用 1.和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致 2.抽象方法的返回值类型即为构造器所属的类的类型 123456789101112131415161718192021class Person&#123; private String name; private int age; public Person()&#123;&#125;; public Person(String name)&#123; this.name = name; &#125; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 3.使用情况 （1）空参构造器123456789101112//Supplier中的T get()//Person的空参构造器：Employee()@Testpublic void test1()&#123; //Lambda表达式 Supplier&lt;Person&gt; sup1 = () -&gt; new Person(); System.out.println(sup1.get()); //构造器引用 Supplier&lt;Person&gt; sup2 = Person :: new;//理解为：Person类的new构造器器 System.out.println(sup2.get());&#125; （2）一个参数构造器1234567891011//带一个参数的构造器@Testpublic void test2()&#123; //Lambda表达式 Function&lt;String, Person&gt; func1 = name -&gt; new Person(name); System.out.println(func1.apply(&quot;Lambda表达式&quot;)); //构造器引用 Function&lt;String, Person&gt; func2 = Person :: new; System.out.println(func2.apply(&quot;构造器引用&quot;));&#125; （3）两个参数构造器1234567891011//带两个参数的构造器@Testpublic void test3()&#123; //Lambda表达式 BiFunction&lt;String, Integer, Person&gt; func1 = (name, age) -&gt; new Person(name, age); System.out.println(func1.apply(&quot;Lambda表达式&quot;, 1)); //构造器引用 BiFunction&lt;String, Integer, Person&gt; func2 = Person :: new; System.out.println(func2.apply(&quot;构造器引用&quot;, 2));&#125; 3.3 数组引用 可以把数组理解为特殊的类，则使用方法和构造器引用没有区别 123456789101112//Lambda引用//Function中的R apply(T t)@Testpublic void test1()&#123; //Lambda表达式 Function&lt;Integer, String[]&gt; func1 = length -&gt; new String[length]; System.out.println(func1.apply(5).length); //数组引用 Function&lt;Integer, String[]&gt; func2 = String[] :: new; System.out.println(func2.apply(5).length);&#125; 四、Stream API4.1 介绍 使用Stream API 对集合数据进行操作，就类似于使用SQL语句对数据库查询 使用理由：项目中多数数据源来自于MySQL，Oracle等。但现在数据源可以更多了，有MongDB，Radisson等，而这些NoSQL的数据就要需要Java层面去处理 与集合的区别： （1）Stream关注的是对数据的运算，与CPU打交道 （2）集合关注的是数据的存储，与内存打交道 （3）集合讲的是数据，Stream讲的是计算！ 注意： （1）Stream自己不会存储元素 （2）Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream （3）Stream操作时延迟执行的。这意味着他们会等到需要结构的时候才执行 Stream操作：创建Stream -&gt; 中间操作 -&gt; 终止操作（终端操作） 说明： （1）一个中间操作链，对数据源的数据进行处理 （2）一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 4.2 创建Stream 提供一个集合 12345678910111213class CollectionTest&#123; private static String[] str = new String[]&#123;&quot;马云&quot;, &quot;马化腾&quot;, &quot;黄旭东&quot;, &quot;咕料&quot;, &quot;C酱&quot;,&quot;C酱&quot;, &quot;C酱&quot;, &quot;C酱&quot;&#125;; public CollectionTest()&#123;&#125; public static String[] getArray()&#123; return str; &#125; public static List&lt;String&gt; getStringList()&#123; return Arrays.asList(str); &#125;&#125; 方法一：通过集合进行创建 1234567//(1)通过集合进行创建@Testpublic void test()&#123; List&lt;String&gt; list = CollectionTest.getStringList(); Stream&lt;String&gt; stream = list.stream();//顺序流 Stream&lt;String&gt; parallelStream = list.parallelStream();//并行流&#125; 方法二：通过数组进行创建 12345@Testpublic void test2()&#123; String[] array = CollectionTest.getArray(); Stream&lt;String&gt; stream = Arrays.stream(array);//类型通过泛型体现&#125; 方法三：通过Stream的of() public static&lt;T&gt; Stream&lt;T&gt; of(T... values) 1234@Testpublic void test3()&#123; Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8);&#125; 方法四：创建无限流（用得少） public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) 12345678910@Testpublic void test4()&#123; //迭代 //遍历前10个偶数 Stream.iterate(0, t -&gt; t+2).limit(10).forEach(System.out :: println); //生成 //生成10个随机数 Stream.generate(Math::random).limit(10).forEach(System.out :: println);&#125; 4.3 中间操作 （1）筛选和切片 方法 功能 filter(Predicate p) 接受Lambda，从流中排序某些元素 distinct() 筛选，通过流锁生成的hashCode和equals()去除重复元素 limit(Long maxSize) 截断点，使其元素不超过给定的数量 skip(long n) 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补 123456789101112131415161718192021//（1）筛选和切片@Testpublic void test1()&#123; List&lt;String&gt; list = CollectionTest.getStringList(); //查询，字符串长度为3的字符 list.stream().filter(s -&gt; s.length() == 3).forEach(System.out :: println); //forEach为终止操作，遍历流中的每个元素，并进行()内的操作 System.out.println(&quot;*******************&quot;); //截断流，截取前3个数据 list.stream().limit(3).forEach(System.out :: println); System.out.println(&quot;*******************&quot;); //跳过元素：跳过前3个数据，与截断形成互补 list.stream().skip(3).forEach(System.out :: println); System.out.println(&quot;*******************&quot;); //去除重复 list.stream().distinct().forEach(System.out :: println);&#125; （2）映射 方法 功能 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新元素 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream mapToint(TointFunction f) 接收一个函数作为参数，该函数会别应用到每个元素上，产生一个新的intStream mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会应用到每个元素上，产生一个新的LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值都缓存另一个流，然后把所有流连成一个流 12345678910111213141516171819202122232425262728//将字符创中的多个字符构成结合转换成对应的Stream的实例public static Stream&lt;Character&gt; fromStringToStream(String str)&#123; ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character c : str.toCharArray())&#123; list.add(c); &#125; return list.stream();&#125;//（2）映射@Testpublic void test2()&#123; //map List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;); list.stream().map(s -&gt; s.toUpperCase()).forEach(System.out :: println); System.out.println(&quot;*******************&quot;); //map操作：类似于在 集合.add(集合) --&gt; [1, 2, 3, [4, 5, 6]] Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream().map(s -&gt; fromStringToStream(s)); stream.forEach(s -&gt; &#123; s.forEach(System.out :: println); &#125;); System.out.println(&quot;*******************&quot;); //flatMap操作：类似于在 集合.addAll(集合) --&gt; [1, 2, 3, 4, 5, 6] Stream&lt;Character&gt; stream1 = list.stream().flatMap(s -&gt; fromStringToStream(s)); stream1.forEach(System.out :: println);&#125; （3）排序 方法 功能 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序排序 12345678910111213//（3）排序@Testpublic void test3()&#123; //sorted：自然排序 List&lt;Integer&gt; list = Arrays.asList(12, 13, 21, -9, 0, 100, 6); Stream&lt;Integer&gt; sorted = list.stream().sorted(); sorted.forEach(s -&gt; System.out.print(s + &quot;\\t&quot;)); System.out.println(&quot;\\n*************************&quot;); //sorted(Comparator com)：定制排序 Stream&lt;Integer&gt; sorted2 = list.stream().sorted((o1, o2) -&gt; -Integer.compare(o1, o2)); sorted2.forEach(s -&gt; System.out.print(s + &quot;\\t&quot;));&#125; 4.4 终止操作 （1）匹配与查找 方法 功能 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中的最大值 min(Comparator c) 返回流中的最小值 forEach(Consumer c) 内部迭代（使用Collection接口需要用户去做迭代，称为外部迭代。相反，StreamAPI使用内部迭代–它帮你把迭代做了） 1234567891011121314151617181920212223242526272829303132333435363738@Testpublic void test()&#123; //allMatch(Predicate p) ： 检查是否匹配所有元素 List&lt;String&gt; list = CollectionTest.getStringList(); boolean b = list.stream().allMatch(s -&gt; s.length() == 3);//是否每个人的名字长度都为3 System.out.println(b + &quot;\\n**********&quot;); //anyMatch(Predicate p) ： 检查是否至少匹配一个元素 boolean b1 = list.stream().anyMatch(s -&gt; s.length() == 3);//是否存在一个名字长度为3的 System.out.println(b1 + &quot;\\n**********&quot;); //noneMatch(Predicate p) ： 检查是否没有匹配所有元素 boolean b3 = list.stream().noneMatch(s -&gt; s.contains(&quot;酱&quot;));//检查是否没有名字含有“酱”的人 System.out.println(b3 + &quot;\\n**********&quot;); //findFirst() ： 返回第一个元素 Optional&lt;String&gt; first = list.stream().findFirst();//返回第一个元素（Optional类） System.out.println(first + &quot;\\n**********&quot;); //findAny() ： 返回当前流中的任意元素 Optional&lt;String&gt; any = list.parallelStream().findAny();//注意使用的并行流 System.out.println(any + &quot;\\n**********&quot;); //count() ： 返回流中元素总数 long count = list.stream().filter(s -&gt; s.length() == 3).count();//返回名字长度为3的个数 System.out.println(count + &quot;\\n**********&quot;); //max(Comparator c) ： 返回流中的最大值 Optional&lt;String&gt; max = list.stream().max(String::compareTo); System.out.println(max + &quot;\\n**********&quot;); //min(Comparator c) ： 返回流中的最小值 Optional&lt;String&gt; min = list.stream().min((String::compareTo)); System.out.println(min + &quot;\\n***********&quot;); //forEach(Consumer c) : 内部迭代 //前面已经演示了&#125; （2）归约 方法 功能 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回T reduce(BinaryOperator b) 可以将流中元素返回结合起来，得到一个值。返回Optional&lt;T&gt; 1234567891011121314@Testpublic void test2()&#123; //reduce(T iden, BinaryOperator b) //求总和 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer reduce = list.stream().reduce(0, Integer::sum); System.out.println(reduce);//55 Integer reduce1 = list.stream().reduce(0, (a, b) -&gt; a + b); System.out.println(reduce1);//55 //reduce(BinaryOperator b) Optional&lt;Integer&gt; reduce2 = list.stream().reduce((a, b) -&gt; a + b); System.out.println(reduce2);&#125; （3）收集 方法 功能 collect(Collector c) 将流转换成其他形式。接受一个Collector接口的实现，用于给Stream中元素做汇总的方法 Collector接口中方法的实现决定了如何对流执行收集的操作（如收集到List、Set、Map），另外，Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表: 方法 返回参数 功能 toList List&lt;T&gt; 把流中元素收集到List中 toSet Set&lt;T&gt; 把流中元素收集到Set中 toCollection Collection&lt;T&gt; 把流中的元素收集到创建的集合中 1234567//收集@Testpublic void test3()&#123; List&lt;String&gt; list = CollectionTest.getStringList(); java.util.List&lt;String&gt; stringList = list.stream().filter(s -&gt; s.length() == 3).collect(Collectors.toList()); System.out.println(stringList);&#125; 五、Optional类5.1 介绍 Optional&lt;T&gt;类是一个容器类，它可以保存类型T的值，代表之歌值存在。或仅仅保存null，表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好表达这个概念。并且可以避免空指针异常。 5.2 方法 （1）创建Optional类对象 方法 功能 Optional.of(T t) 创建一个Optional实例，t必须非空 Optional.empty() 创建一个空的Optional实例 Optional.ofNullable(T t) t可以为null （2）获取Optional容器中是否包含对象 方法 功能 boolean isPresent() 判断是否包含对象 void ifPresent(Consumer&lt;? super T&gt; consumer) 如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它 （3）获取Optional容器的对象 方法 功能 T get() 如果调用对象包含值，返回该值，否则抛异常 T orElse(T other) 如果有值则将其返回，否则返回指定的other对象 T orElseGet(Supplier&lt;? extends T&gt; other) 如果有值则将其返回，否则返回有Supplier接口实现提供的对象 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果有值则将其返回，否则抛出有Supplier皆苦实现提供的异常","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】反射","slug":"【Java基础】反射","date":"2020-09-22T13:19:24.000Z","updated":"2020-09-24T07:11:06.622Z","comments":true,"path":"2020/09/22/【Java基础】反射/","link":"","permalink":"https://letere-gzj.github.io/2020/09/22/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%8F%8D%E5%B0%84/","excerpt":"学习反射的学习笔记","text":"学习反射的学习笔记 一、Java反射机制概述1.1 反射概述 Reflection(反射)是被视为动态语言的关键。反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并直接操作任意对象的内部属性及方法 加载完类之后，在堆内存的方法去中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构 补充： （1）动态语言：运行时可以改变其结构的语言 （2）静态语言：运行时结构不可变的语言就是静态语言 1.2 实例理解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class ReflectionTest &#123; //反射前，对Person类的操作 @Test public void test1()&#123; //1.创建Person类的对象 Person p1 = new Person(&quot;Tom&quot;, 12); //2.调用其内部属性和方法 p1.toString(); p1.show(); //在Person类外部，不能通过Person类的对象调用其内部私有结构 //比如showNation()，私有构造器 &#125; //反射之后，对于Person的操作 @Test public void test2() throws Exception &#123; Class clazz = Person.class; //1.通过反射，创建Person类的对象 Constructor cons = clazz.getConstructor(String.class, int.class); Object obj = cons.newInstance(&quot;Tom&quot;, 12); Person p = (Person)obj; System.out.println(p.toString()); //2.通过反射，调用对象指定的属性、方法 Field age = clazz.getDeclaredField(&quot;age&quot;);//私有属性 age.set(p, 10); System.out.println(p.toString()); Method show = clazz.getDeclaredMethod(&quot;show&quot;); show.invoke(p); //************************************************************ //通过反射，可以调用Person类私有结构。比如：私有的构造器、方法、属性 //调用私有构造器 Constructor cons1 = clazz.getDeclaredConstructor(String.class); cons1.setAccessible(true); Person p1 = (Person)cons1.newInstance(&quot;Jerry&quot;); System.out.println(p1); //调用私有属性 Field name = clazz.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(p1, &quot;frankile&quot;); System.out.println(p1); //调用私有方法 Method showNation = clazz.getDeclaredMethod(&quot;showNation&quot;, String.class); showNation.setAccessible(true); showNation.invoke(p1, &quot;中国&quot;); &#125;&#125;class Person&#123; private String name; public int age; private Person(String name)&#123;//用于体现反射作用，私有构造器 this.name = name; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public void show()&#123; System.out.println(&quot;我是一个人&quot;); &#125; private String showNation(String nation)&#123;//用于体现反射 System.out.println(&quot;我的国籍是&quot; + nation); return nation; &#125;&#125; 疑问1：通过直接new的方式或反射都可以调用公共的结构，开发中到底用哪个？ 建议：在建直接new的方法是 运用到代码动态性才使用比较好 疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术 不矛盾（封装性，私有不能用；反射，还是能使用私有） 封装性只是建议如何使用，反射是能不能使用，是两码事 二、理解Class类并获取Class实例2.1 类的加载过程 （1）类的加载过程： 程序警经过javac.exe命令以后，会生成一个或多个字节码文件（.class结尾），然后使用java.exe命令对某个字节码文件进行解释运行。相当于对某个字节码文件加载到内存中。此过程就称为类的加载。加载内存中的类，我们就称为运行时类。此运行时类，就作为Class的一个实例。 （相当于把编译成功的xxx.class直接调入到内存中） 万事万物皆对象(类本身也是对象) （2）换句话说，Class的实例就对应着一个运行时类 2.2 Class类的四种实例化方式12345678910111213141516171819202122232425262728 @Testpublic void test1() throws ClassNotFoundException &#123; //方式一：调用运行时类的属性：xxx.class（编译时已经写死，体现不出动态性） Class&lt;Person&gt; clazz1 = Person.class; System.out.println(clazz1); //方式二：通过运行时类的对象 Person p = new Person(); Class clazz2 = p.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法 forName(String classPath)//需要异常处理，防止文件寻找不了 //（在运行时才知道是否出错，更能体现动态性） Class clazz3 = Class.forName(&quot;ClassUnderstand.Person&quot;); System.out.println(clazz3); System.out.println(clazz1 == clazz2);//true System.out.println(clazz1 == clazz3);//true System.out.println(clazz2 == clazz3);//true //加载到内存中的运行类，会缓存一定的时间，在此事件之类，我们可以通过不同的方式类获取此运行时类 //方式四：使用类的加载器：ClassLoader（了解，使用频率不高） ClassLoader classLoader = Instantiation.class.getClassLoader(); Class clazz4 = classLoader.loadClass(&quot;ClassUnderstand.Person&quot;); System.out.println(clazz4); System.out.println(clazz4 == clazz1);//true&#125; 2.3 有Class对象的类型 （1）外部类、成员（成员内部类，静态内部类），局部内部类，匿名内部类 （2）interface：接口 — Comparable.class （3）[]：数组 — int[].class （4）enum：枚举 — ElementType.class （5）annotation：注解@interface — Override.class （6）primitive type：基本数据类型 — int.class （7）void — void.class 1234567注意：int[] a = new int[10];int[] b = new int[100];Class clazz1 = a.getClass();Class clazz2 = b.getClass();System.out.println(clazz1 == clazz2); // true//只要数组的元素类型与围堵一样，就是同一个Class 三、类的加载和ClassLoader的理解3.1 类的加载过程（了解） 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化 类的加载（Load） –&gt; 类的连接（Link） –&gt; 类的初始化（Initialize） 类的加载：将类的class文件读入内存，并为之创建一个java.lang.Class对象。 类的链接：将类的二进制数据合并到JRE中 类的初始化：JVM负责对类进行初始化 3.2 类的加载器 （1）引导类加载器：用C++编写的，是JVM自带的类的加载器，负责Java平台核心库。用来装载核心类库。该加载无法直接获取。（例：String） （2）扩展类加载器：扶着“jre/lib/ex”目录下的jar包或 “—D java.exit.dirs” 指定目录下的jar包装入工作库 （3）系统类加载器：负责java-classpath 或 -D java.class.path 所指示的目录下类与jar包装入工作，是最常用的类加载器 12345678910111213141516代码举例理解：@Testpublic void classLoadTest()&#123; //对于自定义类，使用系统类加载器进行加载 ClassLoader classLoader = LoadingProcess.class.getClassLoader(); System.out.println(classLoader); //jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d(系统加载器) ClassLoader parent = classLoader.getParent(); System.out.println(parent); //jdk.internal.loader.ClassLoaders$PlatformClassLoader@23223dd8（扩展加载器） ClassLoader parent1 = parent.getParent(); System.out.println(parent1); //null（引导类加载器无法获取）&#125; 四、创建运行时类的对象12345678@Testpublic void test() throws Exception &#123; Class&lt;Person&gt; clazz = Person.class; //Person obj = newInstance(); 方法过时(since = &quot;9&quot;) Person obj = clazz.getConstructor().newInstance(); //创建对应的运行时磊的对象，调用空参、非私有构造器 System.out.println(obj);&#125; 默认调用的是类的空参构造器，需要给类提供。 五、获取运行时类的对象5.1 获取当前类的属性123456789101112Class clazz = Person.class;Field[] fields = clazz.getFields();//能够获取当前运行时类，及其父类所有public权限的属性Field[] declaredFields = clazz.getDeclaredFields();//获取当前运行时类中所有声明的属性（但不包含父类的属性）Filed field = clazz.getField(String name);//获取指定名称的属性（仅限于public权限）Filed declaredField = clazz.getDeclaredFiled(String name);//获取指定名称的属性（当前运行类全部属性） 5.2 获取当前类的方法1234567891011Method[] methods = clazz.getMethods();//获取当前运行时类，及其父类所有pulic方法Method[] declaredMethods = clazz.getDeclaredMethods();//获取当前运行时类中所有方法（不包括父类）Method method =clazz.getMethod(String name, Class[] parameterTypes);//获取当前运行类指定的方法名，参数类型的public方法Method declaredMethod = clazz.getDeclaredMethod(String name, Class[] parameterTypes);//获取当前运行时类指定的方法名，参数类型的方法（不受限于修饰符） 5.3 获取当前类的构造器1234567891011Constructor[] constructor = clazz.getConstructors();//获取当前运行时类被声明为public的构造器Constructor[] declaredConstructors = clazz.getDeclaredConstructors();//获取当前运行类中所有的构造器Constructor constructor = clazz.getConstructor(Class[] parameterTypes);//获取指定的构造器（仅限于public）Constructor declaredConstructor = clazz.getDeclaredConstructor(Class[] parameterTypes);//获取指定的构造器（不受限于修饰符） 5.4 获取当前类的父类，接口，包123456789101112131415Class superclass = clazz.getSuperclass();//获取当前运行类的父类Type genericSuperclass = clazz.getGenericSuperclass();//获取当前运行类带泛型的父类ParameterizedType paramtype = (ParameterizedType)genericSuperclass;Type[] actualTypeArguments = paramtype.getActualTypeArguments();//获取泛型类型Class[] interfaces = clazz.getInterfaces();//获取运行时类实现的接口（不含父类）Package package = clazz.getPackage()；//获取当前运行类所在的包 5.5 获取上面内容的参数/属性1234567891011121314151617public int getModifiers();//获取权限修饰符，0：缺省， 1：public， 2：privatepublic Class&lt;?&gt; getType()；//获取数据类型public String getName();//获取变量名，方法名...public Annotation[] getAnnotations()；//获取注解public Class&lt;?&gt; getReturnType()；//获取返回值类型public Class&lt;?&gt;[] getParameterTypes()；//获取形参列表 六、调用运行时类的指定结构6.1 调用属性12345678910111213141516171819202122@Testpublic void FiledTest() throws Exception&#123; Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.getConstructor().newInstance(); //获取指定的数据 Field id = clazz.getField(&quot;id&quot;);//只能获取类中属性的public //设置当前的值 set()：[参数1]指明设置那个对象的属性 [参数2]将次属性值设置为多少 id.set(p, 1001); //获取当前属性值get() System.out.println(id.get(p)); //--------------------------上面方法不常用-------------------------- Field age = clazz.getDeclaredField(&quot;age&quot;);//获取指定变量名的属性 age.setAccessible(true);//保证当前属性可访问（非public需要） age.set(p, 12); System.out.println(age.get(p));&#125; 6.2 调用方法12345678910111213141516171819@Testpublic void MethodTest() throws Exception&#123; Class clazz = Person.class; Person p = (Person) clazz.getConstructor().newInstance(); //getDeclaredMethod():参数1：指明获取的方法名 参数2：指明获取方法的参数列表 Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class); show.setAccessible(true);//保证当前方法可访问 show.invoke(p, &quot;中国&quot;);//invoke()：调用方法，参数1--对象，参数2--形参列表 Object nation = show.invoke(p, &quot;日本&quot;);//invoke()方法有返回值，返回值为当前调用方法的返回值 System.out.println(nation); //**********************如何调用静态方法************************ Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;); showDesc.setAccessible(true); Object invoke = showDesc.invoke(Person.class); System.out.println(invoke);//调用运行时类的方法没有返回值时，返回null&#125; 6.3 调用构造器12345678910111213@Testpublic void ConstructorTest() throws Exception&#123; Class clazz = Person.class; //getDeclaredConstructor()：参数--指明构造器的参数列表 Constructor constructor = clazz.getDeclaredConstructor(String.class); //设置构造器可访问 constructor.setAccessible(true); //利用构造器创建对象 Person p = (Person) constructor.newInstance(&quot;Tom&quot;); System.out.println(p);&#125; 七、动态代理（了解） 使用Proxy 和 InvocationHander创建动态代理 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)：直接创建一个动态代理对象，该对象实现类实现了interfaces指定的系列接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class proxyTest &#123; public static void main(String[] args) &#123; SuperMan superMan = new SuperMan(); Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);//创建代理类对象 //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(&quot;北京烤鸭！&quot;); &#125;&#125;interface Human&#123; String getBelief(); void eat(String food);&#125;class SuperMan implements Human&#123; @Override public String getBelief() &#123; return &quot;I believe I can fly!&quot;; &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125;&#125;class ProxyFactory&#123; //调用此方法，返回一个代理类的对象 public static Object getProxyInstance(Object obj)&#123; MyInvocationHander handler = new MyInvocationHander(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); &#125;&#125;class MyInvocationHander implements InvocationHandler &#123; private Object obj;//需要使用被代理类的对象进行赋值 public void bind (Object obj)&#123; this.obj = obj; &#125; //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法，invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method：即为地阿里类对象调用的方法，此方法也作为了被代理对象要调用的方法 //obj：被代理类的对象 Object returnValue = method.invoke(obj, args); return returnValue; &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】网络编程","slug":"【Java基础】网络编程","date":"2020-09-21T06:04:42.000Z","updated":"2020-09-21T07:31:49.168Z","comments":true,"path":"2020/09/21/【Java基础】网络编程/","link":"","permalink":"https://letere-gzj.github.io/2020/09/21/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"关于网络编程的学习笔记（注意：只是简单介绍网络编程，真正深入学习要去学JavaWeb）","text":"关于网络编程的学习笔记（注意：只是简单介绍网络编程，真正深入学习要去学JavaWeb） 一、网络编程概述1.1 定义 网络编程目的： 直接或间接地接通网络协议与其他计算机实现数据交换，进行通讯 网络编程中的两个主要问题： ·如何转且定位网络上一台或多台主机：定位主机上特定的应用 找到主机后如何可靠高效地进行数据传输 1.2 网络通信要素 （1）通信双方地址 ip 端口号 （2）一定的规则（即：网络通信协议） TCP/IP参考模型：国际标准 应用层 — HTTP、FTP、Telnet、DNS… 传输层 — TCP、UDP… 网络层 — IP、ICMP、ARP… 物理+数据链路层 — Link 1.3 IP地址和端口号 IP地址：InetAddress类 定义：唯一标识Internet上的计算机 分类：IPV4 、IPV6 分类2：公网地址（万维网地址）、私网地址（局域网地址） 域名：类似 www.baidu.com www.mi.com 域名使用方法：域名 —&gt; DNS(解析域名) —&gt; IP地址 —&gt; 访问 本地地址：loaclhost — 127.0.0.1 端口号：标识正在计算机上运行的进程 分类： 公认端口 注册端口 动态/私有端口 端口号 和 IP地址 的组合得出一个网络套接字：Socket 1.4 网络通信协议 分类：TCP 、 UDP TCP： （1）要先建立TCP传输数据通道 （2）采用“三次握手”方式，点对点通信，可靠的 （3）连接中课传输大量数据 （4）传输完毕需要关闭连接，效率低 （5）四次挥手关闭连接 UDP： （1）将数据、目的、源封装为包 （2）每个数据大小限制在64k内 （3）发送不管对方是否准备好，接受发收到也不确认，故不可靠 （4）可以广播发送 （5）发送数据结束时无需释放资源，开销小，速度快 1.5 InetAddress类 InetAddress对象表示一个主机的位置，类似于IO流中的File类 实例化： （1）getByName(String host)：设置IP地址主机 （2）getLocalHost()：本地主机 常用方法： （1）getHostName():获取主机域名 （2）getHostAddress()：获取主机IP地址 二、TCP网络编程 实现TCP网络编程，需要用到Socket类、和ServerSocket类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//客户端：放送照片@Testpublic void client() throws IOException &#123; //1.访问服务器地址 Socket socket = new Socket(&quot;127.0.0.1&quot;, 8899); //2.创建输入输出流 OutputStream os = socket.getOutputStream(); FileInputStream fis = new FileInputStream(&quot;佩可莉姆.png&quot;); //3.读取本地图片数据，并向服务器发送 byte[] bbuf = new byte[1024]; int len; while((len = fis.read(bbuf)) != -1)&#123; os.write(bbuf, 0, len); &#125; socket.shutdownOutput();//关闭数据的输出 //read方法会使线程阻塞，不知道什么时候结束，需要手动关闭 //------------------------------------------ //4.接受服务器端返回的数据，显示到控制台上 InputStream is = socket.getInputStream(); InputStreamReader isr = new InputStreamReader(is); char[] cbuf = new char[5]; while((len = isr.read(cbuf)) != -1)&#123; System.out.print(new String(cbuf, 0, len)); &#125; //5.资源关闭 isr.close(); os.close(); socket.close(); fis.close(); //6.省略了try-catch-finally处理&#125;//服务器：接受照片并保存到本地@Testpublic void server() throws IOException &#123; //1.创建服务器 ServerSocket serverSocket = new ServerSocket(8899); //2.等待接受客户端的数据 Socket accept = serverSocket.accept(); //3.收到客户端的数据后，创建相应的输入输出流 InputStream is = accept.getInputStream(); FileOutputStream fos = new FileOutputStream(&quot;佩可莉姆-server.png&quot;); //4.读取接受的数据，并写入本地文件 byte[] bbuf = new byte[1024]; int len; while ((len = is.read(bbuf)) != -1) &#123; fos.write(bbuf, 0, len); &#125; //------------------------------------------- //5.向客户端进行反馈 OutputStream os = accept.getOutputStream(); os.write(&quot;照片收到啦！-- by:服务器&quot;.getBytes()); //6.资源关闭 os.close(); fos.close(); is.close(); accept.close(); serverSocket.close(); //7.省略了try-catch-finally处理&#125; 三、UDP网络编程 需要DatagramSocket类，来表示发送端/接收端 需要DatagramPacket对数据进行封装，发送，接受1234567891011121314151617181920212223242526272829303132333435//发送端@Testpublic void send() throws IOException &#123; DatagramSocket socket = new DatagramSocket(); //将发送数据的信息都封装在一个包上 byte[] data = &quot;我是UDP方式发送的数据！&quot;.getBytes(); InetAddress localHost = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data, 0, data.length, localHost, 9090); //发送数据 socket.send(packet); //关闭资源 socket.close();&#125;//接收端@Testpublic void receiver() throws IOException &#123; DatagramSocket socket = new DatagramSocket(9090); //创建一个包，来接受数据 byte[] buffer = new byte[100]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); //等待接受 socket.receive(packet); //将接受的资源打印 System.out.println(new String(packet.getData(), 0, packet.getLength())); //关闭资源 socket.close();&#125; 四、URL网络编程 URL(Uniform Resoursce Locator)：统一资源定位符 URL结构：&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表 URL实例化：URL url = new URL(String url); URL常用方法： pulic String getProtocol()：获取该URL的协议名 public String getHost()：获取该URL的主机名 public String getPort()：获取该URL的端口号 public String getPath()：获取给URL的文件路径 public String getFIle()：获取该URL的文件名 public String getQuery()：获取该URL的查询名 123456789101112131415161718192021222324252627@Testpublic void download() throws Exception &#123; //创建URL连接对象 URL url = new URL(&quot;https://i0.hdslb.com/bfs/album/6d2b77cd835f0789e8de0f23618d8b396e304aa9.jpg&quot;); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); //连接服务器 urlConnection.connect(); //创建输入、输出流 InputStream is = urlConnection.getInputStream(); FileOutputStream fos = new FileOutputStream(new File(&quot;鹿乃.jpg&quot;)); //对数据进行读写 byte[] bbuf = new byte[1024]; int len; while ((len = is.read(bbuf)) != -1)&#123; fos.write(bbuf, 0, len); &#125; //资源关闭 is.close(); fos.close(); urlConnection.disconnect(); //省略了try-catch-finally异常处理&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】IO流","slug":"【Java基础】IO流","date":"2020-09-19T02:32:43.000Z","updated":"2020-09-20T14:28:39.482Z","comments":true,"path":"2020/09/19/【Java基础】IO流/","link":"","permalink":"https://letere-gzj.github.io/2020/09/19/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91IO%E6%B5%81/","excerpt":"关于Java IO流的学习笔记","text":"关于Java IO流的学习笔记 一、File类1.1 FIle类的理解 （1）java.io.File类：文件和文件目录路径的抽象表达形式，与平台无关 （2）File功能：新建、删除、重命名文件和目录。但不能打开文件，访问内容 （3）在Java程序中表示文件/目录，必须要有一个File对象。但是File对象，不一定存在真实的本地文件/目录 （4）File对象可以作为参数传递给流的构造器 1.2 FIle类的实例化（构造器）123456789（1）File file = new File(String pathName);---文件路径作为参数// 路径：相对路径 / 绝对路径// 路径分割符：&quot;\\&quot;，由于&quot;\\&quot;也是一个转义字符，需要使用&quot;\\\\&quot;来表示路径分隔符（2）File file = new File(String parentPath, String childPath);// 在parentPath路径下，创建childPath文件/文件夹，即parentPath\\childPath（3）File file = new File(File parentFile, String childPath);// 和第二种方法一样，只不过参数改为了File对象 123456举例： File file1 = new File(&quot;hello.txt&quot;); File file2 = new File(&quot;..\\\\&quot;, &quot;FileTest&quot;); File file3 = new File(file2, &quot;hi.txt&quot;); 1.3 File类的常用方法123456public String getAbsolutePath()：获取绝对路径public String gtePath()：获取路径(根据File类实例传入的参数)public String getName()：获取名称(根据File类实例传入的参数)public String getParent()：获取上层文件目录路径。若无，返回null(根据File类实例传入的参数)public long length()：获取文件大小（即：字节数）。不能获取文件目录大小public long lastModified()：获取最后一次的修改时间，毫秒值 123只适用于文件目录：public String[] list()：获取指定目录下的所有文件或文件目录的名称数组public File[] listFile()：指定目录下的所有文件或者文件目录的File数组 12public boolean rename(File dest)：把文件重命名为指定的文件路径（即：把文件进行剪切并且重命名）//注意：被重命名的对象，必须在硬盘中存在，否则失败 1234567判断条件：public boolean isDirectory()：判断是否是文件目录public boolean isFile()：判断是否是文件public boolean exists()：判断你是否存在public boolean canRead()：判断是否可读public boolean canWrite()：判断是否可写public boolean isHidden()：判断是否隐藏 1234硬盘中创建文件 / 文件目录public boolean createNewFile()：创建文件。若文件存在，则不创建，返回false（会抛异常）public boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建了public boolean mkidrs()：创建文件目录。如果上层文件目录不存在，一并创建 123硬盘中删除文件：public boolean delete()：删除文件 / 文件夹（Java删除的文件不会出现在回收站）//注意：如果删除的是文件目录，则文件目录下不能存放任何东西，否则失败 1.4 总结 File类中涉及到关于文件后文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成 后续File类的对象常会作为参数传递到六的构造器中，指定读取或写入的“终点” 二、IO流2.1 流的分类 按操作数据单位不同：字节流(8 bit)、字符流(16 bit) 按数据流的流向不同：输入流、输出流 按流的角色不同：节点流、处理流 2.2 四个流的抽象基类 抽象基类 字节流 字符流 输入流 InputStream Reader 输出流 OutputStream Writer 后面的流都是这些了流的派生 三、文件流（常用流1）3.1 文件流种类 文件流 字节流 字符流 输入流 FileInputStream FileReader 输出流 FileOutputStream FileWriter 就在抽象基类中多加了个”File” 3.2 FileReader使用 操作步骤： 1.指明文件对象 2.提供具体的流 3.数据的读入 4.流的关闭操作 5.try-catch-finally处理异常，finally填写资源的关闭操作 1234567891011121314151617181920212223242526FileReader fr = null;//5.需要异常处理try &#123; //1.指明文件对象 File file = new File(&quot;hello.txt&quot;); //2.提供具体的流 fr = new FileReader(file); //3.数据的读入 int data; while((data = fr.read()) != -1)&#123; System.out.print((char)data); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; //4.流的关闭操作 try &#123; if (fr != null)&#123; fr.close();//close()也会出现异常，还需要在try-catch一次 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 写入数据的两种方法： （1）调用空参方法read()，返回读取的整数数据，需要强转转为字符 1234int data;while((data = fr.read()) != -1)&#123; System.out.print((char)data);&#125; （2）创建一个字符数组，调用read(char[] arr)方法，将数据读取数组里，返回一个读取长度 123456789101112char[] cbuf = new char[5];//数组长度随意int len;while ((len = fr.read(cbuf)) != -1)&#123; //方式一： for (int i = 0; i &lt; len; i++) &#123; System.out.print(cbuf[i]); &#125; //方式二： String str = new String(cbuf, 0, len); System.out.print(str);&#125; 3.3 FileWriter使用 操作步骤： 1.指明文件对象 2.提供具体的流，参数2是boolean型，true是继续文件内容往下写，false是覆盖文件内容重新写 3.数据的写入 4.流的关闭操作 5.try-catch-finally处理异常，finally填写资源的关闭操作 12345678910111213此处省略了第五步：异常处理//1.提供指定文件对象File file = new File(&quot;hello1.txt&quot;);//2提供FileWriter的对象，用于数据的写出FileWriter fw = new FileWriter(file, true);//3.写出操作fw.write(&quot;I have a dream!\\n&quot;);fw.write(&quot;You need to have a dream!\\n&quot;);//4.流资源关闭fw.close(); 读取数据的两种方法： （1）调用write(String str),进行数据写入 1fw.write(&quot;I have a dream!\\n&quot;); （2）调用write(char[] arr, int start, int end)，传入一个字符数组，写入这数组从arr[start]，到arr[end]的数据，一般配合FileReader的read(char[])来使用 12345char[] cbuf = new byte[1024];int len;while((len = fis.read(cbuf)) != -1)&#123; fos.write(cbuf, 0,len);&#125; 3.4 FileInputStream 和 FileOutputStream使用 用法与字符流的FileReader 和 FileWriter区别不大 读取的数据变成字节，所以创建数组存储时，应该使用byte[] 字节流适合用于非文本文件，例如：（.jpg, .mp3, .mp4, .ppt, .doc …） 四、缓冲流（常用流2）4.1 缓冲流分类 缓冲流 字节流 字符流 输入流 BufferedInputStream BufferedReader 输出流 BufferedOutputStream BufferedWriter 4.2 缓冲流说明 缓冲流作用：提高流的读取，写入速度 提高读写速度的原因：内部提供了一个缓冲区 缓冲流属于处理流的一种，处理流就是“套接”在已有的流的基础上 4.3 使用方法 在原来的流，套一个缓冲流。即创建一个缓冲流，用原来的流作为参数 12345678910111213141516171819202122232425以：文件的复制为例//1.创造文件对象File file = new File(&quot;original.txt&quot;);File copyFile = new File(&quot;original-copy.txt&quot;);//2.创造流//2.1创造节点流FileInputStream fis = new FileInputStream(file);FileOutputStream fos = new FileOutputStream(copyFile);//2.2创造缓冲流BufferedInputStream bis = new BufferedInputStream(fis);BufferedOutputStream bos = new BufferedOutputStream(fos);//3.读写数据byte[] bbuf = new byte[1024];int len;while((len = bis.read(bbuf)) != -1)&#123; bos.write(bbuf, 0, len);&#125;//4.关闭流//要求：先关闭外层流，再关闭内层流//但是，关闭外层流的同时，内层流也会自动关闭bos.close();bis.close(); 4.4 额外说明 缓冲流的用法和文件流的用法几乎没有差异 缓冲流的BufferedReader，提供了一个新的方法String readline()，可以读取一整行的数据，但该数据不包括换行符，需要自己添加换行符 五、转换流（常用流3）5.1 转换流分类 转换流 流 作用 输入流 InputStreamReader InputStream –&gt; Reader（解码） 输出流 OutPutStreamWriter Writer –&gt; OutputStream（编码） 5.2 转换流说明 作用：提供了字节流和字符流之间的转换 转换流也是处理流的一种，套在原有流的基础上 5.3 使用方法 方法和缓冲流一样，要套在原有的流，使字节流变成字符流，字符流变成字节流 123456789101112131415例：对文件进行重新编码FileInputStream fis = new FileInputStream(&quot;hello.txt&quot;);FileOutputStream fos = new FileOutputStream(&quot;hello-gbk.txt&quot;);InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;);OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;GBK&quot;);char[] cbuf = new char[5];int len;while((len = isr.read(cbuf)) != -1)&#123; osw.write(cbuf, 0, len);&#125;isr.close();osw.close(); 5.4 额外补充 创建转换流会有个参数2，参数2填写的是字符集 字符集种类： ASCII：美国标准信息交换码 ISO8859-1：拉丁码表。欧洲码表 GB2312：中国的中文编码表，最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号，最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所有字符 UTF-8：目前最常用的字符集，编程的编码方式，可用1-4个字节表示一个字符 六、其他流（不常用）（了解）6.1 标准输入 / 输出流 种类： System.in：标准的输出流(字节流)，默认从键盘输入 System.out：标准输出流(字节流)，默认从控制台输出 说明： 标准流本身就是一个流，不需要创建对象，可以直接使用 System类的setIn(InputStream is) / setOut(PrintStream os)，重新指定输入和输出的流 123456789101112131415161718192021使用例子： 从键盘输入字符串，要求将读到的整行字符串转变成大写输出，然后继续进行输入操作 ，直到输入&#x27;e&#x27; 或者 &quot;exit&quot;时，退出程序（非Scanner方式） 思路：System.in --&gt; 转换流 --&gt; BufferedReader的readline InputStreamReader isr = new InputStreamReader(System.in);BufferedReader br = new BufferedReader(isr);while (true) &#123; System.out.println(&quot;请输入字符串(e或exit退出)：&quot;); String data = br.readLine(); if (&quot;e&quot;.equalsIgnoreCase(data) || &quot;exit&quot;.equalsIgnoreCase(data)) &#123; System.out.println(&quot;程序结束...&quot;); break; &#125; System.out.println(data.toUpperCase());&#125;br.close(); 6.2 打印流 种类： PrintStream PrintWriter 说明： 打印流，将基本数据类型的数据格式转化为字符串输出 操作： （1）创建一个输出流 （2）PrintStream ps = new PrintStream(输出流, autoFlush:true/false)//创建一个打印流 （3）System.setOut(打印流)：修改了System.out的打印位置，从控制台打印，变成到输出流所在位置 （4）调用System.out.print() 和 System.out.println() 来使用打印流 6.3 数据流 种类： DataInputStream DataOutputStream 说明： 数据流：用于读写或写出基本数据类型的变量或字符串 用数据流写入的文件，也只能用数据流读取，其他方式读取会出现乱码。并且读取的顺序，要按照写入顺序就行读取 123456789101112131415161718192021222324252627例：演示写入以及读取@Test //写入public void testDataOutputStream() throws IOException &#123; FileOutputStream fos = new FileOutputStream(&quot;data.txt&quot;); DataOutputStream dos = new DataOutputStream(fos); dos.writeUTF(&quot;马化腾&quot;); dos.writeInt(21); dos.writeBoolean(true); dos.flush();//将内存中的数据，写入文件中 dos.close();&#125;@Test //读取public void testDataInputStream() throws IOException&#123; FileInputStream fis = new FileInputStream(&quot;data.txt&quot;); DataInputStream dis = new DataInputStream(fis); String name = dis.readUTF(); int age = dis.readInt(); boolean isMale = dis.readBoolean(); System.out.println(&quot;name = &quot; + name);// name = 马化腾 System.out.println(&quot;age = &quot; + age);// age = 21 System.out.println(&quot;isMale = &quot; + isMale); // isMale = true&#125; 七、对象流7.1 定义 作用：用于存储和读取基本数据类型数据 或 对象的处理流 方法： ObjectInputStream：（序列化）保存基本数据类型数据或对象的机制 ObjectOutputStream：（反序列化）读取基本数据类型或对象的机制 7.2 使用方法 序列化 12345678910111213141516@Testpublic void testObjectOutputStream() throws IOException&#123; //1.创建对象流 File file = new File(&quot;ObjectStream.dat&quot;); FileOutputStream fos = new FileOutputStream(file); ObjectOutputStream oos = new ObjectOutputStream(fos); //2.写入对象数据 oos.writeObject(new String(&quot;对象流测试！&quot;)); oos.flush();//刷新操作 //3.关闭资源 oos.close(); //4.省略try-catch-finally&#125; 反序列化 1234567891011121314151617@Testpublic void testObjectInputStream() throws IOException, ClassNotFoundException &#123; //1.创建对象流 File file = new File(&quot;ObjectStream.dat&quot;); FileInputStream fis = new FileInputStream(file); ObjectInputStream ois = new ObjectInputStream(fis); //2.读取数据 Object o = ois.readObject(); String str = (String)o; System.out.println(str); //3.关闭资源 ois.close(); //4.省略try-catch-finally&#125; 7.3 自定义类序列化要求 （1）实现Serializable (标识接口，不需要重写任何方法) （2）提供全局常量，标识UID public static final long serivalVersionUID = 1231231L; （3）除了当前Person类需要实现Serializeable，其类中属性，除了基本数据类型，其余属性也要实现Serializable接口 八、RandomAccessFile8.1 定义 1.RandomAccessFile直接继承与java.lang.Object类，实现了DataInput和DataOutput接口 2.RandomAccessFile即可以作为一个输入流，又可以作为一个输出流 8.2 构造器 public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) mode参数： r：以只读方式打开 rw：打开以便读取和写入 rwd：打开以便读取和写入；同步文件内容的更新 rws：打开以便读取和写入；同步文件内容和元数据的更新 8.3 使用方法 使用的方法和 FileInputStream 和 FileOutputStream区别不大 如果RandomAccessFile作为输出流，写出到的文件如果不存在，则在执行过程中自动创建，如果写出到文件存在，则对原有文件内容进行覆盖 RandomAccessFile类，额外新增的方法 public void seek(int pos) //将指针调到角标为pos的位置，可通过此方法实现从文件末尾添加 12345678910111213141516171819202122通过seek()方法，来实现插入效果@Testpublic void test2() throws Exception&#123; File file = new File(&quot;RandomAccessFile.txt&quot;); RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;); raf.seek(3); StringBuilder sb = new StringBuilder((int) file.length()); byte[] bbuf = new byte[10]; int len; while((len = raf.read(bbuf)) != -1)&#123; sb.append(new String(bbuf, 0, len)); &#125; raf.seek(3); raf.write(&quot;xyz&quot;.getBytes()); raf.write(sb.toString().getBytes()); raf.close(); //省略了try-catch-finally处理&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】泛型","slug":"【Java基础】泛型","date":"2020-09-18T11:38:53.000Z","updated":"2020-09-18T12:40:23.026Z","comments":true,"path":"2020/09/18/【Java基础】泛型/","link":"","permalink":"https://letere-gzj.github.io/2020/09/18/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E6%B3%9B%E5%9E%8B/","excerpt":"学习泛型的学习笔记","text":"学习泛型的学习笔记 一、泛型定义 泛型：用”&lt;&gt;”括住的被称为泛型 泛型类似于标签，规定了该类/方法使用哪种类型的数据，自带数据检测 二、在集合中使用泛型1234ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(11);//规定了Integer型数据，只能使用Integer数据 总结： （1）集合接口在JDK5.0时修改为带泛型的结构 （2）在实例化集合类时，可以指明具体的泛型类型 （3）指明完以后，在集合类或接口中凡是定义类或接口（比如：方法、构造器、属性等）使用泛型的位置，都指定为实例化的泛型类型。 比如：add(E e) —&gt; 实例化以后：add(Integer e) （4）注意点：泛型实例的类型必须是类，不能是基本数据类型。需要使用时，可以使用其包装类 （5）如果实例化没有指定泛型的类型，默认使用Object类型 三、自定义泛型结构3.1 定义泛型类 / 泛型接口123456789101112class Order&lt;T&gt;&#123;//定义泛型 String orderName; int orderId; T orderT;//把泛型当作一个类来使用 public Order()&#123;&#125; public Order(String orderName, int orderId, T orderT) &#123; this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125;&#125; 注意： （1）泛型类可以有多个参数，&lt;E1, E2, E3&gt; （2）泛型不同的引用不能相互赋值 （3）JDK7.0简化泛型操作：ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); （4）异常类不能声明为泛型类 （5）要用泛型声明数组：T[] arr = (T[]) new Object[10];，不能直接new，因为泛型并不是真正意义上的类 （6）类中的带泛型的方法不能声明为static （7）子类继承带泛型的父类时，若指明了泛型类型。在子类实例化时不需要指明泛型 3.2 泛型方法 定义：泛型方法，在方法中出现泛型的结构，泛型参数与类的泛型参数没有关系 123456789一、泛型做方法的参数public &lt;E&gt; List&lt;E&gt; copyArrayList(E[] arr)&#123; return null;&#125;二、泛型作为返回值public &lt;F&gt; F copy(String str)&#123; return (F)new Object();&#125; 注意： 泛型方法可以声明为static 四、泛型在继承上的体现1234567891011Object obj = null;String str = null;obj = str;//有子父类关系，自动类型转换List&lt;Object&gt; list1 = null;List&lt;String&gt; list2 = null;list1 = list2;//编译不通过，list1与list2不具备子父类关系List&lt;String&gt; list3 = null;ArrayList&lt;String&gt; list4 = null;list3 = list4; 类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;二者不具备子父类关系，二者是并列关系 类A是类B的父类，A&lt;G&gt;和B&lt;G&gt;仍然是子父类关系 五、通配符5.1 通配符使用123456List&lt;Object&gt; list1 = null;List&lt;String&gt; list2 = null;List&lt;?&gt; list = null;//通配符list = list1;list = list2; 通配符：’?’ 虽然类A是类B的父类，但是G&lt;A&gt;和G&lt;B&gt;并没有关系，二者共同的父类时：G&lt;?&gt; 5.2 有限制条件的通配符使用123456789101112131415//[Student &lt; Person &lt; Object]List&lt;? extends Person&gt; list1 = null;//用数学方式来理解，? = [-∞, +∞]，? extends Person = [-∞, Person]List&lt;? super Person&gt; list2 = null;//? super Person = [Person, +∞]List&lt;Student&gt; list3 = null;List&lt;Person&gt; list4 = null;List&lt;Object&gt; list5 = null;list1 = list3;list1 =list4;list1 = list5;//编译不通过，Student不在该区间list2 = list3;//编译不通过，Object不在该区间list2 = list4;list2 = list5;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】集合","slug":"【Java基础】集合","date":"2020-09-16T13:43:18.000Z","updated":"2020-09-18T04:02:14.261Z","comments":true,"path":"2020/09/16/【Java基础】集合/","link":"","permalink":"https://letere-gzj.github.io/2020/09/16/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E9%9B%86%E5%90%88/","excerpt":"学习集合整理的学习笔记","text":"学习集合整理的学习笔记 一、Collection（集合）1.1 集合框架的概述 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器 此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储(.txt) 2.数组在存储多个数据方面的特点： 一旦初始化以后，其长度就确定了 数组一旦定义好，其元素的类型也就确定了，我们也只能操作指定类型的数据了 3.数组在存储多个数据方面的缺点： 一旦初始化以后，其长度就不可以修改 数组中提供的方法非常有限，对于添加，删除，插入数据等操作，非常不便，同时效率不高 获取数组中实际元素的个数，数组没有现成的属性或方法可用 数组存储数据的特点：有序、可重复。对于无序，不可重复的需求，不能满足 1.2 分类 Collection接口： 单列数据，定义了一组对象的方法的集合 List： 元素有序、可重复的集合（动态数组） ArrayList、LinkedList、Vector Set： 元素无序，不可重复的集合 HashSet、LinkedHashSet、TreeSet Map接口： 双列数据，保存具有映射关系“key-value”的集合【类似python的字典】 HashMap、LinkedHashMap、TreeMap、Hashtable、Properties 1.3 Collection中定义的方法123456789101112131415161718192021222324252627282930add(Object e)：集合里添加数据size()：返回一个int型，获取集合里数据的个数addAll(Collection coll)：将一个集合的元素，全部添加到另一个集合里clear()：清空集合里的元素isEmpty()：返回一个boolean型，判断当前集合是否为空contains(Object obj)：返回一个boolean型，判断当前集合中是否包含obj注意:contains判断对象时，是调用该对象内equals方法，若此方法没重写，默认比较地址值。containsAll(Collection coll)：返回一个boolean型，判断当前集合里的数据是否全部包含了另一个集合的数据remove(Object obj)：返回一个boolean型，移除某个元素，移除成功true，否者false 注意：remove也是调用该对象的equals方法进行匹配，相同就进行移除removeAll(Collection coll)：返回一个boolean型，将一个集合里的元素从另一个集合里全部移除（差集）retainAll(Collection coll)：返回一个boolean型，保留两个集合的共同数据（交集）equals(Object obj)：返回一个boolean型，比较两个集合是否相同hashCode()：返回一个int型，计算哈希值并返回toArray()：返回一个Object[]，将一个集合转变成数组额外拓展： Arrays.asList(数组)：将一个数组变成一个集合 1.4 集合遍历 （1）迭代器 迭代器是Collocetion的其中一个方法。iterator()，返回一个迭代器对象。用于遍历数组 迭代器操作： 1.内部的方法：hasNext() 和 next() 2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前 3.内部定义了remove()，可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove() 123while(iterator.hasNext())&#123;//是否有下一个，有就true，无就false System.out.println(iterator.next());&#125; （2）增强for循环 格式： for(集合中元素的类型 局部变量 ：集合对象)，类似python的for xx in xx 内部仍然调用了迭代器 123for(Object obj : coll)&#123; System.out.println(obj);&#125; 二、List2.1 分类|—-Collection接口&emsp;&emsp;|—-List接口：存储有序的，可重复的数据&emsp;&emsp;&emsp;&emsp;|—-ArrayList：作为List接口的主要实现类（1.2出现），线程不安全，效率高；底层使用Object[] elementData存储&emsp;&emsp;&emsp;&emsp;|—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList效率高。底层使用双向链表存储&emsp;&emsp;&emsp;&emsp;|—-Vector：作为List接口的古老实现类（1.0出现），线程安全，效率低；底层使用Object[] elementData存储 2.2 ArrayList源码分析 JDK 7情况下： 123456789ArrayList list = new ArrayList();//底层创建了长度为10的Object[]数组elementDatalist.add(123);//list[0] = new Integer(123);...list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。//默认情况下扩容为原来容量的1.5倍，同时将原有数组中的数组赋值到新的数组中 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) JDK8情况下： 1234567ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;，并没有创建list.add(123);//第一次调用add()时，底层才创建长度为10的数组，并将数据添加到数组中...后续的添加和扩容操作与JDK7一样 总结：&emsp;JDK7中的ArrayList的对象创建，类似于单例模式的饿汉式&emsp;JDK8中的ArrayList的对象创建，类似于单例模式的懒汉式，延迟了数组的创建，节省内存 2.3 LinkedList源码分析12345LinkedList list = new LinkedList();//内部声明了Node类型的first和last属性，默认值为nulllist.add(213);//将213封装到Node中，创建Node对象。 123456789101112其中，Node定义为：体现了LinkedList的双向链表的说法private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 2.4 List接口中的常用方法12345678910111213141516除了Collection中的方法外： void add(int index, Obejct else)：在指定的位置中插入数组 boolean addAll(int index, Collection else)：从index位置将else集合中所有数据插入 Object get(int index)：获取index位置的数据 int indexOf(Object obj)：返回obj在集合中首次出现的位置 int lastIndexOf(Object obj)：返回obj在当前集合末次出现的位置 Object remove(int index)：移除指定index位置的元素 Object set(int index, Object ele)：设置指定index位置的元素为ele List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合 12345678910总结常用方法： 增：add(Object obj) 删：remove(int index) / remove(Object obj) 改：set(int index, Object else) 查：get(int index) 插：add(int index, Object else) 长度：size() 遍历：（1）Iterator迭代器 （2）增强for循环 （3）普通循环 三、Set3.1 分类|—-Collection接口&emsp;&emsp;|—-Set接口：单列集合，用来存储一个一个的对象&emsp;&emsp;&emsp;&emsp;|—-HashSet：作为Set接口的主要实现类；线程不安全；可以存放nll值&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|—-LinkedSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历&emsp;&emsp;&emsp;&emsp;|—-TreeSet：可以按照添加对象的指定属性，进行排序 3.2 无序、不可重复性理解 （1）无序性 （1）不等于随机性。 （2）存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值进行存储 （2）不可重复性 保证添加的元素，按照equals()判断时，不能反回true。即：相同的元素只能添加一个 （3）以HashSet为例，来了解存储过程 我们向HashSet中添加元素b，首先调用元素b所在类的hashCode()方法，计算元素b的哈希值 此哈希值通过某种算法计算出HashSet底层数组中存放位置（即：索引位置），判断数组在此位置上是否已经有元素： 如果此位置上没有其他元素，则元素b添加成功 （情况一） 如果此位置上有其他元素b(或以链表形式存在多个元素)，则比较元素a与元素b的hash值 如果hash值不相同，以链表的形式将元素b添加（情况二） 如果hash只相同，进而需要调用元素b所在类的equals()方法： equals()返回false，以链表的形式将元素b添加（情况三） equals()返回true，则元素b添加失败 注意： JDK7以链表添加数据，是将新数据放进数组，并用指针指向原数组数据； JDK8以链表添加数据，是数组里面的数据，用指针指向新添加的数据 口诀：七上八下 （4）总结 向Set中添加数据，其所在的类一定要重写hashCode() 和 equals() 重写hashCode() 和 equals() 尽可能保持一致性：相等的对象必须具有相等的散列码 HashSet底层：数组 + 链表 3.3 LinkedHashSet 说明 LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录次数据前一个数据和后一个数据。本质上和HashSet区别不大 优点：对于频繁的遍历操作，LinkedHashSet的效率比HashSet高 3.4 TreeSet （1）使用说明 向TreeSet中添加的数据，要求是相同类的对象 存储的形式类似于二叉树 访问数据是从小到大访问，需要用到Java比较器 （2）比较方法 自然排序 类实现Comparable接口，重写compareTo()方法 TreeSet判断是否存储数据是否相同，使用的是compareTo()方法，不再是equals 定制排序 创建comparator实现类对象，该实现类重写compare()方法，将此对象作为参数传入TreeSet的创建中 TreeSet判断是否存储数据是否相同，使用的是compare()方法，不再是equals 四、Map4.1 Map分类|—-Map：双列数据，存储key-value对的数据 —类似于高中函数：y=f(x)&emsp;&emsp;|—-HashMap：作为主要实现类；线程不安全，效率高；存储null的key和value；&emsp;&emsp;&emsp;&emsp;|—-LinkedHashMap：保证在遍历map元素是，可以按照添加的顺序实现遍历&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对于频繁的遍历操作，此类的执行效率高于HashMap&emsp;&emsp;|—-TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序、定制排序&emsp;&emsp;&emsp;&emsp;底层使用红黑树&emsp;&emsp;|—-Hashtable：作为古老实现类；线程安全，效率低；不能存储null的key和value；&emsp;&emsp;&emsp;&emsp;|—-Properties：常用来处理配置文件。key和value都是String类型 4.2 Map结构理解 Map中的key是无序的、不可重复的，使用Set存储所有的key —&gt; key所在的类要重写equals()和hashCode()[以hashMap为例] Map中的value：无序的。可重复的，使用Collection存储所有的value —&gt; value的所在类要重写equals() 一个键值对：key-value构成了一个Entry对象 Map中的entry：无序的，不可重复的，使用Set存储所有的entry 4.3 底层实现原理 基本与HashSet没有太大区别（以HashMap为例）： 比较key的hash值，看位置上是否有其他数据 有就再比较该位置上链表的key的hash值，看是否相同 key的hash值相同，就调用equals方法 equals()返回false，添加成功 equals()返回true，修改该key的value值—不同点 在不断添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)。默认的扩容方式：扩容到原来容量的2倍，并将原有的数据复制过来。 4.4 JDK7 和 JDK8 底层区别 1.new HashMap()：JDK7底层直接创建长度为16的数组； JDK8底层没有创建一个长度为16的数组，添加数据时再创建 2.JDK7底层数组是：Entry[]； JDK8底层数组是：Node[] 3.JDK7底层结构只有：数组+链表 JDK8底层结构：数组+链表+红黑树 当数组的某一个索引位置上的元素一链表形式存在的数组个数&gt;8，且当前数组长度&gt;64时，此时此索引位置上的所有数组改为使用红黑树 4.5 其他实现类 LinkedHashMap： 原理与LinkedHashSet无太大差异，就是在HashMap基础上，多两个指针指引数据前后顺序 TreeMap： 原理与TreeSet无太大差异，key存储的数据必须是同一对象，并提供Java比较器（自然排序，定制排序）来进行对数据的排序 Properties： 配置文件，涉及文件的读写操作（暂不细讲） （1）创建Properties对象 （2）对象.load(流)//加载流对应的文件 （3）对象.getProperty(String key)//获取对应key相应的value 注意： 配置文件里面的内容为：&quot;key=value&quot;，不要在”=”之间添加空格 4.6 常用方法Map接口定义方法 12345添加、删除、修改操作： Object put(Object key, Object value)：将指定的key-value添加到（或修改）当前map对象中 void putAll(Map m)：将m中所有key-value中存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中所有的数据 1234567元素查询操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 1234元视图操作（用于遍历）： Set KeySet()：返回所有Key构成的Set集合 Collection value()：返回所有value构成的Collection集合 Set entrySet()：返回所有Key-value对构成的集合 总结 1234567总结：常用方法 添加：Object put(Object key, Object value) 删除：Object remove(Object key) 修改：Object put(Object key, Object value) 查询：Object get(Object key) 长度：int size() 遍历：Set KeySet() / Collection value() / Set entrySet() 五、Collections工具类5.1 常用方法123456（1）排序操作： void reverse(List)：反转List中元素的顺序 void shuffle(List)：对List集合元素进行随机排序 void sort(List)：根据元素的自然顺序对指定List集合元素按升序排序 void sort(List, Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序 void swap(List, int, int)：将指定list集合中的i处元素和j处元素进行交换 12345678（2）查找、替换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素 Object min(Collection)：同理，找最小 Object min(Collection, Comparator)：同理，找最小 int frequency(Collection, Object)：返回指定集合中指定元素的出现次数 void copy(List dest, List src)：将src中的内容赋值到dest中 boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值 123（3）Collections类提供了多个synchronizedXxx()方法， 该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 例：List list1 = Collections.synchronizedList(list); 5.2 注意点 copy方法的使用： 1234错误示范： List list1 = new ArrayList(list.size()); Collections.copy(list1, list);新建的List中并没有元素，不能进行赋值 1234正确操作： List list2 = Arrays.asList(new Object[list.size()]); Collections.copy(list2, list);数组转变成集合，默认赋予null值 六、面试题 面试题：Collection 和 Collections 的区别？ Collection是集合的接口 Collections是操作Collection和Map的工具类 面试题：ArrayList、LinkedList、Vector三者的异同？ 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的，可重复的数据 异： ArrayList：作为List接口的主要实现类（1.2出现），线程不安全，效率高；底层使用Object[] elementData存储 Vector：作为List接口的古老实现类（1.0出现），线程安全，效率低；底层使用Object[] elementData存储 LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList效率高。底层使用双向链表存储 面试题：HashMap的底层实现原理？ 存储数据时，先通过获取该数据的key的hash值，通过某种算法计算在数组的位置，查看该位置是否有数据： 若无，存储成功。若有，比较该位置上链表元素的hash值是否相同： 若相同，链表形式存储(JDK7：头插法；JDK8：尾接法)。若不同，调用equals()方法： 若equals()返回false，链表形式存储。若equals返回true，则修改该key上的value值。 面试题：HashMap 和 Hashtable的异同？ 同：双列数据，存储key-value对的数据 异： HashMap：作为主要实现类；线程不安全，效率高；存储null的key和value Hashtable：作为古老实现类；线程安全，效率低；不能存储null的key和value","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】枚举类与注解","slug":"【Java基础】枚举类与注解","date":"2020-09-15T13:59:13.000Z","updated":"2020-09-18T04:02:07.173Z","comments":true,"path":"2020/09/15/【Java基础】枚举类与注解/","link":"","permalink":"https://letere-gzj.github.io/2020/09/15/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/","excerpt":"学习枚举类与注解整理的学习笔记","text":"学习枚举类与注解整理的学习笔记 一、枚举类1.1 说明 类的对象只有有限个，确定的。称这种类为枚举类 当需要定义一组常量时，强烈建议使用枚举类 1.2 枚举类定义 方式一：JDK5.0之前，自定义枚举类 1.定义类的属性:用private final 来修饰 2.构造器私有化，并带参对类的属性进行赋值 3.创建对象（public static final） 4.（可选）提供类的属性get方法，以及重写toString方法 1234567891011121314151617181920212223242526272829303132class Season&#123; //1.声明Season对象的属性：private、final修饰 private final String SeasonName; private final String SeasonDesc; //2.私有化类的构造器，并对属性进行赋值 private Season(String SeasonName, String SeasonDesc)&#123; this.SeasonName = SeasonName; this.SeasonDesc = SeasonDesc; &#125; //3.提供当前枚举类的多个对象 public static final Season SPRING = new Season(&quot;春天&quot;, &quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;雪花飘飘&quot;); //(可选)4.获取枚举类的属性，提供toString方法 public String getSeasonName() &#123; return SeasonName; &#125; public String getSeasonDesc() &#123; return SeasonDesc; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;SeasonName=&#x27;&quot; + SeasonName + &#x27;\\&#x27;&#x27; + &quot;, SeasonDesc=&#x27;&quot; + SeasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 方式二：JDK5.0之后，使用enum创建枚举类 1.提供当前枚举类的对象，多个对象用“,”隔开，末尾用“;”结束 2.声明Season对象的属性：private、final修饰 3.私有化类的构造器，并对属性进行赋值 4.(可选)获取枚举类的属性，提供toString方法 注意：enum继承的父类并不是Object类，而是java.lang.Enum类 1234567891011121314151617181920212223242526//使用enum创建枚举类enum Season1&#123; //1.提供当前枚举类的对象，多个对象用“,”隔开，末尾用“;”结束 SPRING(&quot;春天&quot;, &quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;, &quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;, &quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;, &quot;雪花飘飘&quot;); //2.声明Season对象的属性：private、final修饰 private final String SeasonName; private final String SeasonDesc; //3.私有化类的构造器 private Season1(String SeasonName, String SeasonDesc)&#123; this.SeasonName = SeasonName; this.SeasonDesc = SeasonDesc; &#125; //(可选)4.获取枚举类的属性，提供toString方法 public String getSeasonName() &#123; return SeasonName; &#125; public String getSeasonDesc() &#123; return SeasonDesc; &#125;&#125; 1.3 Enum类的常用方法 1.values()方法：返回枚举类的对象数组，该方法可以很方便地遍历所有的枚举类 12345//values()Season1[] values = Season1.values();for (int i = 0; i &lt; values.length; i++) &#123; System.out.println(values[i]);&#125; 2.valueOf(String objName)：可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象 123//valueOf(String objName)Season1 winter = Season1.valueOf(&quot;WINTER&quot;);System.out.println(winter); 3.toString()：返回当前枚举类对象常量的名称 1.4 使用enum关键字定义的枚举类实现接口的情况 1.情况一：实现接口，在enum类中实现抽象方法（普通方法） 2.情况二：让枚举类对象分别实现接口中的抽象方法，在对象后面加上{}，在里面重写抽象方法 123456SPRING(&quot;春天&quot;, &quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;这是春天！&quot;); &#125;&#125; 二、注解2.1 注解(Annotation)理解 （1）这是JDK5.0新增的功能 （2）Annotation其实是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息 （3）在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 2.2 Annotation使用示例 示例一： 生成文档相关的注解 12345678910111213@author 标明开发各类莫尅的作者，多个作者使用&quot;,&quot;来进行分割@version 标明该类模块的版本@see 参考转向，也就是相关的主题@since 从哪个版本开始增加的@param 对方法中参数的说明，如果没有参数就不能写@return 对方法返回值的说明，如果方法的返回值类型是void就不能写@exception 对方法可能抛出异常进行说明，如果方法没用throws显示抛出异常就不能写 12345678910其中： @param @return 和 @ exception 这三个标记都是只用于方法的 @param的格式要求： @param 形参名 形参类型 形参说明 @return的格式要求：@return 返回值类型 返回值说明 @exception的格式要求：@exception 异常类型 异常说明 @param 和 @exception 可以并列多个 示例二： 在编译时进行格式检查(JDK内置的三个基本注解) 12345@Override：限定重写父类方法，该注解只能用于方法@Deprecated：用于表示所修饰的元素(类、方法等)一过时。通常是因为所修饰的结构危险或存在更好的选择@SuppressWarnings：抑制编译器警告 2.3 元注解 理解： JDK提供四种元注解，用来修饰其他Annotation （1）Retention： 指定所修饰的注解的生命周期 格式：@Retention(RetentionPolicy.xxx) 三种状态： SOURCE：通过javac编译后的class文件就不存在次注解 CLASS(默认)：编译后注解还在，但通过java运行时，该注解不会被加载 RUNTIME：运行时注解会被加载 注意：只有声明为RUNTIME生命周期的注解，才能通过反射获取 （2）Target： 用于指定被修饰的注解，能用于修饰那些程序元素 格式：@Target(&#123;xxx, xxx, xxx,......&#125;) 属性： TYPE：表示类、接口、枚举类 FIELD：field属性 METHOD：方法 PARAMETER：属性 CONSTRUCTOR：构造器 LOCAL_VARIABLE：局部变量 ANNOTATION_TYPE：注解类型 PACKAGE：包 （3）Documented： 被此元注解修饰的注解会被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的 注意：定义为Documented的注解必须设置Retention值为RUNTIME （4）Inherited： 被修饰的注解将具有继承性 2.4 自定义注释（实用度不高） 参照@SuppressWarnings来定义 （1）注解声明为@interface （2）内部定义成员，通常用value表示 （3）可以指定成员的默认值，使用default定义 （4）如果自定义注解没有成员，表明只是个标识 如果注解有成员，在使用注解时，需要指明成员的值 自定义注解必须配上注解的信息流程（使用反射）才有意义 自定义注解一般会指明两个元注解：Retention 和 Target 123@interface MyAnnotion&#123; String value() default &quot;hello&quot;;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】常用类","slug":"【Java基础】常用类","date":"2020-09-13T13:23:33.000Z","updated":"2020-09-18T03:55:23.245Z","comments":true,"path":"2020/09/13/【Java基础】常用类/","link":"","permalink":"https://letere-gzj.github.io/2020/09/13/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%B8%B8%E7%94%A8%E7%B1%BB/","excerpt":"Java常用类学习，自己整理的学习笔记","text":"Java常用类学习，自己整理的学习笔记 一、String类1.1 String类的使用 （1）String:字符串，使用一对””引起来表示 （2）String声明为final的，不可以被继承 （3）String实现了Serializable接口：表示是字符串是支持序列化的 实现了Comparable接口：表示String是可以比较大小的 （4）String内部定义了final char[] value用于存储字符串数据 1、新版JDK定义时 final byte[] value数组 2、当对现有字符串进行连接操作时，需要重写指定内存区域赋值，不能使用原有的value进行赋值 3、当嗲用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值 （5）Sting代表不可变得字符(byte)序列；简称：不可变性 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 （6）通过字面量的方法(区别于new)给一个字符串赋值，此时的字符串值声明在字符串常量池中 （7）字符串常量池中是不会存储相同内容的字符串的 1.2 String实例化方式 方式一：通过字面量定义的方式 （1）常量与常量的拼接，定义仍然在常量池中 （2）只要出现变量，结果就在堆空间中 （3）拼接的结果调用intern()方法，返回值就在常量池中 方式二：通过 new + 构造器的方式 1.3 String的常用方法1234567891011121314151617181920212223int length()：但会字符串的长度，return value lengthchar charAt(int index)：返回某索引处的字符return value[index]boolean isEmpty()：判断是否是空字符串，return value.length == 0String toLowerCase()：使用默认语言环境，将String中的所有字符转换成小写String toUpperCase()：使用默认语言环境，将String中所有字符转换成大写String trim()：返回字符串的副本，忽略前导空白和尾部空白boolean equals(Object obj)：比较字符串的内容是否相同boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写String concat(String str)：将指定字符串连接到此字符串的尾部，等同于使用&quot;+&quot;int compareTo(String antherString)：比较两个字符串的大小String subString(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取，直到末尾String subString(int beginIndex, int endIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取,到endIndex结束,左闭右开区间 12345boolean eadsWith(String suffix)：测试次字符串是否指定的后续结束boolean startsWith(String prefix)：测试次字符串是否以指定的前缀开始boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的字符串是否指定前缀开始 1234567891011boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回trueint indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现的索引，从指定的索引开始int lastIndexOf(String str)：返回指定字符串中最右边出现处的索引int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索#注意：indexOf和lastIndexOf方法如果未找到，返回值是-1 12345678//替换String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串宿友匹配字面值目标序列的子字符串String replaceAll(String regex, String repacement)：使用给定的replacement替换此字符串所有匹配给定的正则表达式的字符串String replaceFirst(String regex, String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个字符串 12//匹配boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式 1234//切片String[] split(String regex)：根据给定的正则表达式的匹配拆分此字符串String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放在最后一个元素中 1.4 String与其他类型的转换 String 与 char[]之间的转换 String –&gt; char[]：调用String的toCharArray() char[] –&gt; String: 调用String的构造器 String 与 byte[]之间的转换 String –&gt; byte[]：调用String的getBytes() / getBytes(charsetName) byte[] –&gt; String：调用String的构造器 new String(byte[]) / new String(byte[], charsetName) 二、StringBuffer 和 StringBuilder2.1 关于StringBuffer和Stringbuilder的使用 String 和 StringBuffer 和 StringBuilder之间的区别 String：不可变的字符序列； StringBuffer：可变的字符序列；线程安全的，效率低； StringBuilder：可变的字符序列；JDK5.0线程不安全，效率高； 源码分析 12345String str = new String(); // char[] value = new char[0]，创造长度为0的字符数组String str1 =new String(&quot;abc&quot;); // char[] value = new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125; 1234567891011StringBuffer sb1 = new StringBuffer();// char[] value = new char[16]，底层默认创建一个长度时16的字符数组sb1.append(&#x27;a&#x27;); // value[0] = &#x27;a&#x27;sb1.append(&#x27;b&#x27;); // value[1] = &#x27;b&#x27;StringBuffer sb2 = new StringBuffer(&quot;abc&quot;); // char[] value = new char[&quot;abc&quot;.lenghth +16] 问题 问题1： System.out.println(sb2.length); 输出为3，虽然底层空间不止3，但是方法被重写，只显示非null字符的个数 问题2：扩容 如果需要添加的数据底层数组盛不下，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍+2，同时将原有的数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 和 StringBuilder(int capacity)来避免扩容 2.1 StringBuffer 和 StringBuilder 的常用方法StringBuffer 和 StringBuilder的方法名一模一样，只是同步与不同步区别 123456789StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接StringBuffer delete(int start, int end)：删除指定位置的内容StringBuffer replace(int statr, int end, String str)：把[start, end)位置替换成strStringBuffer insert(int offset, xxx)：在指定的位置插入xxxStringBuffer reverse()：把当前字符序列逆转 123456789public int indexOf(String str)public String subString(int start, int end)：返回一个从start开始到end索引结束的左闭右开区间的子字符串public int length()：字符串长度public char charAt(int n)：读取特定的字符public void setCharAt(int n, char ch)：将指定的位置的字符进行更改 2.3 总结 增：append(xxxx) 删：delete(int start, int end) 查：charAt(int n) 改：replace(int statr, int end, String str) / setCharAt(int n, char ch) 插：insert(int offset, xxx) 长度：length() 遍历：for() + charAt() / toString() 效率：StringBuilder &gt; StringBuffer &gt; String 三、Date类3.1 Date类分类 java.util.Date java.sql.Date sql的Date类是继承于util的Date类 3.2 Date类的使用 两个构造器 123Date date = new Date(); ：空参，默认获取本地时间Date date = new Date(毫秒数); ：毫秒数是从1970年1月1日开始计算的 两个常用方法 1234toString()：显示当前的年、月、日、时、分、秒//格式为：Sun Sep 13 19:21:19 CST 2020getTtime()：获取当前Date对象的对象的毫秒数（时间戳） 3.3 两个Date类之间的转换 java.sql.Date –&gt; java.util.Date 多态性，可以使用强转的方式 java.util.Date –&gt; java.sql.Date 利用getTime()返回的毫秒数，作为参数传入构造器中 java.sql.Date date = new java.sql.Date(java.util.Date().getTime()); 3.4 额外拓展 返回毫秒数的方式也可以用System.CurrentTimeMillis()的方式进行返回 四、SimpleDateFormat类4.1 SimpleDateFormat说明 simpleDateFormat对日期Date类的格式化和解析 4.2 SimpleDateFormate使用 （1）两个构造器 12345SimpleDateFormat sdf = new SimpleDateFormat(); ：使用默认的格式//格式为：2020/9/14 下午9:55SimpleDateFormat sdf = new SimpleDateFormat(&quot;自定义格式&quot;); ：使用规定的格式//例：&quot;yyyy-MM-dd hh:mm:ss&quot; --&gt; 2020-09-14 10:13:52 （2）两个操作 格式化：日期 –&gt; 字符串（将Date对象转变成字符串） String newDate = sdf.format(date); 解析：字符串 –&gt; 日期（将SimpleDateFormat对象的格式转变成Date对象） Date date = sdf.parse(&quot;2020/9/14 下午9:55&quot;) 五、Calendar类5.1 说明 Calendar类称为 日历类，是一个抽象类 5.2 Calendar使用 1.实例化 创建子类（GregorianCalendar）的对象，但名字过长，一般不用 利用Calendar的静态方法getInstance()创建1234Calendar calendar = Calendar.getInstance();System.out.println(calendar.getClass());//返回：java.util.GregorianCalendar，即跟创建GregorianCalendar效果一样 2.常用方法 （1）get() int days = calendar.get(Calendar.DAY_OF_MONTH);//获取当月的天数，参数是Calendar内部定义的常量，数量过多，就不列举出来 （2）set() calendar.set(Calendar.DAY_OF_MONTH, 22);//修改当月的天数为22，变相修改时间 （3）add() calendar.add(Calendar.DAY_OF_MONTH, 3);//增加天数，增加3天(可以负数) （4）getTime() Date date = calendar.getTime();//Calendar类转变成Date类 （5）setTime() calendar.setTime(new Date());//Date类转变成Calendar 六、JDK8新增的时间API6.1 LocalDate、LocalTime、LocalDateTime 说明 三个API的方法都一样，就Date就只是获取日期，TIme只是获取时间。一般都用LocalDateTime。以下都以LocalDateTime举例 方法 实例化1：使用静态方法now()12LocalDateTime localDateTime = LocalDateTime.now();//获取本地日期和时间 实例化2：利用静态方法of()来按指定日期时间创建1LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 1, 13, 23, 23); getXxx()：获取想要的数据（例：获取本月中第几天）1int days = localDateTime1.getDayOfMonth(); withXxx()：修改数据（例：修改本月中的第几天）1LocalDateTime localDateTime2 = localDateTime1.withDayOfMonth(22); plusXxx()：加法（例：月份+3）1LocalDateTime localDateTime3 = localDateTime1.plusMonths(3); minusXxxx()：减法（例：月份-2）1LocalDateTime localDateTime4 = localDateTime1.minusMonths(2); 6.2 Instant 说明 使用方法类似于java.util.Date 方法 实例化1：使用静态方法now()12Instant instant = Instant.now();//注意：获取的时间是本初子午线的时间，有时间差 实例化2：使用静态方法ofEpochMilli()，参数为毫秒数（时间戳）1Instant instant1 = Instant.ofEpochMilli(毫秒数); 获取毫秒数1long l = instant.toEpochMilli(); 添加时间偏移量12OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));//将时间+8小时，变成中国时间 6.3 DateTimeFormatter 说明 使用方法类似于SimpleDateFormat类 方法 实例化1：使用预定义格式，如：ISO_LOCAL_DATE_TIME1DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME; 实例化2：ofLocalizedDateTime()； 参数：FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT1DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM); 实例化3（推荐）：自定义格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)1DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); 格式化：format()&emsp;&emsp;日期 —&gt; 字符串1String str1 = formatter.format(LocalDateTime.now()); 解析：parse()&emsp;&emsp;字符串 —&gt; 日期1TemporalAccessor parse = formatter.parse(对应的格式); 七、Java比较器7.1 分类 Java比较器通过两个接口来实现，Comparable 和 Comparator。Comparable称为自然排序，而Comparator被称为定制排序 7.2 Comparable接口的使用 使用： 类实现Comparable接口，重写compareTo方法，利用Arrays.sort(数组)的方法，会按照重写的compareTo的方法，对数组进行排序。 重写compareTo(obj)规则； 如果当前对象this大于形参对象obj，则返回正整数 如果当前对象this小于形参对象obj，则返回负整数 如果当前对象this等于形参对象obj，则返回0 7.3 Comparator接口的使用 背景： 当元素的类型没有实现java.lang.Comparable接口而有不方便修改代码 或实现了java.langComparable接口的排序规则不适合当前的操作 那么可以考虑使用Comparator的对象来排序 使用方法： 创建Comparator接口实现类，该类中对compare方法进行重写。然后使用Arrays.sort(数组，Comparator实现类对象)，然后会按照重写的compare的方法对该数组进行排序。 重写compare(Object o1, Object o2)方法规则： 如果方法返回正整数，则表示o1比o2大 如果返回负整数，表示o1比o2小 如果返回0，表示相等 7.4 Comparable接口 和 Comparator的使用的比较 Comparble 接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小 Comparator接口属于临时性的比较 八、其他常用类8.1 System类123456789101112131415161.System.currentTimeMillis()：获取毫秒数2.System.exit(int status)：退出 0：正常退出 非0：异常退出 3.System.gc():请求系统垃圾回收4.System.getProperty(String key)：获取系统中属性名为key属性对应的值 java.version -- Java运行时环境版本 java.home -- Java安装目录 os.name -- 操作系统名字 os.version -- 操作系统的版本 user.name -- 用户的账户名称 user.home -- 用户的主目录 user.dir -- 用户当前工作目录 8.2 Math类12345678910111213141516171819202122231.abs：绝对值2.acos, asin, atan, cos, sin, tan ：三角函数3.sqrt：平方根4.pow(double a, double b)：a的b次幂5.log ：自然对数6.exp ：e为底指数7.max(double a, double b)：求最大8.min(double a, double b)：求最小9.random() ：返回0.0 到 1.0的随机数10.long round(double a) ：double型数据a转变成long型11.toDegrees(double angrad) ：弧度--&gt;角度12.toRadians(double angdeg) ：角度--&gt;弧度 8.3 BigInteger类12345678910111213141516//BigInteger可以表示不可变的任意精度的整数1.public BigInteger abs()：返回次BigInteger的绝对值的BigInteger2.BigInteger add(BigInteger val)：返回其值为（this + val）的BigInteger3.BigInteger subtract(BigInteger val)：返回其值为（this -val）的BigInteger4.BigInteger multiply(BigInteger val)：返回其值为（this * val）的BigInteger5.BigInteger divide(BigInteger val)：返回其值为（this / val）的BigInteger，整数相除只保留整数部分6.BigInteger remainder(BigInteger val)：返回其值为（this % val）的BigInteger7.BigInteger[] divideAndRemainder(BigInteger val)：返回包含(this / val)后跟(this % val)的两个BigInteger的数组8.BigInteger pow(int exponent)：返回其值为(this^exponent)的BigInteger 8.4 BigDecimal12345678//BigDecimal要求数字的精度比Float, Double要高1.public BigDecimal add(BigDecimal augend)2.public BigDecimal subtract(BigDecimal subtrahend)3.public BigDecimal multiply(BigDeciaml multiplicand)4.public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【Java基础】多线程","slug":"【Java基础】多线程","date":"2020-09-09T15:55:20.000Z","updated":"2020-09-18T04:02:22.541Z","comments":true,"path":"2020/09/09/【Java基础】多线程/","link":"","permalink":"https://letere-gzj.github.io/2020/09/09/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"Java多线程学习，自己整理的学习笔记","text":"Java多线程学习，自己整理的学习笔记 一、基础概念 程序： 完成特定的任务，用某种语言编写的一组指令的集合。（静态代码） 进程： 运行起来的程序 线程： （1）进程的进一步细化，进程执行的其中一条路径 （2）线程拥有独立的栈和独立的程序计数器 （3）多个线程共享堆和方法区，方便线程之间的通讯，但也带来安全隐患 并行和并发： 并行：多个CPU同时执行多个任务 并发：一个CPU“同时”执行多个任务 多线程优点： 提高应用程序的响应，对图形化界面更有意义，可以增强用于体验 提高计算机系统CPU的利用率 改善程序结构，将复杂的进程分为多个线程，利于理解和修改 何时需要多线程： （1）程序需要同时执行多个任务 （2）程序实现一些需要等待的任务。如用户输入、文件读写操作、网络操作、搜索等 （3）需要一些后台运行的程序 二、创建多线程多线程的创建，需要使用到java.lang.Thread类中的内容 2.1 创建线程的方法 方法一： （1）创建一个继承与Thread的子类 （2）重写Thread类的run() -&gt; 将线程执行的操作[方法体]声明在run()中 （3）常见Thread类子类的对象 （4）通过此对象调用start()来新开一个线程来执行，不是使用main()中的线程 1234567891011121314151617181920212223代码测试：public class ThreadTest &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread();//创建对象 myThread.start();//调用对象start()方法 System.out.println(&quot;helloworld&quot;); &#125;&#125;//例子：遍历100以内的偶数class MyThread extends Thread&#123;//继承Thread类 @Override public void run() &#123;//重写run方法 for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 12345678910111213141516171819整合方法：public class ThreadTest &#123; public static void main(String[] args) &#123; //可以通过匿名子类对象，上面几步方法整合 new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(i); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 方法二： 1.创建一个实现了Runnable接口的类 2.实现了类去实现Runable中的抽象方法：Run() 3.创建实现类的对象 4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 5.通过Thread类的对象调用start() 1234567891011121314151617181920212223class MThread implements Runnable&#123;//1.创建一个实现了Runnable接口的类 @Override public void run() &#123;//2.实现了类去实现Runable中的抽象方法：Run() for (int i = 0; i &lt; 100; i++) &#123; if (i%2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;：&quot; + i); &#125; &#125; &#125;&#125;public class ThreadCreate2 &#123; public static void main(String[] args) &#123; MThread mThread = new MThread();//3.创建实现类的对象 Thread thread = new Thread(mThread);//4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 thread.start();//5.通过Thread类的对象调用start() &#125;&#125; 比较创建线程的两种方式： 1.开发中，优先选择：实现Runnable接口的方式 （1）实现的方式没有类的单继承性的局限性 （2）实现的方式更适合处理多个线程共享数据的情况 2.联系：Thread类其实也是继承于Runnable接口 public class Thread implements Runnable 3.相同点：两个方式都需要重新run()，将执行的逻辑声明在run()中 三、Thread中的方法3.1 基本方法12345678910111213141516171819start()：启动当前线程，调用当前线程的run()run()：通常需要重写此方法，将创建的线程要执行的操作声明在此方法中currentThread()：静态方法，返回当前代码的线程getName()：获去当前线程名字setName()：设置当前线程的名字yield()：释放当前CPU的执行权join()：在线程A中调用线程B的join()，此时线程A进入阻塞状态，知道线程B执行完后，线程A才继续执行（可以理解为插队，但线程不一样）stop()：已过时，执行此方法时，强制结束当前线程sleep()：使当前线程“睡眠”一段时间[单位：毫秒]，在该时间内线程是阻塞状态。静态方法，会报异常，需要try-catchisAlive()：判断线程是否还存活 3.2 线程优先级 在Thread方法中存在三个常量，来表示线程的优先级 123MAX_PRIORITY: 10MIN_PRIORITY: 1NORM_PRIORITY: 5 --&gt; 默认优先级 通过get、set方法来获取设置优先级 12getPriority(); 获取优先级setPriority(); 设置优先级 注意：优先级高只是被CPU执行的概率变高，但不一定是优先执行 四、线程的生命周期 五、同步同步是用于解决使用共享数据引发的线程安全问题 5.1 经典线性安全问题 100张票，3个窗口同时进行售卖&emsp;（1）使用继承Thread类方式实现： 1234567891011121314151617181920212223242526272829303132public class Thread1Test &#123; public static void main(String[] args) &#123; Window w1 = new Window();//创建三个对象，达到三个线程效果 Window w2 = new Window(); Window w3 = new Window(); w1.setName(&quot;窗口一&quot;); w2.setName(&quot;窗口二&quot;); w3.setName(&quot;窗口三&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125;class Window extends Thread&#123; private static int ticket = 100;//静态变量保证三个对象使用同一变量 @Override public void run() &#123; while (true)&#123; if (ticket &gt; 0)&#123; System.out.println(getName() + &quot;卖票，票号为：&quot; + ticket); ticket --; &#125; else &#123; break; &#125; &#125; &#125;&#125; &emsp;（2）使用Runnable接口的方式实现 1234567891011121314151617181920212223242526272829303132public class Thread2Test &#123; public static void main(String[] args) &#123; Window1 window1 = new Window1();//创建实现类对象 Thread t1 = new Thread(window1);//通过实现类对象创建三个线程 Thread t2 = new Thread(window1); Thread t3 = new Thread(window1); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125;class Window1 implements Runnable&#123;//实现Runnable接口 private int ticket = 100; @Override public void run() &#123; while (true)&#123; if (ticket &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;卖票：票号&quot; + ticket); ticket--; &#125; &#125; &#125;&#125; 以上的方法都会出现重票，错票的情况，是由于使用了共享数据ticket的问题 5.2 同步方法一：同步代码块123synchronized(同步监视器)&#123; //需要被同步的代码---&gt;操作共享数据的代码&#125; 同步监视器： 俗称“锁”，任何一个类的对象都可以充当锁，但必须多个线程用的是同一把锁 补充： 可以考虑使用”this”或者”类名.class”来充当锁，但慎重考虑是否是唯一的锁 &emsp;（1）对继承Thread方法的进行修改 1234567891011121314151617181920class Window extends Thread&#123; private static int ticket = 100;//静态变量保证三个对象使用同一变量 @Override public void run() &#123; while (true)&#123; synchronized(Window.class)&#123;//使用“类名.class”，来充当锁，并且是唯一的 if (ticket &gt; 0)&#123; System.out.println(getName() + &quot;卖票，票号为：&quot; + ticket); ticket --; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; &emsp;（2）对实现Runnable接口的进行修改 12345678910111213141516171819202122232425class SaleTicket implements Runnable&#123; private int ticket = 100; Object obj = new Object();//任意一个类对象当同步监视器 @Override public void run() &#123; while (true) &#123; synchronized (obj) &#123;//同步代码块 //可以偷懒直接用synchronized(this)，用当前对象“st”充当锁 //还可以synchronized(SaleTicket.class)，类也算是对象，因为只会加载一次，是唯一对象 if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖票：票号&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 5.3 同步方法二：同步方法123private synchronized void 方法名()&#123; //操作共享数据的代码&#125; 说明： 将操作共享数据的代码封装到一个方法中，并对该方法声明为synchronized 补充： 1.同步方法依然使用了同步监视器，只是不需要我们显示声明 2.非静态同步方法的同步监视器是：this 3.静态同步方法的同步监视器是：当前类本身 &emsp;（1）对继承Thread方法的进行修改 12345678910111213141516171819202122class SaleTicket2 implements Runnable&#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); if (ticket == 0)&#123; break; &#125; &#125; &#125; //使用synchronized关键字修饰方法，变成同步方法 private static synchronized void show() &#123;//静态方法的同步监视器为类的本身，静态才能使得同步监视器唯一 if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖票：票号&quot; + ticket); ticket--; &#125; &#125;&#125; &emsp;（2）对实现Runnable接口的进行修改 12345678910111213141516171819202122class SaleTicket2 implements Runnable&#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); if (ticket == 0)&#123; break; &#125; &#125; &#125; //使用synchronized关键字修饰方法，变成同步方法 private synchronized void show() &#123;//非静态方法，使用默认同步监视器：this if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖票：票号&quot; + ticket); ticket--; &#125; &#125;&#125; 六、死锁6.1 死锁的理解 不同的线程分别占用了对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//举例public class DeadLockTest &#123; public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); //线程一 new Thread()&#123; @Override public void run() &#123; synchronized(s1)&#123;//第一把锁 s1.append(&quot;123&quot;); try &#123; Thread.sleep(100);//添加阻塞提高死锁概率 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123;//第二把锁 s2.append(&quot;456&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); //线程二 new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized(s2) &#123;//与前面线程锁互换 s2.append(&quot;123&quot;); synchronized (s1) &#123; s1.append(&quot;456&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125;&#125;//线程一拿着s1锁，阻塞一段时间。线程二拿了s2锁，准备拿s1锁却被线程一拿了。线程一醒了，需要s2锁，但s2锁被线程二拿了没释放出来。 说明： （1）出现死锁后，不会出现异常，不会出现提示，只是所有线程进入阻塞状态，无法执行 （2）使用同步时，要注意避免死锁。就如使用循环避免死循环。 七、线程通信7.1 理解 线程通信是指线程之间交互执行 7.2 实现方法 wait()，使线程进入阻塞状态，并会释放当前拥有的锁 notify()，唤醒被wait()的一个线程，有多个被wait()的线程，唤醒优先级高的线程 notifyAll()，唤醒所有被wait()的线程 7.3 举例 线程通信例子：使用两个线程打印1-100。线程1，线程2，交替打印 12345678910111213141516171819202122232425262728293031323334353637383940public class communicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125;class Number implements Runnable&#123; private int num = 1; @Override public void run() &#123; while(true)&#123; synchronized (this) &#123; this.notify();//使被wait()的线程进入就绪状态 if (num &lt;= 100)&#123; System.out.println(Thread.currentThread().getName() + &quot;--打印了:&quot; + num); num ++; try &#123; this.wait();//使得调用wait()方法的线程进入阻塞状态 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125; 八、JDK5.0后新增的内容8.1新增同步方法 Lock锁： 1.导入java.util.concurrent.locks.ReentrantLock包 2.创建一个实例化的Reentrantlock对象 可以选择传入参数“true”，使线程之间交互执行，形成线程通信 3.try-finally包裹执行共享数据的代码 4.在try{}内调用lock方法上锁，在finally{}调用unlock方法解锁 注意：lock对象也需要每个线程使用的都是同一对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LockTest &#123; public static void main(String[] args) &#123; Windows w = new Windows(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125;class Windows implements Runnable&#123; private int ticket = 100; //1.实例化Reentrantlock对象 private ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true)&#123; try&#123; //2.调用对象的lock方法 lock.lock(); if (ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;卖票：票号为&quot; + ticket); ticket --; &#125;else&#123; break; &#125; &#125;finally&#123; //3.调用解锁方法unlock lock.unlock(); &#125; &#125; &#125;&#125; 8.2 新增线程创建方法 （1）实现Callable接口 1.创建一个Callable的实现类 2.实现call方法，将次线程需要执行的操作声明在call()中 3.创建Callable的实现类对象 4.将实现类对象作为参数，传递到FutureTask中，并创建FutureTask对象 5.FutureTask对象作为参数，传递到Thread中，并创建出对象，并start方法调用 6.若是需要返回值，可以通过FutureTask对象.get()来获取返回值，会抛出异常 1234567891011121314151617181920212223242526272829303132 //1.创建Callable接口实现类class NumThread implements Callable &#123; @Override public Object call() throws Exception &#123;//2.实现call()方法，将执行代码放在里面 int sum = 0; for (int i = 0; i &lt;= 100; i++) &#123; if (i % 2 == 0)&#123; System.out.println(i); sum += i; &#125; &#125; return sum; //测试Callable接口返回值 &#125;&#125;public class CreateMethod3 &#123; public static void main(String[] args) &#123; NumThread numthread = new NumThread();//3.创建Callable实现类的对象 FutureTask futureTask = new FutureTask(numthread);//4.将对Callable对象作为参数，创建Future对象 new Thread(futureTask).start();//将FutureTask对象作为参数，创建Thread对象，启动start() try &#123; //get()返回值为FutureTask构造器参数callable实现类重新call的返回值 Object sum = futureTask.get(); System.out.println(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 如何理解实现Callable接口 比 Runnable接口强大 1.call()可以有返回值 2.call()可以抛出异常 3.Callable是支持泛型 （2）线程池 1.提供指定数量的线程池 2.设置线程属性（可选） corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后悔终止 3执行指定线程的操作，需要提供实现Runnable接口 或 Callable接口的实现类的对象 Runnable 用 execute() Callable 用 submit() 1234567891011121314151617181920212223242526272829303132333435363738394041public class CreateMethod4 &#123; public static void main(String[] args) &#123; //1.提供指定数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); //2.设置线程池属性 //ExecutorService是一个接口，需要用其实现类进行属性设置，可以进行强转; ((ThreadPoolExecutor) service).setMaximumPoolSize(10); //3.执行指定线程的操作，需要提供实现Runnable接口或Callable接口的实现类的对象 service.execute(new RunTest());//适合使用于Runnable service.submit(new CallTest());//适合使用于Callable service.shutdown();//关闭连接池 &#125;&#125;//Runnable接口实现类class RunTest implements Runnable&#123; @Override public void run() &#123; for (int i = 1; i &lt;= 100; i++) &#123; if (i%2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;：&quot; + i); &#125; &#125; &#125;&#125;//Callable接口实现类class CallTest implements Callable &#123; @Override public Object call() throws Exception &#123; for (int i = 1; i &lt;= 100; i++) &#123; if (i%2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;：&quot; + i); &#125; &#125; return null;//一定要有return &#125;&#125; 线程池的好处： 1.提高响应速度(减少了创建新线程的时间) 2.降低资源消耗(重复利用线程池中线程，不需要每次都创建) 3.便于线程的管理 九、面试题 （1）synchronized 与 lock的异同？ 1.相同： 二者都可以解决线程安全问题 2.不同点： synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 lock需要手动的启动同步(lock())，同时结束同步也需要手动的实现(unlock()) （2）sleep() 与 wait()方法的区别 1.相同点： 都可以使得当前线程进入阻塞状态 2.不同点： 声明位置不同，sleep()是声明在Thread类中的，wait()是声明在Object()类中 调用要求不同：sleep()可以在任何场景下调用。wait()只能在同步代码块或同步方法中 如果都在同步代码块 或 同步方法 中调用，sleep()不会释放同步监视器，wait()方法会","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【教程】快速上手IDEA编程软件","slug":"【教程】快速上手IDEA编程软件","date":"2020-09-08T17:17:46.000Z","updated":"2020-09-18T04:03:31.444Z","comments":true,"path":"2020/09/09/【教程】快速上手IDEA编程软件/","link":"","permalink":"https://letere-gzj.github.io/2020/09/09/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BIDEA%E7%BC%96%E7%A8%8B%E8%BD%AF%E4%BB%B6/","excerpt":"关于Java常用编程软件IDEA的一些个人设置，帮助更快上手IDEA编程软件。","text":"关于Java常用编程软件IDEA的一些个人设置，帮助更快上手IDEA编程软件。 一、IDEA下载和基础了解1.1下载 官网位置：https://www.jetbrains.com/idea/download/#section=windows 建议直接下载最终版，到时网上找破解补丁即可，但下载的版本不要太新，可能还没破解 1.2 安装 安装路径自己选择 设置安装选择相应系统位数即可 其余默认安装 1.3 优化 建议64位，16G运行内存的机器进行修改，运行速度变快 （1）-Xms128m 修改为：-Xms512m 【初始内存数，提高启动Java程序的速度】 （2）-Xmx750m 修改为：-Xmx1500m 【最大内存数，减少内存Garage收集频率，提高性能】 （3）-XX：ReservedCodeCacheSize=240m 修改为：-XX：ReservedCodeCacheSize=500m 【提高保留代码占用内存的容量】 1.4 工作空间(Workspace)、项目(Project)、模块(Model)介绍 IDEA新建一个项目 约等于 Eclipse新建一个工作空间 IDEA新建一个模块 约等于 Eclipse新建一个项目 区别：Eclipse一个窗口可以管理多个项目；IDEA一个窗口只能管理一个项目，但可以通过多个模块来弥补 二、IDEA便利设置前提：本人版本为2020.1，不同版本设置位置可能不同，可能需要自行百度 （1）界面主题修改 (Appearance&amp;Behavior -&gt; Appearance) （2）快捷键 ，习惯用Eclipse可以调整，未用过其他编程软件的可以不用改(Keymap) （3）鼠标滚轮修改代码字体大小 (Editor -&gt; General) （4）自动导包 (Editor -&gt; General -&gt; Auto import) （5）方法之间有分割符，方便查看 (Editor -&gt; General -&gt; Appearance ) （6）忽略大小写，方便代码自动检索 (Editor -&gt; General -&gt; Code completion) （7）取消打开的文件只显示一行，可以防止打开的文件折叠隐藏 (Editor -&gt; General -&gt; Edtior Tabs) （8）修改代码字体类型，字体大小 (Editor -&gt; Font) （9）代码主题修改 (Editor -&gt; Color Scheme) （10）修改特定代码颜色，对于用惯Eclipse的我，不太习惯IDEA的灰色注释颜色(Edtior -&gt; Color Scheme -&gt; Language Defaults) （11）添加头部注释内容，按自己喜好添加 (Editor -&gt; Code Style -&gt; File and Code Templates) （12）修改编码方法，中文字符一般都是用UTF-8的了 （13）自动构建，代码修改后进行再运行时，运行新代码，而不是旧的 三、IDEA模板所谓模板，就是输入特定的关键字，自动帮你生成相应的代码。熟练掌握模板使用，可以提高编码速度。 （1）查看IDEA默认模板 （2）自定义模板，可以自己写一些常用的算法或其他的，存为自己的模板，可以快速调用不用重写。","categories":[{"name":"教程","slug":"教程","permalink":"https://letere-gzj.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[]},{"title":"【Java基础】异常处理","slug":"【Java基础】异常处理","date":"2020-09-05T14:08:35.000Z","updated":"2020-09-18T04:01:54.228Z","comments":true,"path":"2020/09/05/【Java基础】异常处理/","link":"","permalink":"https://letere-gzj.github.io/2020/09/05/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%91%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"Java编程中异常处理的学习记录","text":"Java编程中异常处理的学习记录 异常处理一、异常定义： 程序执行中法神的不正常情况称为异常（不是语法错误/逻辑错误） 二、异常类型： （1）Error： Java虚拟机无法解决的严重问题（JVM系统内部错误、资源耗尽） （2）Exception： 其他因编程错误或偶然的外在因素导致的一般性问题（一般说的异常都是指Exception） 三、Exception分类： （1）编译异常 （2）运行异常[RuntimeException]： 以下是常见运行异常 1234567891011NullPointerException(空指针异常)ArrayIndexOutOfBoundsException(数组角标越界异常)ClassCastException(类型转换异常)NumberFormatException(数字格式异常)InputMismatchException(输入不匹配异常)ArithmeticException(算术异常) 四、异常处理方式： （1）try-catch-finally（自行处理异常） 1234567891011121314//try-catch-finally结构： try&#123; //可能出现错误的代码 &#125;catch(异常类型1 变量名1)&#123; //处理异常1的方法 &#125;catch(异常类型2 变量名2)&#123; //处理异常2的方法 &#125; ...... ...... finally&#123; //一定会执行的代码 &#125; try-catch注意点： （1）catch异常中，出现子父类关系时，父类必须在子类下面 （2）一旦匹配到某个catch异常后，就不会再匹配其他异常，直接到finally结构中 （3）try结构中的变量无法在外面使用，如要在外面使用，在try之前将变形声明好并赋初始值 （4）常用的处理方法为：System.out.println(e.getMessage) 或 e.printStackTrace finallly注意点： （1）finally是可选的，不一定要加上去 （2）finally一定会执行，无论catch是都会再报错，或前面出现return语句，一样会被执行 （3）finally一般用在数据库连接，输入输出流，网络编程Socket等JVM不能自动回收的物理连接，确保一定能够关闭资源，不占内存。 1234567891011121314//代码演示： @Test public int test1()&#123; try &#123; int[] arr = new int[10]; System.out.println(arr[10]);//数组角标越界异常 return 1; &#125;catch(Exception e) &#123;//报错，执行catch内容 return 2; &#125;finally &#123;//虽然有return语句，但finally一定会执行 System.out.println(&quot;一定会被执行&quot;); &#125; &#125; （2）throws + 异常类型（抛出异常，寻求帮助，自己无法解决） 12345throws + 异常类型 结构： public void method() throws Exception&#123; //可能出现异常代码 &#125; throws 注意点： （1）throws出现异常只是返回一个异常对象，后续代码不再执行 （2）throws中出现子父类关系时，子类throws异常要小于父类，并且父类如果没throws语句，子类也不能添加throws语句 （3）throw new 异常类型() —（手动抛出异常） 1234567891011121314//代码实例： public void regist(int id) &#123; try &#123; if (id &gt; 0) &#123; this.id = id; &#125;else &#123; //正常情况：System.out.println(&quot;输入数据非法&quot;) throw new Exception(&quot;输入数据非法&quot;);//手动抛出异常 &#125; &#125; catch (Exception e) &#123; System.out.println(e.getMessage());//处理异常 &#125; &#125; throw注意点： 一般配合 “try-catch-finally结构” 或 “throws+异常类型” 来使用 五、额外拓展 自定义异常类： （1）继承现有的异常结构RuntimeException / Exception （2）提供全局变量：serivalVersionUID （3）提供重载构造器 12345678910111213实例： public class MyException extends RuntimeException&#123; static final long serialVersionUID = -70546873213L;//标识异常类型编号 //构造器-空参/带参 public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125; &#125; 六、常见面试题 throw 和 throws 区别： （1）throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体类 （2）throws 属于异常处理的一种方法，声明在方法的声明处","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"【教程】手动搭建hexo博客","slug":"【教程】手动搭建hexo博客","date":"2020-08-13T16:11:42.000Z","updated":"2020-09-18T04:03:20.981Z","comments":true,"path":"2020/08/14/【教程】手动搭建hexo博客/","link":"","permalink":"https://letere-gzj.github.io/2020/08/14/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/","excerpt":"这是关于我搭建博客过程，以及遇到问题的解决","text":"这是关于我搭建博客过程，以及遇到问题的解决 搭建hexo博客一、环境准备1.1 安装Nodejs ‘Nodejs’官网：https://nodejs.org/zh-cn/ （免费） 默认安装即可 1.2 安装Git ‘Git’官网：https://git-scm.com/ （免费） 默认安装即可 1.3 安装Hexo（1）启动命令行cmd（管理员模式），检查环境 12345node -v #检测node 版本npm -v #检测npm 版本git version 检测Git 版本 &emsp;&emsp;显示版本号证明安装成功 （2）安装cnpm搭载镜像源到淘宝（国内源下载速度快） 1npm install -g cnpm --registry=https://registry.npm.taobao.org （3）安装hexo 12cnpm install -g hexo-cli cnpm install hexo --save 二、搭建博客2.1 创建项目文件夹（blog） 博客的所有资源都在里面，博客创建有问题，把文件夹删了重来就是了 2.2 初始化hexo（1）命令行切换到blog文件夹下 1cd xx/xx/blog #切换工作目录 （2）初始化hexo 1hexo init #hexo初始化 遇到问题：一直卡着不动，初始化不了 hexo下载用的github网址，是外网，可能下不动 解决方法：手动下载资源，自己初始化hexo hexo整体框架：https://github.com/hexojs/hexo-starter 解压内容放在/blog文件夹下 hexo默认主题landspace：https://github.com/hexojs/hexo-theme-landscape 解压内容放在./blog/theme/landspace文件夹下 1cnpm install #搭建博客 2.3 测试是否创建成功1hexo s #启动hexo服务器 浏览器输入http://localhost:4000打开本地博客 见到这画面说明搭建成功 三、部署博客3.1 注册gitee，并登陆Gitee官网：https://gitee.com 3.2 创建仓库(1)新建仓库 (2)参数设置 (3)记住/复制仓库地址 3.3 修改_config.yml(1)前期准备 在blog文件夹cmd敲下面指令12345678#安装发送git，用来上传文件到giteecnpm install --save hexo-deployer-git #设置邮箱（随便填，只是给个git身份）git config --global user.email &#x27;******@qq.com&#x27; #设置用户名（随便填，只是给个git身份）git config --global user.name &#x27;****&#x27; （2）修改根目录_config.yml 打开_config.yml【打开方式选txt即可】，找到以下内容，进行修改【注意冒号’:’后面有空格】1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: &#x27;git&#x27; #上传方式 repo: https://gitee.com/letere/MyBlog.git #上传的仓库地址 branch: master #分支，默认为master，不添加也行 3.4 部署博客 （1）上传文件 1hexo d #上传文件到仓 第一次上传会出现gitee的登录验证，输入gitee账号、密码即可 若账号密码输错，可以在’控制面板\\用户帐户\\凭据管理器’进行修改 （2）开启服务 回到仓库，发现多了很多东西，这时可以去“服务”—&gt;“Gitee Pages” 点击启动，会生成你博客的地址，这时博客已经部署到网络上了 （3）重新修改__config.yml 打开博客发现与预想的不一样，缺少了字体样式 重新修改_config.yml，找到以下内容进行修改1234567891011# URL## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;url: http://letere.gitee.io/myblog #博客网址root: /myblog/ #博客网址最后一小部分permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks （4）重新部署 在blog文件夹内cmd敲以下命令12345hexo clean #清空生成的资源hexo g #生成资源hexo d #上传到仓库 会到仓库Gitee pages上，点击更新 点进博客，恢复正常","categories":[{"name":"教程","slug":"教程","permalink":"https://letere-gzj.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[]}],"categories":[{"name":"Spring","slug":"Spring","permalink":"https://letere-gzj.github.io/categories/Spring/"},{"name":"Gradle","slug":"Gradle","permalink":"https://letere-gzj.github.io/categories/Gradle/"},{"name":"Redis","slug":"Redis","permalink":"https://letere-gzj.github.io/categories/Redis/"},{"name":"面试","slug":"面试","permalink":"https://letere-gzj.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://letere-gzj.github.io/categories/ElasticSearch/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://letere-gzj.github.io/categories/JavaWeb/"},{"name":"拓展","slug":"拓展","permalink":"https://letere-gzj.github.io/categories/%E6%8B%93%E5%B1%95/"},{"name":"工作技能","slug":"工作技能","permalink":"https://letere-gzj.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"},{"name":"教程","slug":"教程","permalink":"https://letere-gzj.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"MySQL","slug":"MySQL","permalink":"https://letere-gzj.github.io/categories/MySQL/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://letere-gzj.github.io/categories/RabbitMQ/"},{"name":"Nginx","slug":"Nginx","permalink":"https://letere-gzj.github.io/categories/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://letere-gzj.github.io/categories/Linux/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://letere-gzj.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"MybatisPlus","slug":"MybatisPlus","permalink":"https://letere-gzj.github.io/categories/MybatisPlus/"},{"name":"SpringCloudAlibaba","slug":"SpringCloudAlibaba","permalink":"https://letere-gzj.github.io/categories/SpringCloudAlibaba/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://letere-gzj.github.io/categories/SpringCloud/"},{"name":"CSS","slug":"CSS","permalink":"https://letere-gzj.github.io/categories/CSS/"},{"name":"Docker","slug":"Docker","permalink":"https://letere-gzj.github.io/categories/Docker/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://letere-gzj.github.io/categories/SpringMVC/"},{"name":"项目总结","slug":"项目总结","permalink":"https://letere-gzj.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"JWT","slug":"JWT","permalink":"https://letere-gzj.github.io/categories/JWT/"},{"name":"Git","slug":"Git","permalink":"https://letere-gzj.github.io/categories/Git/"},{"name":"智能算法","slug":"智能算法","permalink":"https://letere-gzj.github.io/categories/%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95/"},{"name":"Vue","slug":"Vue","permalink":"https://letere-gzj.github.io/categories/Vue/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://letere-gzj.github.io/categories/SpringBoot/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://letere-gzj.github.io/categories/Mybatis/"},{"name":"SSM整合","slug":"SSM整合","permalink":"https://letere-gzj.github.io/categories/SSM%E6%95%B4%E5%90%88/"},{"name":"Maven","slug":"Maven","permalink":"https://letere-gzj.github.io/categories/Maven/"},{"name":"JDBC技术","slug":"JDBC技术","permalink":"https://letere-gzj.github.io/categories/JDBC%E6%8A%80%E6%9C%AF/"},{"name":"Java基础","slug":"Java基础","permalink":"https://letere-gzj.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[]}